<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Django filter中用contains和icontains区别</title>
    <url>/2021/11/24/Django-filter%E4%B8%AD%E7%94%A8contains%E5%92%8Cicontains%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>用 django 的人经常会用到filter过滤集合的功能，这里对比下contains和icontains区别：</p>
<pre><code class="python">queryset.filter(name__contains=&quot;e&quot;)
queryset.filter(name__icontains=&quot;e&quot;)
</code></pre>
<p>打印一下这两行代码对应的sql语句就会看到区别：</p>
<pre><code class="python">&#39;contains&#39;: &#39;LIKE BINARY %s&#39;,
&#39;icontains&#39;: &#39;LIKE %s&#39;,
</code></pre>
<p>这其中的BINARY到底代表什么意思呢，答案是 <strong>精确大小写</strong><br>而’icontains’中的’i’表示<strong>忽略大小写</strong></p>
<p>这其中的BINARY到底代表什么意思呢，答案是 <strong>精确大小写</strong><br>而’icontains’中的’i’表示<strong>忽略大小写</strong></p>
<p>举例：</p>
<pre><code>select * from plant where name like BINARY &#39;%e%&#39;;
2   eee

select * from plant where name like &#39;%e%&#39;;
1   Ezs
2   eee
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>JS模块规范</title>
    <url>/2022/04/27/JS%E6%A8%A1%E5%9D%97%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h2><p>commonJS主要用于 Node.js，输出方式有2种：默认输出—module export  和带有名字的输出—exports.area，引入方式为 required。<br>commonJs是同步加载，所以更适合用在服务端，因为服务端是磁盘读取。如果用在客户端，可能会造成阻塞。</p>
<h2 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h2><p>AMD是 required.js 所引出的一种规范，通过 required([Module], callback)来进行引入，其中 Module 里传一个数组，依次引入。然后在 callback 中将 module名作为参数使用。</p>
<p>AMD 模式整个过程是异步且依赖前置的，在定义前需要将在 Module 中声明。且 Module 中的模块加载完后立即执行，谁快就先执行谁。这样就导致了，AMD模式虽然运行速度很快，但是里面的代码执行顺序是不可控的，可能会产生大坑。</p>
<h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><pre><code class="js">define(function(require, exports, module) &#123;
  var $ = require(&#39;jquery.js&#39;)
  $(&#39;div&#39;).addClass(&#39;active&#39;);
&#125;);
</code></pre>
<p>CMD 是 Sea.js的思想，它也是异步并行加载多个模块，不过 CMD 和 AMD 的区别在于，CMD 是在使用前再去 required 加载。虽然 CMD也会在一开始就下载好所有模块，但是确得等到使用前才执行。这样的好处是，整个代码的执行顺序是可控的，方便开发。缺点是执行模块的等待时间会叠加，速度慢。</p>
<h2 id="ES6-import-export"><a href="#ES6-import-export" class="headerlink" title="ES6(import/export)"></a>ES6(import/export)</h2><p>import/export 和上述的 required 最大的区别就在于，import 输出的是引入值，即导入和导出的值都指向同一个内存地址，所以导入值会随着导出值变化。而 required 是值拷贝，不会互相影响。</p>
<p>import 必须放在开头，required 则无所谓放哪都行。</p>
<p>required 支持动态引入，如：require(${path}/xx.js)。import 目前不支持。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js模块规范</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript-es7、8</title>
    <url>/2021/11/26/JavaScript-es7%E3%80%818/</url>
    <content><![CDATA[<h1 id="ECMASript-7-新特性"><a href="#ECMASript-7-新特性" class="headerlink" title="ECMASript 7 新特性"></a>ECMASript 7 新特性</h1><h2 id="Array-prototype-includes"><a href="#Array-prototype-includes" class="headerlink" title="Array.prototype.includes"></a>Array.prototype.includes</h2><blockquote>
<p> includes 方法用来检测数组中是否包含某个元素，返回布尔类型值</p>
</blockquote>
<pre><code class="javascript">&lt;script&gt;
    // includes   indexOf
    // const mingzhu = [&#39;西游记&#39;,&#39;红楼梦&#39;,&#39;三国演义&#39;,&#39;水浒传&#39;];

    //判断
    // console.log(mingzhu.includes(&#39;西游记&#39;));
    // console.log(mingzhu.includes(&#39;金瓶梅&#39;));    
&lt;/script&gt;
</code></pre>
<h2 id="指数操作符"><a href="#指数操作符" class="headerlink" title="指数操作符"></a>指数操作符</h2><blockquote>
<p>在 ES7 中引入指数运算符「**」，用来实现幂运算，功能与 Math.pow 结果相同</p>
</blockquote>
<pre><code class="javascript">// **
console.log(2 ** 10);// 
console.log(Math.pow(2, 10));
</code></pre>
<h1 id="ECMASript-8-新特性"><a href="#ECMASript-8-新特性" class="headerlink" title="ECMASript 8 新特性"></a>ECMASript 8 新特性</h1><h2 id="async-和-await"><a href="#async-和-await" class="headerlink" title="async 和 await"></a>async 和 await</h2><h3 id="async-函数"><a href="#async-函数" class="headerlink" title="async 函数"></a>async 函数</h3><blockquote>
<ol>
<li><p>async 函数的返回值为 promise 对象， </p>
</li>
<li><p>promise 对象的结果由 async 函数执行的返回值决定</p>
</li>
</ol>
</blockquote>
<pre><code class="javascript">&lt;script&gt;
    //async 函数
    async function fn()&#123;
        // 返回一个字符串
        // return &#39;尚硅谷&#39;;
        // 返回的结果不是一个 Promise 类型的对象, 返回的结果就是成功 Promise 对象
        // return;
        //抛出错误, 返回的结果是一个失败的 Promise
        // throw new Error(&#39;出错啦!&#39;);
        //返回的结果如果是一个 Promise 对象
        return new Promise((resolve, reject)=&gt;&#123;
            resolve(&#39;成功的数据&#39;);
            // reject(&quot;失败的错误&quot;);
        &#125;);
    &#125;

    const result = fn();

    //调用 then 方法
    result.then(value =&gt; &#123;
        console.log(value);
    &#125;, reason =&gt; &#123;
        console.warn(reason);
    &#125;)
&lt;/script&gt;
</code></pre>
<h3 id="await-表达式"><a href="#await-表达式" class="headerlink" title="await 表达式"></a>await 表达式</h3><blockquote>
<ol>
<li>await 必须写在 async 函数中</li>
<li>await 右侧的表达式一般为 promise 对象 </li>
<li> await 返回的是 promise 成功的值 </li>
<li>await 的 promise 失败了, 就会抛出异常, 需要通过 try…catch 捕获处理</li>
</ol>
</blockquote>
<pre><code class="javascript">&lt;script&gt;
    //创建 promise 对象
    const p = new Promise((resolve, reject) =&gt; &#123;
        // resolve(&quot;用户数据&quot;);
        reject(&quot;失败啦!&quot;);
    &#125;)

    // await 要放在 async 函数中.
    async function main() &#123;
        try &#123;
            let result = await p;
            //
            console.log(result);
        &#125; catch (e) &#123;
            console.log(e);
        &#125;
    &#125;
    //调用函数
    main();
&lt;/script&gt;
</code></pre>
<h3 id="async和await结合读取文件"><a href="#async和await结合读取文件" class="headerlink" title="async和await结合读取文件"></a>async和await结合读取文件</h3><pre><code class="javascript">//1. 引入 fs 模块
const fs = require(&quot;fs&quot;);

//读取『为学』
function readWeiXue() &#123;
    return new Promise((resolve, reject) =&gt; &#123;
        fs.readFile(&quot;./resources/为学.md&quot;, (err, data) =&gt; &#123;
            //如果失败
            if (err) reject(err);
            //如果成功
            resolve(data);
        &#125;)
    &#125;)
&#125;

function readChaYangShi() &#123;
    return new Promise((resolve, reject) =&gt; &#123;
        fs.readFile(&quot;./resources/插秧诗.md&quot;, (err, data) =&gt; &#123;
            //如果失败
            if (err) reject(err);
            //如果成功
            resolve(data);
        &#125;)
    &#125;)
&#125;

function readGuanShu() &#123;
    return new Promise((resolve, reject) =&gt; &#123;
        fs.readFile(&quot;./resources/观书有感.md&quot;, (err, data) =&gt; &#123;
            //如果失败
            if (err) reject(err);
            //如果成功
            resolve(data);
        &#125;)
    &#125;)
&#125;

//声明一个 async 函数
async function main()&#123;
    //获取为学内容
    let weixue = await readWeiXue();
    //获取插秧诗内容
    let chayang = await readChaYangShi();
    // 获取观书有感
    let guanshu = await readGuanShu();

    console.log(weixue.toString());
    console.log(chayang.toString());
    console.log(guanshu.toString());
&#125;

main();
</code></pre>
<h3 id="async与await封装AJAX请求"><a href="#async与await封装AJAX请求" class="headerlink" title="async与await封装AJAX请求"></a>async与await封装AJAX请求</h3><pre><code class="javascript">&lt;script&gt;
    // 发送 AJAX 请求, 返回的结果是 Promise 对象
    function sendAJAX(url) &#123;
        return new Promise((resolve, reject) =&gt; &#123;
            //1. 创建对象
            const x = new XMLHttpRequest();

            //2. 初始化
            x.open(&#39;GET&#39;, url);

            //3. 发送
            x.send();

            //4. 事件绑定
            x.onreadystatechange = function () &#123;
                if (x.readyState === 4) &#123;
                    if (x.status &gt;= 200 &amp;&amp; x.status &lt; 300) &#123;
                        //成功啦
                        resolve(x.response);
                    &#125;else&#123;
                        //如果失败
                        reject(x.status);
                    &#125;
                &#125;
            &#125;
        &#125;)
    &#125;

    //promise then 方法测试
    // sendAJAX(&quot;https://api.apiopen.top/getJoke&quot;).then(value=&gt;&#123;
    //     console.log(value);
    // &#125;, reason=&gt;&#123;&#125;)

    // async 与 await 测试  axios
    async function main()&#123;
        //发送 AJAX 请求
        let result = await sendAJAX(&quot;https://api.apiopen.top/getJoke&quot;);
        //再次测试
        let tianqi = await sendAJAX(&#39;https://www.tianqiapi.com/api/?version=v1&amp;city=%E5%8C%97%E4%BA%AC&amp;appid=23941491&amp;appsecret=TXoD5e8P&#39;)

        console.log(tianqi);
    &#125;

    main();
    
&lt;/script&gt;
</code></pre>
<h3 id="对象方法扩展"><a href="#对象方法扩展" class="headerlink" title="对象方法扩展"></a>对象方法扩展</h3><h4 id="Object-values-和-Object-entries"><a href="#Object-values-和-Object-entries" class="headerlink" title="Object.values 和 Object.entries"></a>Object.values 和 Object.entries</h4><blockquote>
<ol>
<li>Object.values()方法返回一个给定对象的所有可枚举属性值的数组</li>
<li>Object.entries()方法返回一个给定对象自身可遍历属性 [key,value] 的数组</li>
</ol>
</blockquote>
<h4 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors"></a>Object.getOwnPropertyDescriptors</h4><blockquote>
<p>该方法返回指定对象所有自身属性的描述对象</p>
</blockquote>
<pre><code>&lt;script&gt;
    //声明对象
    const school = &#123;
        name:&quot;恋爱学院&quot;,
        cities:[&#39;北京&#39;,&#39;上海&#39;,&#39;深圳&#39;],
        xueke: [&#39;前端&#39;,&#39;Java&#39;,&#39;大数据&#39;,&#39;运维&#39;]
    &#125;;

    //获取对象所有的键
    // console.log(Object.keys(school));
    //获取对象所有的值
    // console.log(Object.values(school));
    //entries
    // console.log(Object.entries(school));
    //创建 Map
    // const m = new Map(Object.entries(school));
    // console.log(m.get(&#39;cities&#39;));

    //对象属性的描述对象
    // console.log(Object.getOwnPropertyDescriptors(school));

    // const obj = Object.create(null, &#123;
    //     name: &#123;
    //         //设置值
    //         value: &#39;恋爱学院&#39;,
    //         //属性特性
    //         writable: true,
    //         configurable: true,
    //         enumerable: true
    //     &#125; 
    // &#125;);
&lt;/script&gt;
</code></pre>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>es7、es8</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript-es9、10、11</title>
    <url>/2021/11/26/JavaScript-es9%E3%80%8110%E3%80%8111/</url>
    <content><![CDATA[<h1 id="ECMASript-9-新特性"><a href="#ECMASript-9-新特性" class="headerlink" title="ECMASript 9 新特性"></a>ECMASript 9 新特性</h1><h2 id="Rest-Spread-属性"><a href="#Rest-Spread-属性" class="headerlink" title="Rest/Spread 属性"></a>Rest/Spread 属性</h2><blockquote>
<p>Rest 参数与 spread 扩展运算符在 ES6 中已经引入，不过 ES6 中只针对于数组， 在 ES9 中为对象提供了像数组一样的 rest 参数和扩展运算符</p>
</blockquote>
<pre><code class="javascript">&lt;!-- 
    Rest 参数与 spread 扩展运算符在 ES6 中已经引入，不过 ES6 中只针对于数组，
    在 ES9 中为对象提供了像数组一样的 rest 参数和扩展运算符
    --&gt;
&lt;script&gt;
    //rest 参数
    function connect(&#123;host, port, ...user&#125;)&#123;
        console.log(host);
        console.log(port);
        console.log(user);
    &#125;

    connect(&#123;
        host: &#39;127.0.0.1&#39;,
        port: 3306,
        username: &#39;root&#39;,
        password: &#39;root&#39;,
        type: &#39;master&#39;
    &#125;);


    //对象合并
    const skillOne = &#123;
        q: &#39;天音波&#39;
    &#125;

    const skillTwo = &#123;
        w: &#39;金钟罩&#39;
    &#125;

    const skillThree = &#123;
        e: &#39;天雷破&#39;
    &#125;
    const skillFour = &#123;
        r: &#39;猛龙摆尾&#39;
    &#125;

    const mangseng = &#123;...skillOne, ...skillTwo, ...skillThree, ...skillFour&#125;;

    console.log(mangseng)

    // ...skillOne   =&gt;  q: &#39;天音波&#39;, w: &#39;金钟罩&#39;

&lt;/script&gt;
</code></pre>
<h2 id="正则表达式命名捕获组"><a href="#正则表达式命名捕获组" class="headerlink" title="正则表达式命名捕获组"></a>正则表达式命名捕获组</h2><blockquote>
<p>ES9 允许命名捕获组使用符号『?』,这样获取捕获结果可读性更强</p>
</blockquote>
<pre><code class="javascript">&lt;script&gt;
    //声明一个字符串
    // let str = &#39;&lt;a href=&quot;https://kuankuan.xyz/&quot;&gt;宽宽博客&lt;/a&gt;&#39;;

    // //提取 url 与 『标签文本』
    // const reg = /&lt;a href=&quot;(.*)&quot;&gt;(.*)&lt;\/a&gt;/;

    // //执行
    // const result = reg.exec(str);

    // console.log(result);
    // // console.log(result[1]);
    // // console.log(result[2]);

    
    let str = &#39;&lt;a href=&quot;https://kuankuan.xyz/&quot;&gt;宽宽博客&lt;/a&gt;&#39;;
    //分组命名
    const reg = /&lt;a href=&quot;(?&lt;url&gt;.*)&quot;&gt;(?&lt;text&gt;.*)&lt;\/a&gt;/;

    const result = reg.exec(str);

    console.log(result.groups.url);

    console.log(result.groups.text);
&lt;/script&gt;
</code></pre>
<h2 id="正则表达式反向断言"><a href="#正则表达式反向断言" class="headerlink" title="正则表达式反向断言"></a>正则表达式反向断言</h2><blockquote>
<p>ES9 支持反向断言，通过对匹配结果前面的内容进行判断，对匹配进行筛选。</p>
</blockquote>
<pre><code class="javascript">&lt;script&gt;
    //声明字符串
    let str = &#39;JS5211314你知道么555啦啦啦&#39;;
    //正向断言
    const reg = /\d+(?=啦)/;
    const result = reg.exec(str);

    //反向断言
    const reg = /(?&lt;=么)\d+/;
    const result = reg.exec(str);
    console.log(result);
&lt;/script&gt;
</code></pre>
<h2 id="正则表达式-dotAll-模式"><a href="#正则表达式-dotAll-模式" class="headerlink" title="正则表达式 dotAll 模式"></a>正则表达式 dotAll 模式</h2><blockquote>
<p>正则表达式中点.匹配除回车外的任何单字符，标记『s』改变这种行为，允许行 终止符出现</p>
</blockquote>
<pre><code class="javascript">&lt;script&gt;
    //dot  .  元字符  除换行符以外的任意单个字符
    let str = `
    &lt;ul&gt;
        &lt;li&gt;
            &lt;a&gt;肖生克的救赎&lt;/a&gt;
            &lt;p&gt;上映日期: 1994-09-10&lt;/p&gt;
        &lt;/li&gt;
        &lt;li&gt;
            &lt;a&gt;阿甘正传&lt;/a&gt;
            &lt;p&gt;上映日期: 1994-07-06&lt;/p&gt;
        &lt;/li&gt;
    &lt;/ul&gt;`;
    //声明正则
    // const reg = /&lt;li&gt;\s+&lt;a&gt;(.*?)&lt;\/a&gt;\s+&lt;p&gt;(.*?)&lt;\/p&gt;/;
    const reg = /&lt;li&gt;.*?&lt;a&gt;(.*?)&lt;\/a&gt;.*?&lt;p&gt;(.*?)&lt;\/p&gt;/gs;
    //执行匹配
    // const result = reg.exec(str);
    let result;
    let data = [];
    while(result = reg.exec(str))&#123;
        data.push(&#123;title: result[1], time: result[2]&#125;);
    &#125;
    //输出结果
    console.log(data);
&lt;/script&gt;
</code></pre>
<h1 id="ECMASript-10-新特性"><a href="#ECMASript-10-新特性" class="headerlink" title="ECMASript 10 新特性"></a>ECMASript 10 新特性</h1><h2 id="1-Object-fromEntries"><a href="#1-Object-fromEntries" class="headerlink" title="1-Object.fromEntries"></a>1-Object.fromEntries</h2><pre><code class="javascript">&lt;script&gt;
    //二维数组
    // const result = Object.fromEntries([
    //     [&#39;name&#39;,&#39;恋爱学院&#39;],
    //     [&#39;xueke&#39;, &#39;Java,大数据,前端,云计算&#39;]
    // ]);

    //Map
    // const m = new Map();
    // m.set(&#39;name&#39;,&#39;ATGUIGU&#39;);
    // const result = Object.fromEntries(m);

    //Object.entries ES8
    const arr = Object.entries(&#123;
        name: &quot;恋爱学院&quot;
    &#125;)
    console.log(arr);
&lt;/script&gt;
</code></pre>
<h2 id="2-trimStart与trimEnd"><a href="#2-trimStart与trimEnd" class="headerlink" title="2-trimStart与trimEnd"></a>2-trimStart与trimEnd</h2><pre><code class="javascript">&lt;script&gt;    
    // trim
    let str = &#39;   iloveyou   &#39;;

    console.log(str);
    console.log(str.trimStart());
    console.log(str.trimEnd());
&lt;/script&gt;
</code></pre>
<h2 id="3-Array-prototype-flat与flatMap"><a href="#3-Array-prototype-flat与flatMap" class="headerlink" title="3-Array.prototype.flat与flatMap"></a>3-Array.prototype.flat与flatMap</h2><pre><code class="javascript">&lt;script&gt;
    //flat 平
    //将多维数组转化为低位数组
    // const arr = [1,2,3,4,[5,6]];
    // const arr = [1,2,3,4,[5,6,[7,8,9]]];
    //参数为深度 是一个数字
    // console.log(arr.flat(2));  

    //flatMap
    const arr = [1,2,3,4];
    const result = arr.flatMap(item =&gt; [item * 10]);
    console.log(result);
&lt;/script&gt;
</code></pre>
<h2 id="4-Symbol-prototype-description"><a href="#4-Symbol-prototype-description" class="headerlink" title="4-Symbol.prototype.description"></a>4-Symbol.prototype.description</h2><pre><code class="javascript">&lt;script&gt;
    //创建 Symbol
    let s = Symbol(&#39;恋爱学院&#39;);

    console.log(s.description);
&lt;/script&gt;
</code></pre>
<h1 id="ECMASript-11-新特性"><a href="#ECMASript-11-新特性" class="headerlink" title="ECMASript 11 新特性"></a>ECMASript 11 新特性</h1><h2 id="1-私有属性"><a href="#1-私有属性" class="headerlink" title="1-私有属性"></a>1-私有属性</h2><pre><code class="JavaScript">&lt;script&gt;
    class Person&#123;
        //公有属性
        name;
        //私有属性
        #age;
        #weight;
        //构造方法
        constructor(name, age, weight)&#123;
            this.name = name;
            this.#age = age;
            this.#weight = weight;
        &#125;

        intro()&#123;
            console.log(this.name);
            console.log(this.#age);
            console.log(this.#weight);
        &#125;
    &#125;

    //实例化
    const girl = new Person(&#39;晓红&#39;, 18, &#39;45kg&#39;);

    // console.log(girl.name);
    // console.log(girl.#age);
    // console.log(girl.#weight);

    girl.intro();
&lt;/script&gt;
</code></pre>
<h2 id="2-Promise-allSettled"><a href="#2-Promise-allSettled" class="headerlink" title="2-Promise.allSettled"></a>2-Promise.allSettled</h2><pre><code class="JavaScript">&lt;script&gt;
    //声明两个promise对象
    const p1 = new Promise((resolve, reject)=&gt;&#123;
        setTimeout(()=&gt;&#123;
            resolve(&#39;商品数据 - 1&#39;);
        &#125;,1000)
    &#125;);

    const p2 = new Promise((resolve, reject)=&gt;&#123;
        setTimeout(()=&gt;&#123;
            resolve(&#39;商品数据 - 2&#39;);
            // reject(&#39;出错啦!&#39;);
        &#125;,1000)
    &#125;);

    //调用 allsettled 方法
    // const result = Promise.allSettled([p1, p2]);
    
    // const res = Promise.all([p1, p2]);

    console.log(res);

&lt;/script&gt;
</code></pre>
<h2 id="3-String-prototype-matchAll"><a href="#3-String-prototype-matchAll" class="headerlink" title="3-String.prototype.matchAll"></a>3-String.prototype.matchAll</h2><pre><code class="JavaScript">&lt;script&gt;
    let str = `&lt;ul&gt;
        &lt;li&gt;
            &lt;a&gt;肖生克的救赎&lt;/a&gt;
            &lt;p&gt;上映日期: 1994-09-10&lt;/p&gt;
        &lt;/li&gt;
        &lt;li&gt;
            &lt;a&gt;阿甘正传&lt;/a&gt;
            &lt;p&gt;上映日期: 1994-07-06&lt;/p&gt;
        &lt;/li&gt;
    &lt;/ul&gt;`;

    //声明正则
    const reg = /&lt;li&gt;.*?&lt;a&gt;(.*?)&lt;\/a&gt;.*?&lt;p&gt;(.*?)&lt;\/p&gt;/sg

    //调用方法
    const result = str.matchAll(reg);

    // for(let v of result)&#123;
    //     console.log(v);
    // &#125;

    const arr = [...result];

    console.log(arr);    
&lt;/script&gt;
</code></pre>
<h2 id="4-可选链操作符"><a href="#4-可选链操作符" class="headerlink" title="4-可选链操作符"></a>4-可选链操作符</h2><pre><code class="JavaScript">&lt;script&gt;
    // ?.
    function main(config)&#123;
        // const dbHost = config &amp;&amp; config.db &amp;&amp; config.db.host;
        const dbHost = config?.db?.host;

        console.log(dbHost);
    &#125;

    main(&#123;
        db: &#123;
            host:&#39;192.168.1.100&#39;,
            username: &#39;root&#39;
        &#125;,
        cache: &#123;
            host: &#39;192.168.1.200&#39;,
            username:&#39;admin&#39;
        &#125;
    &#125;)
&lt;/script&gt;
</code></pre>
<h2 id="5-动态import加载"><a href="#5-动态import加载" class="headerlink" title="5-动态import加载"></a>5-动态import加载</h2><pre><code class="javascript">&lt;body&gt;
    &lt;button id=&quot;btn&quot;&gt;点击&lt;/button&gt;
    &lt;script src=&quot;./js/app.js&quot; type=&quot;module&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
</code></pre>
<pre><code class="javascript">// import * as m1 from &quot;./hello.js&quot;;
//获取元素
const btn = document.getElementById(&#39;btn&#39;);

btn.onclick = function()&#123;
    import(&#39;./hello.js&#39;).then(module =&gt; &#123;
        module.hello();
    &#125;);
&#125;
</code></pre>
<pre><code class="javascript">export function hello()&#123;
    alert(&#39;Hello&#39;);
&#125;
</code></pre>
<h2 id="6-BigInt"><a href="#6-BigInt" class="headerlink" title="6-BigInt"></a>6-BigInt</h2><pre><code class="JavaScript">&lt;script&gt;
    //大整形
    // let n = 521n;
    // console.log(n, typeof(n));

    //函数
    // let n = 123;
    // console.log(BigInt(n));
    // console.log(BigInt(1.2));

    //大数值运算
    let max = Number.MAX_SAFE_INTEGER;
    console.log(max);
    console.log(max + 1);
    console.log(max + 2);

    console.log(BigInt(max))
    console.log(BigInt(max) + BigInt(1))
    console.log(BigInt(max) + BigInt(2))
&lt;/script&gt;
</code></pre>
<h2 id="7-globalThis"><a href="#7-globalThis" class="headerlink" title="7-globalThis"></a>7-globalThis</h2><pre><code class="javascript">&lt;script&gt;
    console.log(globalThis);
&lt;/script&gt;
</code></pre>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>es9、es10、es11</tag>
      </tags>
  </entry>
  <entry>
    <title>MVC、MVP、MVVM之间的关系</title>
    <url>/2020/03/06/MVC%E3%80%81MVP%E3%80%81MVVM%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<h2 id="一、MVC"><a href="#一、MVC" class="headerlink" title="一、MVC"></a>一、MVC</h2><hr>
<h3 id="什么是MVC"><a href="#什么是MVC" class="headerlink" title="什么是MVC"></a>什么是MVC</h3><hr>
<ul>
<li>MVC是一种模式，它将应用分为3个部分：数据（模型）、表现层（视图）、用户交互层（控制器）</li>
<li>一个事件的处理大概是这样<ul>
<li>用户和应用产生交互</li>
<li>控制器的事件处理器被触发</li>
<li>控制器从模型中请求数据，并将其交给视图</li>
<li>视图将数据呈现给用户</li>
</ul>
</li>
</ul>
<h3 id="模型（数据保存）"><a href="#模型（数据保存）" class="headerlink" title="模型（数据保存）"></a>模型（数据保存）</h3><hr>
<ul>
<li>模型用来存放用户的所有数据对象。比如有一个user模型，用来存放用户列表、他们的属性以及所有和模型有关的逻辑</li>
<li>模型不必知晓视图和控制器的细节，模型只需包含数据以及直接和这些数据相关的逻辑</li>
</ul>
<h3 id="视图（用户界面）"><a href="#视图（用户界面）" class="headerlink" title="视图（用户界面）"></a>视图（用户界面）</h3><hr>
<ul>
<li>视图是呈现给用户的，用户与之产生交互。在JavaScript应用中，视图大都是由HTML、css、JavaScript模板组成的</li>
</ul>
<h3 id="控制器（业务逻辑）"><a href="#控制器（业务逻辑）" class="headerlink" title="控制器（业务逻辑）"></a>控制器（业务逻辑）</h3><hr>
<ul>
<li>控制器是模型和视图之间的纽带。控制器从视图获得事件和输入，对它们进行进行处理，并相应的更新视图。</li>
<li>当页面加载时，控制器会给视图添加事件监听，比如监听表单提交或按钮点击。然后当用户和你的应用产生交互时，控制器中的事件触发器就开始工作了</li>
</ul>
<h3 id="总结一下："><a href="#总结一下：" class="headerlink" title="总结一下："></a>总结一下：</h3><hr>
<ul>
<li><code>Controller</code> 监听 <code>Model</code> 变化，<code>Model</code> 一变，<code>Controller</code> 就会去更新<code>View</code>。</li>
<li><code>Controller</code> 监听用户交互，用户点了提交或修改按钮，Controller 就要去更新 Model</li>
<li><code>View</code> 传送指令到 <code>Controller</code></li>
<li><code>Controller</code> 完成业务逻辑后，要求 <code>Model</code> 改变状态</li>
<li><code>Model</code> 将新的数据发送到 <code>View</code>，用户得到反馈</li>
</ul>
<p>各部分之间的通信方式</p>
<p><img src="http://image.beekka.com/blog/2015/bg2015020105.png" alt="img"></p>
<h2 id="互动模式"><a href="#互动模式" class="headerlink" title="互动模式"></a>互动模式</h2><hr>
<ul>
<li>接受用户指令时，MVC 可以分成两种方式。一种是通过 View 接受指令，传递给 Controller</li>
</ul>
<p><img src="http://image.beekka.com/blog/2015/bg2015020106.png" alt="img"></p>
<ul>
<li>另一种是直接通过controller接受指令</li>
</ul>
<p><img src="http://image.beekka.com/blog/2015/bg2015020107.png" alt="img"></p>
<h2 id="二、MVP"><a href="#二、MVP" class="headerlink" title="二、MVP"></a>二、MVP</h2><hr>
<ul>
<li><code>MVP</code> 模式将 <code>Controller 改名为</code>Presenter`，同时改变了通信方向</li>
</ul>
<p><img src="http://image.beekka.com/blog/2015/bg2015020109.png" alt="img"></p>
<ul>
<li>各部分之间的通信，都是双向的。</li>
<li><code>View</code> 与<code>Model</code> 不发生联系，都通过 <code>Presenter</code> 传递。</li>
<li><code>View</code> 非常薄，不部署任何业务逻辑，称为”被动视图”（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里</li>
</ul>
<h2 id="三、MVVM"><a href="#三、MVVM" class="headerlink" title="三、MVVM"></a>三、MVVM</h2><hr>
<ul>
<li><code>MVVM</code> 模式将 <code>Presenter</code> 改名为 <code>ViewModel</code>，基本上与 <code>MVP</code> 模式完全一致</li>
<li>唯一的区别是，它采用双向绑定（data-binding）：<code>View</code>的变动，自动反映在 <code>ViewModel</code>，反之亦然</li>
</ul>
<p><img src="http://image.beekka.com/blog/2015/bg2015020110.png" alt="img"></p>
]]></content>
      <categories>
        <category>架构模式</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Object.defineProperty详解</title>
    <url>/2020/02/13/Object.defineProperty%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p><strong>兼容性</strong></p>
<blockquote>
<p>在<code>ie8</code>下只能在<code>DOM</code>对象上使用，尝试在原生的对象使用 <code>Object.defineProperty()</code>会报错。</p>
</blockquote>
<p>定义对象可以使用构造函数或字面量的形式</p>
<pre><code>var obj = new Object;  //obj = &#123;&#125;
obj.name = &quot;张三&quot;;  //添加描述
obj.say = function()&#123;&#125;;  //添加行为
</code></pre>
<blockquote>
<p>除了以上添加属性的方式，还可以使用<code>Object.defineProperty</code>定义新属性或修改原有的属性</p>
</blockquote>
<h2 id="二、Object-defineProperty"><a href="#二、Object-defineProperty" class="headerlink" title="二、Object.defineProperty()"></a>二、Object.defineProperty()</h2><h3 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h3><pre><code>Object.defineProperty(obj, prop, descriptor)
</code></pre>
<p><strong>参数说明</strong>：</p>
<ul>
<li><code>obj</code>：必需。目标对象</li>
<li><code>prop</code>：必需。需定义或修改的属性的名字</li>
<li><code>descriptor</code>：必需。目标属性所拥有的特性</li>
</ul>
<blockquote>
<p>返回值：传入函数的对象。即第一个参数<code>obj</code></p>
</blockquote>
<ul>
<li>针对属性，我们可以给这个属性设置一些特性，比如是否只读不可以写；是否可以被<code>for..in</code>或<code>Object.keys()</code>遍历。</li>
</ul>
<p><strong>给对象的属性添加特性描述，目前提供两种形式：数据描述和存取器描述</strong></p>
<h3 id="2-2-数据描述"><a href="#2-2-数据描述" class="headerlink" title="2.2 数据描述"></a>2.2 数据描述</h3><blockquote>
<p>当修改或定义对象的某个属性的时候，给这个属性添加一些特性</p>
</blockquote>
<pre><code>var obj = &#123;
    test:&quot;hello&quot;
&#125;
//对象已有的属性添加特性描述
Object.defineProperty(obj,&quot;test&quot;,&#123;
    configurable:true | false,
    enumerable:true | false,
    value:任意类型的值,
    writable:true | false
&#125;);
//对象新添加的属性的特性描述
Object.defineProperty(obj,&quot;newKey&quot;,&#123;
    configurable:true | false,
    enumerable:true | false,
    value:任意类型的值,
    writable:true | false
&#125;);
</code></pre>
<blockquote>
<p>数据描述中的属性都是可选的，来看一下设置每一个属性的作用</p>
</blockquote>
<h4 id="2-2-1-value"><a href="#2-2-1-value" class="headerlink" title="2.2.1 value"></a>2.2.1 value</h4><blockquote>
<p>属性对应的值,可以使任意类型的值，默认为<code>undefined</code></p>
</blockquote>
<pre><code>var obj = &#123;&#125;
//第一种情况：不设置value属性
Object.defineProperty(obj,&quot;newKey&quot;,&#123;

&#125;);
console.log( obj.newKey );  //undefined
------------------------------
//第二种情况：设置value属性
Object.defineProperty(obj,&quot;newKey&quot;,&#123;
    value:&quot;hello&quot;
&#125;);
console.log( obj.newKey );  //hello
</code></pre>
<h4 id="2-2-2-writable"><a href="#2-2-2-writable" class="headerlink" title="2.2.2 writable"></a>2.2.2 writable</h4><blockquote>
<p>属性的值是否可以被重写。设置为<code>true</code>可以被重写；设置为<code>false</code>，不能被重写。默认为<code>false</code></p>
</blockquote>
<pre><code>var obj = &#123;&#125;
//第一种情况：writable设置为false，不能重写。
Object.defineProperty(obj,&quot;newKey&quot;,&#123;
    value:&quot;hello&quot;,
    writable:false
&#125;);
//更改newKey的值
obj.newKey = &quot;change value&quot;;
console.log( obj.newKey );  //hello

//第二种情况：writable设置为true，可以重写
Object.defineProperty(obj,&quot;newKey&quot;,&#123;
    value:&quot;hello&quot;,
    writable:true
&#125;);
//更改newKey的值
obj.newKey = &quot;change value&quot;;
console.log( obj.newKey );  //change value
</code></pre>
<h4 id="2-2-3-enumerable"><a href="#2-2-3-enumerable" class="headerlink" title="2.2.3 enumerable"></a>2.2.3 enumerable</h4><blockquote>
<p>此属性是否可以被枚举（使用<code>for...in</code>或<code>Object.keys()</code>）。设置为<code>true</code>可以被枚举；设置为<code>false</code>，不能被枚举。默认为<code>false</code></p>
</blockquote>
<pre><code>var obj = &#123;&#125;
//第一种情况：enumerable设置为false，不能被枚举。
Object.defineProperty(obj,&quot;newKey&quot;,&#123;
    value:&quot;hello&quot;,
    writable:false,
    enumerable:false
&#125;);

//枚举对象的属性
for( var attr in obj )&#123;
    console.log( attr );  
&#125;
//第二种情况：enumerable设置为true，可以被枚举。
Object.defineProperty(obj,&quot;newKey&quot;,&#123;
    value:&quot;hello&quot;,
    writable:false,
    enumerable:true
&#125;);

//枚举对象的属性
for( var attr in obj )&#123;
    console.log( attr );  //newKey
&#125;
</code></pre>
<h4 id="2-2-4-configurable"><a href="#2-2-4-configurable" class="headerlink" title="2.2.4 configurable"></a>2.2.4 configurable</h4><blockquote>
<p>是否可以删除目标属性或是否可以再次修改属性的特性（<code>writable</code>, <code>configurable</code>, <code>enumerable</code>）。设置为<code>true</code>可以被删除或可以重新设置特性；设置为<code>false</code>，不能被可以被删除或不可以重新设置特性。默认为<code>false</code></p>
</blockquote>
<p><strong>这个属性起到两个作用</strong></p>
<ul>
<li>目标属性是否可以使用<code>delete</code>删除</li>
<li>目标属性是否可以再次设置特性</li>
</ul>
<pre><code>//-----------------测试目标属性是否能被删除------------------------
var obj = &#123;&#125;
//第一种情况：configurable设置为false，不能被删除。
Object.defineProperty(obj,&quot;newKey&quot;,&#123;
    value:&quot;hello&quot;,
    writable:false,
    enumerable:false,
    configurable:false
&#125;);
//删除属性
delete obj.newKey;
console.log( obj.newKey ); //hello

//第二种情况：configurable设置为true，可以被删除。
Object.defineProperty(obj,&quot;newKey&quot;,&#123;
    value:&quot;hello&quot;,
    writable:false,
    enumerable:false,
    configurable:true
&#125;);
//删除属性
delete obj.newKey;
console.log( obj.newKey ); //undefined
//-----------------测试是否可以再次修改特性------------------------
var obj = &#123;&#125;
//第一种情况：configurable设置为false，不能再次修改特性。
Object.defineProperty(obj,&quot;newKey&quot;,&#123;
    value:&quot;hello&quot;,
    writable:false,
    enumerable:false,
    configurable:false
&#125;);

//重新修改特性
Object.defineProperty(obj,&quot;newKey&quot;,&#123;
    value:&quot;hello&quot;,
    writable:true,
    enumerable:true,
    configurable:true
&#125;);
console.log( obj.newKey ); //报错：Uncaught TypeError: Cannot redefine property: newKey

//第二种情况：configurable设置为true，可以再次修改特性。
Object.defineProperty(obj,&quot;newKey&quot;,&#123;
    value:&quot;hello&quot;,
    writable:false,
    enumerable:false,
    configurable:true
&#125;);

//重新修改特性
Object.defineProperty(obj,&quot;newKey&quot;,&#123;
    value:&quot;hello&quot;,
    writable:true,
    enumerable:true,
    configurable:true
&#125;);
console.log( obj.newKey ); //hello
</code></pre>
<blockquote>
<p>除了可以给新定义的属性设置特性，也可以给已有的属性设置特性</p>
</blockquote>
<pre><code>//定义对象的时候添加的属性，是可删除、可重写、可枚举的。
var obj = &#123;
    test:&quot;hello&quot;
&#125;

//改写值
obj.test = &#39;change value&#39;;

console.log( obj.test ); //&#39;change value&#39;

Object.defineProperty(obj,&quot;test&quot;,&#123;
    writable:false
&#125;)


//再次改写值
obj.test = &#39;change value again&#39;;

console.log( obj.test ); //依然是：&#39;change value&#39;
</code></pre>
<blockquote>
<p>提示：一旦使用<code>Object.defineProperty</code>给对象添加属性，那么如果不设置属性的特性，那么<code>configurable</code>、<code>enumerable</code>、<code>writable</code>这些值都为默认的<code>false</code></p>
</blockquote>
<pre><code>var obj = &#123;&#125;;
//定义的新属性后，这个属性的特性中configurable，enumerable，writable都为默认的值false
//这就导致了neykey这个是不能重写、不能枚举、不能再次设置特性
//
Object.defineProperty(obj,&#39;newKey&#39;,&#123;

&#125;);

//设置值
obj.newKey = &#39;hello&#39;;
console.log(obj.newKey);  //undefined

//枚举
for( var attr in obj )&#123;
    console.log(attr);
&#125;
</code></pre>
<p><strong>设置的特性总结</strong></p>
<ul>
<li><code>value</code>: 设置属性的值</li>
<li><code>writable</code>: 值是否可以重写。<code>true</code> | <code>false</code></li>
<li><code>enumerable</code>: 目标属性是否可以被枚举。<code>true</code> | <code>false</code></li>
<li><code>configurable</code>: 目标属性是否可以被删除或是否可以再次修改特性 <code>true</code> | <code>false</code></li>
</ul>
<h3 id="2-3-存取器描述"><a href="#2-3-存取器描述" class="headerlink" title="2.3 存取器描述"></a>2.3 存取器描述</h3><h4 id="2-3-1-定义"><a href="#2-3-1-定义" class="headerlink" title="2.3.1 定义"></a>2.3.1 定义</h4><blockquote>
<p>当使用存取器描述属性的特性的时候，允许设置以下特性属性</p>
</blockquote>
<pre><code>var obj = &#123;&#125;;
Object.defineProperty(obj,&quot;newKey&quot;,&#123;
    get:function ()&#123;&#125; | undefined,
    set:function (value)&#123;&#125; | undefined
    configurable: true | false
    enumerable: true | false
&#125;);
</code></pre>
<blockquote>
<p>注意：当使用了<code>getter</code>或<code>setter</code>方法，不允许使用<code>writable</code>和<code>value</code>这两个属性</p>
</blockquote>
<h4 id="2-3-2-getter-setter"><a href="#2-3-2-getter-setter" class="headerlink" title="2.3.2 getter/setter"></a>2.3.2 getter/setter</h4><blockquote>
<p>当设置或获取对象的某个属性的值的时候，可以提供<code>getter/setter</code>方法。</p>
</blockquote>
<ul>
<li><code>getter</code> 是一种获得属性值的方法</li>
<li><code>setter</code>是一种设置属性值的方法</li>
</ul>
<blockquote>
<p>在特性中使用<code>get/set</code>属性来定义对应的方法</p>
</blockquote>
<pre><code>var obj = &#123;&#125;;
var initValue = &#39;hello&#39;;
Object.defineProperty(obj,&quot;newKey&quot;,&#123;
    get:function ()&#123;
        //当获取值的时候触发的函数
        return initValue;    
    &#125;,
    set:function (value)&#123;
        //当设置值的时候触发的函数,设置的新值通过参数value拿到
        initValue = value;
    &#125;
&#125;);
//获取值
console.log( obj.newKey );  //hello

//设置值
obj.newKey = &#39;change value&#39;;

console.log( obj.newKey ); //change value
</code></pre>
<blockquote>
<p>注意：get或set不是必须成对出现，任写其一就可以。如果不设置方法，则<code>get</code>和<code>set</code>的默认值为<code>undefined</code></p>
</blockquote>
]]></content>
      <categories>
        <category>原理</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV基础篇</title>
    <url>/2022/02/07/OpenCV%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    <content><![CDATA[<h1 id="PythonOpenCV基础篇"><a href="#PythonOpenCV基础篇" class="headerlink" title="PythonOpenCV基础篇"></a>PythonOpenCV基础篇</h1><h1 id="第6章-绘制图形和文字"><a href="#第6章-绘制图形和文字" class="headerlink" title="第6章　绘制图形和文字"></a>第6章　绘制图形和文字</h1><p>OpenCV提供了许多绘制图形的方法，包括绘制线段的line()方法、绘制矩形的rectangle()方法、绘制圆形的circle()方法、绘制多边形的polylines()方法和绘制文字的putText()方法。本章将依次对上述各个方法进行讲解，并使用上述方法绘制相应的图形。</p>
<p><img src="/.com//image-20211118141415260.png" alt="image-20211118141415260"></p>
<h2 id="6-1-线段的绘制"><a href="#6-1-线段的绘制" class="headerlink" title="6.1　线段的绘制"></a>6.1　线段的绘制</h2><p>OpenCV提供了用于绘制线段的line()方法，使用这个方法即可绘制长短不一、粗细各异、五颜六色的线段。line()方法的语法格式如下：</p>
<pre><code> img = cv2.line(img, pt1, pt2, color, thickness)
</code></pre>
<p>参数说明：　</p>
<p>img：画布。　</p>
<p>pt1：线段的起点坐标。　</p>
<p>pt2：线段的终点坐标。　</p>
<p>color：绘制线段时的线条颜色。　</p>
<p>thickness：绘制线段时的线条宽度。</p>
<p>注意<br>线条颜色是RGB格式的，例如红色的RGB值是(255, 0, 0)。但是在OpenCV中，RGB图像的通道顺序被转换成B→G→R，因此(0, 0, 255)代表的是红色。</p>
<p>【实例6.1】　绘制线段并拼成一个“王”字。<br>编写一个程序，使用line()方法分别绘制颜色为蓝色、绿色、红色和黄色，线条宽度为5、10、15和20的4条线段，并且这4条线段能够拼成一个“王”字如图6.1所示，把其主体部分放在图6.2所示的坐标系中，即可确定每条线段的起点坐标和终点坐标，代码如下：</p>
<pre><code> import numpy as np # 导入Python中的numpy模块
 import cv2
 # np.zeros()：创建了一个画布
 # (300, 300, 3)：一个300 x 300，具有3个颜色空间（即Red、Green和Blue）的画布
 # np.uint8：OpenCV 中的灰度图像和RGB图像都是以uint8存储的，因此这里的类型也是uint8
 canvas = np.zeros((300, 300, 3), np.uint8)
 # 在画布上，绘制一条起点坐标为(50, 50)、终点坐标为(250, 50)、蓝色的、线条宽度为5的线段
 canvas = cv2.line(canvas, (50, 50), (250, 50), (255, 0, 0), 5)
 # 在画布上，绘制一条起点坐标为(50, 150)、终点坐标为(250, 150)、绿色的、线条宽度为10的线段
 canvas = cv2.line(canvas, (50, 150), (250, 150), (0, 255, 0), 10)
 # 在画布上，绘制一条起点坐标为(50, 250)、终点坐标为(250, 250)、红色的、线条宽度为15的线段
 canvas = cv2.line(canvas, (50, 250), (250, 250), (0, 0, 255), 15)
 # 在画布上，绘制一条起点坐标为(150, 50)、终点坐标为(150, 250)、黄色的、线条宽度为20的线段
 canvas = cv2.line(canvas, (150, 50), (150, 250), (0, 255, 255), 20)
 cv2.imshow(&quot;Lines&quot;, canvas) # 显示画布
 cv2.waitKey()
 cv2.destroyAllWindows()
</code></pre>
<p><img src="/.com//image-20211118142121651.png" alt="image-20211118142121651"></p>
<p>​                                                                                          图6.1　绘制线段并拼成一个“王”字</p>
<p><img src="/.com//image-20211118142054962.png" alt="image-20211118142054962"></p>
<p>​                                                                                图6.2　每条线段的起点坐标和终点坐标</p>
<p>此外，如果想把图6.1中的黑色背景替换为白色背景，应该如何操作呢？</p>
<p>这时，只需将实例6.1的第7行代码替换成如下代码即可：</p>
<pre><code> canvas = np.ones((300, 300, 3), np.uint8) * 255
</code></pre>
<p>运行修改后的代码，得到如图6.3所示的结果。</p>
<p><img src="/.com//image-20211118142429945.png" alt="image-20211118142429945"></p>
<p>​                                                                             图6.3　把图6.1中的黑色背景替换为白色背景</p>
<h2 id="6-2-矩形的绘制"><a href="#6-2-矩形的绘制" class="headerlink" title="6.2　矩形的绘制"></a>6.2　矩形的绘制</h2><p>OpenCV提供了用于绘制矩形的rectangle()方法，使用这个方法既可以绘制矩形边框，也可以绘制实心矩形。rectangle()方法的语法格式如下：</p>
<pre><code> img = cv2.rectangle(img, pt1, pt2, color, thickness)
</code></pre>
<p>参数说明：　</p>
<p>img：画布。</p>
<p>pt1：矩形的左上角坐标。　</p>
<p>pt2：矩形的右下角坐标。　</p>
<p>color：绘制矩形时的线条颜色。　</p>
<p>thickness：绘制矩形时的线条宽度。</p>
<p>【实例6.2】　绘制一个矩形边框。<br>编写一个程序，使用rectangle()方法绘制一个青色的、线条宽度为20的矩形边框。绘制矩形时，矩形的左上角坐标为(50, 50)，矩形的右下角坐标为(200, 150)，代码如下：</p>
<pre><code> import numpy as np # 导入Python中的numpy模块
 import cv2
 # np.zeros()：创建了一个画布
 # (300, 300, 3)：一个300 x 300，具有3个颜色空间（即Red、Green和Blue）的画布
 # np.uint8：OpenCV中的灰度图像和RGB图像都是以uint8存储的，因此这里的类型也是uint8
 canvas = np.zeros((300, 300, 3), np.uint8)
 # 在画布上绘制一个左上角坐标为(50,50)、右下角坐标为(200,150)、青色的、线条宽度为20的矩形边框
 canvas = cv2.rectangle(canvas, (50, 50), (200, 150), (255, 255, 0), 20)
 cv2.imshow(&quot;Rectangle&quot;, canvas) # 显示画布
 cv2.waitKey()
 cv2.destroyAllWindows()
</code></pre>
<p>上述代码的运行结果如图6.4所示</p>
<p>说明<br>可参照图6.2所示的坐标系，了解矩形的左上角坐标和矩形的右下角坐标是如何确定的。<br>如果想要填充图6.4中的矩形边框，使之变成实心矩形，应该如何修改上述代码呢？<br>在rectangle()方法的语法格式中，thickness表示绘制矩</p>
<p>形时的线条宽度。当thickness的值为-1时，即可绘制一个实心矩形。也就是说，只需要把实例6.2的第9行代码中的最后一个参数20修改为-1，就能够绘制一个实心矩形，关键代码如下：</p>
<pre><code> canvas = cv2.rectangle(canvas, (50, 50), (200, 150), (255, 255, 0), -1) # 绘制一个实心矩形
</code></pre>
<p>运行修改后的代码，得到如图6.5所示的结果。</p>
<p><img src="/.com//image-20211118142643073.png" alt="image-20211118142643073"></p>
<p>​                                                                             图6.4　绘制一个矩形边框</p>
<p><img src="/.com//image-20211118142722661.png" alt="image-20211118142722661"></p>
<p>​                                                                                      图6.5　绘制一个实心矩形</p>
<p>正方形是特殊的矩形，因此使用rectangle()方法不仅能绘制矩形，还能绘制正方形。</p>
<p>【实例6.3】　绘制正方形。<br>编写一个程序，使用rectangle()方法分别绘制3个正方形边框和1个实心正方形，具体要求如下。<br>（1）左上角坐标为(50, 50)、右下角坐标为(250, 250)、红色的、线条宽度为40的正方形边框。<br>（2）左上角坐标为(90, 90)、右下角坐标为(210, 210)、绿色的、线条宽度为30的正方形边框。<br>（3）左上角坐标为(120, 120)、右下角坐标为(180, 180)、蓝色的、线条宽度为20的正方形边框。</p>
<p>（4）左上角坐标为(140, 140)、右下角坐标为(160, 160)、黄色的实心正方形。<br>代码如下：</p>
<pre><code> import numpy as np # 导入Python中的numpy模块
 import cv2
 # np.zeros()：创建了一个画布
 # (300, 300, 3)：一个300 x 300，具有3个颜色空间（即Red、Green和Blue）的画布
 # np.uint8：OpenCV中的灰度图像和RGB图像都是以uint8存储的，因此这里的类型也是uint8
 canvas = np.zeros((300, 300, 3), np.uint8)
 # 绘制一个左上角坐标为(50,50)、右下角坐标为(250,250)、红色的、线条宽度为40的正方形边框
 canvas = cv2.rectangle(canvas, (50, 50), (250, 250), (0, 0, 255), 40)
 # 绘制一个左上角坐标为(90,90)、右下角坐标为(210,210)、绿色的、线条宽度为30的正方形边框
 canvas = cv2.rectangle(canvas, (90, 90), (210, 210), (0, 255, 0), 30)
 # 绘制一个左上角坐标为(120,120)、右下角坐标为(180,180)、蓝色的、线条宽度为20的正方形边框
 canvas = cv2.rectangle(canvas, (120, 120), (180, 180), (255, 0, 0), 20)
 # 绘制一个左上角坐标为(140,140)、右下角坐标为(160,160)、黄色的实心正方形
 canvas = cv2.rectangle(canvas, (140, 140), (160, 160), (0, 255, 255), -1)
 cv2.imshow(&quot;Square&quot;, canvas) # 显示画布
 cv2.waitKey()
 cv2.destroyAllWindows()
</code></pre>
<p>上述代码的运行结果如图6.6所示。</p>
<p><img src="/.com//image-20211118143019442.png" alt="image-20211118143019442"></p>
<p>​                                                                                      图6.6　绘制正方形</p>
<h2 id="6-3-圆形的绘制"><a href="#6-3-圆形的绘制" class="headerlink" title="6.3　圆形的绘制"></a>6.3　圆形的绘制</h2><p>OpenCV提供了用于绘制圆形的circle()方法，这个方法与rectangle()方法的功能相同，既可以绘制圆形边框，也可以绘制实心圆形。circle()方法的语法格式如下：</p>
<pre><code> img = cv2.circle(img, center, radius, color, thickness)
</code></pre>
<p>参数说明：　img：画布。　center：圆形的圆心坐标。　radius：圆形的半径。　color：绘制圆形时的线条颜色。　thickness：绘制圆形时的线条宽度。</p>
<p>【实例6.4】　绘制“交通灯”。（实例位置：资源包\TM\sl\6\04）<br>编写一个程序，使用circle()方法分别绘制红色的、黄色的和绿色的3个实心圆形，用于模拟交通灯。这3个实心圆形的半径均为40，并且呈水平方向放置，代码如下：</p>
<pre><code> import numpy as np # 导入Python中的numpy模块
 import cv2
 # np.zeros()：创建了一个画布
 # (100, 300, 3)：一个100 x 300，具有3个颜色空间（即Red、Green和Blue）的画布
 # np.uint8：OpenCV中的灰度图像和RGB图像都是以uint8存储的，因此这里的类型也是uint8
 canvas = np.zeros((100, 300, 3), np.uint8)
</code></pre>
<p>在画布上，绘制一个圆心坐标为(50, 50)、半径为40、红色的实心圆形</p>
<pre><code> canvas = cv2.circle(canvas, (50, 50), 40, (0, 0, 255), -1)
 # 在画布上，绘制一个圆心坐标为(150, 50)、半径为40、黄色的实心圆形
 canvas = cv2.circle(canvas, (150, 50), 40, (0, 255, 255), -1)
 # 在画布上，绘制一个圆心坐标为(250, 50)、半径为40、绿色的实心圆形
 canvas = cv2.circle(canvas, (250, 50), 40, (0, 255, 0), -1)
 cv2.imshow(&quot;TrafficLights&quot;, canvas) # 显示画布
 cv2.waitKey()
 cv2.destroyAllWindows()
</code></pre>
<p>上述代码的运行结果如图6.7所示。</p>
<p><img src="/.com//image-20211118143049435.png" alt="image-20211118143049435"></p>
<p>​                                                                                                   图6.7　绘制“交通灯”<br>绘制圆形和绘制线段或者矩形一样容易，但是绘制圆形要比绘制线段或者矩形多一些趣味。例如，绘制同心圆、绘制随机圆等。</p>
<p>【实例6.5】　绘制同心圆。（实例位置：资源包\TM\sl\6\05）<br>编写一个程序，使用circle()方法和for循环绘制5个同心圆，这些圆形的圆心坐标均为画布的中心，半径的值分别为0，30，60，90和120，线条颜色均为绿色，线条宽度均为5，代码如下：</p>
<pre><code> import numpy as np # 导入Python中的numpy模块
 import cv2
 # np.zeros()：创建了一个画布
 # (300, 300, 3)：一个300 x 300，具有3个颜色空间（即Red、Green和Blue）的画布
 # np.uint8：OpenCV中的灰度图像和RGB图像都是以u
 #uint8存储的，因此这里的类型也是uint8
 canvas = np.zeros((300, 300, 3), np.uint8)

#shape[1]表示画布的宽度，center_X表示圆心的横坐标

#圆心的横坐标等于画布的宽度的一半

center_X = int(canvas.shape[1] / 2)

#shape[0]表示画布的高度，center_X表示圆心的纵坐标

#圆心的纵坐标等于画布的高度的一半

center_Y = int(canvas.shape[0] / 2)

#r表示半径；其中，r的值分别为0，30，60，90和120

for r in range(0, 150, 30):

#绘制一个圆心坐标为(center_X, center_Y)、半径为r、绿色的、线条宽度为5的圆形

    cv2.circle(canvas, (center_X, center_Y), r, (0, 255, 0), 5)
cv2.imshow(&quot;Circles&quot;, canvas) # 显示画布
cv2.waitKey()
cv2.destroyAllWindows()
</code></pre>
<p>上述代码的运行结果如图6.8所示。</p>
<p><img src="/.com//image-20211118143455707.png" alt="image-20211118143455707"></p>
<p>​                                                                                                   图6.8　绘制同心圆</p>
<p>【实例6.6】　绘制27个随机实心圆。（实例位置：资源包\TM\sl\6\06）<br>编写一个程序，使用circle()方法和for循环随机绘制27个实心圆。其中，圆心的横、纵坐标在[0, 299]内取值，半径在[11, 70]内取值，线条颜色由3个在[0, 255]内的随机数组成的列表表示，代码如下：</p>
<pre><code> import numpy as np # 导入Python中的numpy模块
 import cv2
 # np.zeros()：创建了一个画布
 # (300, 300, 3)：一个300 x 300，具有3个颜色空间（即Red、Green和Blue）的画布
 # np.uint8：OpenCV中的灰度图像和RGB图像都是以uint8存储的，因此这里的类型也是uint8
 canvas = np.zeros((300, 300, 3), np.uint8)
 # 通过循环绘制27个实心圆
 for numbers in range(0, 28):
     # 获得随机的圆心横坐标，这个横坐标在[0, 299]范围内取值
     center_X = np.random.randint(0, high = 300)
     # 获得随机的圆心纵坐标，这个纵坐标在[0, 299]范围内取值
     center_Y = np.random.randint(0, high = 300)
     # 获得随机的半径，这个半径在[11, 70]范围内取值
     radius = np.random.randint(11, high = 71)
     # 获得随机的线条颜色，这个颜色由3个在[0, 255]范围内的随机数组成的列表表示
     color = np.random.randint(0, high = 256, size = (3,)).tolist()
     # 绘制一个圆心坐标为(center_X, center_Y)、半径为radius、颜色为color的实心圆形
     cv2.circle(canvas, (center_X, center_Y), radius, color, -1)
 cv2.imshow(&quot;Circles&quot;, canvas) # 显示画布
 cv2.waitKey()
 cv2.destroyAllWindows()
</code></pre>
<p>上述代码的运行结果如图6.9所示。</p>
<p><img src="/.com//image-20211118143627408.png" alt="image-20211118143627408"></p>
<pre><code>                                                                              图6.9　绘制27个随机实心圆注意
</code></pre>
<p>因为OpenCV中的颜色值是一个列表（例如(0, 0, 255))等），所以color=np.random.randint(0, high =256, size=(3,)).tolist()中的.tolist()不能忽略，否则运行程序时会发生错误。</p>
<h2 id="6-4-多边形的绘制"><a href="#6-4-多边形的绘制" class="headerlink" title="6.4　多边形的绘制"></a>6.4　多边形的绘制</h2><p>OpenCV提供了绘制多边形的polylines()方法，使用这个方法绘制的多边形既可以是闭合的，也可以是不闭合的。polylines()方法的语法格式如下：</p>
<pre><code> img = cv2.polylines(img, pts, isClosed, color, thickness)
</code></pre>
<p>参数说明：　</p>
<p>img：画布。　</p>
<p>pts：由多边形各个顶点的坐标组成的一个列表，这个列表是一个numpy的数组类型。　</p>
<p>isClosed：如果值为True，表示一个闭合的多边形；如果值为False，表示一个不闭合的多边形。　</p>
<p>color：绘制多边形时的线条颜色。　</p>
<p>thickness：绘制多边形时的线条宽度。</p>
<p>【实例6.7】　绘制一个等腰梯形边框。<br>编写一个程序，按顺时针给出等腰梯形4个顶点的坐标，即(100, 50)，(200, 50)，(250, 250)和(50, 250)。在画布上根据4个顶点的坐标，绘制一个闭合的、红色的、线条宽度为5的等腰梯形边框，代码如下：</p>
<pre><code> import numpy as np # 导入Python中的numpy模块
 import cv2
 # np.zeros()：创建了一个画布
 # (300, 300, 3)：一个300 x 300，具有3个颜色空间（即Red、Green和Blue）的画布
 # np.uint8：OpenCV中的灰度图像和RGB图像都是以uuint8存储的，因此这里的类型也是uint8
 canvas = np.zeros((300, 300, 3), np.uint8)
 # 按顺时针给出等腰梯形4个顶点的坐标
 # 这4个顶点的坐标构成了一个大小等于“顶点个数 * 1 * 2”的数组
 # 这个数组的数据类型为np.int32
 pts = np.array([[100, 50], [200, 50], [250, 250], [50, 250]], np.int32)
 # 在画布上根据4个顶点的坐标，绘制一个闭合的、红色的、线条宽度为5的等腰梯形边框
 canvas = cv2.polylines(canvas, [pts], True, (0, 0, 255), 5)
 cv2.imshow(&quot;Polylines&quot;, canvas) # 显示画布
 cv2.waitKey()
 cv2.destroyAllWindows()
</code></pre>
<p>上述代码的运行结果如图6.10所示。注意<br>在绘制一个等腰梯形边框时，需按顺时针（即(100, 50)，(200, 50)，(250, 250)和(50, 250)）或者逆时针（即(100, 50)，(50, 250)，(250, 250)和(200, 50)）给出等腰梯形4个顶点的坐标，否则无法绘制一个等腰梯形边框。<br>例如，把实例6.7的第11行代码做如下修改：</p>
<pre><code> pts = np.array([[100, 50], [200, 50], [50, 250], [250, 250]], np.int32)
</code></pre>
<p>运行修改后的代码，得到如图6.11所示的结果。</p>
<p><img src="/.com//image-20211118183008718.png" alt="image-20211118183008718"></p>
<p>​                                                                                 图6.10　绘制一个等腰梯形边框</p>
<p><img src="/.com//image-20211118183106168.png" alt="image-20211118183106168"></p>
<p>​                                                          图6.11　不按顺时针或逆时针给出等腰梯形4个顶点的坐标的运行结果<br>再如，把实例6.7的第13行代码中的True修改为False，那么将绘制出一个不闭合的等腰梯形边框，代码如下：</p>
<pre><code> canvas = cv2.polylines(canvas, [pts], False, (0, 0, 255), 5) # 绘制一个不闭合的等腰梯形边框
</code></pre>
<p>运行修改后的代码，得到如图6.12所示的结果。</p>
<p><img src="/.com//image-20211118183128142.png" alt="image-20211118183128142"></p>
<p>​                                                                                      图6.12　绘制一个不闭合的等腰梯形边框</p>
<h2 id="6-5-文字的绘制"><a href="#6-5-文字的绘制" class="headerlink" title="6.5　文字的绘制"></a>6.5　文字的绘制</h2><p>OpenCV提供了用于绘制文字的putText()方法，使用这个方法不仅能够设置字体的样式、大小和颜色，而且能够使字体呈现斜体的效果，还能够控制文字的方向，进而使文字呈现垂直镜像的效果。putText()方法的语法格式如下：</p>
<pre><code> img = cv2.putText(img, text, org, fontFace, fontScale, color, thickness, lineType, bottomLeftOrigin)
</code></pre>
<p>参数说明：　</p>
<p>img：画布。　</p>
<p>text：要绘制的文字内容。　</p>
<p>org：文字在画布中的左下角坐标。　</p>
<p>fontFace：字体样式，可选参数如表6.1所示。</p>
<p>​                                                                                        表6.1　字体样式及其含义</p>
<p><img src="/.com//image-20211118190722929.png" alt="image-20211118190722929"></p>
<p>fontScale：字体大小。　</p>
<p>color：绘制文字时的线条颜色。　</p>
<p>thickness：绘制文字时的线条宽度。　</p>
<p>lineType：线型。（线型指的是线的产生算法，有4和8两个值，默认值为8）　</p>
<p>bottomLeftOrigin：绘制文字时的方向。（有True和False两个值，默认值为False）</p>
<p>说明<br>使用putText()方法时，thickness、lineType和bottomLeftOrigin是可选参数，有无均可。</p>
<p>【实例6.8】　绘制文字“mrsoft”。（实例位置：资源包\TM\sl\6\08）<br>编写一个程序，在画布上绘制文字“mrsoft”。其中，文字左下角的坐标为(20, 70)，字体样式为FONT_HERSHEY_TRIPLEX，字体大小为2，线条颜色是绿色，线条宽度为5，代码如下：</p>
<pre><code> import numpy as np # 导入Python中的numpy模块
 import cv2
 # np.zeros()：创建了一个画布
 # (100, 300, 3)：一个100 x 300，具有3个颜色空间（即Red、Green和Blue）的画布
 # np.uint8：OpenCV中的灰度图像和RGB图像都是以uint8存储的，因此这里的类型也是uint8
 canvas = np.zeros((100, 300, 3), np.uint8)
 # 在画布上绘制文字“mrsoft”，文字左下角的坐标为(20, 70)
 #字体样式为FONT_HERSHEY_TRIPLEX

#字体大小为2，线条颜色是绿色，线条宽度为5
cv2.putText(canvas, &quot;mrsoft&quot;, (20, 70), cv2.FONT_HERSHEY_TRIPLEX, 2, (0, 255, 0), 5)
cv2.imshow(&quot;Text&quot;, canvas) # 显示画布
cv2.waitKey()
cv2.destroyAllWindows()
</code></pre>
<p>上述代码的运行结果如图6.13所示。说明<br>不借助其他库或者模块，使用putText()方法绘制中文时，即把实例6.8的第11行代码中的mrsoft修改为“您好”，代码如下：</p>
<pre><code> cv2.putText(canvas, &quot;您好&quot;, (20, 70), cv2.FONT_HERSHEY_TRIPLEX, 2, (0, 255, 0), 5)
</code></pre>
<p>运行上述代码会出现如图6.14所示的乱码。</p>
<p>如果把实例6.8的第11行代码中的字体样式由“cv2.FONT_HERSHEY_TRIPLEX”修改为“cv2.FONT_HERSHEY_DUPLEX”，那么将改变图6.13中的字体样式，关键代码如下：</p>
<pre><code> cv2.putText(canvas, &quot;mrsoft&quot;, (20, 70), cv2.FONT_HERSHEY_DUPLEX, 2, (0, 255, 0), 5)
</code></pre>
<p>运行修改后的代码，得到如图6.15所示的效果（图6.15（a）是FONT_HERSHEY_TRIPLEX呈现的效果）。</p>
<p><img src="/.com//image-20211118191113526.png" alt="image-20211118191113526"></p>
<p>​                                                                                    图6.15　字体样式变化效果<br>根据上述修改方法，读者朋友可以把实例6.8的第11行代码中的字体样式依次修改为表6.1中的各个字体样式，这样就能够查看每一个字体样式所呈现的效果。</p>
<h3 id="6-5-1-文字的斜体效果"><a href="#6-5-1-文字的斜体效果" class="headerlink" title="6.5.1　文字的斜体效果"></a>6.5.1　文字的斜体效果</h3><p>FONT_ITALIC可以与其他文字类型一起使用，使字体在呈现指定字体样式效果的同时，也呈现斜体效果。</p>
<p>【实例6.9】　绘制指定字体样式的文字并呈现斜体效果。（实例位置：资源包\TM\sl\6\09）<br>编写一个程序，在图6.13呈现的文字效果的基础上，使字体呈现斜体效果，代码如下：</p>
<pre><code> import numpy as np # 导入Python中的numpy模块
 import cv2
 # np.zeros()：创建了一个画布
 # (100, 300, 3)：一个100 x 300，具有3个颜色空间（即Red、Green和Blue）的画布
 # np.uint8：OpenCV中的灰度图像和RGB图像都是以uint8存储的，因此这里的类型也是uint8
 canvas = np.zeros((100, 300, 3), np.uint8)
 # 字体样式为FONT_HERSHEY_TRIPLEX和FONT_ITALIC
 fontStyle = cv2.FONT_HERSHEY_TRIPLEX + cv2.FONT_ITALIC
 # 在画布上绘制文字“mrsoft”，文字左下角的坐标为(20, 70)
 # 字体样式为fontStyle，字体大小为2，线条颜色是绿色，线条宽度为5
 cv2.putText(canvas, &quot;mrsoft&quot;, (20, 70), fontStyle, 2, (0, 255, 0), 5)
 cv2.imshow(&quot;Text&quot;, canvas) # 显示画布
 cv2.waitKey()
 cv2.destroyAllWindows()
</code></pre>
<p>上述代码的运行效果如图6.16所示（图6.16（a）是原图像，即图6.13）。</p>
<p><img src="/.com//image-20211118191251684.png" alt="image-20211118191251684"></p>
<p>​                                                                                              图6.16　文字的斜体效果</p>
<h3 id="6-5-2-文字的垂直镜像效果"><a href="#6-5-2-文字的垂直镜像效果" class="headerlink" title="6.5.2　文字的垂直镜像效果"></a>6.5.2　文字的垂直镜像效果</h3><p>在putText()方法的语法格式中，有一个控制绘制文字时的方向的参数，即bottomLeftOrigin，其默认值为False。当bottomLeftOrigin为True时，文字将呈现垂直镜像效果。</p>
<p>【实例6.10】　绘制呈现垂直镜像效果的“mrsoft”。（实例位置：资源包\TM\sl\6\10）<br>编写一个程序，首先在画布上绘制文字“mrsoft”。其中，文字左下角的坐标为(20, 70)，字体样式为FONT_HERSHEY_TRIPLEX，字体大小为2，线条颜色是绿色，线条宽度为5。然后在该画布上绘制相同的字体样式、字体大小、线条颜色和线条宽度，而且呈现垂直镜像效果的“mrsoft”，代码如下：</p>
<pre><code> import numpy as np # 导入Python中的numpy模块
 import cv2
 # np.zeros()：创建了一个画布
 # (200, 300, 3)：一个200 x 300，具有3个颜色空间（即Red、Green和Blue）的画布
 # np.uint8：OpenCV中的灰度图像和RGB图像都是以uint8存储的，因此这里的类型也是uint8
 canvas = np.zeros((200, 300, 3), np.uint8)
 # 字体样式为FONT_HERSHEY_TRIPLEX
 fontStyle = cv2.FONT_HERSHEY_TRIPLEX
 # 在画布上绘制文字“mrsoft”，文字左下角的坐标为(20, 70)
 # 字体样式为fontStyle，字体大小为2，线条颜色是绿色，线条宽度为5
 cv2.putText(canvas, &quot;mrsoft&quot;, (20, 70), fontStyle, 2, (0, 255, 0), 5)
 # 使文字“mrsoft”呈现垂直镜像效果，这时lineType和bottomLeftOrigin变成了必须参数
 # 其中，lineType取默认值8，bottomLeftOrigin的值为True
 cv2.putText(canvas, &quot;mrsoft&quot;, (20, 100), fontStyle, 2, (0, 255, 0), 5, 8, True)
 cv2.imshow(&quot;Text&quot;, canvas) # 显示画布
 cv2.waitKey()
 cv2.destroyAllWindows()
</code></pre>
<p>上述代码的运行效果如图6.17所示。</p>
<p><img src="/.com//image-20211118191411682.png" alt="image-20211118191411682"></p>
<p>​                                                                             图6.17　绘制呈现垂直镜像效果的“mrsoft”</p>
<h3 id="6-5-3-在图像上绘制文字"><a href="#6-5-3-在图像上绘制文字" class="headerlink" title="6.5.3　在图像上绘制文字"></a>6.5.3　在图像上绘制文字</h3><p>OpenCV除了可以在np.zeros()创建的画布上绘制文字外，还能够在图像上绘制文字。区别是当在图像上绘制文字时，不再需要导入Python中的numpy模块。</p>
<p>【实例6.11】　在图像上绘制文字。（实例位置：资源包\TM\sl\6\11）<br>编写一个程序，在D盘根目录下的2.1.jpg上绘制文字“Flower”。其中，文字左下角的坐标为(20, 90)，字体样式为FONT_HERSHEY_TRIPLEX，字体大小为1，线条颜色是黄色，代码如下：</p>
<pre><code class="HTML">import cv2
image = cv2.imread(&amp;quot;D:/2.1.jpg&amp;quot;) # 读取D盘根目录下的2.1.jpg
#字体样式为FONT_HERSHEY_TRIPLEX
fontStyle = cv2.FONT_HERSHEY_TRIPLEX
# 在image上绘制文字“mrsoft”，文字左下角的坐标为(20, 90)，
# 字体样式为fontStyle，字体大小为1，线条颜色是黄色
cv2.putText(image, &amp;quot;Flower&amp;quot;, (20, 90), fontStyle, 1, (0, 255, 255))
cv2.imshow(&amp;quot;Text&amp;quot;, image) # 显示画布
cv2.waitKey()
cv2.destroyAllWindows()
</code></pre>
<p>上述代码的运行结果如图6.18所示。</p>
<p>说明<br>借助Python中的PIL(Python Imaging Library)模块，OpenCV能够在图像上输出中文，需要做的是对图像进行OpenCV格式和PIL格式的相互转换。这部分内容较为复杂，本书不做介绍，读者可以自学相关内容。</p>
<p><img src="/.com//image-20211118191653484.png" alt="image-20211118191653484"></p>
<p>​                                                                                       图6.18　在图像上绘制文字</p>
<h2 id="6-6-动态绘制图形"><a href="#6-6-动态绘制图形" class="headerlink" title="6.6　动态绘制图形"></a>6.6　动态绘制图形</h2><p>前面主要讲解的是如何在画布上绘制静态的图形，如线段、矩形、正方形、圆形、多边形和文字等。那么，能不能让这些静态的图形动起来呢？如果能，又该怎么做呢？</p>
<p>【实例6.12】　弹球动画。（实例位置：资源包\TM\sl\6\12）</p>
<p>在一个宽、高都为200像素的纯白色图像中，绘制一个半径为20像素的纯蓝色小球。让小球做匀速直线运动，一旦圆形碰触到图像边界则开始反弹（反弹不损失动能）。想要实现这个功能需要解决两个问题：如何计算运动轨迹和如何实现动画。下面分别介绍这两个问题的解决思路。</p>
<p>1．通过图像坐标系计算运动轨迹<br>小球在运动的过程中可以把移动速度划分为上、下、左、右4个方向。左右为横坐标移动速度，上下为纵坐标移动速度。小球向右移动时横坐标不断变大，向左移动时横坐标不断变小，由此可以认为：小球向右的移动速度为正，向左的移动速度为负。纵坐标同理，因为图像坐标系的原点为背景左上角顶点，越往下延伸纵坐标越大，所以小球向上的移动速度为负，向下的移动速度为正。4个方向的速度如图6.19所示。<br>假设小球移动一段时间后，移动的轨迹如图6.20所示，小球分别达到了4个位置，2号位置和3号位置发生了反弹，也就是移动速度发生变化，导致移动方向发生变化。整个过程中，4个位置的速度分别如下：<br>❶：右下方向移动，横坐标向右，横坐标速度为+vx，纵坐标向下，纵坐标速度为+vy。<br>❷：右上方向移动，横坐标向右，横坐标速度为+vx，纵坐标向上，纵坐标速度为-vy。<br>❸：左上方向移动，横坐标向左，横坐标速度为-vx，纵坐标向上，纵坐标速度为-vy。<br>❹：左上方移动，没有碰到边界，依然保持着与3号位置相同移动速度。<br>由此可以得出，只需要改变速度的正负号小球就可以改变移动方向，所以在程序中可以将小球的横坐标速度和纵坐标速度设定成一个不变的值，每次小球碰到左右边界，就更改横坐标速度的正负号，碰到上下边界，就更改纵坐标速度的正负号。</p>
<p><img src="/.com//image-20211118191737740.png" alt="image-20211118191737740"></p>
<p>​                                                                               图6.19　小球在4个方向的速度</p>
<p><img src="/.com//image-20211118191824935.png" alt="image-20211118191824935"></p>
<p>​                                                                                     图6.20　小球的移动轨迹</p>
<p>2．通过time模块实现动画效果</p>
<p>Python自带一个time时间模块，该模块提供了一个sleep()方法可以让当前线程休眠一段时间，其语法格式如下：</p>
<pre><code> time.sleep(seconds)
</code></pre>
<p>参数说明：　</p>
<p>seconds：休眠时间，单位为s，可以是小数，如1/10表示（1/10）s。<br>例如，让当前线程休眠1s，代码如下：</p>
<pre><code> import time
 time.sleep(1)  # 休眠1s
</code></pre>
<p>动画实际上是由多幅画面在短时间内交替放映实现的视觉效果。每一幅画面被称为一帧，所谓的60帧就是指1s放映了60幅画面。使用time模块每（1/60）s计算一次小球的移动轨迹，并将移动后的结果绘制到图像上，这样1s有60幅图像交替放映，就可以看到弹球的动画效果了。<br>弹球动画的具体代码如下：</p>
<p><img src="/.com//image-20211118191858592.png" alt="image-20211118191858592"></p>
<p>运行结果如图6.21所示。</p>
<p><img src="/.com//image-20211118191931672.png" alt="image-20211118191931672"></p>
<p>​                                                                                                  图6.21　小球运动轨迹</p>
<h2 id="6-7-小结"><a href="#6-7-小结" class="headerlink" title="6.7　小结"></a>6.7　小结</h2><p>不论是绘制图形，还是绘制文字，都需要创建画布，这个画布可以是一幅图像。需要确定线条的颜色时，要特别注意颜色的表示方式，即(B, G, R)。当绘制矩形、圆形和多边形时，通过设置线条宽度，既可以绘制图形的边框，又可以绘制被填充的图形。但是，在绘制多边形的过程中，要按照顺时针或者逆时针的方向，标记多边形各个顶点的坐标。此外，OpenCV提供的用于绘制图形的方法，不仅可以绘制静态的图形，还可以绘制动态的图形。</p>
<h1 id="第7章-图像的几何变换"><a href="#第7章-图像的几何变换" class="headerlink" title="第7章　图像的几何变换"></a>第7章　图像的几何变换</h1><p>几何变换是指改变图像的几何结构，例如大小、角度和形状等，让图像呈现出缩放、翻转、映射和透视效果。这些几何变换操作都涉及复杂、精密的计算，OpenCV将这些计算过程封装成非常灵活的方法，开发者只需修改一些参数，就能实现图像的变换效果。本章将介绍几种常见的几何变换效果及其实现方法。</p>
<h2 id="7-1-缩放"><a href="#7-1-缩放" class="headerlink" title="7.1　缩放"></a>7.1　缩放</h2><p>“缩”表示缩小，“放”表示放大，通过OpenCV提供的resize()方法可以随意更改图像的大小比例，其语法如下：</p>
<pre><code> dst = cv2.resize(src, dsize, fx, fy, interpolation)
</code></pre>
<p>参数说明：　</p>
<p>src：原始图像。　</p>
<p>dsize：输出图像的大小，格式为（宽，高），单位为像素。　</p>
<p>fx：可选参数。水平方向的缩放比例。　</p>
<p>fy：可选参数。垂直方向的缩放比例。　</p>
<p>interpolation：可选参数。缩放的插值方式。在图像缩小或放大时需要删减或补充像素，该参数可以指定使用哪种算法对像素进行增减。建议使用默认值。<br>返回值说明：　</p>
<p>dst：缩值之后的图像。</p>
<p>resize()方法有两种使用方式，一种是通过dsize参数实现缩放，另一种是通过fx和fy参数实现缩放，下面分别介绍。</p>
<h3 id="7-1-1-dsize参数实现缩放"><a href="#7-1-1-dsize参数实现缩放" class="headerlink" title="7.1.1　dsize参数实现缩放"></a>7.1.1　dsize参数实现缩放</h3><p>dsize参数的格式是一个元组，例如(100, 200)，表示将图像按照宽100像素、高200像素的大小进行缩放。如果使用dsize参数，就可以不写fx和fy参数。</p>
<p>【实例7.1】　将图像按照指定宽高进行缩放。（实例位置：资源包\TM\sl\7\01）<br>将一个图像按照宽100像素、高100像素的大小进行缩小，再按照宽400像素、高400像素的大小进行放大，代码如下：<br>上述代码的运行结果如图7.1所示。</p>
<p><img src="/.com//image-20211118192105062.png" alt="image-20211118192105062"></p>
<p>​                                                                                  图7.1　dsize参数缩放图像效果</p>
<h3 id="7-1-2-fx和fy参数实现缩放"><a href="#7-1-2-fx和fy参数实现缩放" class="headerlink" title="7.1.2　fx和fy参数实现缩放"></a>7.1.2　fx和fy参数实现缩放</h3><p>使用fx参数和fy参数控制缩放时，dsize参数值必须使用None，否则fx和fy失效。<br>fx参数和fy参数可以使用浮点值，小于1的值表示缩小，大于1的值表示放大。其计算公式为：</p>
<pre><code> 新图像宽度 = round(fx × 原图像宽度)
 新图像高度 = round(fy × 原图像高度)
</code></pre>
<p>【实例7.2】　将图像按照指定比例进行缩放</p>
<p>将一个图像宽缩小到原来的1/3、高缩小到原来的1/2，再将图像宽放大2倍，高也放大2倍，代码如下：</p>
<p><img src="/.com//image-20211118192221463.png" alt="image-20211118192221463"></p>
<p>上述代码的运行结果如图7.2所示。</p>
<p><img src="/.com//image-20211118192248191.png" alt="image-20211118192248191"></p>
<p>​                                                                                      图7.2　fx和fy参数缩放图像效果</p>
<h2 id="7-2-翻转"><a href="#7-2-翻转" class="headerlink" title="7.2　翻转"></a>7.2　翻转</h2><p>水平方向被称为X轴，垂直方向被称为Y轴。图像沿着X轴或Y轴翻转之后，可以呈现出镜面或倒影的效果，如图7.3和图7.4所示。</p>
<p><img src="/.com//image-20211118192311942.png" alt="image-20211118192311942"></p>
<p>​                                                                                              图7.3　沿X轴翻转的效果</p>
<p><img src="/.com//image-20211118192332597.png" alt="image-20211118192332597"></p>
<p>​                                                                                                图7.4　沿Y轴翻转的效果<br>OpenCV通过cv2.flip()方法实现翻转效果，其语法如下：</p>
<pre><code> dst = cv2.flip(src, flipCode)
</code></pre>
<p>参数说明：　</p>
<p>src：原始图像。</p>
<p>flipCode：翻转类型，类型值及含义如表7.1所示。<br>返回值说明：　</p>
<p>dst：翻转之后的图像。</p>
<p>​                                                                                               表7.1　flipCode类型值及含义</p>
<p><img src="/.com//image-20211118192448155.png" alt="image-20211118192448155"></p>
<p>【实例7.3】　同时实现3种翻转效果。<br>分别让图像沿X轴翻转，沿Y轴翻转，同时沿X轴、Y轴翻转，查看翻转的效果，代码如下：</p>
<p><img src="/.com//image-20211118192557425.png" alt="image-20211118192557425"></p>
<p>上述代码的运行结果如图7.5所示。</p>
<p><img src="/.com//image-20211118192614947.png" alt="image-20211118192614947"></p>
<p>​                                                                                           图7.5　图像实现3种翻转效果</p>
<h2 id="7-3-仿射变换"><a href="#7-3-仿射变换" class="headerlink" title="7.3　仿射变换"></a>7.3　仿射变换</h2><p>仿射变换是一种仅在二维平面中发生的几何变形，变换之后的图像仍然可以保持直线的“平直性”和“平行性”，也就是说原来的直线变换之后还是直线，平行线变换之后还是平行线。常见的仿射变换效果如图7.6所示，包含平移、旋转和倾斜。</p>
<p><img src="/.com//image-20211118192719998.png" alt="image-20211118192719998"></p>
<p>​                                                                                         图7.6　3种常见的仿射变换效果<br>OpenCV通过cv2. warpAffine()方法实现仿射变换效果，其语法如下：</p>
<pre><code> dst = cv2.warpAffine(src, M, dsize, flags, borderMode, borderValue)
</code></pre>
<p>参数说明：　</p>
<p>src：原始图像。　</p>
<p>M：一个2行3列的矩阵，根据此矩阵的值变换原图中的像素位置。　</p>
<p>dsize：输出图像的尺寸大小。　</p>
<p>flags：可选参数，插值方式，建议使用默认值。　</p>
<p>borderMode：可选参数，边界类型，建议使用默认值。　</p>
<p>borderValue：可选参数，边界值，默认为0，建议使用默认值。</p>
<p>返回值说明：　</p>
<p>dst：经过反射变换后输出图像。M也被叫作仿射矩阵，实际上就是一个2×3的列表，其格式如下：</p>
<pre><code> M = [[a, b, c],[d, e, f]]
</code></pre>
<p>图像做何种仿射变换，完全取决于M的值，仿射变换输出的图像按照以下公式进行计算：</p>
<pre><code> 新x = 原x × a + 原y × b + c
 新y = 原x × d + 原y × e + f
</code></pre>
<p>原x和原y表示原始图像中像素的横坐标和纵坐标，新x与新y表示同一个像素经过仿射变换后在新图像中的横坐标和纵坐标。M矩阵中的数字采用32位浮点格式，可以采用两种方式创建M。<br>（1）创建一个全是0的M，代码如下：</p>
<pre><code> import numpy as np
 M = np.zeros((2, 3), np.float32)
</code></pre>
<p>（2）创建M的同时赋予具体值，代码如下：</p>
<pre><code> import numpy as np
 M = np.float32([[1, 2, 3], [4, 5, 6]])
</code></pre>
<p>通过设定M的值就可以实现多种仿射效果，下面分别介绍如何实现图像的平移、旋转和倾斜。</p>
<h3 id="7-3-1-平移"><a href="#7-3-1-平移" class="headerlink" title="7.3.1　平移"></a>7.3.1　平移</h3><p>平移就是让图像中的所有像素同时沿着水平或垂直方向移动。实现这种效果只需要将M的值按照以下格式进行设置：</p>
<pre><code> M = [[1, 0, 水平移动的距离],[0, 1, 垂直移动的距离]]
</code></pre>
<p>原始图像的像素就会按照以下公式进行变换：</p>
<pre><code> 新x = 原x × 1 + 原y × 0 + 水平移动的距离 = 原x + 水平移动的距离
 新y = 原x × 0 + 原y × 1 + 垂直移动的距离 = 原y + 垂直移动的距离
</code></pre>
<p>若水平移动的距离为正数，图像向右移动，若为负数，图像向左移动；若垂直移动的距离为正数，图像向下移动，若为负数，图像向上移动；若水平移动的距离和垂直移动的距离的值为0，图像不发生移动。</p>
<p>【实例7.4】　让图像向右下方平移。（实例位置：资源包\TM\sl\7\04）<br>例如，将图像向右移动50像素、向下移动100像素，代码如下：</p>
<p><img src="/.com//image-20211118192856809.png" alt="image-20211118192856809"></p>
<p>上述代码的运行结果如图7.7所示。</p>
<p><img src="/.com//image-20211118192839832.png" alt="image-20211118192839832"></p>
<p>​                                                                  图7.7　图像向右下方平移效果<br>通过修改M的值可以实现其他平移效果。例如，横坐标不变，纵坐标向上移动50像素，M的值如下：</p>
<pre><code> M = np.float32([[1, 0, 0],  # 横坐标不变
              [0, 1, -50]])  # 纵坐标向上移动50像素
</code></pre>
<p>移动效果如图7.8所示。<br>纵坐标不变，横坐标向左移动200像素，M的值如下：</p>
<pre><code> M = np.float32([[1, 0, -200],  # 横坐标向左移动200像素
               [0, 1, 0]])      # 纵坐标不变
</code></pre>
<p>移动效果如图7.9所示。</p>
<p><img src="/.com//image-20211118192940668.png" alt="image-20211118192940668"></p>
<p>​                                                            图7.8　横坐标不变、纵坐标向上移动50像素的效果</p>
<p><img src="/.com//image-20211118193002091.png" alt="image-20211118193002091"></p>
<p>​                                                     图7.9　纵坐标不变、横坐标向左移动200像素的效果</p>
<h3 id="7-3-2-旋转"><a href="#7-3-2-旋转" class="headerlink" title="7.3.2　旋转"></a>7.3.2　旋转</h3><p>让图像旋转也是通过M矩阵实现的，但得出这个矩阵需要做很复杂的运算，于是OpenCV提供了getRotationMatrix2D()方法自动计算旋转图像的M矩阵。getRotationMatrix2D()方法的语法如下：</p>
<pre><code>  M = cv2.getRotationMatrix2D(center, angle, scale)
</code></pre>
<p>参数说明：　</p>
<p>center：旋转的中心点坐标。　</p>
<p>angle：旋转的角度（不是弧度）。正数表示逆时针旋转，负数表示顺时针旋转。　</p>
<p>scale：缩放比例，浮点类型。如果取值1，表示图像保持原来的比例。</p>
<p>返回值说明：　</p>
<p>M：getRotationMatrix2D()方法计算出的仿射矩阵。</p>
<p>【实例7.5】　让图像逆时针旋转。<br>让图像逆时针旋转30°的同时缩小到原来的80%，代码如下：</p>
<p><img src="/.com//image-20211118193039585.png" alt="image-20211118193039585"></p>
<p>上述代码的运行效果如图7.10所示。</p>
<p><img src="/.com//image-20211118193113385.png" alt="image-20211118193113385"></p>
<p>​                                                                                           7.10　图像逆时针旋转效果</p>
<h3 id="7-3-3-倾斜"><a href="#7-3-3-倾斜" class="headerlink" title="7.3.3　倾斜"></a>7.3.3　倾斜</h3><p>OpenCV需要定位图像的3个点来计算倾斜效果，3个点的位置如图7.11所示，这3个点分别是“左上角”点A、“右上角”点B和“左下角”点C。OpenCV会根据这3个点的位置变化来计算其他像素的位置变化。因为要保证图像的“平直性”和“平行性”，所以不需要“右下角”的点做第4个参数，右下角这个点的位置根据A、B、C 3点的变化自动计算得出。</p>
<p><img src="/.com//image-20211118193145154.png" alt="image-20211118193145154"></p>
<p>​                                                                  图7.11　通过3个点定位图像的仿射变换效果说明</p>
<p>“平直性”是指图像中的直线在经过仿射变换之后仍然是直线。“平行性”是指图像中的平行线在经过仿射变换之后仍然是平行线。<br>让图像倾斜也是需要通过M矩阵实现的，但得出这个矩阵需要做很复杂的运算，于是OpenCV提供了getAffineTransform()方法来自动计算倾斜图像的M矩阵。getRotationMatrix2D()方法的语法如下：</p>
<pre><code> M = cv2.getAffineTransform(src, dst)
</code></pre>
<p>参数说明：　</p>
<p>src：原图3个点坐标，格式为3行2列的32位浮点数列表，例如：[[0, 1], [1, 0], [1, 1]]。　</p>
<p>dst：倾斜图像的3个点坐标，格式与src一样。</p>
<p>返回值说明：　</p>
<p>M：getAffineTransform()方法计算出的仿射矩阵。</p>
<p>【实例7.6】　让图像向右倾斜。<br>让图像向右倾斜，代码如下：</p>
<p><img src="/.com//image-20211119061021581.png" alt="image-20211119061021581"></p>
<p>上述代码的运行结果如图7.12所示</p>
<p><img src="/.com//image-20211119061045205.png" alt="image-20211119061045205"></p>
<p>​                                                                                            图7.12　图像向右倾斜效果<br>如果让图像向左倾斜，不能只通过移动点A来实现，还需要通过移动点B和点C来实现，3个点的修改方式如下：</p>
<p><img src="/.com//image-20211119061108326.png" alt="image-20211119061108326"></p>
<p>使用这两组数据计算出的M矩阵可以实现如图7.13所示的向左倾斜效果。</p>
<p><img src="/.com//image-20211119061130763.png" alt="image-20211119061130763"></p>
<p>​                                                                                                               图7.13　向左倾斜效果</p>
<h2 id="7-4-透视"><a href="#7-4-透视" class="headerlink" title="7.4　透视"></a>7.4　透视</h2><p>如果说仿射是让图像在二维平面中变形，那么透视就是让图像在三维空间中变形。从不同的角度观察物体，会看到不同的变形画面，例如，矩形会变成不规则的四边形，直角会变成锐角或钝角，圆形会变成椭圆，等等。这种变形之后的画面就是透视图。</p>
<p><img src="/.com//image-20211119061322272.png" alt="image-20211119061322272"></p>
<p>​                                                                        图7.14　从图像的底部观察图像</p>
<p>如图7.14所示从图像的底部观察图7.15（a），眼睛距离图像底部较近，所以图像底部宽度不变，但眼睛距离图像顶部较远，图像顶部宽度就会等比缩小，于是观察者就会看到如图7.15（b）所示的透视效果。</p>
<p><img src="/.com//image-20211119061347353.png" alt="image-20211119061347353"></p>
<p>​                                                                                    图7.15　人眼观察图像透视效果<br>OpenCV中需要通过定位图像的4个点计算透视效果，4个点的位置如图7.16所示。OpenCV根据这4个点的位置变化来计算其他像素的位置变化。透视效果不能保证图像的“平直性”和“平行性”。<br>OpenCV通过warpPerspective()方法来实现透视效果，其语法如下：</p>
<pre><code> dst = cv2.warpPerspective(src, M, dsize, flags, borderMode, borderValue)
</code></pre>
<p><img src="/.com//image-20211119061419756.png" alt="image-20211119061419756"></p>
<p>​                                                                                 图7.16　通过4个点定位图像的透视效果<br>参数说明：　</p>
<p>src：原始图像。　</p>
<p>M：一个3行3列的矩阵，根据此矩阵的值变换原图中的像素位置。　</p>
<p>dsize：输出图像的尺寸大小。　</p>
<p>flags：可选参数，插值方式，建议使用默认值。　</p>
<p>borderMode：可选参数，边界类型，建议使用默认值。</p>
<p>borderValue：可选参数，边界值，默认为0，建议使用默认值。<br>返回值说明：　</p>
<p>dst：经过透视变换后输出图像。</p>
<p>warpPerspective()方法也需要通过M矩阵计算透视效果，但得出这个矩阵需要做很复杂的运算，于是OpenCV提供了getPerspectiveTransform()方法自动计算M矩阵。getPerspectiveTransform()方法的语法如下：</p>
<pre><code> M = cv2.getPerspectiveTransform(src, dst,)
</code></pre>
<p>参数说明：　</p>
<p>src：原图4个点坐标，格式为4行2列的32位浮点数列表，例如：[[0, 0], [1, 0], [0, 1],[1, 1]]。　</p>
<p>dst：透视图的4个点坐标，格式与src一样。<br>返回值说明：　</p>
<p>M：getPerspectiveTransform()方法计算出的仿射矩阵。</p>
<p>【实例7.7】　模拟从底部观察图像得到的透视效果。<br>模拟从底部观察图像得到的透视效果，将图像顶部边缘收窄，底部边缘保持不变，代码如下：</p>
<p><img src="/.com//image-20211119061533770.png" alt="image-20211119061533770"></p>
<p>上述代码的运行结果如图7.17所示。</p>
<p><img src="/.com//image-20211119061620244.png" alt="image-20211119061620244"></p>
<p>​                                                                                              图7.17　图像透视效果</p>
<h2 id="7-5-小结"><a href="#7-5-小结" class="headerlink" title="7.5　小结"></a>7.5　小结</h2><p>图像的缩放有2种方式：一种是设置dsize参数，另一种是设置fx参数和fy参数。图像的翻转有3种方式，沿X轴翻转、沿Y轴翻转和同时沿X轴、Y轴翻转，这3种方式均由flipCode参数的值决定。图像的仿射变换取决于仿射矩阵，采用不同的仿射矩阵（M），就会使图像呈现不同的仿射效果。此外，图像的透视仍然要依靠M矩阵实现。因此，只要熟练掌握并灵活运用M矩阵，就能够得心应手地对图像进行几何变换操作。</p>
<h1 id="第8章-图像的阈值处理"><a href="#第8章-图像的阈值处理" class="headerlink" title="第8章　图像的阈值处理"></a>第8章　图像的阈值处理</h1><p>阈值是图像处理中一个很重要的概念，类似一个“像素值的标准线”。所有像素值都与这条“标准线”进行比较，最后得到3种结果：像素值比阈值大、像素值比阈值小或像素值等于阈值。程序根据这些结果将所有像素进行分组，然后对某一组像素进行“加深”或“变淡”操作，使得整个图像的轮廓更加鲜明，更容易被计算机或肉眼识别。</p>
<p><img src="/.com//image-20211119061719129.png" alt="image-20211119061719129"></p>
<h2 id="8-1-阈值处理函数"><a href="#8-1-阈值处理函数" class="headerlink" title="8.1　阈值处理函数"></a>8.1　阈值处理函数</h2><p>在图像处理的过程中，阈值的使用使得图像的像素值更单一，进而使得图像的效果更简单。首先，把一幅彩色图像转换为灰度图像，这样图像的像素值的取值范围即可简化为0~255。然后，通过阈值使得转换后的灰度图像呈现出只有纯黑色和纯白色的视觉效果。例如，当阈值为127时，把小于127的所有像素值都转换为0（即纯黑色），把大于127的所有像素值都转换为255（即纯白色）。虽然会丢失一些灰度细节，但是会更明显地保留灰度图像主体的轮廓。<br>OpenCV提供的threshold()方法用于对图像进行阈值处理，threshold()方法的语法如下：</p>
<pre><code> retval, dst = cv2.threshold(src, thresh, maxval, type)
</code></pre>
<p>参数说明：　</p>
<p>src：被处理的图像，可以是多通道图像。　</p>
<p>thresh：阈值，阈值在125～150取值的效果最好。　</p>
<p>maxval：阈值处理采用的最大值。　</p>
<p>type：阈值处理类型。常用类型和含义如表8.1所示。</p>
<p>​                                                                                                 表8.1　阈值处理类型</p>
<p><img src="/.com//image-20211119061937771.png" alt="image-20211119061937771"></p>
<p>返回值说明：　</p>
<p>retval：处理时采用的阈值。　</p>
<p>dst：经过阈值处理后的图像。</p>
<h2 id="8-2-“非黑即白”的图像"><a href="#8-2-“非黑即白”的图像" class="headerlink" title="8.2　“非黑即白”的图像"></a>8.2　“非黑即白”的图像</h2><p>二值化处理和反二值化处理使得灰度图像的像素值两极分化，灰度图像呈现出只有纯黑色和纯白色的视觉效果。</p>
<h3 id="8-2-1-二值化处理"><a href="#8-2-1-二值化处理" class="headerlink" title="8.2.1　二值化处理"></a>8.2.1　二值化处理</h3><p>二值化处理也叫二值化阈值处理，该处理让图像仅保留两种像素值，或者说所有像素都只能从两种值中取值。<br>进行二值化处理时，每一个像素值都会与阈值进行比较，将大于阈值的像素值变为最大值，将小于或等于阈值的像素值变为0，计算公式如下：</p>
<pre><code> if 像素值 &lt;= 阈值: 像素值 = 0
 if 像素值 &gt; 阈值: 像素值 = 最大值
</code></pre>
<p>通常二值化处理是使用255作为最大值，因为灰度图像中255表示纯白色，能够很清晰地与纯黑色进行区分，所以灰度图像经过二值化处理后呈现“非黑即白”的效果。<br>例如，图8.1是一个由白到黑的渐变图，最左侧的像素值为255（表现为纯白色），右侧的像素值逐渐递减，直到最右侧的像素值为0（表现为纯黑色）。像素值的变化如图8.2所示。</p>
<p><img src="/.com//image-20211119062048670.png" alt="image-20211119062048670"></p>
<p>​                                                                                     图8.1　由白到黑的渐变图像</p>
<p><img src="/.com//image-20211119062107944.png" alt="image-20211119062107944"></p>
<p>​                                                                                   图8.2　渐变图像像素值变化示意图</p>
<p>【实例8.1】　二值化处理白黑渐变图。<br>将图8.1进行二值化处理，取0~255的中间值127作为阈值，将255作为最大值，代码如下：</p>
<p><img src="/.com//image-20211119062149699.png" alt="image-20211119062149699"></p>
<p>上述代码的运行结果如图8.3和图8.4所示，图像中凡是大于127的像素值都变成了255（纯白色），小于或等于127的像素值都变成了0（纯黑色）。原图从白黑渐变图像变成了白黑拼接图像，可以看到非常清晰的黑白交界。</p>
<p><img src="/.com//image-20211119062216440.png" alt="image-20211119062216440"></p>
<p>​                                                                                         图8.3　原图</p>
<p><img src="/.com//image-20211119062238704.png" alt="image-20211119062238704"></p>
<p>​                                                                            图8.4　二值化处理效果</p>
<p>【实例8.2】　观察不同阈值的处理效果。<br>通过修改阈值大小可以调整黑白交界的位置。例如，分别采用127和210作为阈值，对比处理结果，代码如下：</p>
<p><img src="/.com//image-20211119062337018.png" alt="image-20211119062337018"></p>
<p>上述代码的运行结果如图8.5所示。因为原图中大部分像素值都大于127，所以阈值为127时，大部分像素都变成了255（纯白色）；但原图中大于210的像素值并不多，所以阈值为210时，大部分像素都变成了0（纯黑色）。</p>
<p><img src="/.com//image-20211119062354861.png" alt="image-20211119062354861"></p>
<p>​                                                                                              图8.5　不同阈值处理效果</p>
<p>【实例8.3】　观察不同最大值的处理效果。（实例位置：资源包\TM\sl\8\03）<br>像素值的最小值默认为0，但最大值可以由开发者设定。如果最大值不是255（纯白色），那么“非黑”的像素就不一定是纯白色了。例如，灰度值150表现为“灰色”，查看将150作为最大值处理的效果，代码如下：</p>
<p><img src="/.com//image-20211119062420756.png" alt="image-20211119062420756"></p>
<p>上述代码的运行结果如图8.6所示。当最大值设为150时，凡是大于127的像素值都被改为150，呈现灰色。</p>
<p><img src="/.com//image-20211119062503592.png" alt="image-20211119062503592"></p>
<p>​                                                                                         图8.6　不同最大值处理效果<br>彩色图像也可以进行二值化处理，处理之后会将颜色夸张化，对比效果如图8.7和图8.8所示。</p>
<p><img src="/.com//image-20211119062737249.png" alt="image-20211119062737249"></p>
<p>​                                                                                     图8.7　彩色图像原图</p>
<p><img src="/.com//image-20211119062804127.png" alt="image-20211119062804127"></p>
<p>​                                                                                           图8.8　彩色图像进行二值化处理的效果</p>
<h3 id="8-2-2-反二值化处理"><a href="#8-2-2-反二值化处理" class="headerlink" title="8.2.2　反二值化处理"></a>8.2.2　反二值化处理</h3><p>反二值化处理也叫反二值化阈值处理，其结果为二值化处理的相反结果。将大于阈值的像素值变为0，将小于或等于阈值的像素值变为最大值。原图像中白色的部分变成黑色，黑色的部分变成白色。计算公式如下：</p>
<pre><code> if 像素值 &lt;= 阈值: 像素值 = 最大值
 if 像素值 &gt; 阈值: 像素值 = 0
</code></pre>
<p>【实例8.4】　对图像进行反二值化处理。</p>
<p>分别将图8.1进行二值化处理和反二值化处理，对比处理结果，代码如下：</p>
<p><img src="/.com//image-20211119062916394.png" alt="image-20211119062916394"></p>
<p>上述代码的运行效果如图8.9所示，可以明显地看出二值化处理效果和反二值化处理效果是完全相反的。</p>
<p><img src="/.com//image-20211119062935052.png" alt="image-20211119062935052"></p>
<p>​                                                                                   图8.9　二值化处理和反二值化处理效果<br>彩色图像经过反二值化处理后，因为各通道的颜色分量值不同，会呈现“混乱”的效果，对比效果如图8.10所示。</p>
<p><img src="/.com//image-20211119062958289.png" alt="image-20211119062958289"></p>
<p>​                                                                            图8.10　彩色图像反二值化处理效果</p>
<h2 id="8-3-零处理"><a href="#8-3-零处理" class="headerlink" title="8.3　零处理"></a>8.3　零处理</h2><p>零处理会将某一个范围内的像素值变为0，并允许范围之外的像素保留原值。零处理包括低于阈值零处理和超出阈值零处理。</p>
<h3 id="8-3-1-低于阈值零处理"><a href="#8-3-1-低于阈值零处理" class="headerlink" title="8.3.1　低于阈值零处理"></a>8.3.1　低于阈值零处理</h3><p>低于阈值零处理也叫低阈值零处理，该处理将低于或等于阈值的像素值变为0，大于阈值的像素值保持原值，计算公式如下：</p>
<pre><code> if 像素值 &lt;= 阈值: 像素值 = 0
</code></pre>
<p>if 像素值 &gt; 阈值: 像素值 = 原值</p>
<p>【实例8.5】　对图像进行低于阈值零处理。</p>
<p>将图8.1进行低于阈值零处理，阈值设为127，代码如下：</p>
<p><img src="/.com//image-20211119063054958.png" alt="image-20211119063054958"></p>
<p>上述代码的运行结果如图8.11所示，像素值低于或等于127的区域彻底变黑，像素值高于127的区域仍然保持渐变效果。</p>
<p><img src="/.com//image-20211119063110806.png" alt="image-20211119063110806"></p>
<p>​                                                                                            图8.11　图像低于阈值零处理效果<br>图像经过低于阈值零处理后，颜色深的位置会彻底变黑，颜色浅的位置不受影响。彩色图像经过低于阈值零处理后，会让深颜色区域的颜色变得更深，甚至变黑，对比效果如图8.12所示。</p>
<p><img src="/.com//image-20211119063132937.png" alt="image-20211119063132937"></p>
<p>​                                                                                   图8.12　彩色图像低于阈值零处理效果</p>
<h3 id="8-3-2-超出阈值零处理"><a href="#8-3-2-超出阈值零处理" class="headerlink" title="8.3.2　超出阈值零处理"></a>8.3.2　超出阈值零处理</h3><p>超出阈值零处理也叫超阈值零处理，该处理将大于阈值的像素值变为0，小于或等于阈值的像素值保持原值。计算公式如下：</p>
<pre><code> if 像素值 &lt;= 阈值: 像素值 = 原值
 if 像素值 &gt; 阈值: 像素值 = 0
</code></pre>
<p>【实例8.6】　对图像进行超出阈值零处理。<br>将图8.1进行超出阈值零处理，阈值设为127，代码如下：</p>
<p><img src="/.com//image-20211119063244471.png" alt="image-20211119063244471"></p>
<p>上述代码的运行结果如图8.13所示，像素值高于127的区域彻底变黑，像素值低于或等于127的区域仍然保持渐变效果。</p>
<p><img src="/.com//image-20211119063259837.png" alt="image-20211119063259837"></p>
<p>​                                                                                              图8.13　图像超出阈值零处理效果<br>图像经过超出阈值零处理后浅颜色区域彻底变黑，深颜色区域则不受影响。但彩色图像经过超出阈值零处理后，浅颜色区域的颜色分量取相反的极值，也呈现出一种“混乱”的效果，对比效果如图8.14所示。</p>
<p><img src="/.com//image-20211119063324538.png" alt="image-20211119063324538"></p>
<p>​                                                                                      图8.14　彩色图像超出阈值零处理效果</p>
<h2 id="8-4-截断处理"><a href="#8-4-截断处理" class="headerlink" title="8.4　截断处理"></a>8.4　截断处理</h2><p>截断处理也叫截断阈值处理，该处理将图像中大于阈值的像素值变为和阈值一样的值，小于或等于阈值的像素保持原值，其公式如下：</p>
<pre><code> if 像素 &lt;= 阈值: 像素 = 原值
 if 像素 &gt; 阈值: 像素 = 阈值
</code></pre>
<p>【实例8.7】　对图像进行截断处理。<br>将图8.1进行截断处理，取127作为阈值，代码如下：</p>
<p><img src="/.com//image-20211119063441020.png" alt="image-20211119063441020"></p>
<p>上述代码的运行结果如图8.15所示，浅颜色区域都变成了灰色，但深颜色区域仍然是渐变效果。</p>
<p><img src="/.com//image-20211119063457401.png" alt="image-20211119063457401"></p>
<p>​                                                                                              图8.15　图像截断处理效果<br>图像经过截断处理后，整体颜色都会变暗。彩色图像经过截断处理后，在降低亮度的同时还会让浅颜色区域的颜色变得更浅，对比效果如图8.16所示。</p>
<p><img src="/.com//image-20211119063611119.png" alt="image-20211119063611119"></p>
<p>​                                                                                         图8.16　彩色图像截断处理效果</p>
<h2 id="8-5-自适应处理"><a href="#8-5-自适应处理" class="headerlink" title="8.5　自适应处理"></a>8.5　自适应处理</h2><p>前面已经依次对cv2.THRESH_BINARY、cv2.THRESH_BINARY_INV、cv2.THRESH_TOZERO、cv2.THRESH_TOZERO_INV和cv2.THRESH_TRUNC这5种阈值处理类型进行了详解。因为图8.1是一幅色彩均衡的图像，所以直接使用一种阈值处理类型就能够对图像进行阈值处理。很多时候图像的色彩是不均衡的，如果只使用一种阈值处理类型，就无法得到清晰有效的结果。</p>
<p>【实例8.8】　使用常用的5种阈值处理类型对色彩不均衡的图像</p>
<p><img src="/.com//4.27.png" alt="4.27"></p>
<p>​                                                                                         图8.17　色彩不均衡的图像<br>先将图8.17转换为灰度图像，再依次使用cv2.THRESH_BINARY、cv2.THRESH_BINARY_INV、cv2.THRESH_TOZERO、cv2.THRESH_TOZERO_INV和cv2.THRESH_TRUNC这5种阈值处理类型对转换后的灰度图像进行阈值处理，代码如下：</p>
<p><img src="/.com//image-20211119063800302.png" alt="image-20211119063800302"></p>
<p>上述代码的运行结果如图8.18～图8.22所示。</p>
<p><img src="/.com//image-20211119063819692.png" alt="image-20211119063819692"></p>
<p>​                                                                                              图8.18　二值化处理</p>
<p><img src="/.com//image-20211119063905724.png" alt="image-20211119063905724"></p>
<p>​                                                                                      图8.19　反二值化处理</p>
<p><img src="/.com//image-20211119063924931.png" alt="image-20211119063924931"></p>
<p>​                                                                                          图8.20　低于阈值零处理</p>
<p><img src="/.com//image-20211119063944429.png" alt="image-20211119063944429"></p>
<p>​                                                                                       图8.21　超出阈值零处理</p>
<p><img src="/.com//image-20211119064005583.png" alt="image-20211119064005583"></p>
<p>​                                                                                                         图8.22　截断处理</p>
<p>从视觉上看，对于色彩不均衡的图像，虽然使用截断处理的效果是5种阈值处理类型中效果比较好的，但是有些轮廓依然模糊不清（例如，图8.22中的手部轮廓），使用程序继续对其进行处理仍然很困难。这时，需要进一步简化图像。<br>OpenCV提供了一种改进的阈值处理技术：图像中的不同区域使用不同的阈值。把这种改进的阈值处理技术称作自适应阈值处理也称自适应处理，自适应阈值是根据图像中某一正方形区域内的所有像素值按照指定的算法计算得到的。与前面讲解的5种阈值处理类型相比，自适应处理能更好地处理明暗分布不均的图像，获得更简单的图像效果。<br>OpenCV提供了adaptiveThresHold()方法对图像进行自适应处理，adaptiveThresHold()方法的语法如下：</p>
<p>dst = cv2.adaptiveThreshold(src, maxValue, adaptiveMethod, thresholdType, blockSize, C)<br>参数说明：　</p>
<p>src：被处理的图像。需要注意的是，该图像需是灰度图像。　</p>
<p>maxValue：阈值处理采用的最大值。　</p>
<p>adaptiveMethod：自适应阈值的计算方法。自适应阈值的计算方法及其含义如表8.2所示。</p>
<p>​                                                                                    表8.2　自适应阈值的计算方法及其含义　</p>
<p><img src="/.com//image-20211119064121242.png" alt="image-20211119064121242"></p>
<p>thresholdType：阈值处理类型；需要注意的是，阈值处理类型需是cv2.THRESH_BINARY或cv2.THRESH_BINARY_INV中的一个。　</p>
<p>blockSize：一个正方形区域的大小。例如，5指的是5×5的区域。　</p>
<p>C：常量。阈值等于均值或者加权值减去这个常量。</p>
<p>返回值说明：　</p>
<p>dst：经过阈值处理后的图像。</p>
<p>【实例8.9】　使用自适应处理的效果。（实例位置：资源包\TM\sl\8\09）<br>先将图8.17转换为灰度图像，再分别使用cv2.ADAPTIVE_THRESH_MEAN_C和cv2.ADAPTIVE_THRESH_GAUSSIAN_C这两种自适应阈值的计算方法对转换后的灰度图像进行阈值处理，代码如下：</p>
<p><img src="/.com//image-20211119064147759.png" alt="image-20211119064147759"></p>
<p>上述代码的运行结果如图8.23和图8.24所示。</p>
<p><img src="/.com//image-20211119064354181.png" alt="image-20211119064354181"></p>
<p>​                                                          图8.23　ADAPTIVE_THRESH_MEAN_C的处理结果</p>
<p><img src="/.com//image-20211119064417014.png" alt="image-20211119064417014"></p>
<p>​                                                                 图8.24　ADAPTIVE_THRESH_GAUSSIAN_C的处理结果<br>与前面讲解的5种阈值处理类型的处理结果相比，自适应处理保留了图像中更多的细节信息，更明显地保留了灰度图像主体的轮廓。注意<br>使用自适应阈值处理图像时，如果图像是彩色图像，那么需要先将彩色图像转换为灰度图像；否则，运行程序时会出现如图8.25所示的错误提示。</p>
<p><img src="/.com//image-20211119064438784.png" alt="image-20211119064438784"></p>
<p>​                                                                                 图8.25　运行程序时出现的错误</p>
<h2 id="8-6-Otsu方法"><a href="#8-6-Otsu方法" class="headerlink" title="8.6　Otsu方法"></a>8.6　Otsu方法</h2><p>前面在讲解5种阈值处理类型的过程中，每个实例设置的阈值都是127，这个127是笔者设置的，并不是通过算法计算得到的。对于有些图像，当阈值被设置为127时，得到的效果并不好，这时就需要一个个去尝试，直到找到最合适的阈值。<br>逐个寻找最合适的阈值不仅工作量大，而且效率低。为此，OpenCV提供了Otsu方法。Otsu方法能够遍历所有可能的阈值，从中找到最合适的阈值。<br>Otsu方法的语法与threshold()方法的语法基本一致，只不过在为type传递参数时，要多传递一个参数，即cv2.THRESH_OTSU。cv2.THRESH_OTSU的作用就是实现Otsu方法的阈值处理。Otsu方法的语法如下：</p>
<p>retval, dst = cv2.threshold(src, thresh, maxval, type)<br>参数说明：　</p>
<p>src：被处理的图像。需要注意的是，该图像需是灰度图像。　</p>
<p>thresh：阈值，且要把阈值设置为0。　</p>
<p>maxval：阈值处理采用的最大值，即255。　</p>
<p>type：阈值处理类型。除在表8.1中选择一种阈值处理类型外，还要多传递一个参数，即cv2.THRESH_OTSU。例如，cv2.THRESH_BINARY+cv2.THRESH_OTSU。<br>返回值说明：　</p>
<p>retval：由Otsu方法计算得到并使用的最合适的阈值。</p>
<p>dst：经过阈值处理后的图像。</p>
<p>【实例8.10】　在图8.26上实现Otsu方法的阈值处理。（实例位置：资源包\TM\sl\8\10）<br>图8.26是一幅亮度较高的图像，分别对这幅图像进行二值化处理和实现Otsu方法的阈值处理，对比处理后图像的差异，代码如下：</p>
<p><img src="/.com//image-20211119064609735.png" alt="image-20211119064609735"></p>
<p>​                                                                                 </p>
<p><img src="/.com//image-20211119064647798.png" alt="image-20211119064647798"></p>
<p>​                                                                                              图8.26　一幅亮度较高的图像<br>上述代码的运行结果如图8.27和图8.28所示。<br>对比图8.27和图8.28后能够发现，由于图8.26的亮度较高，使用阈值为127进行二值化阈值处理的结果没有很好地保留图像主体的轮廓，并出现了大量的白色区域。但是，通过实现Otsu方法的阈值处理，不仅找到了最合适的阈值（即184），还将图像主体的轮廓很好地保留了下来，获得了比较好的处理结果。</p>
<p><img src="/.com//image-20211119064729264.png" alt="image-20211119064729264"></p>
<p>​                                                                                   图8.27　二值化处理的结果</p>
<p><img src="/.com//image-20211119064754376.png" alt="image-20211119064754376"></p>
<p>​                                                                                          图8.28　实现Otsu方法的阈值处理的结果</p>
<h2 id="8-7-阈值处理的作用"><a href="#8-7-阈值处理的作用" class="headerlink" title="8.7　阈值处理的作用"></a>8.7　阈值处理的作用</h2><p>阈值处理在计算机视觉技术中占有十分重要的位置，它是很多高级算法的底层处理逻辑之一。因为二值图像会忽略细节，放大特征，而很多高级算法要根据物体的轮廓来分析物体特征，所以二值图像非常适合做复杂的识别运算。在进行识别运算之前，应先将图像转为灰度图像，再进行二值化处理，这样就得到了算法所需要的物体（大致）轮廓图像。<br>下面通过一个实例来演示通过阈值处理获取物体轮廓的方法。</p>
<p>【实例8.11】　利用阈值处理勾勒楼房和汽车的轮廓。<br>读取一幅图像，先将图像转为灰度图像，再将图像分别进行二值化处理和反二值化处理，具体代码如下：</p>
<p><img src="/.com//image-20211119064833488.png" alt="image-20211119064833488"></p>
<p>上述代码的运行结果如图8.29～图8.32所示。</p>
<p><img src="/.com//image-20211119064852964.png" alt="image-20211119064852964"></p>
<p>​                                                                                                          图8.29　原始图像</p>
<p><img src="/.com//image-20211119065010880.png" alt="image-20211119065010880"></p>
<p>​                                                                                                 图8.30　灰度图像</p>
<p><img src="/.com//image-20211119065032490.png" alt="image-20211119065032490"></p>
<p>​                                                                                           图8.31　二值化处理效果</p>
<p><img src="/.com//image-20211119065054225.png" alt="image-20211119065054225"></p>
<p>​                                                                                             图8.32　反二值化处理效果<br>从后面两幅图像可以看到，二值化处理后，图片只有纯黑和纯白两种颜色，图像中的楼房边缘变得更加鲜明，更容易被识别。地面因为颜色较深，所以大面积被涂黑，这样白色的汽车就与地面形成了鲜明的反差。二值化处理后的汽车轮廓在肉眼看来可能还不够明显，但反二值化处理后的汽车轮廓与地面的反差就非常大。高级图像识别算法可以根据这种鲜明的像素变化来搜寻特征，最后达到识别物体分类的目的。</p>
<h2 id="8-8-小结"><a href="#8-8-小结" class="headerlink" title="8.8　小结"></a>8.8　小结</h2><p>OpenCV提供了一个可以快速抠出图像主体线条的工具，这个工具就是阈值。在阈值的作用下，一幅彩色图像被转换为只有纯黑和纯白的二值图像。然而，灰度图像经5种阈值处理类型处理后，都无法得到图像主体的线条。为此，OpenCV提供了一种改进的阈值处理技术，即自适应处理，其关键在于对图像中的不同区域使用不同的阈值。有了这种改进的阈值处理技术，得到图像主体的线条就不再是一件难以实现的事情了。</p>
<h1 id="第9章-图像的运算"><a href="#第9章-图像的运算" class="headerlink" title="第9章　图像的运算"></a>第9章　图像的运算</h1><p>图像是由像素组成的，像素又是由具体的正整数表示的，因此图像也可以进行一系列数学运算，通过运算可以获得截取、合并图像等效果。OpenCV提供了很多图像运算方法，经过运算的图像可以呈现出很多有趣的视觉效果。下面将对OpenCV中一些常用的图像运算方法进行介绍。</p>
<p><img src="/.com//image-20211120060956203.png" alt="image-20211120060956203"></p>
<h2 id="9-1-掩模"><a href="#9-1-掩模" class="headerlink" title="9.1　掩模"></a>9.1　掩模</h2><p>前面的章节出现过“掩模”这个参数，当时建议大家不使用这个参数。掩模到底有什么用呢？这一节将介绍掩模的概念。<br>外科医生在给患者做手术时，会为患者盖上手术洞巾，类似图9.1，这样医生就只在这个预设好的孔洞部位进行手术。手术洞巾不仅有利于医生定位患处、暴露手术视野，还可以对非患处起到隔离、防污的作用。<br>同样，当计算机处理图像时，图像也如同一名“患者”一样，有些内容需要处理，有些内容不需要处理。通常计算机处理图像时会把所有像素都处理一遍，但如果想让计算机像外科大夫那样仅处理某一小块区域，那就要为图像盖上一张仅暴露一小块区域的“手术洞巾”。像“手术洞巾”那样能够覆盖原始图像、仅暴露原始图像“感兴趣区域”（ROI）的模板图像就被叫作掩模。<br>掩模，也叫作掩码，英文为mask，在程序中用二值图像来表示：0值（纯黑）区域表示被遮盖的部分，255值（纯白）区域表示暴露的部分（某些场景下也会用0和1当作掩模的值）。<br>例如，图9.2是一幅小猫的原始图像，图9.3是原始图像的掩模，掩模覆盖原始图像之后，可以得到如图9.4所示的结果。</p>
<p><img src="/.com//image-20211120061039170.png" alt="image-20211120061039170"></p>
<p>​                                                                      图9.1　外科手术给患者使用的手术洞巾</p>
<p><img src="/.com//image-20211120061106906.png" alt="image-20211120061106906"></p>
<p>​                                                                                                    图9.2　原始图像</p>
<p><img src="/.com//image-20211120061128635.png" alt="image-20211120061128635"></p>
<p>​                                                                              图9.3　掩模</p>
<p><img src="/.com//image-20211120061150893.png" alt="image-20211120061150893"></p>
<p>​                                                                         图9.4　被掩模覆盖后得到的图像<br>如果调换了掩模中黑白区域，如图9.5所示，掩模覆盖原始图像之后得到的结果如图9.6所示。</p>
<p><img src="/.com//image-20211120061213880.png" alt="image-20211120061213880"></p>
<p>​                                                                         图9.5　调换黑白区域的新掩模</p>
<p><img src="/.com//image-20211120061336692.png" alt="image-20211120061336692"></p>
<p>​                                                                               图9.6　被新掩模覆盖后得到的图像<br>在使用OpenCV处理图像时，通常使用numpy库提供的方法创建掩模图像，下面通过一个实例演示如何创建掩模图像。</p>
<p>【实例9.1】　创建3通道掩模图像。（实例位置：资源包\TM\sl\9\01）<br>利用numpy库的zeros()方法创建一幅掩模图像，感兴趣区域为在该图像中横坐标为20、纵坐标为50、宽为60、高为50的矩形，展示该掩模图像。调换该掩模图像的感兴趣区域和不感兴趣区域之后，再次展示掩模图像，具体代码如下：</p>
<p><img src="/.com//image-20211120061301526.png" alt="image-20211120061301526"></p>
<p>运行结果如图9.7和图9.8所示。</p>
<p><img src="/.com//image-20211120061400048.png" alt="image-20211120061400048"></p>
<p>​                                                                                     图9.7　掩模图像</p>
<p><img src="/.com//image-20211120061420875.png" alt="image-20211120061420875"></p>
<p>​                                                                                         图9.8　调换之后的掩模图像</p>
<p>掩模在图像运算过程中充当了重要角色，通过掩模才能看到最直观的运算结果，接下来将详细介绍图像运算的相关内容。</p>
<h2 id="9-2-图像的加法运算"><a href="#9-2-图像的加法运算" class="headerlink" title="9.2　图像的加法运算"></a>9.2　图像的加法运算</h2><p>图像中每一个像素都有用整数表示的像素值，2幅图像相加就是让相同位置像素值相加，最后将计算结果按照原位置重新组成一幅新图像。原理如图9.9所示。</p>
<p><img src="/.com//image-20211120061517289.png" alt="image-20211120061517289"></p>
<p>​                                                                                               图9.9　图像相加生成新像素<br>图9.9中2幅图像的左上角像素值相加的结果就是新图像左上角的像素值，计算过程如下：</p>
<pre><code> 152 + 35 = 187
</code></pre>
<p>在开发程序时通常不会使用“+”运算符对图像做加法运算，而是用OpenCV提供的add()方法，该方法的语法如下：</p>
<pre><code> dst = cv2.add(src1, src2, mask, dtype)
</code></pre>
<p>参数说明：　</p>
<p>src1：第一幅图像。　</p>
<p>src2：第二幅图像。　</p>
<p>mask：可选参数，掩模，建议使用默认值。　</p>
<p>dtype：可选参数，图像深度，建议使用默认值。<br>返回值说明：　</p>
<p>dst：相加之后的图像。如果相加之后值的结果大于255，则取255。</p>
<p>下面通过一个实例演示“+”运算符和add()方法处理结果的不同。</p>
<p>【实例9.2】　分别使用“+”和add()方法计算图像和。（实例位置：资源包\TM\sl\9\02）<br>读取一幅图像，让该图像自己对自己做加法运算，分别使用“+”运算符和add()方法，观查两者相加结果的不同，具体代码如下：</p>
<p><img src="/.com//image-20211120061614335.png" alt="image-20211120061614335"></p>
<p>上述代码的运行结果如图9.10所示。从结果可以看出，“+”运算符的计算结果如果超出了255，就会取相加和除以255的余数，也就是取模运算，像素值相加后反而变得更小，由浅色变成了深色；而add()方法的计算结果如果超过了255，就取值255，很多浅颜色像素彻底变成了纯白色。</p>
<p><img src="/.com//image-20211120061639378.png" alt="image-20211120061639378"></p>
<p>​                                                              图9.10　图像的加法运算效果</p>
<p>下面通过一个实例演示如何使用加运算修改图像颜色。</p>
<p>【实例9.3】　模拟三色光叠加得白光。<br>颜料中的三原色为红、黄、蓝，这3种颜色混在一起变成黑色，而光学中的三原色为红、绿、蓝，这3种颜色混在一起变成白色。现在分别创建纯蓝、纯绿、纯红3种图像，取3幅图像的相加和，查看结果是黑色还是白色，具体代码如下：</p>
<p><img src="/.com//image-20211120061705351.png" alt="image-20211120061705351"></p>
<p>蓝色加上绿色等于青色，青色再加上红色就等于白色，结果符合光学三原色的叠加原理。</p>
<p>图像的加法运算中也可以使用掩模，下面通过一个实例介绍掩模的使用方法。</p>
<p>【实例9.4】　利用掩模遮盖相加结果。<br>创建纯蓝和纯红2幅图像，使用add()方法对2幅图像进行加法运算，并在方法中添加一个掩模，具体代码如下：</p>
<p><img src="/.com//image-20211120061833765.png" alt="image-20211120061833765"></p>
<p>上述代码的运行结果如图9.16～图9.18所示，从结果可以看出，add()方法中如果使用了掩模参数，相加的结果只会保留掩模中白色覆盖的区域。</p>
<p><img src="/.com//image-20211120061859770.png" alt="image-20211120061859770"></p>
<p>​                                                                                图9.16　蓝色和红色相加的结果</p>
<p><img src="/.com//image-20211120061924099.png" alt="image-20211120061924099"></p>
<p>​                                                                                                   图9.17　掩模</p>
<p><img src="/.com//image-20211120061948929.png" alt="image-20211120061948929"></p>
<p>​                                                                                          图9.18　通过掩模相加的结果</p>
<h2 id="9-3-图像的位运算"><a href="#9-3-图像的位运算" class="headerlink" title="9.3　图像的位运算"></a>9.3　图像的位运算</h2><p>位运算是二进制数特有的运算操作。图像由像素组成，每个像素可以用十进制整数表示，十进制整数又可以转化为二进制数，所以图像也可以做位运算，并且位运算是图像数字化技术中一项重要的运算操作。<br>OpenCV提供了几种常用的位运算方法，具体如表9.1所示。</p>
<p>表9.1　OpenCV提供的位运算方法</p>
<p><img src="/.com//image-20211120062045946.png" alt="image-20211120062045946"></p>
<p>接下来将详细介绍这些方法的含义及使用方式。</p>
<h3 id="9-3-1-按位与运算"><a href="#9-3-1-按位与运算" class="headerlink" title="9.3.1　按位与运算"></a>9.3.1　按位与运算</h3><p>与运算就是按照二进制位进行判断，如果同一位的数字都是1，则运算结果的相同位数字取1，否则取0。<br>OpenCV提供bitwise_and()方法来对图像做与运算，该方法的语法如下：</p>
<p><strong>都是1则为1，只要有一个不是1则为0</strong></p>
<pre><code> dst = cv2.bitwise_and(src1, src2, mask)
</code></pre>
<p>参数说明：　</p>
<p>src1：第一幅图像。　</p>
<p>src2：第二幅图像。　</p>
<p>mask：可选参数，掩模。</p>
<p>返回值说明：　</p>
<p>dst：与运算之后的图像。<br>图像做与运算时，会把每一个像素值都转为二进制数，然后让两幅图像相同位置的两个像素值做与运算，最后把运算结果保存在新图像的相同位置上，运算过程如图9.19所示。</p>
<p><img src="/.com//image-20211120062122565.png" alt="image-20211120062122565"></p>
<p>​                                                                                图9.19　图像做与运算的过程<br>与运算有两个特点。<br>（1）如果某像素与纯白像素做与运算，结果仍然是某像素的原值，计算过程如下：</p>
<pre><code> 00101011 &amp; 11111111 = 00101011
</code></pre>
<p>（2）如果某像素与纯黑像素做与运算，结果为纯黑像素，计算过程如下：</p>
<pre><code> 00101011 &amp; 00000000 = 00000000
</code></pre>
<p>由此可以得出：如果原图像与掩模进行与运算，原图像仅保留掩模中白色区域覆盖的内容，其他区域全部变成黑色。下面通过一个实例演示掩模在与运算过程的作用。</p>
<p>【实例9.5】　花图像与十字掩模做与运算。<br>创建一个掩模，在掩模中央保留一个十字形的白色区域，让掩模与花图像做与运算，具体代码如下：</p>
<p><img src="/.com//image-20211120062312995.png" alt="image-20211120062312995"></p>
<p>上述代码的运行结果如图9.20～图9.22所示，经过与运算之后，花图像仅保留了掩模中白色区域覆盖的内容，其他区域都变成了黑色。</p>
<p><img src="/.com//image-20211120062336698.png" alt="image-20211120062336698"></p>
<p>​                                                                                               图9.20　花图像</p>
<p><img src="/.com//image-20211120062357566.png" alt="image-20211120062357566"></p>
<p>​                                                                                          图9.21　掩模图像</p>
<p><img src="/.com//image-20211120062502072.png" alt="image-20211120062502072"></p>
<p>​                                                                                  图9.22　花图像与掩模图像与运算的效果</p>
<h3 id="9-3-2-按位或运算"><a href="#9-3-2-按位或运算" class="headerlink" title="9.3.2　按位或运算"></a>9.3.2　按位或运算</h3><p>或运算也是按照二进制位进行判断，如果同一位的数字都是0，则运算结果的相同位数字取0，否则取1。<br>OpenCV提供bitwise_or()方法来对图像做或运算，该方法的语法如下：</p>
<p><strong>都是0则为0，只要有一个不是0则为1</strong></p>
<pre><code> dst = cv2.bitwise_or(src1, src2, mask)
</code></pre>
<p>参数说明：　</p>
<p>src1：第一幅图像。　</p>
<p>src2：第二幅图像。　</p>
<p>mask：可选参数，掩模。</p>
<p>返回值说明：　</p>
<p>dst：或运算之后的图像。<br>图像做或运算时的运算过程如图9.23所示。</p>
<p><img src="/.com//image-20211120062536061.png" alt="image-20211120062536061"></p>
<p>​                                                                             图9.23　图像做或运算的过程<br>或运算有以下两个特点。<br>（1）如果某像素与纯白像素做或运算，结果为纯白像素，计算过程如下：</p>
<pre><code> 00101011 | 11111111 = 11111111
</code></pre>
<p>（2）如果某像素与纯黑像素做或运算，结果仍然是某像素的原值，过程如下：</p>
<pre><code> 00101011 | 00000000 = 00101011
</code></pre>
<p>由此可以得出：如果原图像与掩模进行或运算，原图像仅保留掩模中黑色区域覆盖的内容，其他区域全部变成白色。下面通过一个实例演示掩模在或运算过程中的作用。</p>
<p>【实例9.6】　花图像与十字掩模做或运算。<br>创建一个掩模，在掩模中央保留一个十字形的白色区域，让掩模与花图像做或运算，具体代码如下：</p>
<p><img src="/.com//image-20211120062638230.png" alt="image-20211120062638230">上述代码的运行结果如图9.24所示，经过或运算后，花图像仅保留了掩模中黑色区域覆盖的内容，其他区域都变成了白色。</p>
<p><img src="/.com//image-20211120062715613.png" alt="image-20211120062715613"></p>
<p>​                                                                              图9.24　图像或运算效果</p>
<h3 id="9-3-3-按位取反运算"><a href="#9-3-3-按位取反运算" class="headerlink" title="9.3.3　按位取反运算"></a>9.3.3　按位取反运算</h3><p>取反运算是一种单目运算，仅需一个数字参与运算就可以得出结果。取反运算也是按照二进制位进行判断，如果运算数某位上数字是0，则运算结果的相同位的数字就取1，如果这一位的数字是1，则运算结果的相同位的数字就取0。<br>OpenCV提供bitwise_not()方法来对图像做取反运算，该方法的语法如下：</p>
<p>dst = cv2.bitwise_not(src, mask)<br>参数说明：　</p>
<p>src：参与运算的图像。　</p>
<p>mask：可选参数，掩模。<br>返回值说明：</p>
<p>　dst：取反运算之后的图像。<br>图像做取反运算的过程如图9.25所示。</p>
<p><img src="/.com//image-20211120062822407.png" alt="image-20211120062822407"></p>
<p>​                                                                                图9.25　图像做取反运算的过程<br>图像经过取反运算后呈现与原图颜色完全相反的效果，下面通过一个实例演示掩膜在取反运算过程中的作用。</p>
<p>【实例9.7】　对花图像进行取反运算。<br>对花图像进行取反运算，具体代码如下：</p>
<p><img src="/.com//image-20211120062846036.png" alt="image-20211120062846036"></p>
<p>上述代码的运行结果如图9.26所示。</p>
<p><img src="/.com//image-20211120062904656.png" alt="image-20211120062904656"></p>
<p>​                                                                      图9.26　图像取反运算的效果</p>
<h3 id="9-3-4-按位异或运算"><a href="#9-3-4-按位异或运算" class="headerlink" title="9.3.4　按位异或运算"></a>9.3.4　按位异或运算</h3><p>异或运算也是按照二进制位进行判断，如果两个运算数同一位上的数字相同，则运算结果的相同位数字取0，否则取1。OpenCV提供bitwise_xor()方法对图像做异或运算，该方法的语法如下：</p>
<p><strong>如果两个数相同则为0，不相同则为1</strong></p>
<pre><code> dst = cv2.bitwise_xor(src, mask)
</code></pre>
<p>参数说明：　</p>
<p>src：参与运算的图像。　</p>
<p>mask：可选参数，掩模。</p>
<p>返回值说明：　</p>
<p>dst：异或运算之后的图像。<br>图像做异或运算的过程如图9.27所示。</p>
<p><img src="/.com//image-20211120063005147.png" alt="image-20211120063005147"></p>
<p>​                                                                                     图9.27　图像做异或运算的过程<br>异或运算有两个特点。<br>（1）如果某像素与纯白像素做异或运算，结果为原像素的取反结果，计算过程如下：</p>
<pre><code> 00101011 ^ 
 11111111 = 
 11010100
</code></pre>
<p>（2）如果某像素与纯黑像素做异或运算，结果仍然是某像素的原值，计算过程如下：</p>
<pre><code> 00101011 ^ 
 00000000 = 
 00101011
</code></pre>
<p>由此可以得出：如果原图像与掩模进行异或运算，掩模白色区域覆盖的内容呈现取反效果，黑色区域覆盖的内容保持不变。下面通过一个实例演示掩模在异或运算过程的作用。</p>
<p>【实例9.8】　花图像与十字掩模做异或运算。<br>创建一个掩模，在掩模中央保留一个十字形的白色区域，让掩模与花图像做异或运算，具体代码如下：</p>
<p><img src="/.com//image-20211120063056227.png" alt="image-20211120063056227"></p>
<p>运算结果如图9.28所示，掩模白色区域覆盖的内容与原图像做取反运算的结果一致，掩模黑色区域覆盖的内容保持不变。</p>
<p><img src="/.com//image-20211120063113955.png" alt="image-20211120063113955"></p>
<p>​                                                                                      图9.28　图像异或运算效果<br>异或运算还有一个特点：执行一次异或运算得到一个结果，再对这个结果执行第二次异或运算，则还原成最初的值。利用这个特点可以实现对图像内容的加密和解密。下面通过一个实例，利用异或运算的特点对图像数据进行加密和解密。</p>
<p>【实例9.9】　对图像进行加密、解密。<br>利用numpy.random.randint()方法创建一个随机像素值图像作为密钥图像，让密钥图像与原始图像做异或运算得出加密图像，再使用密钥图像对加密图像进行解密，具体代码如下：</p>
<p><img src="/.com//image-20211120063142267.png" alt="image-20211120063142267"></p>
<p>上述代码的运行结果如图9.29所示。</p>
<p><img src="/.com//image-20211120063219114.png" alt="image-20211120063219114"></p>
<p>​                                                                                         图9.29　图像加密、解密效果</p>
<h2 id="9-4-合并图像"><a href="#9-4-合并图像" class="headerlink" title="9.4　合并图像"></a>9.4　合并图像</h2><p>在处理图像时经常会遇到需要将两幅图像合并成一幅图像，合并图像也分2种情况：①两幅图像融合在一起；②每幅图像提供一部分内容，将这些内容拼接成一幅图像。OpenCV分别用加权和和覆盖两种方式来满足上述需求。本节将分别介绍如何利用代码实现加权和和覆盖效果。</p>
<h3 id="9-4-1-加权和"><a href="#9-4-1-加权和" class="headerlink" title="9.4.1　加权和"></a>9.4.1　加权和</h3><p>多次曝光技术是指在一幅胶片上拍摄几个影像，最后冲印出的相片同时具有多个影像的信息。<br>OpenCV通过计算加权和的方式，按照不同的权重取两幅图像的像素之和，最后组成新图像。加权和不会像纯加法运算那样让图像丢失信息，而是在尽量保留原有图像信息的基础上把两幅图像融合到一起。<br>OpenCV通过addWeighted()方法计算图像的加权和，该方法语法如下：</p>
<pre><code> dst = cv2.addWeighted(src1, alpha, src2, beta, gamma)
</code></pre>
<p>参数说明：　</p>
<p>src1：第一幅图像。　</p>
<p>alpha：第一幅图像的权重。　</p>
<p>src2：第二幅图像。　</p>
<p>beta：第二幅图像的权重。　</p>
<p>gamma：在和结果上添加的标量。该值越大，结果图像越亮，相反则越暗。可以是负数。</p>
<p>返回值说明：　</p>
<p>dst：加权和后的图像。</p>
<p>下面通过一个实例演示addWeighted()方法的效果。</p>
<p>【实例9.10】　利用计算加权和的方式实现多次曝光效果。<br>读取两幅不同的风景照片，使用addWeighted()方法计算两幅图像的加权和，两幅图像的权重都为0.6，标量为0，查看处理之后的图像是否为多次曝光效果，具体代码如下：</p>
<p><img src="/.com//image-20211120063330427.png" alt="image-20211120063330427"></p>
<p>上述代码的运行结果如图9.30～图9.32所示，可以看出最后得到的图像中同时包含两幅图像的信息。</p>
<p><img src="/.com//image-20211120063347197.png" alt="image-20211120063347197"></p>
<p>​                                                                                               图9.30　日落图像</p>
<p><img src="/.com//image-20211120063409727.png" alt="image-20211120063409727"></p>
<p>​                                                                                              图9.31　沙滩图像</p>
<p><img src="/.com//image-20211120063438319.png" alt="image-20211120063438319"></p>
<p>​                                                                                 图9.32　两幅图像加权和的结果</p>
<h3 id="9-4-2-覆盖"><a href="#9-4-2-覆盖" class="headerlink" title="9.4.2　覆盖"></a>9.4.2　覆盖</h3><p>覆盖图像就是直接把前景图像显示在背景图像中，前景图像挡住背景图像。覆盖之后背景图像会丢失信息，不会出现加权和那样的“多次曝光”效果。<br>OpenCV没有提供覆盖操作的方法，开发者可以直接用修改图像像素值的方式实现图像的覆盖、拼接效果：从A图像中取像素值，直接赋值给B图像的像素，这样就能在B图像中看到A图像的信息了。<br>下面通过一个实例来演示如何从前景图像中抠图，再将抠出的图像覆盖在背景图像中。</p>
<p>【实例9.11】　将小猫图像覆盖到沙滩图像上。</p>
<p>读取小猫原始图像，将原始图像中75～400行、120～260列的像素单独保存成一幅小猫图像，并将小猫图像缩放成70×160大小。读取沙滩图像，将小猫图像覆盖到沙滩图像(100, 200)的坐标位置。覆盖过程中将小猫图像的像素逐个赋值给沙滩图像中对应位置的像素，具体代码如下：</p>
<p><img src="/.com//image-20211120063525987.png" alt="image-20211120063525987"></p>
<p>运行结果如图9.33所示，沙滩图像中的像素被替换成小猫之后，就可实现类似拼接图像的效果。</p>
<p><img src="/.com//image-20211120063608529.png" alt="image-20211120063608529"></p>
<p>​                                                                                                图9.33　覆盖图像效果<br>如果前景图像是4通道（含alpha通道）图像，就不能使用上面例子中直接替换整个区域的方式覆盖背景图像了。因为前景图像中有透明的像素，透明的像素不应该挡住背景，所以在给背景图像像素赋值时应排除所有透明的前景像素。下面通过一个实例来演示如何在覆盖过程中排除4通道图像的透明区域。</p>
<p>【实例9.12】　拼接禁止吸烟图像。<br>禁止图像由一个红圈和一个斜杠组成，这个图像是4通道图像，格式为PNG。将禁止图像覆盖到吸烟图像上时要注意：不要把前景图像的透明像素覆盖到背景图像上。覆盖之前要遍历前景图像中的每一个像素，如果像素的alpha通道值为0，表示该像素是透明像素，就要停止操作该像素，实现的具体代码如下：</p>
<p><img src="/.com//image-20211120063635612.png" alt="image-20211120063635612"></p>
<p>上述代码的运行结果如图9.34～图9.36所示，禁止图像的透明位置没有挡住吸烟图像。</p>
<p><img src="/.com//image-20211120063725775.png" alt="image-20211120063725775"></p>
<p>​                                                                                        图9.34　禁止图像</p>
<p><img src="/.com//image-20211120063745746.png" alt="image-20211120063745746"></p>
<p>​                                                                                          图9.35　吸烟图像</p>
<p><img src="/.com//image-20211120063807277.png" alt="image-20211120063807277"></p>
<p>​                                                                                图9.36　2幅图像拼接之后的禁止吸烟图像</p>
<h2 id="9-5-小结"><a href="#9-5-小结" class="headerlink" title="9.5　小结"></a>9.5　小结</h2><p>明确关于掩模的3个问题：0和255这2个值在掩模中各自发挥的作用；通过这2个值，掩模的作用又是什么；如何创建一个掩模。掌握了掩模后，就能够利用掩模遮盖图像相加后的结果。掩模除了应用于图像的加法运算外，还应用于图像的位运算。一个掩模应用于图像的位运算的典型实例就是对图像进行加密、解密。本章除了上述内容，还讲解了合并图像的2种方式：加权和、覆盖。</p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
  </entry>
  <entry>
    <title>OpenCV基础篇01</title>
    <url>/2022/02/07/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%8701/</url>
    <content><![CDATA[<h1 id="OpenCV进阶篇01"><a href="#OpenCV进阶篇01" class="headerlink" title="OpenCV进阶篇01"></a>OpenCV进阶篇01</h1><h1 id="第14章-视频处理"><a href="#第14章-视频处理" class="headerlink" title="第14章　视频处理"></a>第14章　视频处理</h1><p>OpenCV不仅能够处理图像，还能够处理视频。视频是由大量的图像构成的，这些图像以固定的时间间隔从视频中获取。这样，就能够使用图像处理的方法对这些图像进行处理，进而达到处理视频的目的。要处理视频，需要先对视频进行读取、显示和保存等相关操作。为此，OpenCV提供了VideoCapture类和VideoWriter类的相关方法。</p>
<p><img src="/.com//image-20211128195439971.png" alt="image-20211128195439971"></p>
<h2 id="14-1-读取并显示摄像头视频"><a href="#14-1-读取并显示摄像头视频" class="headerlink" title="14.1　读取并显示摄像头视频"></a>14.1　读取并显示摄像头视频</h2><p>摄像头视频指的是从摄像头（见图14.1）中实时读取到的视频。为了读取并显示摄像头视频，OpenCV提供了VideoCapture类的相关方法，这些方法包括摄像头的初始化方法、检验摄像头初始化是否成功的方法、从摄像头中读取帧的方法和关闭摄像头的方法等。下面依次对这些方法进行讲解。</p>
<p><img src="/.com//image-20211128195512490.png" alt="image-20211128195512490"></p>
<p>​                                                                                         图14.1　摄像头说明<br>视频是由大量的图像构成的，把这些图像称作帧。</p>
<h3 id="14-1-1-VideoCapture类"><a href="#14-1-1-VideoCapture类" class="headerlink" title="14.1.1　VideoCapture类"></a>14.1.1　VideoCapture类</h3><p>VideoCapture类提供了构造方法VideoCapture()，用于完成摄像头的初始化工作。VideoCapture()的语法格式如下：</p>
<pre><code> capture = cv2.VideoCapture(index)
</code></pre>
<p>参数说明：　</p>
<p>capture：要打开的摄像头。　</p>
<p>index：摄像头的设备索引。</p>
<p>注意<br>摄像头的数量及其设备索引的先后顺序由操作系统决定，因为OpenCV没有提供查询摄像头的数量及其设备索引的任何方法。<br>当index的值为0时，表示要打开的是第1个摄像头；对于64位的Windows 10笔记本，当index的值为0时，表示要打开的是笔记本内置摄像头，关键代码如下：</p>
<pre><code> capture = cv2.VideoCapture(0)
</code></pre>
<p>当index的值为1时，表示要打开的是第2个摄像头；对于64位的Windows 10笔记本，当index的值为1时，表示要打开的是一个连接笔记本的外置摄像头，关键代码如下：</p>
<pre><code> capture = cv2.VideoCapture(1)
</code></pre>
<p>为了检验摄像头初始化是否成功，VideoCapture类提供了isOpened()方法。isOpened()方法的语法格式如下：</p>
<pre><code> retval = cv2.VideoCapture.isOpened()
</code></pre>
<p>参数说明：　</p>
<p>retval：isOpened()方法的返回值。如果摄像头初始化成功，retval的值为True；否则，retval的值为False。</p>
<p>说明<br>在VideoCapture()的语法格式基础上，isOpened()方法的语法格式可以简写为retval = capture.isOpened()<br>摄像头初始化后，可以从摄像头中读取帧，为此VideoCapture类提供了read()方法。read()方法的语法格式如下：</p>
<pre><code> retval, image = cv2.VideoCapture.read() # 可以简写为retval, image = capture.read()
</code></pre>
<p>参数说明：　</p>
<p>retval：是否读取到帧。如果读取到帧，retval的值为True；否则，retval的值为False。　</p>
<p>image：读取到的帧。因为帧指的是构成视频的图像，所以可以把“读取到的帧”理解为“读取到的图像”。</p>
<p>OpenCV官网特别强调，在不需要摄像头时，要关闭摄像头。为此，VideoCapture类提供了release()方法。release()方法的语法格式如下：</p>
<pre><code> cv2.VideoCapture.release() # 可以简写为capture.release()
</code></pre>
<h3 id="14-1-2-如何使用VideoCapture类"><a href="#14-1-2-如何使用VideoCapture类" class="headerlink" title="14.1.2　如何使用VideoCapture类"></a>14.1.2　如何使用VideoCapture类</h3><p>在14.1.1节中，介绍了VideoCapture类中的VideoCapture()方法、isOpened()方法、read()方法和release()方法。那么，在程序开发的过程中，如何使用这些方法呢？本节将通过3个实例进行讲解。</p>
<p>【实例14.1】　读取并显示摄像头视频。<br>编写一个程序，打开笔记本内置摄像头实时读取并显示视频。当按下空格键时，关闭笔记本内置摄像头，销毁显示摄像头视频的窗口，代码如下：</p>
<p><img src="/.com//image-20211128200517716.png" alt="image-20211128200517716"></p>
<p>上述代码的运行结果如图14.2所示。</p>
<p><img src="/.com//image-20211128200557699.png" alt="image-20211128200557699"></p>
<p>​                                                                                     图14.2　读取并显示摄像头视频说明<br>图14.2是笔者用笔记本内置摄像头实时读取并显示公司天花板的视频。<br>在实例14.1运行期间，如果按下空格键，笔记本内置摄像头将被关闭，显示摄像头视频的窗口也将被销毁。此外，PyCharm控制台将输出如图14.3所示的警告信息。</p>
<p><img src="/.com//image-20211128200630928.png" alt="image-20211128200630928"></p>
<p>​                                                                             图14.3　PyCharm控制台输出的警告信息<br>为了消除图14.3所示的警告信息，需要将实例14.1第3行代码：</p>
<pre><code> capture = cv2.VideoCapture(0) # 打开笔记本内置摄像头
</code></pre>
<p>修改为如下代码：</p>
<pre><code> capture = cv2.VideoCapture(0, cv2.CAP_DSHOW) # 打开笔记本内置摄像头
</code></pre>
<p>如果想打开的是一个连接笔记本的外置摄像头，那么需要将实例14.1第3行代码：</p>
<p>capture = cv2.VideoCapture(0) # 打开笔记本内置摄像头<br>修改为如下代码：</p>
<pre><code> capture = cv2.VideoCapture(1, cv2.CAP_DSHOW) # 打开笔记本外置摄像头
</code></pre>
<p>实例14.1已经成功地读取并显示了摄像头视频，那么如何对这个视频进行处理呢？其实，处理视频所用的方法与处理图像所用的方法是相同的。实例14.2将使用处理图像的相关方法把实例14.1读取并显示的彩色视频转换为灰度视频。</p>
<p>【实例14.2】　将摄像头视频由彩色视频转换为灰度视频。<br>编写一个程序，使用图像处理的相关方法把实例14.1读取并显示的彩色视频转换为灰度视频。当按下空格键时，关闭笔记本内置摄像头，销毁显示摄像头视频的窗口，代码如下：</p>
<p><img src="/.com//image-20211128200727172.png" alt="image-20211128200727172"></p>
<p>上述代码的运行结果如图14.4所示。</p>
<p><img src="/.com//image-20211128200757312.png" alt="image-20211128200757312"></p>
<pre><code>                                                                           图14.4　把彩色视频转换为灰度视频
</code></pre>
<p>实例14.1和实例14.2都用到了按键指令。当按下空格键时，关闭笔记本内置摄像头，销毁显示摄像头视频的窗口。那么，能否通过按键指令，保存并显示摄像头视频某一时刻的图像？带着这个疑问，请读者朋友继续阅读实例14.3。</p>
<p>【实例14.3】　显示并保存摄像头视频某一时刻的图像。<br>编写一个程序，打开笔记本内置摄像头实时读取并显示视频。当按下空格键时，关闭笔记本内置摄像头，保存并显示此时摄像头视频中的图像，代码如下：</p>
<p><img src="/.com//image-20211128200847208.png" alt="image-20211128200847208"></p>
<p>上述代码的运行结果如图14.5所示。</p>
<p><img src="/.com//image-20211128200934953.png" alt="image-20211128200934953"></p>
<p>​                                                                          图14.5　显示摄像头视频某一时刻的图像<br>实例14.3除能够显示摄像头视频某一时刻的图像外（见图14.5），还能够把图14.5保存为D盘根目录下的copy.png文件，如图14.6所示。</p>
<p><img src="/.com//image-20211128201000098.png" alt="image-20211128201000098"></p>
<p>​                                                                         图14.6　把图14.5保存为D盘根目录下的copy.png<br>实例14.1～实例14.3打开的都是笔记本内置摄像头，如果在打开笔记本内置摄像头的同时，再打开一个连接笔记本的外置摄像头，应该如何实现呢？</p>
<p>【实例14.4】　读取并显示2个摄像头视频。</p>
<p>编写一个程序，在打开笔记本内置摄像头实时读取并显示视频的同时，再打开一个连接笔记本的外置摄像头。当按下空格键时，关闭笔记本内置摄像头和连接笔记本的外置摄像头，销毁显示摄像头视频的窗口。代码如下：</p>
<p><img src="/.com//image-20211128201055804.png" alt="image-20211128201055804"></p>
<p>上述代码的运行结果如图14.7和图14.8所示。其中，图14.7是读取并显示笔记本内置摄像头视频，图14.8是读取并显示连接笔记本的外置摄像头视频。</p>
<p><img src="/.com//image-20211128201118623.png" alt="image-20211128201118623"></p>
<p>​                                                                             图14.7　读取并显示笔记本内置摄像头视频</p>
<p><img src="/.com//image-20211128201143279.png" alt="image-20211128201143279"></p>
<p>​                                                                   图14.8　读取并显示连接笔记本的外置摄像头视频</p>
<h2 id="14-2-播放视频文件"><a href="#14-2-播放视频文件" class="headerlink" title="14.2　播放视频文件"></a>14.2　播放视频文件</h2><p>VideoCapture类及其方法除了能够读取并显示摄像头视频外，还能够读取并显示视频文件。当窗口根据视频文件的时长显示视频文件时，便实现了播放视频文件的效果。</p>
<h3 id="14-2-1-读取并显示视频文件"><a href="#14-2-1-读取并显示视频文件" class="headerlink" title="14.2.1　读取并显示视频文件"></a>14.2.1　读取并显示视频文件</h3><p>VideoCapture类的构造方法VideoCapture()不仅能够完成摄像头的初始化工作，还能够完成视频文件的初始化工作。当VideoCapture()用于初始化视频文件时，其语法格式如下：</p>
<p>video = cv2.VideoCapture(filename)<br>参数说明：　</p>
<p>video：要打开的视频。　</p>
<p>filename：打开视频的文件名。例如，公司宣传.avi等。</p>
<p>注意<br>OpenCV中的VideoCapture类虽然支持各种格式的视频文件，但是这个类在不同的操作系统中，支持的视频文件格式不同。尽管如此，VideoCapture类能够在不同的操作系统中支持后缀名为.avi的视频文件。</p>
<p>【实例14.5】　读取并显示视频文件。<br>编写一个程序，读取并显示PyCharm当前项目路径下名为“公司宣传.avi”的视频文件。当按Esc键时，关闭视频文件并销毁显示视频文件的窗口，代码如下：</p>
<p><img src="/.com//image-20211128201246445.png" alt="image-20211128201246445"></p>
<p>上述代码的运行结果如图14.9所示。</p>
<p><img src="/.com//image-20211128201314133.png" alt="image-20211128201314133"></p>
<pre><code>                                                        图14.9　读取并显示名为“公司宣传.avi”的视频文件说明
</code></pre>
<p>调整waitKey()方法中的参数值可以控制视频文件的播播放速度。例如，当代码为cv2.waitKey(1)时，等待用户按下键盘的时间为1ms，视频文件的播放速度非常快；当代码为cv2.waitKey(50)时，等待用户按下键盘的时间为50ms，能够减缓视频文件的播放速度。<br>使用处理图像的相关方法，能够将摄像头视频由彩色视频转换为灰度视频。那么，使用相同的方法，也能够将视频文件由彩色视频转换为灰度视频。</p>
<p>【实例14.6】　将视频文件由彩色视频转换为灰度视频。<br>编写一个程序，使用处理图像的相关方法，先将PyCharm当前项目路径下名为“公司宣传.avi”的视频文件由彩色视频转换为灰度视频，再显示转换后的灰度图像，代码如下：</p>
<p><img src="/.com//image-20211128201410162.png" alt="image-20211128201410162"></p>
<p>上述代码的运行结果如图14.10所示。</p>
<p><img src="/.com//image-20211128201434739.png" alt="image-20211128201434739"></p>
<p>​                                                            图14.10　将“公司宣传.avi”由彩色视频转换为灰度视频</p>
<h3 id="14-2-2-视频的暂停播放和继续播放"><a href="#14-2-2-视频的暂停播放和继续播放" class="headerlink" title="14.2.2　视频的暂停播放和继续播放"></a>14.2.2　视频的暂停播放和继续播放</h3><p>实例14.5使用VideoCapture类及其相关方法实现了在窗口中播放视频文件的效果。那么，能否在实例14.5的基础上，通过按键指令，在播放视频的过程中，实现视频的暂停播放和继续播放呢？答案是肯定的。</p>
<p>【实例14.7】　视频的暂停播放和继续播放。<br>编写一个程序，读取并显示PyCharm当前项目路径下名为“公司宣传.avi”的视频文件。在播放视频文件的过程中，当按空格键时，暂停播放视频；当再次按空格键时，继续播放视频；当按Esc键时，关闭视频文件并销毁显示视频文件的窗口，代码如下：</p>
<p><img src="/.com//image-20211128201543614.png" alt="image-20211128201543614"></p>
<p>上述代码的运行结果如图14.11和图14.12所示（其中，图14.11是暂停播放视频的效果，图14.12是继续播放视频的效果）。</p>
<p><img src="/.com//image-20211128202037480.png" alt="image-20211128202037480"></p>
<p>​                                                                                  图14.11　暂停播放视频</p>
<p><img src="/.com//image-20211128202102795.png" alt="image-20211128202102795"></p>
<p>​                                                                                          图14.12　继续播放视频</p>
<h3 id="14-2-3-获取视频文件的属性"><a href="#14-2-3-获取视频文件的属性" class="headerlink" title="14.2.3　获取视频文件的属性"></a>14.2.3　获取视频文件的属性</h3><p>在实际开发中，有时需要获取视频文件的属性。为此，VideoCapture类提供了get()方法。get()方法的语法格式如下：</p>
<pre><code> retval = cv2.VideoCapture.get(propId)
</code></pre>
<p>参数说明：　</p>
<p>retval：获取与propId对应的属性值。　</p>
<p>propId：视频文件的属性值。　</p>
<p>VideoCapture类提供视频文件的属性值及其含义如表14.1所示。                        </p>
<p>​                                                                     表14.1　视频文件的属性值及其含义</p>
<p><img src="/.com//image-20211128202208827.png" alt="image-20211128202208827"></p>
<p>说明<br>（1）视频是由大量的、连续的图像构成的，把其中的每一幅图像称作一帧。<br>（2）帧数指的是视频文件中含有的图像总数，帧数越多，视频播放时越流畅。<br>（3）在播放视频的过程中，把每秒显示图像的数量称作帧速率（FPS，单位：帧／s）。<br>（4）帧宽度指的是图像在水平方向上含有的像素总数。<br>（5）帧高度指的是图像在垂直方向上含有的像素总数。</p>
<p>【实例14.8】　获取并输出视频文件的指定属性值。<br>编写一个程序，使用VideoCapture类get()方法，先获取“公司宣传.avi”的帧速率、帧数、帧宽度和帧高度，再把上述4个属性值输出在PyCharm的控制台上，代码如下：</p>
<p><img src="/.com//image-20211128202243529.png" alt="image-20211128202243529"></p>
<p>上述代码的运行结果如图14.13所示。</p>
<p><img src="/.com//image-20211128202327955.png" alt="image-20211128202327955"></p>
<p>​                                              图14.13　获取并输出“公司宣传.avi”的帧速率、帧数、帧宽度和帧高度<br>实例14.8演示了初始化视频文件后，获取并输出视频文件的指定属性值。那么，能否使得窗口在播放视频的同时，动态显示当前视频文件的属性值呢？例如，当前视频播放到第几帧，该帧对应着视频的第几秒等。</p>
<p>【实例14.9】　动态显示视频文件的属性值。<br>编写一个程序，窗口在播放“公司宣传.avi”视频文件的同时，动态显示当前视频播放到第几帧和该帧对应视频的第几秒，代码如下：</p>
<p><img src="/.com//image-20211128202356380.png" alt="image-20211128202356380"></p>
<p>上述代码的运行结果如图14.14所示。</p>
<p><img src="/.com//image-20211128202452972.png" alt="image-20211128202452972"></p>
<p>​                                                                            图14.14　动态显示视频文件的属性值</p>
<p>说明<br>图14.14中的185和7.4s的含义是当前视频播放到第185帧，第185帧对应着“公司宣传.avi”视频文件中的第7.4s。</p>
<h2 id="14-3-保存视频文件"><a href="#14-3-保存视频文件" class="headerlink" title="14.3　保存视频文件"></a>14.3　保存视频文件</h2><p>在实际开发过程中，很多时候希望保存一段视频。为此，OpenCV提供了VideoWriter类。下面先来熟悉一下VideoWriter类中的常用方法。</p>
<h3 id="14-3-1-VideoWriter类"><a href="#14-3-1-VideoWriter类" class="headerlink" title="14.3.1　VideoWriter类"></a>14.3.1　VideoWriter类</h3><p>VideoWriter类中的常用方法包括VideoWriter类的构造方法、write()方法和release()方法。其中，VideoWriter类的构造方法用于创建VideoWriter类对象，其语法格式如下：</p>
<pre><code> &lt;VideoWriter object&gt; = cv2.VideoWriter(filename, fourcc, fps, frameSize)
</code></pre>
<p>参数说明：　</p>
<p>VideoWriter object：VideoWriter类对象。　</p>
<p>filename：保存视频时的路径（含有文件名）。　</p>
<p>fourcc：用4个字符表示的视频编码格式。　</p>
<p>fps：帧速率。　</p>
<p>frameSize：每一帧的大小。</p>
<p>在OpenCV中，使用cv2.VideoWriter_fourcc()来确定视频编码格式。表14.2列出了几个常用的视频编码格式。</p>
<p>​                                                                  表14.2　常用的视频编码格式</p>
<p><img src="/.com//image-20211128202614177.png" alt="image-20211128202614177"></p>
<p>根据上述内容，即可创建一个VideoWriter类对象。</p>
<p>例如，在Windows操作系统下，fourcc的值为cv2.VideoWriter_fourcc(‘X’, ‘V’, ‘I’, ‘D’)，帧速率为20，帧大小为640×480。如果想把一段视频保存为当前项目路径下的output.avi，那么就要创建一个VideoWriter类对象output，关键代码如下：</p>
<pre><code> fourcc = cv2.VideoWriter_fourcc(&#39;X&#39;, &#39;V&#39;, &#39;I&#39;, &#39;D&#39;)
 output = cv2.VideoWriter(&quot;output.avi&quot;, fourcc, 20, (640, 480))
</code></pre>
<p>上述代码也可以写作：</p>
<pre><code> fourcc = cv2.VideoWriter_fourcc(* &#39;XVID&#39;)
 output = cv2.VideoWriter(&quot;output.avi&quot;, fourcc, 20, (640, 480))
</code></pre>
<p>为了保存一段视频，除需要使用VideoWriter类的构造方法外，还需要使用VideoWriter类提供的write()方法。write()方法的作用是在创建好的VideoWriter类对象中写入读取到的帧，其语法格式如下：</p>
<pre><code> cv2.VideoWriter.write(frame)
</code></pre>
<p>参数说明：　</p>
<p>frame：读取到的帧。</p>
<p>注意<br>使用write()方法时，需要由VideoWriter类对象进行调用。例如，在创建好的VideoWriter类对象output中写入读取到的帧frame，关键代码如下：</p>
<pre><code> output.write(frame)
</code></pre>
<p>当不需要使用VideoWriter类对象时，需要将其释放掉。为此，VideoWriter类提供了release()方法，其语法格式如下：</p>
<p>cv2.VideoWriter.release()<br>例如，完成保存一段视频后，需要释放VideoWriter类对象output。关键代码如下：</p>
<pre><code> output.release()
</code></pre>
<h3 id="14-3-2-如何使用VideoWriter类"><a href="#14-3-2-如何使用VideoWriter类" class="headerlink" title="14.3.2　如何使用VideoWriter类"></a>14.3.2　如何使用VideoWriter类</h3><p>使用VideoWriter类保存一段视频需要经过以下几个步骤：创建VideoWriter类对象、写入读取到的帧、释放VideoWriter类对象等。而且，这段视频既可以是摄像头视频，也可以是视频文件。本节将使用VideoWriter类以实例的方式分别对保存摄像头视频和保存视频文件进行讲解。</p>
<p>【实例14.10】　保存一段摄像头视频。<br>编写一个程序，首先打开笔记本内置摄像头，实时读取并显示视频；然后按Esc键，关闭笔记本内置摄像头，销毁显示摄像头视频的窗口，并且把从打开摄像头到关闭摄像头的这段视频保存为PyCharm当前项目路径下的output.avi，代码如下：</p>
<p><img src="/.com//image-20211128202745833.png" alt="image-20211128202745833"></p>
<p>说明<br>在Windows操作系统下，fourcc的值为cv2.VideoWriter_fourcc(‘X’, ‘V’, ‘I’, ‘D’)，帧速率为20，帧大小为640×480。<br>在上述代码运行的过程中，按Esc键后，会在PyCharm当前项目路径（D:\PyCharm\PythonDevelop）下生成一个名为“output.avi”的视频文件，如图14.15所示。双击打开D:</p>
<p>PyCharm\PythonDevelop路径下的“output.avi”视频文件，即可浏览被保存的摄像头视频，如图14.16所示。</p>
<p><img src="/.com//image-20211128202856720.png" alt="image-20211128202856720"></p>
<p>​                                                           图14.15　PyCharm当前项目路径下的output.avi</p>
<p><img src="/.com//image-20211128202918741.png" alt="image-20211128202918741"></p>
<p>​                                                           图14.16　浏览被保存的摄像头视频说明       </p>
<p>这里是使用笔记本内置摄像头录制的手机秒表的视频，读者可以根据自己的喜好录制其他视频。<br>实例14.10可以重复运行，由于output.avi已经存在于PyCharm当前项目路径下，因此新生成的output.avi会覆盖已经存在的output.avi。<br>从图14.16中能够发现，笔者使用笔记本内置摄像头录制的视频时长为26s。也就是说，从打开摄像头、到关闭摄像头的这段时间间隔为26s，并且这段时间间隔由是否按Esc键决定。那么，能否对这段时间间隔进行设置呢？例如，打开摄像头并显示10s的摄像头视频？如果能，又该如何编写具有如此功能的代码呢？</p>
<p>【实例14.11】　保存一段时长为10s的摄像头视频。<br>编写一个程序，首先打开笔记本内置摄像头，实时读取并显示视频；然后录制一段时长为10s的摄像头视频；10s后，自动关闭笔记本内置摄像头，同时销毁显示摄像头视频的窗口，并且把这段时长为10s的摄像头视频保存为PyCharm当前项目路径下的ten_Seconds.avi，代码如下：</p>
<p><img src="/.com//image-20211128203038547.png" alt="image-20211128203038547"></p>
<p>运行上述代码10s后，会在PyCharm当前项目路径下生成一个名为“ten_Seconds.avi”的视频文件。双击打开D:\PyCharm\PythonDevelop路径下的“ten_Seconds.avi”视频文件，即可浏览被保存的摄像头视频，如图14.17所示。</p>
<p><img src="/.com//image-20211128203057475.png" alt="image-20211128203057475"></p>
<p>​                                                                 图14.17　浏览被保存的、时长为10s的摄像头视频</p>
<p>实例14.10和实例14.11演示了如何使用VideoWriter类保存摄像头视频。VideoWriter类不仅能保存摄像头视频，还能保存视频文件，而且保存视频文件与保存摄像头视频的步骤是相同的。接下来，仍以实例的方式演示如何使用VideoWriter类保存视频文件。</p>
<p>【实例14.12】　保存视频文件。<br>编写一个程序，首先读取PyCharm当前项目路径下名为“公司宣传.avi”的视频文件，然后将“公司宣传.avi”视频文件保存为PyCharm当前项目路径下的copy.avi，代码如下：</p>
<p><img src="/.com//image-20211128203126554.png" alt="image-20211128203126554"></p>
<p>由于要以帧为单位，一边读取视频文件，一边保存视频文件，因此运行上述代码后，PyCharm控制台没有立即输出代码中的提示信息，如图14.18所示。</p>
<p><img src="/.com//image-20211128203221855.png" alt="image-20211128203221855"></p>
<p>​                                                            图14.18　PyCharm控制台没有立即输出代码中的提示信息<br>大约1min后，会在PyCharm当前项目路径下生成一个名为“copy.avi”的视频文件，如图14.19所示。这时，PyCharm控制台也将输出如图14.20所示的提示信息。</p>
<p><img src="/.com//image-20211128203239999.png" alt="image-20211128203239999"></p>
<p>​                                                               图14.19　PyCharm当前项目路径下生成的copy.avi</p>
<p><img src="/.com//image-20211128203302454.png" alt="image-20211128203302454"></p>
<p>​                                                                       图14.20　PyCharm控制台将输出提示信息<br>双击打开D:\PyCharm\PythonDevelop路径下的“copy.avi”视频文件，即可浏览被保存的视频文件，如图14.21所示。</p>
<p><img src="/.com//image-20211128203324502.png" alt="image-20211128203324502"></p>
<p>​                                                                 图14.21　浏览被保存的“copy.avi”视频文件</p>
<p>从图14.21中能够发现，保存后的“copy.avi”视频文件的时长为49s。那么，能否缩短“copy.avi”视频文件的时长？例如，只保存“公司宣传.avi”视频文件中的前10s视频？这是可以实现的，实现逻辑与实例14.11是相同的。</p>
<p>【实例14.13】　保存视频文件中的前10s视频。<br>编写一个程序，首先读取PyCharm当前项目路径下名为“公司宣传.avi”的视频文件，然后将“公司宣传.avi”视频文件中的前10s视频保存为PyCharm当前项目路径下的ten_Seconds.avi，代码如下：</p>
<p><img src="/.com//image-20211128203418911.png" alt="image-20211128203418911"></p>
<p>运行上述代码10s后，不仅会在PyCharm当前项目路径下生成一个名为“ten_Seconds.avi”视频文件，而且会在PyCharm控制台输出提示信息。双击打开D:\PyCharm\PythonDevelop路径下的“ten_Seconds.avi”视频文件，即可浏览被保存的视频文件，如图14.22所示。</p>
<p><img src="/.com//image-20211128203447064.png" alt="image-20211128203447064"></p>
<p>​                                                       图14.22　保存“公司宣传.avi”视频文件中的前10s视频</p>
<h2 id="14-4-小结"><a href="#14-4-小结" class="headerlink" title="14.4　小结"></a>14.4　小结</h2><p>视频是由一系列连续的图像构成的，这一系列连续的图像被称作帧，帧是以固定的时间间隔从视频中获取的。因为视频播放的速度就是获取帧的速度，所以把视频播放的速度称作帧速率，其单位是帧／s（即1s内出现的图像数）。所谓视频处理，处理的对象就是从视频中获取的帧，而后使用图像处理的方法对获取的帧进行处理。OpenCV提供了VideoCapture类和VideoWriter类处理视频，虽然这2个类在不同的操作系统中支持的视频文件的格式不同，但是这2个类在不同的操作系统中都支持AVI格式的视频文件。</p>
<h1 id="第15章-人脸检测和人脸识别"><a href="#第15章-人脸检测和人脸识别" class="headerlink" title="第15章　人脸检测和人脸识别"></a>第15章　人脸检测和人脸识别</h1><p>人脸识别是基于人的脸部特征信息进行身份识别的一种生物识别技术，也是计算机视觉重点发展的技术。机器学习算法诞生之后，计算机可以通过摄像头等输入设备自动分析图像中包含的内容信息，随着技术的不断发展，现在已经有了多种人脸识别的算法。本章将介绍OpenCV自带的多种图像跟踪技术和3种人脸识别技术的用法。</p>
<p><img src="/.com//image-20211128203604892.png" alt="image-20211128203604892"></p>
<h2 id="15-1-人脸检测"><a href="#15-1-人脸检测" class="headerlink" title="15.1　人脸检测"></a>15.1　人脸检测</h2><p>人脸检测是让计算机在一幅画面中找出人脸的位置。毕竟计算机还达不到人类的智能水平，所以计算机在检测人脸的过程中实际上是在做“分类”操作，例如，计算机发现图像中有一些像素组成了眼睛的特征，那这些像素就有可能是“眼睛”；如果“眼睛”旁边还有“鼻子”和“另一只眼睛”的特征，那这3个元素所在的区域就很有可能是人脸区域；但如果“眼睛”旁边缺少必要的“鼻子”和“另一只眼睛”，那就认为这些像素并没有组成人脸，它们不是人脸图像的一部分。<br>检测人脸的算法比较复杂，但OpenCV已经将这些算法封装好，本节将介绍如何利用OpenCV自带的功能进行人脸检测。</p>
<h3 id="15-1-1-级联分类器"><a href="#15-1-1-级联分类器" class="headerlink" title="15.1.1　级联分类器"></a>15.1.1　级联分类器</h3><p>将一系列简单的分类器按照一定顺序级联到一起就构成了级联分类器，使用级联分类器的程序可以通过一系列简单的判断来对样本进行识别。例如，依次满足“有6条腿”“有翅膀”“有头、胸、腹”这3个条件的样本就可以被初步判断为昆虫，但如果任何一个条件不满足，则不会被认为是昆虫。</p>
<p>OpenCV提供了一些已经训练好的级联分类器，这些级联分类器以XML文件的方式保存在以下路径中：</p>
<pre><code> ...\Python\Lib\site-packages\cv2\data\
</code></pre>
<p>路径说明：　“…\Python\”：Python虚拟机的本地目录。　“\Lib\site-packages\”：pip安装扩展包的默认目录。　“\cv2\data\”：OpenCV库的data文件夹。<br>例如，这里的Python虚拟机安装在C:\Program Files\Python\目录下，级联分类器文件所在的位置如图15.1所示。</p>
<p><img src="/.com//image-20211128203651374.png" alt="image-20211128203651374"></p>
<p>​                                                                 图15.1　OpenCV自带的级联分类器XML文件<br>不同版本的OpenCV自带的级联分类器XML文件可能会有差别，data文件夹中缺少的XML文件可以到OpenCV的源码托管平台下载，地址为：<a href="https://github.com/opencv/opencv/tree/master/data/haarcascades%E3%80%82">https://github.com/opencv/opencv/tree/master/data/haarcascades。</a><br>每一个XML文件都对应一种级联分类器，但有些级联分类器的功能是类似的（正面人脸识别分类器就有3个），表15.1是部分XML文件对应的功能，</p>
<p>​                                                                                       表15.1　部分级联分类器XML的功能</p>
<p><img src="/.com//image-20211128203757228.png" alt="image-20211128203757228"></p>
<p>想要实现哪种图像检测，就要在程序启动时加载对应的级联分类器。下一节将介绍如何加载并使用这些XML文件。</p>
<h3 id="15-1-2-方法"><a href="#15-1-2-方法" class="headerlink" title="15.1.2　方法"></a>15.1.2　方法</h3><p>OpenCV实现人脸检测需要做两步操作：加载级联分类器和使用分类器识别图像。这两步操作都有对应的方法。<br>首先是加载级联分类器，OpenCV通过CascadeClassifier()方法创建了分类器对象，其语法如下：</p>
<pre><code> &lt;CascadeClassifier object&gt; = cv2.CascadeClassifier(filename)
</code></pre>
<p>参数说明：　</p>
<p>filename：级联分类器的XML文件名。</p>
<p>返回值说明：　</p>
<p>object：分类器对象。<br>然后使用已经创建好的分类器对图像进行识别，这个过程需要调用分类器对象的detectMultiScale()方法，其语法如下：</p>
<pre><code> objects = cascade.detectMultiScale(image, scaleFactor, minNeighbors, flags, minSize, maxSize)
</code></pre>
<p>对象说明：　</p>
<p>cascade：已有的分类器对象。<br>参数说明：　</p>
<p>image：待分析的图像</p>
<p>scaleFactor：可选参数，扫描图像时的缩放比例。　</p>
<p>minNeighbors：可选参数，每个候选区域至少保留多少个检测结果才可以判定为人脸。该值越大，分析的误差越小。　</p>
<p>flags：可选参数，旧版本OpenCV的参数，建议使用默认值。　</p>
<p>minSize：可选参数，最小的目标尺寸。　</p>
<p>maxSize：可选参数，最大的目标尺寸。</p>
<p>返回值说明：　</p>
<p>objects：捕捉到的目标区域数组，数组中每一个元素都是一个目标区域，每一个目标区域都包含4个值，分别是：左上角点横坐标、左上角点纵坐标、区域宽、区域高。object的格式为：[[244　203　111　111]　[432　81　133　133]]。<br>下一节将介绍如何在程序中使用这2个方法。</p>
<h3 id="15-1-3-分析人脸位置"><a href="#15-1-3-分析人脸位置" class="headerlink" title="15.1.3　分析人脸位置"></a>15.1.3　分析人脸位置</h3><p>haarcascade_frontalface_default.xml是检测正面人脸的级联分类器文件，加载该文件就可以创建出追踪正面人脸的分类器，调用分类器对象的detectMultiScale()方法，得到的objects结果就是分析得出的人脸区域的坐标、宽和高。下面通过一个实例介绍如何实现此功能。【实例15.1】　在图像的人脸位置绘制红框。<br>将haarcascade_frontalface_default.xml文件放到项目根目录下的cascades文件夹中，加载此级联分类器之后，检测出所有可能是人脸的区域，通过for循环在这些区域上绘制红色边框，具体代码如下：</p>
<p><img src="/.com//image-20211128203902576.png" alt="image-20211128203902576"></p>
<p>上述代码的运行结果如图15.2所示。</p>
<p><img src="/.com//image-20211128203949284.png" alt="image-20211128203949284"></p>
<p>​                                                                                图15.2　检测出的人脸位置</p>
<p>【实例15.2】　戴墨镜特效。<br>手机拍照软件自带各种各样的贴图特效，实际上这些贴图特效就是先定位了人脸位置，然后在人脸相应位置覆盖素材实现的。OpenCV也可以实现此类功能，例如为人脸添加戴墨镜的特效，需要执行以下3个步骤：</p>
<p>（1）编写一个覆盖图片的overlay_img()方法。因为素材中可能包含透明像素，这些透明像素不可以遮挡人脸，所以在覆盖背景图像时要做判断，忽略所有透明像素。判断一个像素是否为透明像素，只需将图像从3通道转为4通道，判断第4通道的alpha值，alpha值为1表示完全不透明，0表示完全透明。<br>（2）创建人脸识别级联分类器，分析图像中人脸的区域。<br>（3）把墨镜图像按照人脸宽度进行缩放，并覆盖到人脸区域约1/3的位置。<br>实现以上功能的具体代码如下：</p>
<p><img src="/.com//image-20211128204015841.png" alt="image-20211128204015841"></p>
<p>上述代码的运行效果如图15.3所示。</p>
<p><img src="/.com//image-20211128204055080.png" alt="image-20211128204055080"></p>
<p>​                                                                                          图15.3　戴墨镜特效</p>
<h2 id="15-2-检测其他内容"><a href="#15-2-检测其他内容" class="headerlink" title="15.2　检测其他内容"></a>15.2　检测其他内容</h2><p>OpenCV提供的级联分类器除了可以识别人脸以外，还可以识别一些其他具有明显特征的物体，如眼睛、行人等。本节将介绍几个OpenCV自带的级联分类器的用法。</p>
<h3 id="15-2-1-眼睛检测"><a href="#15-2-1-眼睛检测" class="headerlink" title="15.2.1　眼睛检测"></a>15.2.1　眼睛检测</h3><p>haarcascade_eye.xml是检测眼睛的级联分类器文件，加载该文件就可以追踪眼睛的分类器，下面通过一个实例来介绍如何实现此功能。【实例15.3】　在图像的眼睛位置绘制红框。<br>将haarcascade_eye.xml文件放到项目根目录下的cascades文件夹中，加载此级联分类器之后，检测出所有可能是眼睛的区域，通过for循环在这些区域上绘制红色边框，具体代码如下：</p>
<p><img src="/.com//image-20211128204131328.png" alt="image-20211128204131328"></p>
<p>上述代码的运行结果如图15.4所示。</p>
<p><img src="/.com//image-20211128204151205.png" alt="image-20211128204151205"></p>
<p>​                                                                                      图15.4　检测出的眼睛位置</p>
<h3 id="15-2-2-猫脸检测"><a href="#15-2-2-猫脸检测" class="headerlink" title="15.2.2　猫脸检测"></a>15.2.2　猫脸检测</h3><p>OpenCV还提供了2个训练好的检测猫脸的级联分类器，分别是haarcascade_frontalcatface.xml和haarcascade_frontalcatface_extended.xml，前者的判断标准比较高，较为精确，但可能有些猫脸识别不出来；后者的判断标准比较低，只要类似猫脸就会被认为是猫脸。使用猫脸分类器不仅可以判断猫脸的位置，还可以识别图像中有几只猫。<br>下面通过一个实例来介绍如何实现此功能。</p>
<p>【实例15.4】　在图像里找到猫脸的位置。<br>为了得到比较理想的检测结果，建议使用haarcascade_frontalcatface_extended.xml。将haarcascade_frontalcatface_extended.xml文件放到项目根目录下的cascades文件夹中，加载此级联分类器之后，检测出所有可能是猫脸的区域，通过for循环在这些区域上绘制红色边框，具体代码如下：</p>
<p><img src="/.com//image-20211128204247078.png" alt="image-20211128204247078"></p>
<p>上述代码的运行结果如图15.5所示。</p>
<p><img src="/.com//image-20211128204308682.png" alt="image-20211128204308682"></p>
<p>​                                                                                         图15.5　检测出猫脸的位置</p>
<h3 id="15-2-3-行人检测"><a href="#15-2-3-行人检测" class="headerlink" title="15.2.3　行人检测"></a>15.2.3　行人检测</h3><p>haarcascade_fullbody.xml是检测人体（正面直立全身或背面直立全身）的级联分类器文件，加载该文件就可以追踪人体的分类器，下面通过一个实例介绍如何实现此功能。</p>
<p>【实例15.5】　在图像中找到行人的位置。</p>
<p>将haarcascade_fullbody.xml文件放到项目根目录下的cascades文件夹中，加载此级联分类器之后，检测出所有可能是人形的区域，通过for循环在这些区域上绘制红色边框，具体代码如下：</p>
<p><img src="/.com//image-20211128204421178.png" alt="image-20211128204421178"></p>
<p>上述代码的运行结果如图15.6所示。</p>
<p><img src="/.com//image-20211128204440594.png" alt="image-20211128204440594"></p>
<p>​                                                                                         图15.6　检测出的行人位置</p>
<h3 id="15-2-4-车牌检测"><a href="#15-2-4-车牌检测" class="headerlink" title="15.2.4　车牌检测"></a>15.2.4　车牌检测</h3><p>haarcascade_russian_plate_number.xml是检测汽车车牌的级联分类器文件，加载该文件就可以追踪图像中的车牌，下面通过一个实例来介绍如何实现此功能。</p>
<p>【实例15.6】　标记图像中车牌的位置。<br>将haarcascade_russian_plate_number.xml文件放到项目根目录下的cascades文件夹中，加载此级联分类器之后，检测出所有可能是车牌的区域，通过for循环在这些区域上绘制红色边框，具体代码如下：</p>
<p><img src="/.com//image-20211128204518734.png" alt="image-20211128204518734"></p>
<p>上述代码的运行结果如图15.7所示。</p>
<p><img src="/.com//image-20211128204601073.png" alt="image-20211128204601073"></p>
<p>​                                                                                      图15.7　检测出的车牌位置</p>
<h2 id="15-3-人脸识别"><a href="#15-3-人脸识别" class="headerlink" title="15.3　人脸识别"></a>15.3　人脸识别</h2><p>OpenCV提供了3种人脸识别方法，分别是Eigenfaces、Fisherfaces和LBPH。这3种方法都是通过对比样本的特征最终实现人脸识别。因为这3种算法提取特征的方式不一样，侧重点不同，所以不能分出孰优孰劣，只能说每种方法都有各自的识别风格。<br>OpenCV为每一种人脸识别方法都提供了创建识别器、训练识别器和识别3种方法，这3种方法的语法非常相似。本节将简单介绍如何使用这些方法。</p>
<h3 id="15-3-1-Eigenfaces人脸识别器"><a href="#15-3-1-Eigenfaces人脸识别器" class="headerlink" title="15.3.1　Eigenfaces人脸识别器"></a>15.3.1　Eigenfaces人脸识别器</h3><p>Eigenfaces也叫作“特征脸”。Eigenfaces通过PCA（主成分分析）方法将人脸数据转换到另外一个空间维度做相似性计算。在计算过程中，算法可以忽略一些无关紧要的数据，仅识别一些具有代表性的特征数据，最后根据这些特征识别人脸。<br>开发者需要通过以下3种方法完成人脸识别操作。<br>（1）通过cv2.face.EigenFaceRecognizer_create()方法创建Eigenfaces人脸识别器，其语法如下：</p>
<pre><code> recognizer = cv2.face.EigenFaceRecognizer_create(num_components, threshold)
</code></pre>
<p>参数说明：　</p>
<p>num_components：可选参数，PCA方法中保留的分量个数，建议使用默认值。　</p>
<p>threshold：可选参数，人脸识别时使用的阈值，建议使用默认值。</p>
<p>返回值说明：　</p>
<p>recognizer：创建的Eigenfaces人脸识别器对象。</p>
<p>（2）创建识别器对象后，需要通过对象的train()方法训练识别器。建议每个人都给出2幅以上的人脸图像作为训练样本。train()方法的语法如下：</p>
<pre><code> recognizer.train(src, labels)
</code></pre>
<p>对象说明：　</p>
<p>recognizer：已有的Eigenfaces人脸识别器对象。<br>参数说明：　</p>
<p>src：用来训练的人脸图像样本列表，格式为list。样本图像必须宽、高一致。　</p>
<p>labels：样本对应的标签，格式为数组，元素类型为整数。数组长度必须与样本列表长度相同。样本与标签按照插入顺序一一对应。<br>（3）训练识别器后可以通过识别器的predict()方法识别人脸，该方法对比样本的特征，给出最相近的结果和评分，其语法如下：</p>
<pre><code> label, confidence = recognizer.predict(src)
</code></pre>
<p>对象说明：　</p>
<p>recognizer：已有的Eigenfaces人脸识别器对象。<br>参数说明：　</p>
<p>src：需要识别的人脸图像，该图像宽、高必须与样本一致。<br>返回值说明：　</p>
<p>label：与样本匹配程度最高的标签值。　</p>
<p>confidence：匹配程度最高的信用度评分。评分小于5000匹配程度较高，0分表示2幅图像完全一样。<br>下面通过一个实例来演示Eigenfaces人脸识别器的用法。</p>
<p>【实例15.7】　使用Eigenfaces识别人脸。<br>现以两个人的照片作为训练样本，第一个人的照片如图15.8～图15.10所示，第二个人的照片如图15.11～图15.13所示。</p>
<p><img src="/.com//image-20211128204741974.png" alt="image-20211128204741974"></p>
<p>​                                                                                           图15.8　Summer 1</p>
<p><img src="/.com//image-20211128204805362.png" alt="image-20211128204805362"></p>
<p>​                                                                                                      图15.9　Summer 2</p>
<p><img src="/.com//image-20211128204824476.png" alt="image-20211128204824476"></p>
<p>​                                                                                                图15.10　Summer 3</p>
<p><img src="/.com//image-20211128204847564.png" alt="image-20211128204847564"></p>
<p>​                                                                                                       图15.11　Elvis 1</p>
<p><img src="/.com//image-20211128204943018.png" alt="image-20211128204943018"></p>
<p>​                                                                                                 图15.12　Elvis 2</p>
<p><img src="/.com//image-20211128205000900.png" alt="image-20211128205000900"></p>
<p>​                                                                                                     图15.13　Elvis 3<br>待识别的照片如图15.14所示。</p>
<p><img src="/.com//image-20211128205024760.png" alt="image-20211128205024760"></p>
<p>​                                                                                                图15.14　待识别照片<br>创建Eigenfaces人脸识别器对象，训练以上样本后，判断图15.13所示是哪一个人，具体代码如下：</p>
<p><img src="/.com//image-20211128205102240.png" alt="image-20211128205102240"></p>
<p>上述代码的运行结果如下：</p>
<pre><code> confidence = 18669.728291380223
 Summer
</code></pre>
<p>程序对比样本特征分析得出，被识别的人物特征最接近的是Summer。</p>
<h3 id="15-3-2-Fisherfaces人脸识别器"><a href="#15-3-2-Fisherfaces人脸识别器" class="headerlink" title="15.3.2　Fisherfaces人脸识别器"></a>15.3.2　Fisherfaces人脸识别器</h3><p>Fisherfaces是由Ronald Fisher最早提出的，这也是Fisherfaces名字的由来。Fisherfaces通过LDA（线性判别分析技术）方法将人脸数据转换到另外一个空间维度做投影计算，最后根据不同人脸数据的投影距离判断其相似度。<br>开发者需要通过以下3种方法完成人脸识别操作。<br>（1）通过cv2.face.FisherFaceRecognizer_create()方法创建Fisherfaces人脸识别器，其语法如下：</p>
<pre><code> recognizer = cv2.face.FisherFaceRecognizer_create(num_components, threshold)
</code></pre>
<p>参数说明：　</p>
<p>num_components：可选参数，通过Fisherface方法进行判断分析时保留的分量个数，建议使用默认值。　</p>
<p>threshold：可选参数，人脸识别时使用的阈值，建议使用默认值。</p>
<p>返回值说明：　</p>
<p>recognizer：创建的Fisherfaces人脸识别器对象。<br>（2）创建识别器对象后，需通过对象的train()方法训练识别器。建议每个人都给出2幅以上的人脸图像作为训练样本。train()方法的语法如下：</p>
<pre><code> recognizer.train(src, labels)
</code></pre>
<p>对象说明：　</p>
<p>recognizer：已有的Fisherfaces人脸识别器对象。</p>
<p>参数说明：　</p>
<p>src：用来训练的人脸图像样本列表，格式为list。样本图像必须宽、高一致。　</p>
<p>labels：样本对应的标签，格式为数组，元素类型为整数。数组长度必须与样本列表长度相同。样本与标签按照插入顺序一一对应。</p>
<p>（3）训练识别器后可以通过识别器的predict()方法识别人脸，该方法对比样本的特征，给出最相近的结果和评分，其语法如下：</p>
<pre><code> label, confidence = recognizer.predict(src)
</code></pre>
<p>对象说明：　</p>
<p>recognizer：已有的Fisherfaces人脸识别器对象。</p>
<p>参数说明：　</p>
<p>src：需要识别的人脸图像，该图像宽、高必须与样本一致。<br>返回值说明：　</p>
<p>label：与样本匹配程度最高的标签值。　</p>
<p>confidence：匹配程度最高的信用度评分。评分小于5000程度较高，0分表示2幅图像完全一样。</p>
<p>下面通过一个实例演示Fisherfaces人脸识别器的用法。</p>
<p>【实例15.8】　使用Fisherfaces识别人脸。<br>现以2个人的照片作为训练样本，第一个人的照片如图15.15～图15.17所示，第二个人的照片如图15.18～图15.20所示。</p>
<p><img src="/.com//image-20211128205304341.png" alt="image-20211128205304341"></p>
<p>​                                                                                               图15.15　Mike 1</p>
<p><img src="/.com//image-20211128205346389.png" alt="image-20211128205346389"></p>
<p>​                                                                                                 图15.16　Mike 2</p>
<p><img src="/.com//image-20211128205403358.png" alt="image-20211128205403358"></p>
<p>​                                                                                                 图15.17　Mike 3</p>
<p><img src="/.com//image-20211128205425662.png" alt="image-20211128205425662"></p>
<p>​                                                                                             图15.18　KaiKai 1</p>
<p><img src="/.com//image-20211128205446503.png" alt="image-20211128205446503"></p>
<p>​                                                                                                  图15.19　KaiKai 2</p>
<p><img src="/.com//image-20211128205509193.png" alt="image-20211128205509193"></p>
<p>​                                                                                                图15.20　KaiKai 3<br>待识别的照片如图15.21所示。</p>
<p><img src="/.com//image-20211128205529188.png" alt="image-20211128205529188"></p>
<p>​                                                                                                    图15.21　待识别照片</p>
<p>创建Fisherfaces人脸识别器对象，训练以上样本后，判断图15.21是哪一个人，具体代码如下：</p>
<p><img src="/.com//image-20211128205614870.png" alt="image-20211128205614870"></p>
<p>上述代码的运行结果如下：</p>
<pre><code> confidence = 2327.170867892041
 Mike
</code></pre>
<p>程序对比样本特征分析得出，被识别的人物特征最接近的是KaiKai。</p>
<h3 id="15-3-3-Local-Binary-Pattern-Histogram人脸识别器"><a href="#15-3-3-Local-Binary-Pattern-Histogram人脸识别器" class="headerlink" title="15.3.3　Local Binary Pattern Histogram人脸识别器"></a>15.3.3　Local Binary Pattern Histogram人脸识别器</h3><p>Local Binary Pattern Histogram简称LBPH，即局部二进制模式直方图，这是一种基于局部二进制模式算法，这种算法善于捕获局部纹理特征。<br>开发者需要通过以下3种方法来完成人脸识别操作。</p>
<p>（1）通过cv2.face. LBPHFaceRecognizer_create()方法创建LBPH人脸识别器，其语法如下：</p>
<pre><code> recognizer = cv2.face.LBPHFaceRecognizer_create(radius, neighbors, grid_x, grid_y, threshold)
</code></pre>
<p>参数说明：　</p>
<p>radius：可选参数，圆形局部二进制模式的半径，建议使用默认值。　</p>
<p>neighbors：可选参数，圆形局部二进制模式的采样点数目，建议使用默认值。</p>
<p>grid_x：可选参数，水平方向上的单元格数，建议使用默认值。　</p>
<p>grid_y：可选参数，垂直方向上的单元格数，建议使用默认值。　</p>
<p>threshold：可选参数，人脸识别时使用的阈值，建议使用默认值。</p>
<p>（2）创建识别器对象后，需要通过对象的train()方法训练识别器。建议每个人都给出2幅以上的人脸图像作为训练样本。train()方法的语法如下：</p>
<pre><code> recognizer.train(src, labels)
</code></pre>
<p>对象说明：　</p>
<p>recognizer：已有的LBPH人脸识别器对象。</p>
<p>参数说明：　</p>
<p>src：用来训练的人脸图像样本列表，格式为list。样本图像必须宽、高一致。</p>
<p>labels：样本对应的标签，格式为数组，元素类型为整数。数组长度必须与样本列表长度相同。样本与标签按照插入顺序一一对应。</p>
<p>（3）训练识别器后就可以通过识别器的predict()方法识别人脸，该方法对比样本的特征，给出最相近的结果和评分，其语法如下：</p>
<pre><code> label, confidence = recognizer.predict(src)
</code></pre>
<p>对象说明：　</p>
<p>recognizer：已有的LBPH人脸识别器对象。</p>
<p>参数说明：　</p>
<p>src：需要识别的人脸图像，该图像宽、高必须与样本一致。</p>
<p>返回值说明：　</p>
<p>label：与样本匹配程度最高的标签值。　</p>
<p>confidence：匹配程度最高的信用度评分。评分小于50匹配程度较高，0分表示2幅图像完全一样。<br>下面通过一个实例来演示LBPH人脸识别器的用法。</p>
<p>【实例15.9】　使用LBPH识别人脸。<br>现以2个人的照片作为训练样本，第一个人的照片如图15.22～图15.24所示，第二个人的照片如图15.25～图15.27所示。</p>
<p><img src="/.com//image-20211128205807097.png" alt="image-20211128205807097"></p>
<p>​                                                                                                      图15.22　lxe 1</p>
<p><img src="/.com//image-20211128205827725.png" alt="image-20211128205827725"></p>
<p>​                                                                                               图15.23　lxe 2</p>
<p><img src="/.com//image-20211128205853204.png" alt="image-20211128205853204"></p>
<p>​                                                                                                  图15.24　lxe 3</p>
<p><img src="/.com//image-20211128205910674.png" alt="image-20211128205910674"></p>
<p>​                                                                                                   图15.25　RuiRui 1</p>
<p><img src="/.com//image-20211128205956685.png" alt="image-20211128205956685"></p>
<p>​                                                                                                   图15.26　RuiRui 2</p>
<p><img src="/.com//image-20211128210013982.png" alt="image-20211128210013982"></p>
<p>​                                                                                                 图15.27　RuiRui 3<br>待识别的照片如图15.28所示。</p>
<p><img src="/.com//image-20211128210039659.png" alt="image-20211128210039659"></p>
<p>​                                                                                                图15.28　待识别照片<br>创建LBPH人脸识别器对象，训练以上样本之后，判断图15.27是哪一个人，具体代码如下：</p>
<p><img src="/.com//image-20211128210105190.png" alt="image-20211128210105190"></p>
<p>上述代码的运行结果如下：</p>
<pre><code> confidence = 45.082326535640014
 RuiRui
</code></pre>
<p>程序对比样本特征分析得出，被识别的人物特征最接近的是RuiRui。</p>
<h2 id="15-4-小结"><a href="#15-4-小结" class="headerlink" title="15.4　小结"></a>15.4　小结</h2><p>人脸检测和人脸识别是相辅相成的，这是因为在进行人脸识别前，要先判断当前图像内是否出现了人脸，这个判断过程需要由人脸检测完成。只有在当前图像内检测到人脸，才能判断出这张人脸属于哪个人，这个判断是由人脸识别器完成的。因此，人脸识别指的是程序先在图像内检测人脸，再识别这张人脸属于哪个人的过程。本章讲解了3种人脸识别器，读者要熟练掌握这3种人脸识别器的实现方法和实现原理。</p>
<h1 id="第16章-MR智能视频打卡系统"><a href="#第16章-MR智能视频打卡系统" class="headerlink" title="第16章　MR智能视频打卡系统"></a>第16章　MR智能视频打卡系统</h1><p>很多公司都使用打卡机或打卡软件进行考勤。传统的打卡方式包括点名、签字、刷卡和指纹等。随着技术的不断发展，计算机视觉技术越来越强大，已经可以实现人脸打卡功能。打卡软件通过摄像头扫描人脸特征，利用人脸的差异识别人员。人脸打卡的准确性不输于指纹打卡，甚至安全性和便捷性都高于指纹打卡。本章将介绍一个由Python OpenCV开发的智能视频打卡系统。</p>
<p><img src="/.com//image-20211128210226814.png" alt="image-20211128210226814"></p>
<h2 id="16-1-需求分析"><a href="#16-1-需求分析" class="headerlink" title="16.1　需求分析"></a>16.1　需求分析</h2><p>打卡系统有3个核心功能：录入打卡人的资料、员工打卡和查看打卡记录，在满足核心功能的基础上需要完善一些附加功能和功能细节。在开发MR智能视频打卡系统前，先对本系统的一些需求进行如下拆解和分析。</p>
<p>1．数据模型</p>
<p>本系统不使用第三方数据库，所有数据都以文本的形式保存在文件中，因此要规范数据内容和格式，建立统一模型。<br>若把软件的使用者设定为“公司”，那么打卡者身份可设定为“员工”，程序中数据模型就应该是员工数据类。<br>每一位员工都有姓名，“姓名”就作为员工类中必备的数据之一。<br>因为员工可能会重名，所以必须使用另一种标记作为员工身份的认证，即为每一位员工添加不重复的员工编号。员工编号的格式为从1开始递增数字，每添加一位新员工，员工编号就+1。员工类中添加“员工编号”。<br>系统中必须保存所有员工的照片用于人脸识别。为了区分每位员工的照片文件，程序使用“员工特征码+随机值.png”的规则为照片文件命名。如果使用员工编号作为特征码，1号员工和11号员工的文件名容易发生混淆，所以特征码不能使用员工编号，而是一种长度一致、复杂性高、不重复的字符串。员工类中添加“特征码”。<br>员工与编号、姓名、特征码是一对一的关系，但员工与打卡记录是一对多的关系，所以打卡记录可以放在员工类中保存，而不是单独保存在打卡记录模型中。打卡记录需要记录每一位员工的具体打卡时间，并能以报表的形式体现。可以使用字段保存打卡记录模型，员工姓名作为key，该员工的打卡记录列表作为value。</p>
<p>2．打卡功能</p>
<p>人脸打卡依赖于人脸识别功能。本程序可以使用OpenCV提供的人脸识别器实现此功能，建议使用正确率较高的LBPH识别器，其他识别器也可以考虑，但需要做好测试验证。<br>系统通过拍照保存员工的照片样本。当员工面对摄像头时，按Enter键就可以生成一张正面特写照片文件。为了增加识别准确率，每位员工应拍3张照片，也就是按3次Enter键才能完成录入操作。<br>OpenCV提供的人脸识别器有一个缺陷：必须比对2种不同样本才能进行判断。如果公司第一次使用打卡系统，系统中没有录入任何员工，缺少比对样本，OpenCV提供的人脸识别器就会报错。因此本系统应该给出几个无人脸的默认样本，保证即使只录入一个员工，该员工也能顺利打卡。</p>
<p>每次员工打卡成功后，都应该记录该员工的打卡时间，然后保存到文件中。</p>
<p>3．数据维护</p>
<p>数据维护总结起来就是增、删、改、查4种操作。简化版的打卡系统可以忽略“改”的操作，由先删除，再新增的方式代替。<br>本系统除了提供录入新员工的功能之外，也提供删除已有员工的功能。删除员工之前应输入验证码进行验证，以防用户操作失误，误删重要数据。确认执行删除操作后，不仅要删除员工的信息，也要同时删除员工的打卡记录和照片文件。完成删除操作后，所有数据文件中不再存有被删员工的任何数据。</p>
<p>4．考勤报表</p>
<p>每个公司的考勤制度都不同，很多公司都主动设置“上班时间”和“下班时间”来做考勤的标准。员工要在“上班时间”之前打卡才算正常到岗，在“下班时间”之后打卡才算正常离岗。未在规定时间内打卡的情况属于“打卡异常”，“打卡异常”通常分为3种情况：迟到、早退或缺席（或缺勤）。<br>本系统分析每一位员工在某一天的打卡记录，如果该员工在“上班时间”前和“下班时间”后都有打卡记录，则认为该员工当天全勤，该员工当天的其他打卡记录会被忽略。但如果该员工在“上班时间”前未能打卡，而是在“上班时间”后到中午12点前打卡，这种情况被视为迟到。如果该员工在“下班时间”后未能打卡，而是在中午12点之后到“下班时间”前打卡，这种情况被视为早退。当天没有打卡记录被视为缺席。</p>
<h2 id="16-2-系统设计"><a href="#16-2-系统设计" class="headerlink" title="16.2　系统设计"></a>16.2　系统设计</h2><h3 id="16-2-1-开发环境"><a href="#16-2-1-开发环境" class="headerlink" title="16.2.1　开发环境"></a>16.2.1　开发环境</h3><p>本系统开发使用的环境如下：<br>Python版本：3.8.2<br>OpenCV版本：4.2.0<br>numpy版本：1.18.1</p>
<p>IED：PyCharm 2019.3.3 (Community Edition)<br>操作系统：Windows 7/Windows 10</p>
<h3 id="16-2-2-功能结构"><a href="#16-2-2-功能结构" class="headerlink" title="16.2.2　功能结构"></a>16.2.2　功能结构</h3><p>MR智能视频打卡系统的功能结构如图16.1所示。</p>
<p><img src="/.com//image-20211128210408201.png" alt="image-20211128210408201"></p>
<p>​                                                                                                 图16.1　功能结构</p>
<h3 id="16-2-3-业务流程"><a href="#16-2-3-业务流程" class="headerlink" title="16.2.3　业务流程"></a>16.2.3　业务流程</h3><p>MR智能视频打卡系统的总体业务流程如图16.2所示。</p>
<p><img src="/.com//image-20211128210435530.png" alt="image-20211128210435530"></p>
<p>​                                                                                                   图16.2　总体业务流程<br>打卡功能业务流程如图16.3所示。<br>查看记录功能业务流程如图16.4所示。</p>
<p><img src="/.com//image-20211128210456043.png" alt="image-20211128210456043"></p>
<p>​                                                                                   图16.3　打卡功能的业务流程</p>
<p><img src="/.com//image-20211128210539359.png" alt="image-20211128210539359"></p>
<p>​                                                                                   图16.4　查看记录功能的业务流程<br>员工管理功能业务流程如图16.5所示。</p>
<p><img src="/.com//image-20211128210604201.png" alt="image-20211128210604201"></p>
<p>​                                                                             图16.5　员工管理功能的业务流程<br>考勤报表功能业务流程如图16.6所示。</p>
<p><img src="/.com//image-20211128210648098.png" alt="image-20211128210648098"></p>
<p>​                                                                                 图16.6　考勤报表功能的业务流程<br>员工管理、查看记录和考勤报表这3个功能中都涉及权限管理业务。如果用户要使用这3个功能，需要登录管理员账号，只有登录成功后才有权使用。权限管理业务流程如图16.7所示。</p>
<p><img src="/.com//image-20211128210720411.png" alt="image-20211128210720411"></p>
<p>​                                                                                    图16.7　权限管理业务流程</p>
<h3 id="16-2-4-项目结构"><a href="#16-2-4-项目结构" class="headerlink" title="16.2.4　项目结构"></a>16.2.4　项目结构</h3><p>MR智能视频打卡系统的项目结构如下：</p>
<p><img src="/.com//image-20211128210741943.png" alt="image-20211128210741943"></p>
<h2 id="16-3-文件系统设计"><a href="#16-3-文件系统设计" class="headerlink" title="16.3　文件系统设计"></a>16.3　文件系统设计</h2><p>本程序没有使用任何数据库保存数据，而是采用直接读写文件的方式来保存数据。项目中的所有数据文件都保存在data文件夹中。<br>程序使用的数据文件及文件夹信息如表16.1所示。</p>
<p>​                                                                       表16.1　程序使用的数据文件及文件夹信息</p>
<p><img src="/.com//image-20211128210902635.png" alt="image-20211128210902635"></p>
<p>下面详细介绍每种数据文件的内容格式。<br>（1）employee_data.txt文件以字符串的形式保存所有员工的数据，数据之间用英文逗号隔开，一行保存一个员工。其格式如下：</p>
<pre><code> 编号1,姓名1,特征码1
 编号2,姓名2,特征码2
 ...
</code></pre>
<p>例如，employee_data.txt文件保存的实际内容可能如下：</p>
<pre><code> 1,张三,526380
 2,李四,571096
 3,王五,381609
</code></pre>
<p>（2）lock_record.txt文件以字符串的形式保存数据，数据格式为打卡记录字典的字符串内容，其格式如下：</p>
<pre><code> &#123;姓名a: [日期list], 姓名b: [日期list], ... , 姓名n：[日期list]&#125;
</code></pre>
<p>例如，lock_record.txt文件保存的实际内容可能如下：</p>
<p>{‘张三’: [‘2020-04-15 14:59:54’], ‘李四’: [‘2020-04-15 15:02:08’], ‘王五’: [‘2020-04-15 15:11:02’, ‘2020-04-15<br>     15:35:49’]}<br>（3）work_time.txt文件以字符串的形式保存数据，其格式如下：</p>
<pre><code> 08:00:00/16:00:00
</code></pre>
<p>前一个时间为上班时间，后一个时间为下班时间，格式均为%H:%M:%S。系统以这2个时间为标准判断员工是否出现迟到、早退。<br>（4）user_password.txt文件以字符串的形式保存数据，数据格式为管理员账号密码字典的字符串内容，其格式如下：</p>
<pre><code> &#123;管理员账号:管理员密码&#125;
</code></pre>
<p>例如，user_password.txt文件保存的实际内容可能如下：</p>
<pre><code> &#123;&#39;mr&#39;: &#39;mrsoft&#39;, &#39;123456&#39;: &#39;123456&#39;&#125;
</code></pre>
<p>用户可以在这个文件中手动修改管理员账号和密码。<br>（5）/data/face/文件夹下保存的是所有员工的照片文件，格式为PNG。每张照片的大小都是640×480。每名员工需保存3张照片。<br>该文件夹下还有2个默认的图像文件，文件名分别为1000000000.png和2000000000.png。这是2幅纯色图像，用于辅助训练人脸识别器。<br>人脸识别器使用样本进行训练时，至少要有2个以上的标签分类。如果程序中仅保存了一位员工的照片，人脸识别器无法拿此员工照片与其他样本做对比，人脸识别器就会报错，此时2幅默认图像文件就充当了对比样本，以防止人脸识别器无法完成训练。当程序录入了足够多的员工信息后，这2幅默认图像虽然丧失了功能，但也不会影响识别器的识别能力。</p>
<h2 id="16-4-数据实体模块设计"><a href="#16-4-数据实体模块设计" class="headerlink" title="16.4　数据实体模块设计"></a>16.4　数据实体模块设计</h2><p>entity包下的organizations.py文件用于封装数据模型。该文件中设计了员工类，并提供一些维护数据的方法。接下来将详细介绍organizations.py中的代码。</p>
<p>1．构建员工类<br>创建Employee类作为员工类，并创建包含3个参数的构造方法。3个参数分别是员工编号、员工姓名和员工特征码。员工类将作为系统的最重要的数据模型，以对象的方式保存每一位员工的信息。<br>员工类的代码如下（代码位置：资源包\TM\sl\16\clock\entity\organizations.py）：</p>
<p><img src="/.com//image-20211128211042060.png" alt="image-20211128211042060"></p>
<p>2．全局变量<br>organizations.py中的全局变量较多，主要用来当作系统缓存保存所有数据。这些全局代码包括：　</p>
<p>LOCK_RECORD　实时保存员工的打卡记录。　</p>
<p>EMPLOYEES　实时保存所有员工信息。　</p>
<p>MAX_ID　记录当前最大ID，可在录入新员工时，为新员工分配新ID。　</p>
<p>CODE_LEN　开发者可以通过修改CODE_LEN的值来控制员工特征码的长度，默认长度为6位。　</p>
<p>WORK_TIME　上班时间，用来判断员工打卡情况。程序启动时由IO流模块为其赋值。　</p>
<p>CLOSING_TIME　下班时间，功能同WORK_TIME。　</p>
<p>USERS　系统所有管理员的账号和密码字典，用于校验用户输入的管理员账号和密码。</p>
<p>这些全局代码如下</p>
<p><img src="/.com//image-20211128211155281.png" alt="image-20211128211155281"></p>
<p>3．增删员工<br>organizations.py提供了添加新员工和删除员工的方法，其他模块需要调用这些方法来进行增删操作，不应直接修改EMPLOYEES列表中的数据。<br>add()方法用于向组织中增加新员工，因为不需要对数据做校验，所以方法中的代码非常少。该方法代码如下：</p>
<pre><code> # 添加新员工
 def add(e: Employee):
     EMPLOYEES.append(e)
</code></pre>
<p>remove()方法用于删除组织中的员工，参数为员工编号。方法遍历员工列表，找到该员工之后，将该员工删除，如果该员工有过打卡记录，同时将其打卡记录删除，该方法代码如下：</p>
<p><img src="/.com//image-20211128211222751.png" alt="image-20211128211222751"></p>
<p>4．分配ID<br>员工编号是员工的唯一标识，有新员工加入时，应为其分配最新编号。<br>get_new_id()方法用于生成新员工编号，其生成规则为“当前最大的员工编号+1”，这样可以保证所有编号都不重复，该方法代码如下）：</p>
<p><img src="/.com//image-20211128211305025.png" alt="image-20211128211305025"></p>
<h2 id="16-5-工具模块设计"><a href="#16-5-工具模块设计" class="headerlink" title="16.5　工具模块设计"></a>16.5　工具模块设计</h2><p>本系统的工具模块包含3个文件：public_tools.py、io_tools.py和camera.py。本节将详细介绍这3个文件中的代码。</p>
<h3 id="16-5-1-公共工具模块"><a href="#16-5-1-公共工具模块" class="headerlink" title="16.5.1　公共工具模块"></a>16.5.1　公共工具模块</h3><p>uitl文件夹下的public_tools.py就是本程序的公共工具模块，该模块提供了以下功能。　生成随机数和随机特征码。　校验时间字符串格式。<br>下面详细介绍public_tools.py中的代码。</p>
<p>1．导入模块<br>公共工具涉及随机数和日期格式，所以导入random和datetime两个服务模块。生成随机特征码需要通过organizations.py获取特征码长度，所以也要导入数据实体模块，代码如下：</p>
<pre><code> import random
 import datetime
 from entity import organizations as o2．生成随机数
</code></pre>
<p>特征码、照片文件名和验证码都用到了随机数，公共工具模块提供了一个生成指定位数数字的randomNumber()方法，其参数就是数字的位数。例如，参数为4，生成的参数就是4位数，且不会以0开头。该方法最后返回的是字符串类。<br>randomNumber()方法的具体代码如下：</p>
<p><img src="/.com//image-20211128211436263.png" alt="image-20211128211436263"></p>
<p>特征码实际上是长度固定的随机码，特征码的程度保存在数据实体模块的CODE_LEN变量中，可以直接调用randomNumber(CODE_LEN)创建特征码。特征码最好保持6位以上，这样才能降低特征码重复的概率。<br>randomCode()就是生成特征码的方法，该方法代码如下# 随机生成与特征码长度相等的数字<br>     def randomCode():<br>         return randomNumber(o.CODE_LEN)  # 特征码的长度</p>
<p>3．校验时间格式</p>
<p><img src="/.com//image-20211128211533748.png" alt="image-20211128211533748"></p>
<h3 id="16-5-2-IO流模块"><a href="#16-5-2-IO流模块" class="headerlink" title="16.5.2　IO流模块"></a>16.5.2　IO流模块</h3><p>uitl文件夹下的io_tools.py是本程序的IO流工具模块，该模块提供了以下功能。　</p>
<p>封装所有对文件的读写操作，包括加载员工信息、加载打卡记录、加载照片文件、删除员工信息、删除打卡记录等。　文件自检功能。　创建CSV文件。<br>下面详细介绍io_tools.py中的代码。</p>
<p>1．导入模块<br>IO流工具将文件中的数据保存到数据实体模块中，需导入os模块和organizations.py文件。因为删除图片需要员工特征码，所以需要人事服务模块提供相关功能，代码如下：</p>
<pre><code> from service import hr_service as hr
 from entity import organizations as o
 from service import recognize_service as rs
 import os
 import cv2
 import numpy as np
</code></pre>
<p>2．全局变量<br>全局变量中保存了各个数据文件配置，包含文件路径、文件名和照片的宽和高。这里使用了os模块提供的os.getcwd()方法来获取项目根目录。全局变量的代码如下（代码位置：资源包\TM\sl\16\clock\util\io_tools.py）：</p>
<p><img src="/.com//image-20211128211636692.png" alt="image-20211128211636692"></p>
<p>3．文件自检方法<br>为了防止用户误删数据文件而导致程序无法正常运行，公共工具模块提供了checking_data_files()文件自检方法。该方法在程序启动时执行，然后自动检查所有数据文件的状态，如果发现丢失文件（或文件夹），就会自动创建新的空数据文件（或文件夹）。该方法代码如下（代码位置：资源包\TM\sl\16\clock\util\io_tools.py）：</p>
<p><img src="/.com//image-20211128211707043.png" alt="image-20211128211707043"></p>
<p>4．从文件中加载数据。</p>
<p>本系统中的所有数据都保存在文本文件中，当程序启动时，需要加载所有数据，包括员工信息、员工打卡记录和员工照片。这3类数据都有各自的加载方法。<br>load_employee_info()是加载员工信息的方法，该方法读取全局变量指定的员工信息文件，将文件中的内容逐行读取，然后通过英文逗号分隔，根据分隔出的数据创建员工对象，最后把员工对象保存在员工列表中。这样就完成了员工信息的加载。<br>在读取员工数据的同时，该方法也会记录出现过的最大员工编号，并将最大员工编号赋值给数据实体模块。<br>load_employee_info()方法的具体代码如下（代码位置：资源包\TM\sl\16\clock\util\io_tools.py）：</p>
<p><img src="/.com//image-20211128211741820.png" alt="image-20211128211741820"></p>
<p>load_lock_record()是加载员工打卡记录的方法。该方法读取全局变量指定的打卡记录文件，因为文件保存的是打卡记录字典的字符串内容，所以直接将文件中所有文本读出，然后转换成字典类型，最后将转换后的字典对象直接赋值数据实体模块即可。<br>load_lock_record()方法的具体代码如下（代码位置：资源包\TM\sl\16\clock\util\io_tools.py）：</p>
<p><img src="/.com//image-20211128211758371.png" alt="image-20211128211758371"></p>
<p>load_employee_pic()是加载员工照片文件的方法，该方法首先遍历全局变量指定的照片文件夹，读取每一张照片文件并封装成OpenCV中的图像对象，然后从文件名中截取特征码，将特征码作为人脸识别的标签，最后将图像、标签统一提交人脸识别器进行训练。load_employee_pic()方法的具体代码如下（代码位置：资源包\TM\sl\16\clock\util\io_tools.py）：</p>
<p><img src="/.com//image-20211128211819740.png" alt="image-20211128211819740"></p>
<p>load_work_time_config()是上下班时间配置文件的方法。因为配置文件中保存的数据格式非常简单，所以该方法直接将文件中所有内容读取出来，按照“/”字符截取，并将截取的数据赋值数据实体的全局变量。<br>load_work_time_config()方法的具体代码如下（代码位置：资源包\TM\sl\16\clock\util\io_tools.py）：</p>
<p><img src="/.com//image-20211128212248428.png" alt="image-20211128212248428"></p>
<p>load_users()是加载管理员账号密码文件的方法。因为文件保存的是管理员账号和密码字典的字符串内容，所以直接将文件中所有文本读出来，然后转换成字典类型，最后将转换之后的字典对象直接赋值数据实体模块即可<br>load_users()方法的具体代码如下（代码位置：资源包\TM\sl\16\clock\util\io_tools.py）：</p>
<p><img src="/.com//image-20211128212304806.png" alt="image-20211128212304806"></p>
<p>5．将数据保存到文件中<br>既然有加载数据的方法，也就应该有保存数据的方法。当数据发生变化时，程序应立即将变化后的数据保存到本地硬盘上。公共工具模块提供了2种将数据保存到文件中的方法（保存新员工照片的方法由摄像头工具模块提供）。<br>save_employee_all()方法可以将员工列表中的数据保存到员工数据文件中。该方法首先打开文件的写权限，以覆盖的方式替换文件中的内容，然后遍历所有员工，将员工信息通过英文逗号和换行符拼接到一起，最后将拼接的文本写入文件中。<br>save_employee_all()方法的具体代码如下（代码位置：资源包\TM\sl\16\clock\util\io_tools.py）：</p>
<p><img src="/.com//image-20211128212324236.png" alt="image-20211128212324236"></p>
<p>save_lock_record()方法可以将打卡记录字典中的数据保存到打卡记录数据文件中，其逻辑与保存员工数据的方法类似，只不过不需要拆分或拼接数据，而是直接把字典对象转换成字符串，将转换得到的字符串覆盖到打卡记录数据文件中。<br>save_lock_record()方法的具体代码如下（代码位置：资源包\TM\sl\16\clock\util\io_tools.py）：</p>
<p><img src="/.com//image-20211128211903408.png" alt="image-20211128211903408"></p>
<p>save_work_time_config()方法可以将数据实体中的上班时间和下班时间保存到文件中。先按照“上班时间／下班时间”格式拼接2个时间的字符串，然后将拼接好的内容写入上下班配置文件中。<br>save_work_time_config ()方法的具体代码如下（代码位置：资源包\TM\sl\16\clock\util\io_tools.py）：</p>
<p><img src="/.com//image-20211128212417032.png" alt="image-20211128212417032"></p>
<p>6．删除照片<br>当一名员工被删除，该员工的照片就成了系统的垃圾文件，若不及时清除不仅会占用空间，还会加重人脸识别器的训练成本。<br>remove_pics()方法就是公共工具模块提供的删除指定员工照片的方法，参数为被删除的员工编号。该方法首先通过员工编号获取该员工的特征码，然后到照片文件夹中遍历所有文件，只要文件名以此员工的特征码开头，就将文件删除。删除后在控制台打印删除日志以提醒用户。<br>remove_pics()方法的具体代码如下（代码位置：资源包\TM\sl\16\clock\util\io_tools.py）：</p>
<p><img src="/.com//image-20211128212439429.png" alt="image-20211128212439429"></p>
<p>7．生成CSV文件<br>考勤月报是一个内容非常多的报表，不适合在控制台中展示，但很适合生成Excel报表来展示。因为使用Python技术创建Excel文件需要下载并导入第三方模块，会加重读者的学习压力，所以这里使用更简单的CSV格式文件来展示报表。Excel可以直接打开CSV文件。<br>CSV文件实际上是一个文本文件，每一行文字都对应Excel中的一行内容。CSV文件将每一行文字内容用英文逗号分隔，Excel根据这些英文逗号自动将文字内容分配到每一列中。<br>create_CSV()方法专门用来创建CSV文件，第一个参数是CSV文件的文件名，这个名称不包含后缀；第二个参数是CSV文件写入的文本内容。方法会将CSV文件生成在／data/文件夹下，因为大部分电脑都是用Windows系统，所以按照gbk字符编码写入内容，这样可以保证Windows系统下使用Excel打开CSV文件不会发生乱码。<br>create_CSV()方法的具体代码如下：</p>
<p><img src="/.com//image-20211128212514367.png" alt="image-20211128212514367"></p>
<h3 id="16-5-3-摄像头工具模块"><a href="#16-5-3-摄像头工具模块" class="headerlink" title="16.5.3　摄像头工具模块"></a>16.5.3　摄像头工具模块</h3><p>uitl文件夹下的camera.py是本程序的摄像头工具模块，该模块提供了以下功能：　开启摄像头打卡。　开启摄像头为员工拍照。<br>下面详细介绍camera.py中的代码。</p>
<p>1．导入模块<br>摄像头模块需要调用OpenCV和人脸识别服务的方法来实现拍照和视频打卡功能。因为打卡成功后要显示员工姓名，所以还需调用人事服务模块提供的方法，代码如下（代码位置：资源包\TM\sl\16\clock\util\camera.py）：</p>
<pre><code> import cv2
 from util import public_tools as tool
 from util import io_tools as io
 from service import recognize_service as rs
 from service import hr_service as hr
</code></pre>
<p>2．全局变量<br>录入新用户时需为新用户拍照，用户通过按键盘按键完成拍照。全局变量保存了键盘上Esc键和Enter键的ASCII码，OpenCV对比这2个变量来判断用户按了哪个按键，代码如下（代码位置：资源包\TM\sl\16\clock\util\camera.py）：</p>
<pre><code> ESC_KEY = 27    # Esc键的ASCII码
 ENTER_KEY = 13  # Enter键的ASCII码3．为新员工拍照
</code></pre>
<p>执行register()方法开启本地默认摄像头，方法参数是被拍照员工的特征码，当用户按Enter键时，该方法把摄像头的当前帧画面保存成图像文件，文件名以该员工特征码开头。每名新员工需要拍3张图片，也就是需要按3次Enter键，该方法才会结束。最后员工拍摄的照片都保存在／data/face/文件夹中，如图16.8所示。</p>
<p><img src="/.com//image-20211128212615823.png" alt="image-20211128212615823"></p>
<p>图16.8　/data/face/文件夹中员工照片文件<br>register()方法的具体代码如下</p>
<p><img src="/.com//image-20211128212655013.png" alt="image-20211128212655013"></p>
<p>4．开启摄像头打卡<br>执行clock_in()方法开启本地默认摄像头，程序扫描摄像头每一帧画面里是否有人脸，如果有人脸，就将这一帧画面与所有员工照片样本做比对，判断当前画面里的人脸属于哪位员工。人脸识别服务给出识别成功的特征码，通过特征码获得员工姓名，最后将识别成功的员工姓名返回。如果屏幕中没有出现人脸或者识别不成功，摄像头会一直处于开启状态。<br>clock_in()方法的具体代码如下（代码位置：资源包\TM\sl\16\clock\util\camera.py）：</p>
<p><img src="/.com//image-20211128212713423.png" alt="image-20211128212713423"></p>
<h2 id="16-6-服务模块设计"><a href="#16-6-服务模块设计" class="headerlink" title="16.6　服务模块设计"></a>16.6　服务模块设计</h2><p>本系统的服务模块包含2个文件：hr_service.py和recognize_service.py。前者提供所有人事管理的相关功能，例如增减员工、查询员工数据；后者提供人脸识别服务。本节将详细介绍这2个文件中的代码。</p>
<h3 id="16-6-1-人事服务模块"><a href="#16-6-1-人事服务模块" class="headerlink" title="16.6.1　人事服务模块"></a>16.6.1　人事服务模块</h3><p>service文件夹下的hr_service.py就是本程序的人事服务模块，该模块专门处理所有人事管理方面的业务，包含以下功能。</p>
<p>添加新员工。　</p>
<p>删除某员工。　</p>
<p>为指定员工添加打卡记录。　</p>
<p>多种获取员工信息的方法。　</p>
<p>生成考勤日报。　</p>
<p>生成考勤月报（CSV文件）。</p>
<p>下面详细介绍hr_service.py中的代码。</p>
<p>1．导入模块<br>人事服务需要管理员工类列表、记录打卡时间，还要计算、对比负责的日期和时间数值，所以要导入数据实体模块、公共工具模块、时间模块和日历模块。代码如下（代码位置：资源包\TM\sl\16\clock\service\hr_service.py）：</p>
<pre><code> from entity import organizations as o
 from util import public_tools as tool
 from util import io_tools as io
 import datetime
 import calendar
</code></pre>
<p>2．加载所有数据</p>
<p>程序启动的首要任务就是加载数据，人事服务模块将所有加载数据的方法封装成load_emp_data()方法，程序启动时运行此方法就可以一次性载入所有保存在文件中的数据。该方法依次进行文件自检，载入管理员账号密码、打卡记录、员工信息和员工照片。<br>load_emp_data()方法的具体代码如下（代码位置：资源包\TM\sl\16\clock\service\hr_service.py）：</p>
<p><img src="/.com//image-20211128212820407.png" alt="image-20211128212820407"></p>
<p>3．添加新员工<br>add_new_employee()方法用于添加新员工，参数为新员工的姓名。该方法通过公共工具模块创建随机特征码，通过数据实体模块创建新员工编号，然后结合姓名参数创建新</p>
<p>员工对象，在员工列表中添加新员工对象，并将最新的员工列表写入员工数据文件中，最后将该员工的特征码返回，摄像头服务根据此特征码为员工创建照片文件。<br>add_new_employee()方法的具体代码如下（代码位置：资源包\TM\sl\16\clock\service\hr_service.py）：</p>
<p><img src="/.com//image-20211128212859144.png" alt="image-20211128212859144"></p>
<p>4．删除员工<br>remove_employee()方法用来删除已有的员工资料，参数为被删除员工的编号。该方法首先删除该员工的所有照片文件，然后在员工列表中清除该员工的所有信息，包括打卡记录，最后将当前员工列表和打卡记录覆盖到数据文件中。这样数据文件里不会再有该员工的任何信息了。<br>remove_employee()方法的具体代码如下（代码位置：资源包\TM\sl\16\clock\service\hr_service.py）：</p>
<p><img src="/.com//image-20211128212918378.png" alt="image-20211128212918378"></p>
<p>5．添加打卡记录<br>add_lock_record()方法用来为指定员工添加打卡记录，参数为员工的姓名。如果某个员工打卡成功，该方法首先检查该员工是否有已经存在的打卡记录，如果没有记录就为其创建新记录，如果有记录就在原有记录上追加新时间字符串。该方法最后把当前打卡记录保存到数据文件中。<br>add_lock_record()方法的具体代码如下（代码位置：资源包\TM\sl\16\clock\service\hr_service.py）：</p>
<p><img src="/.com//image-20211128212933763.png" alt="image-20211128212933763"></p>
<p>6．获取员工数据<br>人事服务提供了多种获取员工数据的方法，可以满足多种业务场景，下面分别介绍。<br>get_employee_report()方法可以返回一个包含所有员工简要信息的报表，可用于在前端展示员工列表，该方法的具体代码如下（代码位置：资源包\TM\sl\16\clock\service\hr_service.py）：</p>
<p><img src="/.com//image-20211128213013377.png" alt="image-20211128213013377"></p>
<p>删除员工操作需输入被删除员工的编号，程序对用户输入的值进行校验，如果用户输入的员工编号不在员工列表之中（即无效编号），就认为用户操作有误，程序中断此业务。<br>check_id()方法用来判断输入的编号是否有效，编号如果有效就返回True，无效就返回False，该方法的代码如下（代码位置：资源包\TM\sl\16\clock\service\hr_service.py）：</p>
<p><img src="/.com//image-20211128213031342.png" alt="image-20211128213031342"></p>
<p>通过员工特征码获取该员工姓名代码如下（代码位置：资源包\TM\sl\16\clock\service\hr_service.py）：</p>
<p><img src="/.com//image-20211128213059725.png" alt="image-20211128213059725"></p>
<p>通过员工编号获取该员工特征码的代码如下（代码位置：资源包\TM\sl\16\clock\service\hr_service.py）：</p>
<p><img src="/.com//image-20211128213116746.png" alt="image-20211128213116746"></p>
<p>7．验证管理员账号和密码<br>valid_user()方法用来验证管理员的账号和密码，第一个参数为管理员账号，第二个参数为管理员密码。该方法首先判断输入的管理员账号是否存在，如果存在则再比对输入的密码，只有管理员账号存在且密码正确的情况下，该方法才返回True，其他情况返回False。</p>
<p>valid_user()方法的具体代码如下（代码位置：资源包\TM\sl\16\clock\service\hr_service.py）：</p>
<p><img src="/.com//image-20211128213220573.png" alt="image-20211128213220573"></p>
<p>8．保存上下班时间<br>save_work_time()方法用来保存用户设置的上下班时间，第一个参数为上班时间，第二个参数为下班时间，2个参数均为字符串，且必须符合“%H:%M:%S”时间格式，例如08:00:00。该方法直接修改数据实体中的全局变量，所以用户可以修改实时的上下班时间，即设置时间之后，日报和月报会立即使用新的时间分析考勤数据。<br>save_work_time()方法的具体代码如下（代码位置：资源包\TM\sl\16\clock\service\hr_service.py）：</p>
<pre><code> # 保存上下班时间
 def save_work_time(work_time, close_time):
     o.WORK_TIME = work_time
     o.CLOSING_TIME = close_time
     io.save_work_time_config()  # 上下班时间保存到文件中
</code></pre>
<p>9．打印考勤日报</p>
<p>打印考勤日报的方法有2个：get_day_report()方法打印指定日期的日报，get_today_report()方法打印今天的日报。下面分别介绍。<br>get_day_report()方法打印哪一天的日报是由参数date决定的，参数d     ate是一个字符串，且必须符合“%Y-%m-%d”时间格式，例如“2008-08-08”。该方法创建date指定的时间对象，分别计算这一天0点、12点和23点59分59秒的时间对象，并且会根据用户设置的上下班时间计算这一天上班时间对象和下班时间对象，这些时间对象将用来分析员工的考勤情况。员工的打卡规则如表16.2所示。</p>
<p>​                                                                                  表16.2　打卡规则</p>
<p><img src="/.com//image-20211128213246503.png" alt="image-20211128213246503"></p>
<p>方法中分别创建了迟到、早退和缺席名单3个列表，只要某员工出现不正常打卡记录，就会将该员工姓名放到对应不正常打卡状态的名单里，最后打印报表，给出各名单人数和明细。<br>get_day_report()方法的具体代码如下（代码位置：资源包\TM\sl\16\clock\service\hr_service.py）：</p>
<p><img src="/.com//image-20211128213913981.png" alt="image-20211128213913981"></p>
<p>因为负责考勤的用户最常查看的就是当天的打卡情况，所以将当天打卡日报单独封装成get_today_report()方法。该方法自动生成当天的date字符串，并将其作为参数调用get_day_report()方法。<br>get_today_report()方法的具体代码如下（代码位置：资源包\TM\sl\16\clock\service\hr_service.py）：</p>
<p><img src="/.com//image-20211128213952660.png" alt="image-20211128213952660"></p>
<p>10．生成考勤月报<br>与考勤日报不同，考勤月报是一种汇总形式的报表，可以展示员工整个月的考勤状况。因为月报表内容较多，所以不会在控制台中展示，而是生成独立的报表文件。<br>生成考勤月报的方法有2个：get_month_report ()方法生成指定月份的月报；get_pre_month_report ()方法打印上个月的月报。下面分别介绍。<br>考勤月报的校验逻辑与考勤日报基本相同，相当于一次性统计了一个月的日报数据。唯一不同的是统计月报的时候不是创建异常打卡名单，而是统计每一位员工每一天的打卡情况。每个员工的打卡情况用一个字符串表示，如有正常打卡，就追加正常打卡的标记，如果迟到就追加迟到标记，以此类推。统计完所有员工一个月打卡情况之后再对每个字符串进行分析。　</p>
<p>如果员工在×日有正常上下班打卡标记，则月报×日下不显示任何内容。迟到或早退标记都被忽略，因为可能是员工误打卡。　</p>
<p>如果员工在×日没有上班打卡标记，且有迟到标记，则在月报×日下显示【迟到】。　</p>
<p>如果员工在×日没有下班打卡标记，且有早退标记，则月报×日下显示【早退】。　</p>
<p>如果员工在×日没有上班打卡标记，也没有迟到标记，则在月报×日下显示【上班未打卡】。　</p>
<p>如果员工在×日没有下班打卡标记，也没有早退标记，则在月报×日下显示【下班未打卡】。　</p>
<p>如果员工在×日没有任何打卡标记，则在月报×日下显示【缺席】。<br>月报采用CSV格式文件展示，CSV文件自动生成在项目的／data/文件夹下。CSV是文本文件，用换行符区分表格的行，用英文逗号区分表格的列。get_month_report()方法最后将生成的CSV格式月报用记事本打开，其效果如图16.9所示，如果用Office Excel打开则可以看到正常的表格内容，效果如图16.10所示。</p>
<p><img src="/.com//image-20211128225917095.png" alt="image-20211128225917095"></p>
<p>​                                                                           图16.9　用记事本打开CSV格式的月报</p>
<p><img src="/.com//image-20211128225941244.png" alt="image-20211128225941244"></p>
<p>​                                                                    图16.10　用Office Excel打开CSV格式的月报<br>get_month_report()方法的具体代码如下（代码位置：资源包\TM\sl\16\clock\service\hr_service.py）：</p>
<p><img src="/.com//image-20211128230016478.png" alt="image-20211128230016478"></p>
<p><img src="/.com//image-20211128230040789.png" alt="image-20211128230040789"></p>
<p>因为负责考勤的用户最常查看上个月的月报，所以将生成上个月月报单独封装成了get_pre_month_report()方法。该方法自动生成上个月的pre_month字符串，并将其作为参数调用get_month_report()方法。<br>get_pre_month_report()具体代码如下（代码位置：资源包\TM\sl\16\clock\service\hr_service.py）：</p>
<p><img src="/.com//image-20211128230117420.png" alt="image-20211128230117420"></p>
<h3 id="16-6-2-人脸识别服务模块"><a href="#16-6-2-人脸识别服务模块" class="headerlink" title="16.6.2　人脸识别服务模块"></a>16.6.2　人脸识别服务模块</h3><p>service文件夹下的recognize_service.py就是本程序的人脸识别服务模块，该模块提供人脸识别算法，其包含以下功能。　检测图像中是否有正面人脸。　判断图像中的人脸属于哪个人。<br>下面详细介绍recognize_service.py中的代码。</p>
<p>1．导入包<br>人脸识别服务需要导入OpenCV相关模块和os模块，代码如下（代码位置：资源包\TM\sl\16\clock\service\recognize_service.py）：</p>
<p>import cv2<br>import numpy as np<br>import os</p>
<p>2．全局变量<br>全局变量中创建了人脸识别器引擎和人脸识别级联分类器对象，PASS_CONF为人脸识别的信用评分，只有低于这个值的人脸识别评分才认为相似度高。全局变量的代码如下：</p>
<p><img src="/.com//image-20211128230309914.png" alt="image-20211128230309914"></p>
<p>3．训练识别器<br>train()方法专门用来训练人脸识别器，该方法仅封装了识别器对象的训练方法，方法参数为样本图像列表和标签列表，其代码如下（代码位置：资源包\TM\sl\16\clock\service\recognize_service.py）：</p>
<pre><code> # 训练识别器
 def train(photos, lables):
    RECOGNIZER.train(photos, np.array(lables))  # 识别器开始训练
</code></pre>
<p>4．发现人脸</p>
<p>found_face()方法用来判断图像中是否有正面人脸，参数为灰度图像。通过正面人脸级联分类器对象检测图像中出现的人脸数量，最后返回人脸数量大于0的判断结果，有人脸就返回True，没有就返回False。<br>found_face()方法的具体代码如下（代码位置：资源包\TM\sl\16\clock\service\recognize_service.py）：</p>
<p><img src="/.com//image-20211128230328108.png" alt="image-20211128230328108"></p>
<p>5．识别人脸<br>recognise_face()方法用来识别图像中的人脸属于哪位员工，方法参数为被识别的图像。该方法必须在识别器接受完训练之后被调用。识别器给出分析得出的评分，如果评分大于可信范围，则认为图像中不存在任何已有员工，返回-1，否则返回已有员工的特征码。<br>recognise_face()方法的具体代码如下（代码位置：资源包\TM\sl\16\clock\service\recognize_service.py）：</p>
<p><img src="/.com//image-20211128230421418.png" alt="image-20211128230421418"></p>
<h2 id="16-7-程序入口设计"><a href="#16-7-程序入口设计" class="headerlink" title="16.7　程序入口设计"></a>16.7　程序入口设计</h2><p>main.py是整个程序的入口文件，负责在控制台中打印菜单界面，用户通过指令可以使用系统中的全部功能，包括打卡、员工管理等，所以会有大量指令判断逻辑。<br>main.py需要导入摄像头工具模块、公共工具模块和人事服务模块。代码如下（代码位置：资源包\TM\sl\16\clock\main.py）：</p>
<pre><code> from util import camera
 from util import public_tools as tool
 from service import hr_service as hr
</code></pre>
<p>下面详细介绍main.py中的代码</p>
<h3 id="16-7-1-用户权限管理"><a href="#16-7-1-用户权限管理" class="headerlink" title="16.7.1　用户权限管理"></a>16.7.1　用户权限管理</h3><p>系统中除了打卡和退出2项功能可以随意使用，其他菜单都需要管理员权限才能使用。用户选中查看记录、员工管理和考勤报表菜单，系统会验证用户身份，如果不是管理员身份就会弹出管理员登录提示，用户输入正确的账号和密码才可以继续使用这些功能。<br>main.py文件中定义了一个全局变量ADMIN_LOGIN，该变量表示管理员的登录状态，默认为False，即管理员未登录。其代码如下（代码位置：资源包\TM\sl\16\clock\main.py）：</p>
<pre><code> ADMIN_LOGIN = False  # 管理员登录状态
</code></pre>
<p>login()为管理员登录方法，该方法弹出输入管理员账号和密码的提示，如果用户输入账号为字符串“0”，则认为用户取消了登录操作。如果用户输入了正确的账号和密码，就将全局变量ADMIN_LOGIN的值改为True，即管理员已处于登录状态，这样系统就会开放所有已设权限的功能，用户可以随意使用。<br>login()方法的具体代码如下（代码位置：资源包\TM\sl\16\clock\main.py）：</p>
<p><img src="/.com//image-20211128230514889.png" alt="image-20211128230514889"></p>
<h3 id="16-7-2-主菜单设计"><a href="#16-7-2-主菜单设计" class="headerlink" title="16.7.2　主菜单设计"></a>16.7.2　主菜单设计</h3><p>start()方法是程序的启动方法，在初始化方法执行完毕后执行。该方法在控制台中打印程序的主功能菜单，效果如图16.11所示。</p>
<p><img src="/.com//image-20211128230537548.png" alt="image-20211128230537548"></p>
<p>​                                                                               图16.11　主菜单<br>此时用户需先输入菜单对应的数字，再按Enter键进入具体功能菜单中。如果用户输入的数字不在功能菜单中，则提示指令有误，请用户重新输入。<br>如果当前用户没有管理员权限，在选中查看记录、员工管理和考勤报表菜单时会要求用户先登录管理员的账号，效果如图16.12所示。</p>
<p><img src="/.com//image-20211128230618875.png" alt="image-20211128230618875"></p>
<p>​                                                         图16.12　用户需登录管理员账号才能使用员工管理功能<br>start()方法的具体代码如下（代码位置：资源包\TM\sl\16\clock\main.py）：</p>
<p><img src="/.com//image-20211128230644783.png" alt="image-20211128230644783"></p>
<h3 id="16-7-3-人脸打卡功能"><a href="#16-7-3-人脸打卡功能" class="headerlink" title="16.7.3　人脸打卡功能"></a>16.7.3　人脸打卡功能</h3><p>face_clock()是人脸打卡功能的执行方法，该方法调用摄像头工具模块提供的打卡方法，此时只要用户面向摄像头，摄像头即可自动扫描人脸并识别特征，效果如图16.13所示。如果镜头中的人脸符合某个员工的特征，则会返回该员工姓名，然后调用人事服务模块为此员工添加打卡记录，最后提示该员工打卡成功，过程如图16.14所示。</p>
<p><img src="/.com//image-20211128230722320.png" alt="image-20211128230722320"></p>
<p>​                                                                                   图16.13　打卡者需正向面对镜头</p>
<p><img src="/.com//image-20211128230745651.png" alt="image-20211128230745651"></p>
<p>​                                                                                  图16.14　员工王五打卡成功<br>face_clock()方法的具体代码如下：</p>
<p><img src="/.com//image-20211128230807096.png" alt="image-20211128230807096"></p>
<h3 id="16-7-4-为新员工登记人脸照片样本"><a href="#16-7-4-为新员工登记人脸照片样本" class="headerlink" title="16.7.4　为新员工登记人脸照片样本"></a>16.7.4　为新员工登记人脸照片样本</h3><p>employee_management()方法是员工管理功能的执行方法，该方法在控制台打印员工管理功能菜单，如图16.15所示。输入菜单对应的数字，再按Enter键进入具体功能菜单中。</p>
<p><img src="/.com//image-20211128230830763.png" alt="image-20211128230830763"></p>
<p>​                                                               图16.15　员工管理功能菜单<br>录入新员工的过程如图16.16所示。如果用户在员工管理功能菜单中输入数字1并按Enter键，则开始执行新员工录入操作。首先输入新员工名称，输入完毕后程序打开默认摄像头，此时让新员工面对摄像头，程序将摄像头拍摄的照片展示在如图16.17所示的register窗口中。在register窗口上按3次Enter键，自动保存3张摄像头拍摄的照片文件，最后提示录入成功。</p>
<p><img src="/.com//image-20211128230908335.png" alt="image-20211128230908335"></p>
<p>​                                                                                                   图16.16　录入新员工的过程</p>
<p><img src="/.com//image-20211128230931356.png" alt="image-20211128230931356"></p>
<p>​                                                                                    图16.17　register窗口展示的员工照片</p>
<h3 id="16-7-5-删除员工全部数据"><a href="#16-7-5-删除员工全部数据" class="headerlink" title="16.7.5　删除员工全部数据"></a>16.7.5　删除员工全部数据</h3><p>如果用户在员工管理功能菜单中输入数字2并按Enter键，则开始执行删除员工操作。首先程序会将所有员工的名单打印到控制台中，用户输入要删除的员工编号并按Enter键，程序给出一个验证码让用户输入，如果用户输入的验证码正确，该员工的员工信息、打卡记录和照片文件都会被删除，如果用户输入的验证码错误，则会取消删除员工操作，员工数据不会丢失。删除员工操作的过程如图16.18所示。</p>
<p><img src="/.com//image-20211128230958321.png" alt="image-20211128230958321"></p>
<p>​                                                                            图16.18　删除员工操作的过程<br>employee_management()方法的具体代码如下（代码位置：资源包\TM\sl\16\clock\main.py）：</p>
<p><img src="/.com//image-20211128231025347.png" alt="image-20211128231025347"></p>
<h3 id="16-7-6-查询员工打卡记录"><a href="#16-7-6-查询员工打卡记录" class="headerlink" title="16.7.6　查询员工打卡记录"></a>16.7.6　查询员工打卡记录</h3><p>check_record()方法是查询记录功能的执行方法，该方法在控制台打印查询记录功能菜单，效果如图16.19所示。此时用户需先输入菜单对应的数字，再按Enter键进入具体功能菜单。</p>
<p><img src="/.com//image-20211128231100025.png" alt="image-20211128231100025"></p>
<p>​                                                                                    图16.19　查看记录功能菜单<br>如果用户在查询记录功能菜单中输入数字1并按Enter键，程序将所有员工列表打印到控制台中，效果如图16.20所示。</p>
<p><img src="/.com//image-20211128231120571.png" alt="image-20211128231120571"></p>
<p>​                                                                                图16.20　查看员工列表</p>
<p>如果用户在查询记录功能菜单中输入数字2并按Enter键，程序将所有员工的打卡记录打印到控制台中，效果如图16.21所示。</p>
<p><img src="/.com//image-20211128231213893.png" alt="image-20211128231213893"></p>
<p>​                                                                                        图16.21　查看打卡记录<br>check_record()方法的具体的代码如下（代码位置：资源包\TM\sl\16\clock\main.py）：</p>
<p><img src="/.com//image-20211128231247326.png" alt="image-20211128231247326"></p>
<h3 id="16-7-7-生成考勤报表"><a href="#16-7-7-生成考勤报表" class="headerlink" title="16.7.7　生成考勤报表"></a>16.7.7　生成考勤报表</h3><p>check_report()方法是考勤报表功能的执行方法，该方法在控制台打印考勤报表功能菜单，效果如图16.22所示。此时用户需先输入菜单对应的数字，再按Enter键进入具体功能菜单。</p>
<p><img src="/.com//image-20211128231405373.png" alt="image-20211128231405373"></p>
<p>​                                                                                               图16.22　考勤报表功能菜单<br>如果用户在考勤报表功能菜单中输入数字1并按Enter键，则会提示用户输入日期。用户按照指定格式输入日期后即可看到该日期的考勤日报。如果用户输入数字0，可以打印当天的考勤日报。例如，打印2021年3月2日考勤日报的效果如图16.23所示。</p>
<p><img src="/.com//image-20211128231458581.png" alt="image-20211128231458581"></p>
<p>​                                                                                     图16.23　打印2021年3月2日的考勤日报<br>如果用户在考勤报表功能菜单中输入数字2并按Enter键，则提示用户输入月份。用户按照指定格式输入月份后，即可生成该月考勤月报，并显示生成的月报文件地址。如果用户输入数字0，可以生成上个月的考勤月报。例如，生成2021年3月考勤月报的效果如图16.24所示。</p>
<p><img src="/.com//image-20211128231521785.png" alt="image-20211128231521785"></p>
<p>​                                                                    图16.24　生成2021年3月考勤月报<br>图16.24中提示“2021年3月考勤月报.csv”文件保存在D:\clock\data\文件夹中，打开这个文件夹即可以看到月报文件，如图16.25所示，用Office Excel打开月报即可以看到如图16.26所示的表格内容。</p>
<p><img src="/.com//image-20211128231550636.png" alt="image-20211128231550636"></p>
<p>​                                                                            图16.25　CSV文件的位置</p>
<p><img src="/.com//image-20211128231612666.png" alt="image-20211128231612666"></p>
<p>​                                                                图16.26　使用Office Excel打开月报的效果<br>check_report()方法的具体代码如下（代码位置：资源包\TM\sl\16\clock\main.py）：</p>
<p><img src="/.com//image-20211128231638940.png" alt="image-20211128231638940"></p>
<h3 id="16-7-8-自定义上下班时间"><a href="#16-7-8-自定义上下班时间" class="headerlink" title="16.7.8　自定义上下班时间"></a>16.7.8　自定义上下班时间</h3><p>report_config()方法是报表设置功能的执行方法，如果用户在考勤报表功能菜单中输入数字3并按Enter键，则进入报表设置功能菜单，效果如图16.27所示，在这个菜单中可以设置用于分析考勤记录的上下班时间。</p>
<p><img src="/.com//image-20211128231711120.png" alt="image-20211128231711120"></p>
<p>​                                                                                     图16.27　报表设置功能菜单<br>如果用户在报表设置功能菜单中输入数字1并按Enter键，则分别提示用户输入上班时间和下班时间，效果如图16.28所示。如果用户输入的时间格式错误，程序要求用户重新输入。当用户设置完后，上下班时间立即生效，此时再打印考勤报表就会按照最新的上下班时间进行分析。</p>
<p><img src="/.com//image-20211128231731240.png" alt="image-20211128231731240"></p>
<p>​                                                                     图16.28　用户设置上班时间和下班时间      </p>
<p>report_config()方法的具体代码如下（代码位置：资源包\TM\sl\16\clock\main.py）：</p>
<p><img src="/.com//image-20211128231810922.png" alt="image-20211128231810922"></p>
<h3 id="16-7-9-启动程序"><a href="#16-7-9-启动程序" class="headerlink" title="16.7.9　启动程序"></a>16.7.9　启动程序</h3><p>main.py定义完所有全局变量和方法之后，代码的最下方就是整个系统的启动脚本：首先执行系统初始化操作，然后启动系统。具体代码如下（代码位置：资源包\TM\sl\16\clock\main.py）：</p>
<p><img src="/.com//image-20211128231824542.png" alt="image-20211128231824542"></p>
<h2 id="16-8-小结"><a href="#16-8-小结" class="headerlink" title="16.8　小结"></a>16.8　小结</h2><p>本章详细介绍了一个完整小型项目的开发流程。这个项目主要包括5大功能：打卡、退出、查看记录、员工管理和考勤报表。其中，查看记录、员工管理和考勤报表3个功能需要管理员权限才能使用。这个项目采用命令提示符窗口实现与计算机之间的交互。虽然命令提示符窗口有些简陋，但不影响这个项目的实用价值。如果读者想制作一个绚丽的窗口界面运行这个项目，可以在掌握这个项目的功能结构、业务流程和实现原理后，尝试用Python PyQt5的相关知识予以实现。</p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
  </entry>
  <entry>
    <title>React 概念</title>
    <url>/2021/03/23/React-01-%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h2 id="一、什么是react"><a href="#一、什么是react" class="headerlink" title="一、什么是react"></a>一、什么是react</h2><ul>
<li>react是由Facebook开发的一个JavaScript库，而不是一个框架。当时Facebook需要解决一个问题，开发（或者说是构建）一个数据不断变化的大型应用。而数据变化会带来两个很严重的问题</li>
</ul>
<h2 id="二、react的特点"><a href="#二、react的特点" class="headerlink" title="二、react的特点"></a>二、react的特点</h2><ul>
<li>简单：学习简单，代码简单</li>
<li>声明式（编程）：自动<code>DOM</code>操作</li>
</ul>
<blockquote>
<p><code>React</code>的核心是组件，组件的设计目的是提升代码的复用率、降低测试难度和代码复杂度。</p>
</blockquote>
<ul>
<li>提高代码复用率：组件将数据与逻辑封装</li>
<li>降低测试难度：组件高内聚低耦合，很容易对单个组件进行测试</li>
<li>降低代码复杂度：使用<code>JSX</code>语法，更直观的在js文件中看<code>HTML</code>代码，提高可读性</li>
</ul>
<h2 id="三、react的开发环境的配置"><a href="#三、react的开发环境的配置" class="headerlink" title="三、react的开发环境的配置"></a>三、react的开发环境的配置</h2><blockquote>
<p>如果是要直接在<code>HTML</code>上编辑，需要下载<code>react.js</code>与<code>react-dom.js</code>。如果要使用JSX语法，则需要使用转换<code>JSX</code>语法的插件。这里使用<code>brower.js</code>。在线地址：<a href="https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.23/browser.min.js">https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.23/browser.min.js</a></p>
</blockquote>
<ul>
<li><code>react.js</code>：<code>react</code>的核心库</li>
<li><code>react-dom.js</code>：提供操作<code>DOM</code>相关的功能</li>
<li><code>brower,js</code>：将使用的<code>JSX</code>语法转换成<code>JavaScript</code>语法</li>
</ul>
<blockquote>
<p>注意：三者引用顺序必须是<code>react</code>、<code>react-dom</code>、<code>brower</code></p>
</blockquote>
<h2 id="四、React、ReactDOM中有什么"><a href="#四、React、ReactDOM中有什么" class="headerlink" title="四、React、ReactDOM中有什么"></a>四、React、ReactDOM中有什么</h2><p><img src="https://poetries1.gitee.io/img-repo/2019/10/449.png" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/2019/10/450.png" alt="img"></p>
<h2 id="五、yeoman环境"><a href="#五、yeoman环境" class="headerlink" title="五、yeoman环境"></a>五、yeoman环境</h2><blockquote>
<p><code>yeoman</code>前端脚手架工具</p>
</blockquote>
<pre><code>cnpm i -g yeoman
</code></pre>
<ul>
<li><a href="http://yeoman.io/">http://yeoman.io/</a></li>
</ul>
<blockquote>
<p><a href="https://github.com/react-webpack-generators/generator-react-webpack#readme">https://github.com/react-webpack-generators/generator-react-webpack#readme</a></p>
<pre><code># Make sure both is installed globally
npm install -g yo
npm install -g generator-react-webpack

# Create a new directory, and `cd` into it:
mkdir my-new-project &amp;&amp; cd my-new-project

# Run the generator
yo react-webpack
</code></pre>
</blockquote>
<pre><code># Start for development
npm start # or
npm run serve

# Start the dev-server with the dist version
npm run serve:dist

# Just build the dist version and copy static files
npm run dist

# Run unit tests
npm test

# Auto-run unit tests on file changes
npm run test:watch

# Lint all files in src (also automatically done AFTER tests are run)
npm run lint

# Clean up the dist directory
npm run clean

# Just copy the static assets
npm run copy
</code></pre>
<h2 id="六、React脚手架搭建"><a href="#六、React脚手架搭建" class="headerlink" title="六、React脚手架搭建"></a>六、React脚手架搭建</h2><pre><code>npm i create-react-app

create-react-app your-app-name &amp;&amp; cd your-app-name

npm install 

npm start
</code></pre>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React 事件</title>
    <url>/2021/04/05/React-04-%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="一、编写事件处理函数"><a href="#一、编写事件处理函数" class="headerlink" title="一、编写事件处理函数"></a>一、编写事件处理函数</h2><p><img src="https://poetries1.gitee.io/img-repo/2019/10/456.png" alt="img"></p>
<ul>
<li>在函数体中进行一些操作，常见的有：更新页面内容，更新组件状态，与后台交互</li>
</ul>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/457.png" alt="img"></p>
<p><strong>书写方式</strong></p>
<pre><code>var Demo = React.createClass(&#123;
        getInitialState:function()&#123;        &#125;,
        handleClick: function(event)&#123;        &#125;,
        handleChange: function()&#123;        &#125;,
        render:function()&#123;        &#125;,
    &#125;)
</code></pre>
<ul>
<li>上面的代码中有的有参数<code>event</code>，有的没有，这个根据自己的需求</li>
</ul>
<h2 id="二、绑定事件处理函数"><a href="#二、绑定事件处理函数" class="headerlink" title="二、绑定事件处理函数"></a>二、绑定事件处理函数</h2><ul>
<li><code>onClick=&#123;this,handleClick&#125;</code></li>
<li>需要注意的是：不要在事件后面添加上一个<code>（）</code></li>
</ul>
<p><strong>其他的事件</strong></p>
<ul>
<li>触摸事件：<code>onTouchCancel</code>，<code>onTouchEnd</code>，<code>onTouchMove</code>，<code>onTouchStart</code></li>
<li>键盘事件：<code>onKeyDown</code>，<code>onKeyUp</code>， <code>onKeyPress</code>（前两者的组合）</li>
<li>表单时间：<code>onChange</code>，<code>onInput</code>，<code>onSubmit</code></li>
<li>焦点事件：<code>onFocus</code>，<code>onBlur</code></li>
<li>UI元素事件：<code>onScroll</code></li>
<li>滚动事件：<code>onWhell</code>（鼠标滚动）</li>
<li>鼠标事件：<code>onClick</code>，<code>onContextMenu</code>，<code>onDoubleClick</code>……</li>
</ul>
<pre><code>var Demo = React.createClass(&#123;
    handleClick:function(e)&#123;
        console.log(e)
        console.log(e.target)
        console.log(e.nativeEvent)
    &#125;,
    render:function()&#123;
        return &lt;div onClick=&#123;this.handleClick&#125;&gt;Hello World&lt;/div&gt;
    &#125;
&#125;)
ReactDOM.render(&lt;Demo/&gt;,document.getElementById(&#39;app&#39;))
var Demo = React.createClass(&#123;
    getInitialState:function()&#123;
        return &#123;
            width: 200,
            height: 200,
            backgroundColor: &#39;#DDDDDD&#39;
        &#125;
    &#125;,
    /*handleWheel:function(e)&#123;
        var newColor = (parseInt(this.state.backgroundColor.substr(1),16) + e.deltaY).toString(16)
        newColor = &#39;#&#39; + newColor.toUpperCase()
        console.log(newColor)
        this.setState(&#123;
            backgroundColor:newColor
        &#125;)
    &#125;,*/
    randomColor:function()&#123;
        var r = Math.floor(Math.random()*256);
        var g = Math.floor(Math.random()*256);
        var b = Math.floor(Math.random()*256);
        return &#39;rgb(&#39;+r+&#39;,&#39;+g+&#39;,&#39;+b+&#39;)&#39;
    &#125;,
    handleWheel:function()&#123;
        this.setState(&#123;
            backgroundColor:this.randomColor()
        &#125;)
    &#125;,
    render:function()&#123;
        return &lt;div onWheel=&#123;this.handleWheel&#125; style=&#123;this.state&#125;&gt;这是一个案例，鼠标滚动实现背景颜色的变化&lt;/div&gt;
    &#125;
&#125;)
ReactDOM.render(&lt;Demo/&gt;,document.getElementById(&#39;app&#39;))
</code></pre>
<h2 id="三、事件对象"><a href="#三、事件对象" class="headerlink" title="三、事件对象"></a>三、事件对象</h2><p><strong>事件对象的使用</strong></p>
<ul>
<li>通用：所有的事件都有事件属性</li>
</ul>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/458.png" alt="img"></p>
<ul>
<li>键盘：键盘事件拥有的事件属性</li>
</ul>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/459.png" alt="img"></p>
<ul>
<li>鼠标：鼠标事件拥有的事件属性</li>
</ul>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/460.png" alt="img"></p>
<ul>
<li>滚动：滚动事件拥有的事件属性<ul>
<li>为什么会有三个，因为有的设备可以实现三个方向的移动</li>
</ul>
</li>
</ul>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/461.png" alt="img"></p>
<h2 id="四、事件与状态关联"><a href="#四、事件与状态关联" class="headerlink" title="四、事件与状态关联"></a>四、事件与状态关联</h2><pre><code>inputChange:function(event)&#123;
    this.setState(&#123;
        inputText:event.target.value
    &#125;)
&#125;
</code></pre>
<ul>
<li>总的来说就是使用<code>this.setState</code>来更新状态，而状态的值因为事件的不同会不同</li>
</ul>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React 组件协议(不)可控组件</title>
    <url>/2021/04/08/React-05-%E7%BB%84%E4%BB%B6%E5%8D%8F%E5%90%8C(%E4%B8%8D)%E5%8F%AF%E6%8E%A7%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="一、为什么要进行组件的协同"><a href="#一、为什么要进行组件的协同" class="headerlink" title="一、为什么要进行组件的协同"></a>一、为什么要进行组件的协同</h2><ul>
<li>我们在实际的开发项目的时候，不会只用几个组件，有时候遇到大型的项目，可能会有成千上百的组件，难免会遇到有功能重复的组件。要进行修改，就会修改大部分的文件。所以我们需要进行组件的协同开发。</li>
</ul>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/451.png" alt="img"></p>
<h2 id="二、什么是组件的协同使用？"><a href="#二、什么是组件的协同使用？" class="headerlink" title="二、什么是组件的协同使用？"></a>二、什么是组件的协同使用？</h2><ul>
<li>组件的协同本质上是对组件的一种组织、管理的方式。</li>
<li>目的：<ul>
<li>逻辑清晰：这是组件与组件之间的逻辑</li>
<li>代码模块化</li>
<li>封装细节：像面向对象一样将常用的方法以及数据封装起来</li>
<li>提高代码的复用性：因为是组件，相当于一个封装好的东西，用的时候直接调用</li>
</ul>
</li>
</ul>
<h2 id="三、如何实现组件的协同使用"><a href="#三、如何实现组件的协同使用" class="headerlink" title="三、如何实现组件的协同使用"></a>三、如何实现组件的协同使用</h2><ul>
<li>第一种：增加一个父组件，将其他的组件进行嵌套，更多的是实现代码的封装</li>
<li>第二种：通过一些操作从后台获取数据，<code>React</code>中的<code>Mixin</code>，更多的是实现代码的复用</li>
</ul>
<h2 id="四、组件嵌套的含义"><a href="#四、组件嵌套的含义" class="headerlink" title="四、组件嵌套的含义"></a>四、组件嵌套的含义</h2><ul>
<li>组件嵌套的本质是父子关系</li>
</ul>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/452.png" alt="img"></p>
<h2 id="五、组件嵌套的优缺点"><a href="#五、组件嵌套的优缺点" class="headerlink" title="五、组件嵌套的优缺点"></a>五、组件嵌套的优缺点</h2><ul>
<li>优点：<ul>
<li>逻辑清晰：父子关系类似于人类中的父子关系</li>
<li>模块化开发：每个模块对应一个功能，不同的模块可以同步开发</li>
<li>封装细节：开发者必须要关注组件的功能，不需要了解细节</li>
</ul>
</li>
<li>缺点：<ul>
<li>编写难度高：父子组件的关系需要经过深思熟虑，贸然编写可能导致关系混乱，代码难以维护</li>
<li>无法掌握所有细节：使用者只知道组件的用法，不知道实现细节，遇到问题难以修复</li>
</ul>
</li>
</ul>
<h2 id="六、Mixin"><a href="#六、Mixin" class="headerlink" title="六、Mixin"></a>六、Mixin</h2><p><strong>Mixin的含义</strong></p>
<ul>
<li><code>Mixin=一组方法</code>。</li>
<li>他的目的是横向抽离出组件的相似代码，把组件的共同作用以及效果的代码提出来</li>
</ul>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/453.png" alt="img"></p>
<p><strong>Mixin的优缺点</strong></p>
<ul>
<li>优点<ul>
<li>代码复用：抽离出通用的代码，减少开发成本，提高开发效率</li>
<li>即插即用：可以使用许多现有的<code>Mixin</code>来开发自己的代码</li>
<li>适应性强：改动一次代码，影响多个组件</li>
</ul>
</li>
<li>缺点<ul>
<li>编写难度高：<code>Mixin</code>可能被用在各种环境中，想要兼容多种环境就需要更多的 - 码与逻辑，通用的代价是提高复杂度</li>
<li>降低代码的可读性：组件的优势在于将逻辑与是界面直接结合在一起，<code>Mixin</code>本质上会分散逻辑，理解起来难度大</li>
</ul>
</li>
</ul>
<h2 id="七、不可控组件"><a href="#七、不可控组件" class="headerlink" title="七、不可控组件"></a>七、不可控组件</h2><p><img src="https://poetries1.gitee.io/img-repo/2019/10/454.png" alt="img"></p>
<ul>
<li>上图：<code>defaultValue</code>的值是固定的，这就是一个不可控组件</li>
<li>如果要获取<code>input</code>的<code>value</code>值，只有使用<code>ref</code>获取节点来获取值</li>
</ul>
<h2 id="八、可控组件"><a href="#八、可控组件" class="headerlink" title="八、可控组件"></a>八、可控组件</h2><p><img src="https://poetries1.gitee.io/img-repo/2019/10/455.png" alt="img"></p>
<ul>
<li><code>defaultValue</code>的值是根据状态确定了，只需要拿到<code>this.state.value</code>的值就可以了</li>
<li>这里需要注意一下：使用<code>value</code>的值是不可修改的，<code>defaultValue</code>的值是可以修改的</li>
</ul>
<p><strong>可控组件的优点</strong></p>
<ul>
<li>符合<code>React</code>的数据流</li>
<li>数据存储在<code>state</code>中，便于获取</li>
<li>便于处理数据</li>
</ul>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React HOC高阶组件</title>
    <url>/2021/03/25/React-02-jsx%E4%B8%8E%E9%9D%9EDOM/</url>
    <content><![CDATA[<h2 id="一、JSX是什么"><a href="#一、JSX是什么" class="headerlink" title="一、JSX是什么"></a>一、JSX是什么</h2><ul>
<li>一个语法或者说是语法糖</li>
<li>基于<code>ECMAScript</code>一种新的特性</li>
<li>一种定义带属性（<code>DOM</code>节点）树结构（<code>DOM</code>结构）的语法</li>
</ul>
<p><strong>JSX不是</strong></p>
<ul>
<li>一门新的语言</li>
<li><code>XML</code>或者<code>HTML</code></li>
<li>一种限制，可以不使用<code>JSX</code></li>
</ul>
<h2 id="二、JSX的特点"><a href="#二、JSX的特点" class="headerlink" title="二、JSX的特点"></a>二、JSX的特点</h2><ul>
<li>类<code>XML</code>语法，易于接受</li>
<li>增强<code>JS</code>语义，在<code>js</code>中编辑<code>HTML</code></li>
<li>结构清晰</li>
<li>抽象程度高（核心）：避免手<code>动DOM</code>操作，跨平台</li>
<li>代码模块化</li>
</ul>
<h2 id="三、JSX语法"><a href="#三、JSX语法" class="headerlink" title="三、JSX语法"></a>三、JSX语法</h2><p><img src="https://poetries1.gitee.io/img-repo/2019/10/463.png" alt="img"></p>
<pre><code>/*
    JSX（javaScriptXML）语法入门：
        1、不是一门语言，是一个语法或者说是语法糖
        2、JSX标签其实就是HTML标签，只不过在javascript中这些标签的时候，
            不使用“”,遇到HTML标签（以&lt;开始），就用HTML规则解析，遇到代码块
            （以&#123;开始），就用javascript规则解析
        3、JSX语法浏览器无法解析，需要使用插件将其转化为js代码
        4、代码更加直观
*/
/*
    1、首字母必须大写
    2、驼峰命名
    3、使用className与htmlFor代替class和for
    4、组件与组件之间是可以嵌套的
    5、在JSX语法中只能使用求值表达式，不能使用语句
    6、只有一个顶层标签
*/
var Demo = React.createClass(&#123;
    change:function ()&#123;
        return &#39;demo&#39;
    &#125;,
    handleClick:function()&#123;
        alert(1)
    &#125;,
    render: function()&#123;
        // this指向整个（当前的组件）组件
        return &lt;div className=&quot;demo&quot; onClick=&#123;this.handleClick&#125;&gt;这是一个&#123;this.change()&#125;&lt;/div&gt;
    &#125;
&#125;)
// console.log(Demo)
ReactDOM.render(&lt;Demo /&gt;,document.getElementById(&#39;app&#39;))
</code></pre>
<h2 id="四、JSX的注释"><a href="#四、JSX的注释" class="headerlink" title="四、JSX的注释"></a>四、JSX的注释</h2><ul>
<li>在<code>JSX</code>语法中，添加注释需要写在 <code>&#123; &#125;</code> 中</li>
<li>可以使用多行注释与单行注释</li>
</ul>
<pre><code>var HelloWorld = React.createClass(&#123;
    render:function()&#123;
        // 现在这里是属于js的部分,不属于JSX语法的部分
        return (
            &lt;div className=&quot;box&quot; // class名字
            &gt;
                &#123;/*这是一个标题*/&#125;
                &lt;h1 className=&quot;title&quot;&gt;Hello World&lt;/h1&gt;
                &#123;/*这是说明*/&#125;
                &lt;p&gt;你好世界！&lt;/p&gt;
                &lt;div className=&quot;box2&quot;&gt;你好&lt;/div&gt;
            &lt;/div&gt;
        )
    &#125;
&#125;)
ReactDOM.render(&lt;HelloWorld/&gt;,document.getElementById(&quot;app&quot;))
</code></pre>
<h2 id="五、JSX中使用样式"><a href="#五、JSX中使用样式" class="headerlink" title="五、JSX中使用样式"></a>五、JSX中使用样式</h2><ul>
<li>内联样式</li>
<li>对象样式</li>
<li>选择器样式（<code>CSS</code>样式）</li>
</ul>
<pre><code>/*
组件的样式:
    1、行内样式：写行内样式的时候需要使用两个&#123;&#125;  ==&gt;&#123;&#123;&#125;&#125;
    2、对象样式：在return前面定义一个样式对象，注意样式的写法，与HTML的不同点
    3、CSS样式

注意事项，在HTML5中与在React中的样式的书写区别：
    1、HTML5中以;结束
        在React中以,结束
    2、在HTML5中属性与值都不需要加上引号
        在React中，属于javascript对象，key中不能存在 - ,
        需要使用驼峰命名，如果是value值，需要加上引号
    3、在HTML中，设置带数字的值，宽度，高度==，需要带上单位
        在React中可以不用带单位，直接写数字
        这里是指那些规定了默认单位的值。比如说像素px，如果要使用em或者是rem则需要加上单位
*/
/*
&#123;&#125; 插值符号
在使用插值符号的是有，里面需要时一个对象或者是一个表达式
*/
var HelloWorld = React.createClass(&#123;
render:function()&#123;
    var styles = &#123;
        color: 'blue',
        fontSize: '30'
    &#125;
    return (
        <div classname="box">
            <h3 classname="title" style="&#123;&#123;color:'red',backgroundColor:'lime'&#125;&#125;&gt;默认标题&lt;/h3&gt;" &lt;p &lt; div&gt; ) &#125; &#125;) reactdom.render(&lt;helloworld &gt;,document.getelementbyid(&quot;app&quot;)) < code></h3></div></code></pre>
<h2 id="六、条件判断的四种写法"><a href="#六、条件判断的四种写法" class="headerlink" title="六、条件判断的四种写法"></a>六、条件判断的四种写法</h2><ul>
<li>三元表达式 ? :</li>
<li>使用变量，通过函数使用条件判断语句，返回一个字符串</li>
<li>直接在<code>&#123;&#125;</code>中调用函数</li>
<li>使用比较运算符 <code>&amp;&amp;</code> <code>||</code>！`</li>
</ul>
<pre><code>/*
1、三元表达式        ?    :
2、使用变量，通过函数使用条件判断语句，返回一个字符串
3、直接在&#123;&#125;中调用函数
4、使用比较运算符    &amp;&amp;   ||  ！
*/
var Demo = React.createClass(&#123;
    // 设置初始的状态
    getInitialState:function()&#123;
        return &#123;
            onOff:true
        &#125;
    &#125;,
    // 自定义一个点击事件
    handleClick:function() &#123;
        this.setState(&#123;
            onOff:!this.state.onOff
        &#125;)
    &#125;,
    render:function()&#123;
        return &lt;div className=&#123;this.state.onOff?&quot;box2&quot;:&quot;box1&quot;&#125; onClick=&#123;this.handleClick&#125;&gt;我是一个盒子&lt;/div&gt;
    &#125;
&#125;)
ReactDOM.render(&lt;Demo/&gt;,document.body)
</code></pre>
<h2 id="七、非DOM（元素）属性"><a href="#七、非DOM（元素）属性" class="headerlink" title="七、非DOM（元素）属性"></a>七、非DOM（元素）属性</h2><ul>
<li><code>dangerouslySetInnerHTML</code>：在<code>JSX</code>中直接插入<code>HTML</code>代码，动态的添加<code>HTML</code>内容，由用户添加。需要使用属性，<code>__html</code></li>
<li><code>ref</code>：父组件引用子组件 <code>this.refs.name</code></li>
<li><code>key</code>：目的提高渲染性能 ，涉及到<code>React diff</code>算法，<code>React</code>通过<code>key</code>值判断是否重新渲染</li>
</ul>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React HOC高阶组件</title>
    <url>/2021/04/09/React-HOC%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h3 id="高阶组件是什么"><a href="#高阶组件是什么" class="headerlink" title="高阶组件是什么"></a>高阶组件是什么</h3><ul>
<li>高阶组件其实就是一个函数，传入一个组件返回一个新的组件。它接受一个组件作为参数，返回一个新的组件。这个新的组件会使用你传给它的组件作为子组件</li>
<li>高阶组件的作用其实不言而喻，其实就是为了组件之间的代码复用。组件可能有着某些相同的逻辑，把这些逻辑抽离出来，放到高阶组件中进行复用。高阶组件内部的包装组件和被包装组件之间通过 props 传递数据</li>
</ul>
<h3 id="如何实现高阶组件"><a href="#如何实现高阶组件" class="headerlink" title="如何实现高阶组件"></a>如何实现高阶组件</h3><blockquote>
<p>高阶组件其实就是处理react组件的函数。那么我们如何实现一个高阶组件？有两种方法</p>
</blockquote>
<p><strong>属性代理</strong></p>
<blockquote>
<p>属性代理是最常见的实现方式，将被处理组件的props和新的props一起传递给新组件</p>
</blockquote>
<pre><code>export default function withHeader(WrappedComponent) &#123;
  return class HOC extends Component &#123;
    render() &#123;
      return &lt;div&gt;
        &lt;div className=&quot;demo-header&quot;&gt;
          我是标题
        &lt;/div&gt;
        &lt;WrappedComponent &#123;...this.props&#125;/&gt;
      &lt;/div&gt;
    &#125;
  &#125;
&#125;
</code></pre>
<blockquote>
<p>在其他组件里，我们引用这个高阶组件，用来强化它</p>
</blockquote>
<pre><code>@withHeader
export default class Demo extends Component &#123;
  render() &#123;
    return (
      &lt;div&gt;
        我是一个普通组件
      &lt;/div&gt;
    );
  &#125;
&#125;
</code></pre>
<blockquote>
<p>使用ES6写法可以更加简洁</p>
</blockquote>
<pre><code>export default(title) =&gt; (WrappedComponent) =&gt; class HOC extends Component &#123;
  render() &#123;
    return &lt;div&gt;
      &lt;div className=&quot;demo-header&quot;&gt;
        &#123;title
          ? title
          : &#39;我是标题&#39;&#125;
      &lt;/div&gt;
      &lt;WrappedComponent &#123;...this.props&#125;/&gt;
    &lt;/div&gt;
  &#125;
&#125;
</code></pre>
<blockquote>
<p>从代码中看，就是使用HOC这个函数，向被处理的组件WrappedComponent上面添加一些属性，并返回一个包含原组件的新组件</p>
</blockquote>
<p><strong>反向继承</strong></p>
<pre><code>function HOC(WrappedComponent)&#123;
    return class HOC extends WrappedComponent &#123;
        //继承了传入的组件
        test1()&#123;
            return this.test2() + 5;
        &#125;
 
        componentDidMount()&#123;
            console.log(&#39;1&#39;);
            this.setState(&#123;number:2&#125;);
        &#125;
 
        render()&#123;
            //使用super调用传入组件的render方法
            return super.render();
        &#125;
    &#125;
&#125;
 
@HOC
class OriginComponent extends Component &#123;
    constructor(props)&#123;
        super(props);
        this.state = &#123;number:1&#125;
    &#125;
 
    test2()&#123;
        return 4;
    &#125;
    componentDidMount()&#123;
        console.log(&#39;2&#39;);
    &#125;
 
    render()&#123;
        return (
            &lt;div&gt;
                &#123;this.state.number&#125;&#123;&#39;and&#39;&#125;
                &#123;this.test1()&#125;
                这是原始组件
            &lt;/div&gt;
        )
    &#125;
&#125;
 
//const newComponent = HOC(OriginComponent)
</code></pre>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>Python数据分析从入门到精通</title>
    <url>/2020/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/</url>
    <content><![CDATA[<h1 id="Python数据分析从入门到精通"><a href="#Python数据分析从入门到精通" class="headerlink" title="Python数据分析从入门到精通"></a>Python数据分析从入门到精通</h1><h1 id="课程简介"><a href="#课程简介" class="headerlink" title="课程简介"></a>课程简介</h1><h2 id="自然智能"><a href="#自然智能" class="headerlink" title="自然智能"></a>自然智能</h2><p>自然智能（Natural Intelligence，NI），指人通过大脑的运算和决策产生有价值的行为。这些行为包括了人的大脑思考及决策、耳朵听力及判断、眼睛视觉及判断、鼻子嗅觉及判断、皮肤触觉及判断等，体现在人行为的方方面面。</p>
<h2 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p> 百度百科：它是<a href="https://baike.baidu.com/item/%E7%A0%94%E7%A9%B6/1883844">研究</a>、<a href="https://baike.baidu.com/item/%E5%BC%80%E5%8F%91/9400971">开发</a>用于<a href="https://baike.baidu.com/item/%E6%A8%A1%E6%8B%9F/7698898">模拟</a>、<a href="https://baike.baidu.com/item/%E5%BB%B6%E4%BC%B8/7834264">延伸</a>和扩展人的<a href="https://baike.baidu.com/item/%E6%99%BA%E8%83%BD/66637">智能</a>的理论、方法、技术及应用系统的一门新的技术科学。</p>
<p>人工智能（Artificial intelligence）简称AI。人工智能是计算机科学的一个分支，它企图了解智能的本质，并生产出一种新的能以人类智能相似的方式做出反应的智能机器，是研究、开发用于模拟、延伸和扩展人的智能的理论、方法、技术及应用系统的一门新的技术科学。</p>
<p>借用《计算机科学导论》作者贝赫鲁兹·佛罗赞（Behrouz Forouzan）的说法，人工智能是对程序系统的研究，该程序系统在一定程度上能模仿人类的活动，如感知，思考，学习和反应。</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>人工智能目前分为弱人工智能和强人工智能和超人工智能。</p>
<ol>
<li>弱人工智能：弱人工智能（Artificial Narrow Intelligence /ANI),只专注于完成某个特定的任务，例如语音识别、图象识别和翻译等，是擅长于单个方面的人工智能。它们只是用于解决特定的具体类的任务问题而存在，大都是统计数据，以此从中归纳出模型。由于弱人工智能智能处理较为单一的问题，且发展程度并没有达到模拟人脑思维的程度，所以弱人工智能仍然属于“工具”的范畴，与传统的“产品”在本质上并无区别。</li>
</ol>
<ol start="2">
<li> 强人工智能：强人工智能（Artificial General Intelligence  /AGI),属于人类级别的人工智能，在各方面都能和人类比肩，它能够进行思考、计划、解决问题、抽象思维、理解复杂理念、快速学习和从经验中学习等操作，并且和人类一样得心应手。</li>
<li> 超人工智能：超人工智能（Artificial Super intelligence/ASI），在几乎所有领域都比最聪明的人类大脑都聪明许多，包括科学创新、通识和社交技能。在超人工智能阶段，人工智能已经跨过“奇点”，其计算和思维能力已经远超人脑。此时的人工智能已经不是人类可以理解和想象。人工智能将打破人脑受到的维度限制，其所观察和思考的内容，人脑已经无法理解，人工智能将形成一个新的社会。</li>
</ol>
<p>我们现阶段还处于若人工智能阶段。</p>
<h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><p><strong>机器学习（MachineLearning）简称ML</strong>。机器学习属于人工智能的一个分支，也是人工智能的和核心。机器学习理论主要是设计和分析一些让计算机可以自动”学习“的算法。</p>
<h2 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h2><p>深度学习（Deep Learning）简称DL。最初的深度学习是利用深度神经网络来解决特征表达的一种学习过程。深度神经网络本身并不是一个全新的概念，可大致理解为包含多个隐含层的神经网络结构。为了提高深层神经网络的训练效果，人们对神经元的连接方法和激活函数等方面做出相应的调整。深度学习是机器学习研究中的一个新的领域，其动机在于建立、模拟人脑进行分析学习的神经网络，它模仿人脑的机制来解释数据，如图象、声音、文本。</p>
<h2 id="区别与联系"><a href="#区别与联系" class="headerlink" title="区别与联系"></a>区别与联系</h2><p><img src="/.com//Users\123\AppData\Roaming\Typora\typora-user-images\image-20211018014131909.png" alt="image-20211018014131909"></p>
<h2 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h2><p>机器学习是强大的数据分析工具</p>
<h3 id="数据分析行业前景"><a href="#数据分析行业前景" class="headerlink" title="数据分析行业前景"></a>数据分析行业前景</h3><p><img src="/.com//Users\123\AppData\Roaming\Typora\typora-user-images\image-20211018014409539.png" alt="image-20211018014409539"></p>
<h3 id="就业岗位"><a href="#就业岗位" class="headerlink" title="就业岗位"></a>就业岗位</h3><p>成为数据分析师</p>
<p>机器学习开发工程师</p>
<p>科学计算的科学家</p>
<h2 id="学习重点"><a href="#学习重点" class="headerlink" title="学习重点"></a>学习重点</h2><p>Numpy、Pandas、Matplotlib, Scipy、Scikit-learn、pyecharts</p>
<p>Numpy库和</p>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>anaconda 的下载和安装</p>
<p>官网：<a href="https://www.anaconda.com/products/individual">https://www.anaconda.com/products/individual</a></p>
<p>百度网盘：链接：<a href="https://pan.baidu.com/s/1VVwv3-AIr7c3S7juGpp8mQ">https://pan.baidu.com/s/1VVwv3-AIr7c3S7juGpp8mQ</a><br>提取码：v2bh </p>
<p>安装成功验证：</p>
<p><img src="/.com//image-20211018024458282.png" alt="image-20211018024458282"></p>
<p>查看已经安装的安装包：</p>
<p>pip list</p>
<p><img src="/.com//image-20211018022738296.png" alt="image-20211018022738296"></p>
<p>anaconda 安装工具包方法：</p>
<p>pip install</p>
<p>pip install 安装包名称 -i <a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a>  </p>
<h2 id="jupyter-notebook"><a href="#jupyter-notebook" class="headerlink" title="jupyter notebook"></a>jupyter notebook</h2><p>Jupyter Notebook将代码、说明文本、数学方程式、数据可视化图表等内容全部组合到一起显示在一个共享的文档中，可以实现一边写代码一边记录，而这些功能是Python自带的IDLE和集成开发环境PyCharm无法比拟的。</p>
<p>快捷键</p>
<ul>
<li><strong>Enter</strong> : 转入编辑模式</li>
<li><strong>Shift-Enter</strong> : 运行本单元，选中下个单元</li>
<li><strong>Ctrl-Enter</strong> : 运行本单元</li>
<li><strong>Alt-Enter</strong> : 运行本单元，在其下插入新单元</li>
<li><strong>Y</strong> : 单元转入代码状态</li>
<li><strong>M</strong> :单元转入markdown状态</li>
<li><strong>R</strong> : 单元转入raw状态</li>
<li><strong>1</strong> : 设定 1 级标题</li>
<li><strong>2</strong> : 设定 2 级标题</li>
<li><strong>3</strong> : 设定 3 级标题</li>
<li><strong>4</strong> : 设定 4 级标题</li>
<li><strong>5</strong> : 设定 5 级标题</li>
<li><strong>6</strong> : 设定 6 级标题</li>
<li><strong>Up</strong> : 选中上方单元</li>
<li><strong>K</strong> : 选中上方单元</li>
<li><strong>Down</strong> : 选中下方单元</li>
<li><strong>J</strong> : 选中下方单元</li>
<li><strong>Shift-K</strong> : 扩大选中上方单元</li>
<li><strong>Shift-J</strong> : 扩大选中下方单元</li>
<li><strong>A</strong> : 在上方插入新单元</li>
<li><strong>B</strong> : 在下方插入新单元</li>
<li><strong>X</strong> : 剪切选中的单元</li>
<li><strong>C</strong> : 复制选中的单元</li>
<li><strong>Shift-V</strong> : 粘贴到上方单元</li>
<li><strong>V</strong> : 粘贴到下方单元</li>
<li><strong>Z</strong> : 恢复删除的最后一个单元</li>
<li><strong>D,D</strong> : 删除选中的单元</li>
<li><strong>Shift-M</strong> : 合并选中的单元</li>
<li><strong>Ctrl-S</strong> : 文件存盘</li>
<li><strong>S</strong> : 文件存盘</li>
<li><strong>L</strong> : 转换行号</li>
<li><strong>O</strong> : 转换输出</li>
<li><strong>Shift-O</strong> : 转换输出滚动</li>
<li><strong>Esc</strong> : 关闭页面</li>
<li><strong>Q</strong> : 关闭页面</li>
<li><strong>H</strong> : 显示快捷键帮助</li>
<li><strong>I,I</strong> : 中断Notebook内核</li>
<li><strong>0,0</strong> : 重启Notebook内核</li>
<li><strong>Shift</strong> : 忽略</li>
<li><strong>Shift-Space</strong> : 向上滚动</li>
<li><strong>Space</strong> : 向下滚动</li>
</ul>
<h2 id="spyder"><a href="#spyder" class="headerlink" title="spyder"></a>spyder</h2><p><img src="/.com//image-20211018024534693.png" alt="image-20211018024534693"></p>
<p>变量浏览器窗口</p>
<p><img src="/.com//image-20211018024612097.png" alt="image-20211018024612097"></p>
<p>创建项目</p>
<p><img src="/.com//image-20211018024700511.png" alt="image-20211018024700511"></p>
<h2 id="pycharm"><a href="#pycharm" class="headerlink" title="pycharm"></a>pycharm</h2><h2 id="开发工具比较"><a href="#开发工具比较" class="headerlink" title="开发工具比较"></a>开发工具比较</h2><p>PyCharm、Jupyter Notebook和Spyder这3种开发工具，各有特点。</p>
<p>a.数据分析，建议使用Spyder和Jupyter Notebook</p>
<p>b.复杂、大型项目，建议使用PyCharm</p>
<p>c. 数据分析、复杂和大型项目，建议三者可以结合使用</p>
<h1 id="第一章-了解数据分析"><a href="#第一章-了解数据分析" class="headerlink" title="第一章 了解数据分析"></a>第一章 了解数据分析</h1><h2 id="一-数据分析流程"><a href="#一-数据分析流程" class="headerlink" title="一. 数据分析流程"></a>一. 数据分析流程</h2><p>熟悉工具-明确目的-获取数据-数据处理-数据分析-验证结果-结果呈现-数据应用</p>
<h3 id="1-熟悉工具"><a href="#1-熟悉工具" class="headerlink" title="1.熟悉工具"></a>1.熟悉工具</h3><h3 id="2-明确目的"><a href="#2-明确目的" class="headerlink" title="2.明确目的"></a>2.明确目的</h3><p>在数据分析方面，首先要花一些时间搞清楚为什么要做数据分析、分析什么、想要达到什么效果。例如，为了评估产品改版后的效果比之前是否有所提升，或通过数据分析找到产品迭代的方向等。只有明确了分析目的，才能够找到适合的分析方法，也才能够有效地进行数据处理、数据分析和预测等后续工作。</p>
<h3 id="3-获取数据"><a href="#3-获取数据" class="headerlink" title="3.获取数据"></a>3.获取数据</h3><p>数据的来源有很多，像我们熟悉的Excel数据、数据库中的数据、网站数据以及公开的数据集等。那么，获取数据之前首先要知道需要什么时间段的数据，哪张表中的数据，以及如何获得，是下载、复制还是爬取等。</p>
<h3 id="4-数据处理"><a href="#4-数据处理" class="headerlink" title="4.数据处理"></a>4.数据处理</h3><p><img src="/.com//image-20211018031333159.png" alt="image-20211018031333159"></p>
<p>数据规约：在接近或保持原始数据完整性的同时将数据集规模减小，以提高数据处理的速度。例如，一张Excel表中包含近3年的几十万条数据，由于我们只分析近一年的数据，因此要一年的数据即可，这样做的目的就是减小数据规模，提高数据处理速度。</p>
<p>数据清洗：在获取到原始数据后，可能其中的很多数据都不符合数据分析的要求，那么就需要按照如下步骤进行处理。</p>
<p>​        a.数据探索分析：分析数据的规律，通过一定的方法统计数据，通过统计结果判断数据是否存在缺失、异常等情况。例如，通过最小值判断数量、金额是否包含缺失数据，如果最小值为0，那么这部分数据就是缺失数据，以及通过判断数据是否存在空值来判断数据是否缺失。</p>
<p>​        b.重复数据处理：对于重复的数据删除即可。</p>
<p>​        c.缺失数据处理：对于缺失的数据，如果比例高于30%可以选择放弃这个指标，删除即可；如果低于30%可以将这部分缺失数据进行填充，以0或均值填充。</p>
<p>​        d.异常数据处理：异常数据需要对具体业务进行具体分析和处理，对于不符合常理的数据可进行删除。例如，性别男或女，但是数据中存在其他值，以及年龄超出正常年龄范围，这些都属于异常数据。</p>
<p>数据加工：包括数据抽取、数据计算、数据分组和数据转换。</p>
<p>​        a.数据抽取：是指选取数据中的部分内容。　</p>
<p>​        b.数据计算：是进行各种算术和逻辑运算，以便得到进一步的信息。　</p>
<p>​        c.数据分组：是按照有关信息进行有效的分组。　</p>
<p>​        d.数据转换：是指数据标准化处理，以适应数据分析算法的需要，常用的有z-score标准化，“最小、最大标准化”和“按小数定标标准化”等。经过上述标准化处理后，数据中各指标值将会处在同一个数量级别上，以便更好地对数据进行综合测评和分析。</p>
<h3 id="5-数据分析"><a href="#5-数据分析" class="headerlink" title="5.数据分析"></a>5.数据分析</h3><p>数据分析过程中，选择适合的分析方法和工具很重要，所选择的分析方法应兼具准确性、可操作性、可理解性和可应用性。但对于业务人员（如产品经理或运营）来说，数据分析最重要的是数据分析思维。</p>
<h3 id="6-验证结果"><a href="#6-验证结果" class="headerlink" title="6.验证结果"></a>6.验证结果</h3><p>通过数据分析我们会得到一些结果，但是这些结果只是数据的主观结果的体现，有些时候不一定完全准确，所以必须要进行验证。</p>
<p>例如，数据分析结果显示某产品点击率非常高，但实际下载量平平，那么这种情况，不要轻易定论，这种产品受欢迎，而要进一步验证，找到真正影响点击率的原因，这样才能做出更好的决策。</p>
<h3 id="7-结果呈现"><a href="#7-结果呈现" class="headerlink" title="7.结果呈现"></a>7.结果呈现</h3><p>现如今，企业越来越重视数据分析给业务决策带来的有效应用，而可视化是数据分析结果呈现的重要步骤。可视化是以图表方式呈现数据分析结果，这样的结果更清晰、更直观、更容易理解。</p>
<h3 id="8-数据应用"><a href="#8-数据应用" class="headerlink" title="8.数据应用"></a>8.数据应用</h3><p>数据分析的结果并不仅仅是把数据呈现出来，而更应该关注的是通过分析这些数据，后面可以做什么？如何将数据分析结果应用到实际业务中才是学习数据分析的重点。<br>数据分析结果的应用是数据产生实际价值的直接体现，而这个过程需要具有数据沟通能力、业务推动能力和项目工作能力。如果看了数据分析结果后并不知道做什么，那么这个数据分析就是失败的。</p>
<h2 id="二-数据分析常用的工具"><a href="#二-数据分析常用的工具" class="headerlink" title="二.数据分析常用的工具"></a>二.数据分析常用的工具</h2><p>excel  或者 python</p>
<ol>
<li><p>excel</p>
<p>Excel具备多种强大功能，例如创建表格、数据透视表、VBA等，Excel的系统如此庞大，确保了大家可以根据自己的需求分析数据。<br>但是在今天，大数据、人工智能时代，数据量很大的情况下Excel已经无法胜任，不仅处理起来很麻烦而且处理速度也会变慢。从数据分析的层面，Excel也只是停留在描述性分析，如对比分析、趋势分析、结构分析等。</p>
</li>
<li><p>python</p>
<p>虽然Excel已尽最大努力考虑到数据分析的大多数应用场景，但由于它是定制软件，很多东西都固化了，不能自由地修改。而Python非常的强大和灵活，可以编写代码来执行所需的任何操作，从专业和方便的角度来看，它比Excel更加强大。另外，Python可以实现Excel难以实现的应用场景。</p>
<p>a．专业的统计分析<br>例如，正态分布、使用算法对聚类进行分类和回归分析等。这种分析就像用数据做实验一样。它可以帮助我们回答下面的问题。<br>数据的分布是正态分布、三角分布还是其他类型的分布？离散情况如何？它是否在我们想要达到的统计可控范围内？不同参数对结果的影响是多少？<br>b．预测分析<br>例如，我们打算预测消费者的行为。他会在我们的商店停留多长时间？他会花多少钱？我们可以找出他的个人信用情况，并根据他的在线消费记录确定贷款金额。或者，我们可以根据他在网页上的浏览历史推送不同的产品。这也涉及当前流行的机器学习和人工智能概念。</p>
</li>
</ol>
<p>综上所述，Python作为数据分析工具的首选，具有以下优势。　Python语言简单易学、数据处理简单高效，对于初学者来说更加容易上手。　Python第三方扩展库不断更新，可用范围越来越广。　在科学计算、数据分析、数学建模和数据挖掘方面占据越来越重要的地位。　可以和其他语言进行对接，兼容性稳定。<br>当然，如果您既会Excel又会Python，那么绝对是职场的加分项！</p>
<h1 id="第二章-Pandas统计分析"><a href="#第二章-Pandas统计分析" class="headerlink" title="第二章 Pandas统计分析"></a>第二章 Pandas统计分析</h1><p>Pandas是Python的核心数据分析支持库，它提供了大量能使我们快速便捷地处理数据的函数和方法。<br>由于Pandas相关知识非常多，本书将Pandas分为上、下两章进行讲解。本章开始Pandas入门内容，从安装开始，逐步介绍Pandas相关的入门知识，包括两个主要的数据结构，即Series对象和DataFrame对象，也包括如何导入外部数据、数据抽取，以及数据的增加、修改和删除，还包括数据清洗、索引设置、数据排序与排名等相关基础知识，这些都是在为后期数据处理和数据分析打下良好的基础。</p>
<h2 id="一-Pandas概述"><a href="#一-Pandas概述" class="headerlink" title="一. Pandas概述"></a>一. Pandas概述</h2><p>Pandas是数据分析三大剑客之一，是Python的核心数据分析库，它提供了快速、灵活、明确的数据结构，能够简单、直观、快速地处理各种类型的数据，具体介绍如下所示。</p>
<p>Pandas能够处理以下类型的数据。　</p>
<p>1.与SQL或Excel表类似的数据。　</p>
<p>2.有序和无序（非固定频率）的时间序列数据。　</p>
<p>3.带行、列标签的矩阵数据。</p>
<p>4.任意其他形式的观测、统计数据集。</p>
<p>Pandas提供的两个主要数据结构Series（一维数组结构）与DataFrame（二维数组结构），可以处理金融、统计、社会科学、工程等领域里的大多数典型案例，并且Pandas是基于NumPy开发的，可以与其他第三方科学计算库完美集成。<br>Pandas的功能很多，它的优势如下。　</p>
<p>1.处理浮点与非浮点数据里的缺失数据，表示为NaN。　</p>
<p>2.大小可变，例如插入或删除DataFrame等多维对象的列。</p>
<p>3.自动、显式数据对齐，显式地将对象与一组标签对齐，也可以忽略标签，在Series、DataFrame计算时自动与数据对齐。　</p>
<p>4.强大、灵活的分组统计（groupby）功能，即数据聚合、数据转换。　</p>
<p>5.把Python和NumPy数据结构里不规则、不同索引的数据轻松地转换为DataFrame对象。　</p>
<p>6.智能标签，对大型数据集进行切片、花式索引、子集分解等操作。　</p>
<p>7.直观地合并（merge）、连接（join）数据集。　灵活地重塑（reshape）、透视（pivot）数据集。</p>
<p>8.成熟的导入、导出工具，导入文本文件（CSV等支持分隔符的文件）、Excel文件、数据库等来源的数据，导出Excel文件、文本文件等，利用超快的HDF5格式保存或加载数据。　</p>
<p>9.时间序列：支持日期范围生成、频率转换、移动窗口统计、移动窗口线性回归、日期位移等时间序列功能。</p>
<p>例1.读取excel数据</p>
<p>01 import pandas as pd               #导入pandas 模块<br>02 df=pd.read_excel(‘data.xlsx’)      #读取Excel 文件<br>03 df1=df.head()                      #显示前5 条数据</p>
<h2 id="二-seires-对象"><a href="#二-seires-对象" class="headerlink" title="二. seires 对象"></a>二. seires 对象</h2><p>Pandas是Python数据分析重要的库，而Series和DataFrame是Pandas库中两个重要的对象，也是Pandas中两个重要的数据结构，如图所示。</p>
<p><img src="/.com//image-20211018035610974.png" alt="image-20211018035610974"><br>本节将主要介绍Series对象。</p>
<h3 id="2-1-图解Series对象"><a href="#2-1-图解Series对象" class="headerlink" title="2.1　图解Series对象"></a>2.1　图解Series对象</h3><p>Series是Python的Pandas库中的一种数据结构，它类似一维数组，由一组数据以及与这组数据相关的标签（即索引)组成，或者仅有一组数据没有索引也可以创建一个简单的Series。Series可以存储整数、浮点数、字符串、Python对象等多种类型的数据。<br>例如，在成绩表（见图3)中包含了Series对象和DataFrame对象，其中“语文”“数学”“英语”3列中的每一列均是一个Series对象，而“语文”“数学”“英语”3列组成了一个DataFrame对象，如图4所示。</p>
<p><img src="/.com//image-20211018035821898.png" alt="image-20211018035821898"></p>
<p>​                                                                                           图3</p>
<p><img src="/.com//image-20211018035900680.png" alt="image-20211018035900680"></p>
<p>​                                                                                         图4</p>
<h3 id="2-2-创建一个series对象"><a href="#2-2-创建一个series对象" class="headerlink" title="2.2 创建一个series对象"></a>2.2 创建一个series对象</h3><p>创建Series对象主要使用Pandas的Series()方法，语法如下：</p>
<p>s=pd.Series(data,index=index)</p>
<p>参数说明：　</p>
<p>data：表示数据，支持Python字典、多维数组、标量值（即只有大小，没有方向的量。也就是说，只是一个数值，如s=pd.Series(5)）。　index：表示行标签（索引）。　</p>
<p>返回值：Series对象。</p>
<p>说明<br>当data参数是多维数组时，index长度必须与data长度一致。如果没有指定index参数，则自动创建数值型索引（从0～data数据长度-1）。</p>
<p>【示例02】　在成绩表添加一列“物理”成绩。（示例位置：资源包\MR\Code\03\02）创建一个Series对象，在成绩表中添加一列“物理”成绩。程序代码如下：</p>
<p>01 import pandas as pd<br>02 s1=pd.Series([88,60,75])<br>03 print(s1)</p>
<p>上述举例，如果通过Pandas模块引入Series对象，那么就可以直接在程序中使用Series对象了。主要代码如下：</p>
<p>01 from pandas import Series<br>02 s1=Series([88,60,75])</p>
<h3 id="2-3-手动设置series索引"><a href="#2-3-手动设置series索引" class="headerlink" title="2.3 手动设置series索引"></a>2.3 手动设置series索引</h3><p>创建Series对象时会自动生成整数索引，默认值从0开始至数据长度减1。例如，3.2.1节举例中使用的就是默认索引，如0、1、2。除了使用默认索引，还可以通过index参数手动设置索引。</p>
<p>【示例03】　手动设置索引。（示例位置：资源包\MR\Code\03\03）<br>下面手动设置索引，将3.2.1节添加的“物理”成绩的索引设置为1、2、3，也可以是“明日同学”“高同学”“七月流火”。</p>
<p>程序代码如下：</p>
<p><img src="/.com//image-20211018040816095.png" alt="image-20211018040816095"></p>
<p>运行程序，控制台输出结果如下：</p>
<p><img src="/.com//image-20211018040836315.png" alt="image-20211018040836315"></p>
<p>说明<br>上述结果中输出的dtype是DataFrame数据的数据类型，int为整型，后面的数字表示位数。</p>
<h3 id="2-4-series-位置索引"><a href="#2-4-series-位置索引" class="headerlink" title="2.4 series 位置索引"></a>2.4 series 位置索引</h3><h4 id="2-4-1-series位置索引"><a href="#2-4-1-series位置索引" class="headerlink" title="2.4.1 series位置索引"></a>2.4.1 series位置索引</h4><p>位置索引是从0开始数，[0]是Series第一个数，[1]是Series第二个数，以此类推。</p>
<p>【示例04】　通过位置索引获取学生物理成绩。（示例位置：资源包\MR\Code\03\04）获取第一个学生的物理成绩。程序代码如下：</p>
<p>01 import pandas as pd<br>02 s1=pd.Series([88,60,75])<br>03 print(s1[0])<br>运行程序，控制台输出结果如下：</p>
<p>88</p>
<p>注意<br>Series不能使用[-1]定位索引。</p>
<h4 id="2-4-2-series-标签索引"><a href="#2-4-2-series-标签索引" class="headerlink" title="2.4.2 series 标签索引"></a>2.4.2 series 标签索引</h4><p>Series标签索引与位置索引方法类似，用[ ]表示，里面是索引名称，注意index的数据类型是字符串，如果需要获取多个标签索引值，用[[ ]]表示（相当于[ ]中包含一个列表）。</p>
<p>【示例05】　通过标签索引获取学生物理成绩。（示例位置：资源包\MR\Code\03\05）通过标签索引“明日同学”和“七月流火”获取物理成绩，程序代码如下：</p>
<p><img src="/.com//image-20211018041305145.png" alt="image-20211018041305145"></p>
<h4 id="2-4-3-series-切片索引"><a href="#2-4-3-series-切片索引" class="headerlink" title="2.4.3 series 切片索引"></a>2.4.3 series 切片索引</h4><p>用标签索引做切片，包头包尾（即包含索引开始位置的数据，也包含索引结束位置的数据）。</p>
<p>【示例06】　通过切片获取数据。（示例位置：资源包\MR\Code\03\06）通过标签切片索引“明日同学”至“七月流火”获取数据。程序代码如下：</p>
<p>print(s1[‘明日同学’:’七月流火’])     #通过切片获取索引值</p>
<p>用位置索引做切片，和list列表用法一样，包头不包尾（即包含索引开始位置的数据，不包含索引结束位置的数据）。</p>
<p>【示例07】　通过位置切片获取数据。（示例位置：资源包\MR\Code\03\07）通过位置切片1～4获取数据，程序代码如下：</p>
<p>01  s2=pd.Series([88,60,75,34,68])<br>02  print(s2[1:4])<br>运行程序，控制台输出结果如下：</p>
<p>1  60<br>2  75<br>3  34</p>
<h4 id="2-4-5-获取series索引和值"><a href="#2-4-5-获取series索引和值" class="headerlink" title="2.4.5 获取series索引和值"></a>2.4.5 获取series索引和值</h4><p>获取Series索引和值主要使用Series的index和values方法。</p>
<p>【示例08】　获取物理成绩的索引和值。（示例位置：资源包\MR\Code\03\08）下面使用Series的index和values方法获取物理成绩的索引和值，程序代码如下：</p>
<p>01 import pandas as pd<br>02 s1=pd.Series([88,60,75])<br>03 print(s1.index)<br>04 print(s1.values)<br>运行程序，控制台输出结果如下：</p>
<p>RangeIndex(start=0, stop=3, step=1)<br>[88 60 75]</p>
<h2 id="三-DataFrame对象"><a href="#三-DataFrame对象" class="headerlink" title="三. DataFrame对象"></a>三. DataFrame对象</h2><p>DataFrame是Pandas库中的一种数据结构，它是由多种类型的列组成的二维表数据结构，类似于Excel、SQL或Series对象构成的字典。DataFrame是最常用的Pandas对象，它与Series对象一样支持多种类型的数据。</p>
<h3 id="3-1-图解DataFrame对象"><a href="#3-1-图解DataFrame对象" class="headerlink" title="3.1　图解DataFrame对象"></a>3.1　图解DataFrame对象</h3><p>DataFrame是一个二维表数据结构，由行、列数据组成的表格。DataFrame既有行索引也有列索引，它可以看作是由Series对象组成的字典，不过这些Series对象共用一个索引，如图3.11所示。</p>
<p><img src="/.com//image-20211018042136168.png" alt="image-20211018042136168"></p>
<p>图3.11　DataFrame结构<br>处理DataFrame表格数据时，用index表示行或用columns表示列更直观。用这种方式迭代DataFrame的列，代码更易读懂。</p>
<p>【示例09】　遍历DataFrame数据。（示例位置：资源包\MR\Code\03\09）遍历DataFrame数据，输出成绩表的每一列数据，程序代码如下：</p>
<p><img src="/.com//image-20211018042332305.png" alt="image-20211018042332305"></p>
<p>运行程序，控制台输出结果如下：</p>
<p><img src="/.com//image-20211018042319399.png" alt="image-20211018042319399"></p>
<p>从运行结果得知，上述代码返回的其实是Series，如图3.12所示。Pandas之所以提供多种数据结构，其目的就是为了代码易读、操作更加方便。</p>
<p><img src="/.com//image-20211018042510540.png" alt="image-20211018042510540"></p>
<h3 id="3-2-创建一个DataFrame对象"><a href="#3-2-创建一个DataFrame对象" class="headerlink" title="3.2 创建一个DataFrame对象"></a>3.2 创建一个DataFrame对象</h3><p>创建DataFrame主要使用Pandas的DataFrame()方法，语法如下：</p>
<p>pandas.DataFrame(data,index,columns,dtype,copy)<br>参数说明：　</p>
<p>data：表示数据，可以是ndarray数组、Series对象、列表、字典等。　</p>
<p>index：表示行标签（索引）。</p>
<p>columns：列标签（索引）。　</p>
<p>dtype：每一列数据的数据类型，其与Python数据类型有所不同，如object数据类型对应的是Python的字符型。</p>
<p>表3.1为Pandas数据类型与Python数据类型的对应表。</p>
<p>​                                                                                          表3.1　数据类型对应表　</p>
<p><img src="/.com//image-20211018042916094.png" alt="image-20211018042916094"></p>
<p>copy：用于复制数据。　</p>
<p>返回值：DataFrame。<br>下面通过两种方法来创建DataFrame，即通过二维数组创建和通过字典创建。</p>
<p>1．通过二维数组创建DataFrame【示例10】　通过二维数组创建成绩表。（示例位置：资源包\MR\Code\03\10）<br>通过二维数组创建成绩表，包括语文、数学和英语，程序代码如下：</p>
<p><img src="/.com//image-20211018043105059.png" alt="image-20211018043105059"></p>
<p>运行程序，控制台输出结果如下：</p>
<p><img src="/.com//image-20211018043117683.png" alt="image-20211018043117683"></p>
<p>2．通过字典创建DataFrame<br>通过字典创建DataFrame，需要注意：字典中的value值只能是一维数组或单个的简单数据类型，如果是数组，要求所有数组长度一致；如果是单个数据，则每行都添加相同数据。</p>
<p>【示例11】　通过字典创建成绩表。（示例位置：资源包\MR\Code\03\11）通过字典创建成绩表，包括语文、数学、英语和班级，程序代码如下：</p>
<p><img src="/.com//image-20211018043238790.png" alt="image-20211018043238790"></p>
<p>运行程序，控制台输出结果如下：</p>
<p><img src="/.com//image-20211018043309599.png" alt="image-20211018043309599"></p>
<p>上述代码中，“班级”的value值是一个单个数据，所以每一行都添加了相同的数据“高一7班”。</p>
<h3 id="3-3-DataFrame重要属性和函数"><a href="#3-3-DataFrame重要属性和函数" class="headerlink" title="3.3 DataFrame重要属性和函数"></a>3.3 DataFrame重要属性和函数</h3><p>DataFrame是Pandas一个重要的对象，它的属性和函数很多，下面先简单了解DataFrame的几个重要属性和函数。重要属性介绍如表3.2所示，重要函数介绍如表3.3所示。</p>
<p>​                                                                                               表3.2　重要属性</p>
<p><img src="/.com//image-20211018043520943.png" alt="image-20211018043520943"></p>
<p>​                                                                                                  表3.3　重要函数</p>
<p><img src="/.com//image-20211018043534263.png" alt="image-20211018043534263"></p>
<h3 id="3-4-导入外部数据"><a href="#3-4-导入外部数据" class="headerlink" title="3.4 导入外部数据"></a>3.4 导入外部数据</h3><p>数据分析首先就要有数据。那么，数据类型有多种，本节介绍如何导入不同类型的外部数据。</p>
<h4 id="3-4-1-导入-xls或-xlsx文件"><a href="#3-4-1-导入-xls或-xlsx文件" class="headerlink" title="3.4.1　导入.xls或.xlsx文件"></a>3.4.1　导入.xls或.xlsx文件</h4><p>导入.xls或.xlsx文件主要使用Pandas的read_excel()方法，语法如下：</p>
<p>pandas.read_excel(io,sheet_name=0,header=0,names=None,index_col=None,usecols=None,squeeze=False,<br>dtype=None,engine=None,converters=None,true_values=None,false_values=None,skiprows=None,nrow=None,<br>na_values=None,keep_default_na=True,verbose=False,parse_dates=False,date_parser=None,thousands=None,<br>comment=None,skipfooter=0,conver_float=True,mangle_dupe_cols=True,**kwds)<br>常用参数说明：　</p>
<p>io：字符串，.xls或.xlsx文件路径或类文件对象。　</p>
<p>sheet_name：None、字符串、整数、字符串列表或整数列表，默认值为0。字符串用于工作表名称，整数为索引表示工作表位置，字符串列表或整数列表用于请求多个工作表，为None时获取所有工作表。参数值如表3.4所示。</p>
<p>​                                                                                     表3.4　sheet_name参数值　</p>
<p><img src="/.com//image-20211018043941426.png" alt="image-20211018043941426"></p>
<p>header：指定作为列名的行，默认值为0，即取第一行的值为列名。数据为除列名以外的数据；若数据不包含列名，则设置header=None。　</p>
<p>names：默认值为None，要使用的列名列表。　</p>
<p>index_col：指定列为索引列，默认值为None，索引0是DataFrame的行标签。</p>
<p>usecols：int、list列表或字符串，默认值为None。　如果为None，则解析所有列。　如果为int，则解析最后一列。　如果为list列表，则解析列号列表的列。　如果为字符串，则表示以逗号分隔的Excel列字母和列范围列表（例如“A:E”或“A,C,E:F”）。范围包括双方。　squeeze：布尔值，默认值为False，如果解析的数据只包含一列，则返回一个Series。　</p>
<p>dtype：列的数据类型名称或字典，默认值为None。例如{‘a’:np.float64,’b’:np.int32}。　</p>
<p>skiprows：省略指定行数的数据，从第一行开始。　</p>
<p>skipfooter：省略指定行数的数据，从尾部数的行开始。</p>
<p>下面通过示例，详细介绍如何导入.xlsx文件。</p>
<h5 id="1．常规导入导入Excel文件。"><a href="#1．常规导入导入Excel文件。" class="headerlink" title="1．常规导入导入Excel文件。"></a>1．常规导入导入Excel文件。</h5><p>【示例12】　（示例位置：资源包\MR\Code\03\12）导入“1月.xlsx”Excel文件，程序代码如下：</p>
<p>01 import pandas as pd<br>02 df=pd.read_excel(‘1 月.xlsx’)<br>03 df1=df.head()          #输出前5 条数据<br>运行程序，输出前5条数据，结果如图3.13所示。<br>图3.13　1月淘宝销售数据（前5条数据）</p>
<p><img src="/.com//image-20211018044223025.png" alt="image-20211018044223025"></p>
<p>知识胶囊<br>导入外部数据，必然要涉及路径问题，下面来了解一下相对路径和绝对路径。　</p>
<p><strong>相对路径</strong>：相对路径就是以当前文件为基准进行一级级目录指向被引用的资源文件。以下是常用的表示当前目录和当前目录的父级目录的标识符。　../：表示当前文件所在目录的上一级目录。　./：表示当前文件所在的目录（可以省略）。　/：表示当前文件的根目录（域名映射或硬盘目录）。　如果使用系统默认文件路径\，那么，在Python中则需要在路径最前面加一个r，以避免路径里面的\被转义。　</p>
<p><strong>绝对路径</strong>：绝对路径是文件真正存在的路径，是指从硬盘的根目录（盘符）开始，进行一级级目录指向文件。</p>
<h5 id="2．导入指定的Sheet页"><a href="#2．导入指定的Sheet页" class="headerlink" title="2．导入指定的Sheet页"></a>2．导入指定的Sheet页</h5><p>一个Excel文件包含多个Sheet页，通过设置sheet_name参数就可以导入指定Sheet页的数据。</p>
<p>【示例13】　导入指定Sheet页的数据。（示例位置：资源包\MR\Code\03\13）一个Excel文件包含多家店铺的销售数据，导入其中一家店铺（莫寒）的销售数据，如图3.14所示。<br>图3.14　原始数据</p>
<p><img src="/.com//image-20211018044701218.png" alt="image-20211018044701218"></p>
<p>程序代码如下：</p>
<p>01 import pandas as pd<br>02 df=pd.read_excel(‘1 月.xlsx’,sheet_name=’莫寒’)<br>03 df1=df.head()          #输出前5条数据<br>运行程序，输出前5条数据，结果如图3.15所示。<br>除了指定Sheet页的名字，还可以指定Sheet页的顺序，从0开始。例如，sheet_name=0表示导入第一个Sheet页的数据，sheet_name=1表示导入第二个Sheet页的数据，以此类推。<br>如果不指定sheet_name参数，则默认导入第一个Sheet页的数据。</p>
<h5 id="3．通过行、列索引导入指定行、列数据"><a href="#3．通过行、列索引导入指定行、列数据" class="headerlink" title="3．通过行、列索引导入指定行、列数据"></a>3．通过行、列索引导入指定行、列数据</h5><p>DataFrame是二维数据结构，因此它既有行索引又有列索引。当导入Excel数据时，行索引会自动生成，如0、1、2；而列索引则默认将第0行作为列索引（如A,B,…,J）。DataFrame行、列索引的示意图如图3.16所示。</p>
<p><img src="/.com//image-20211018044837800.png" alt="image-20211018044837800"></p>
<p>​                                                  </p>
<p>​                                                                            图3.15　导入指定的Sheet页（前5条数据） </p>
<p><img src="/.com//image-20211018044932996.png" alt="image-20211018044932996"></p>
<p>​                                                                                图3.16　DataFrame行、列索引示意图</p>
<p>【示例14】　指定行索引导入Excel数据。（示例位置：资源包\MR\Code\03\14）<br>如果通过指定行索引导入Excel数据，则需要设置index_col参数。下面将“买家会员名”作为行索引（位于第0列），导入Excel数据，程序代码如下：</p>
<p>01 import pandas as pd<br>02 df1=pd.read_excel(‘1 月.xlsx’,index_col=0)     #“买家会员名”为行索引<br>03 df1=df1.head()                                 #输出前5条数据<br>运行程序，输出结果如图3.17所示。</p>
<p><img src="/.com//image-20211018045103681.png" alt="image-20211018045103681"></p>
<p>图3.17　通过指定行索引导入Excel数据<br>如果通过指定列索引导入Excel数据，则需要设置header参数，主要代码如下：</p>
<p>df2=pd.read_excel(‘1月.xlsx’,header=1)        #设置第1行为列索引</p>
<p>运行程序，输出结果如图3.18所示。<br>如果将数字作为列索引，可以设置header参数为None，主要代码如下：</p>
<p>df3=pd.read_excel(‘1月.xlsx’,header=None)    #列索引为数字</p>
<p>运行程序，输出结果如图3.19所示。</p>
<p><img src="/.com//image-20211018045218250.png" alt="image-20211018045218250"></p>
<p>图3.18　通过指定列索引导入Excel数据</p>
<p><img src="/.com//image-20211018045231796.png" alt="image-20211018045231796"></p>
<p>图3.19　指定列索引<br>那么，为什么要指定索引呢？因为通过索引可以快速地检索数据，例如df3[0]，就可以快速检索到“买家会员名”这一列数据。</p>
<h5 id="4-导入指定列数据"><a href="#4-导入指定列数据" class="headerlink" title="4.导入指定列数据"></a>4.导入指定列数据</h5><p>一个Excel往往包含多列数据，如果只需要其中的几列，可以通过usecols参数指定需要的列，从0开始（表示第1列，以此类推）。</p>
<p>【示例15】　导入第1列数据。（示例位置：资源包\MR\Code\03\15）下面导入第1列数据（索引为0），程序代码如下：</p>
<p>01 import pandas as pd<br>02 df1=pd.read_excel(‘1 月.xlsx’,usecols=[0])       #导入第1列<br>03 df1.head()<br>运行程序，输出结果如图3.20所示。<br>如果导入多列，可以在列表中指定多个值。例如，导入第1列和第4列，主要代码如下：</p>
<p>df2=pd.read_excel(‘1月.xlsx’,usecols=[0,3])<br>也可以指定列名称，主要代码如下：</p>
<p>df3=pd.read_excel(‘1月.xlsx’,usecols=[‘买家会员名’,’宝贝标题’])<br>运行程序，输出结果如图3.21所示。</p>
<p><img src="/.com//image-20211018045614397.png" alt="image-20211018045614397"></p>
<p>​                                                                                               图3.20　导入第1列</p>
<p><img src="/.com//image-20211018045541729.png" alt="image-20211018045541729"></p>
<p>​                                                                                     图3.21　导入第1列和第4列数据</p>
<h4 id="3-4-2-导入-csv文件"><a href="#3-4-2-导入-csv文件" class="headerlink" title="3.4.2　导入.csv文件"></a>3.4.2　导入.csv文件</h4><p>导入.csv文件主要使用Pandas的read_csv()方法，语法如下：</p>
<p><img src="/.com//image-20211018045855117.png" alt="image-20211018045855117">常用参数说明：　</p>
<p>filepath_or_buffer：字符串，文件路径，也可以是URL链接。　</p>
<p>sep、delimiter：字符串，分隔符。</p>
<p>header：指定作为列名的行，默认值为0，即取第1行的值为列名。数据为除列名以外的数据；若数据不包含列名，则设置header=None。　</p>
<p>names：默认值为None，要使用的列名列表。　</p>
<p>index_col：指定列为索引列，默认值为None，索引0是DataFrame的行标签。　</p>
<p>usecols：int、list列表或字符串，默认值为None。　如果为None，则解析所有列。　如果为int，则解析最后一列。　如果为list列表，则解析列号列表的列。　如果为字符串，则表示以逗号分隔的Excel列字母和列范围列表（例如“A:E”或“A,C,E:F”）。范围包括双方。　dtype：列的数据类型名称或字典，默认值为None。例如{‘a’:np.float64,’b’:np.int32}。　</p>
<p>parse_dates：布尔类型值、int类型值的列表、列表或字典，默认值为False。可以通过parse_dates参数直接将某列转换成datetime64日期类型。例如，df1=pd.read_csv(‘1月.csv’, parse_dates=[‘订单付款时间’])。　</p>
<p>​        parse_dates为True时，尝试解析索引。　</p>
<p>​        parse_dates为int类型值组成的列表时，如[1,2,3]，则解析1、2、3列的值作为独立的日期列。　</p>
<p>​        parse_date为列表组成的列表，如[[1,3]]，则将1、3列合并，作为一个日期列使用。　</p>
<p>​        parse_date为字典时，如{‘总计’：[1, 3]}，则将1、3列合并，合并后的列名为“总计”。　</p>
<p>encoding：字符串，默认值为None，文件的编码格式。Python常用的编码格式是UTF-8。　返回值：返回一个DataFrame。</p>
<p>【示例16】　导入.csv文件。（示例位置：资源包\MR\Code\03\16）导入.csv文件，程序代码如下：</p>
<p>01 import pandas as pd<br>02 df1=pd.read_csv(‘1月.csv’,encoding=’gbk’)        #导入.csv文件，并指定编码格式<br>03 df1=df1.head()                                   #输出前5条数据<br>运行程序，输出结果如图3.22所示。</p>
<p><img src="/.com//image-20211018050346464.png" alt="image-20211018050346464">                                                  </p>
<p>​                                                                                            图3.22　导入.csv文件</p>
<p>注意<br>上述代码中指定了编码格式，即encoding=’gbk’。Python常用的编码格式是UTF-8和gbk，默认编码格式为UTF-8。导入.csv文件时，需要通过encoding参数指定编码格式。当将Excel文件另存为.csv文件时，默认编码格式为gbk，此时当编写代码导入.csv文件时，就需要设置编码格式为gbk，与源文件编码格式保持一致；否则会提示错误。</p>
<h4 id="3-4-3-导入-txt文本文件"><a href="#3-4-3-导入-txt文本文件" class="headerlink" title="3.4.3　导入.txt文本文件"></a>3.4.3　导入.txt文本文件</h4><p>导入.txt文件同样使用Pandas的read_csv()方法，不同的是需要指定sep参数（如制表符\t）。read_csv()方法读取.txt文件返回一个DataFrame，像表格一样的二维数据结构，如图3.23所示。</p>
<p>【示例17】　导入.txt文件。（示例位置：资源包\MR\Code\03\17）<br>下面使用read_csv()方法导入1月.txt文件，主要代码如下：</p>
<p>01 import pandas as pd<br>02 df1=pd.read_csv(‘1月.txt’,sep=’\t’,encoding=’gbk’)<br>03 print(df1.head())<br>运行程序，输出结果如图3.24所示。</p>
<p><img src="/.com//image-20211018050613488-16345047782181.png" alt="image-20211018050613488"></p>
<p>​                                                                                                        图3.23　.txt文件形式</p>
<p><img src="/.com//image-20211018050642828.png" alt="image-20211018050642828"></p>
<p>​                                                                                                         图3.24　导入.txt文本</p>
<h4 id="3-4-4-导入HTML网页"><a href="#3-4-4-导入HTML网页" class="headerlink" title="3.4.4　导入HTML网页"></a>3.4.4　导入HTML网页</h4><p>导入HTML网页数据主要使用Pandas的read_html()方法，该方法用于导入带有table标签的网页表格数据，语法如下：</p>
<p>pandas.read_html(io,match=’.+’,flavor=None,header=None,index_col=None,skiprows=None,attrs=None,parse_<br>dates=False,thousands=’,’,encoding=None,decimal=’.’,converters=None,na_values=None,keep_default_na=True,<br>displayed_only=True)<br>常用参数说明：　</p>
<p>io：字符串，文件路径，也可以是URL链接。网址不接受https，可以尝试去掉https中的s后爬取，如<a href="http://www.mingribook.com./">http://www.mingribook.com。</a></p>
<p>match：正则表达式，返回与正则表达式匹配的表格。　</p>
<p>flavor：解析器默认为lxml。　</p>
<p>header：指定列标题所在的行，列表list为多重索引。　</p>
<p>index_col：指定行标题对应的列，列表list为多重索引。　</p>
<p>encoding：字符串，默认为None，文件的编码格式。　</p>
<p>返回值：返回一个DataFrame。<br>使用read_html()方法前，首先要确定网页表格是否为table类型。例如，NBA球员薪资网页（<a href="http://www.espn.com/nba/salaries%EF%BC%89%EF%BC%8C%E5%8F%B3%E5%87%BB%E8%AF%A5%E7%BD%91%E9%A1%B5%E4%B8%AD%E7%9A%84%E8%A1%A8%E6%A0%BC%EF%BC%8C%E5%9C%A8%E5%BC%B9%E5%87%BA%E7%9A%84%E5%BF%AB%E6%8D%B7%E8%8F%9C%E5%8D%95%E4%B8%AD%E9%80%89%E6%8B%A9%E2%80%9C%E6%A3%80%E6%9F%A5%E5%85%83%E7%B4%A0%E2%80%9D%E5%91%BD%E4%BB%A4%EF%BC%8C%E6%9F%A5%E7%9C%8B%E4%BB%A3%E7%A0%81%E4%B8%AD%E6%98%AF%E5%90%A6%E5%90%AB%E6%9C%89%E8%A1%A8%E6%A0%BC%E6%A0%87%E7%AD%BE">http://www.espn.com/nba/salaries），右击该网页中的表格，在弹出的快捷菜单中选择“检查元素”命令，查看代码中是否含有表格标签</a><table>…</table>的字样，如图3.25所示。确定后才可以使用read_html()方法。</p>
<p><img src="/.com//image-20211018051003748.png" alt="image-20211018051003748"></p>
<p>​                                                                            图3.25　<table>…</table>表格标签</p>
<p>【示例18】　导入NBA球员薪资数据。（示例位置：资源包\MR\Code\03\18）<br>下面使用read_html()方法导入NBA球员薪资数据，程序代码如下：</p>
<p><img src="/.com//image-20211018051015470.png" alt="image-20211018051015470"></p>
<p>运行程序，输出结果如图3.26所示。</p>
<p><img src="/.com//image-20211018051117577.png" alt="image-20211018051117577"></p>
<p>​                                                                                              图3.26　导入网页数据注意<br>运行程序，如果出现ImportError: lxml not found, please install it错误提示信息，则需要安装lxml模块。</p>
<h3 id="3-5-数据抽取"><a href="#3-5-数据抽取" class="headerlink" title="3.5　数据抽取"></a>3.5　数据抽取</h3><p>数据分析过程中，并不是所有的数据都是我们想要的，此时可以抽取部分数据，主要使用DataFrame对象的loc属性和iloc属性，示意图如图3.27所示。</p>
<p><img src="/.com//image-20211018051225461.png" alt="image-20211018051225461">          </p>
<pre><code>                                                                                     图3.27　loc属性和iloc属性示意图
</code></pre>
<p>对象的loc属性和iloc属性都可以抽取数据，区别如下。　</p>
<p>loc属性：以列名（columns）和行名（index）作为参数，当只有一个参数时，默认是行名，即抽取整行数据，包括所有列，如df.loc[‘A’]。　</p>
<p>iloc属性：以行和列位置索引（即0，1，2，…)作为参数，0表示第1行，1表示第2行，以此类推。当只有一个参数时，默认是行索引，即抽取整行数据，包括所有列。如抽取第1行数据，df.iloc[0]。</p>
<h4 id="3-5-1-抽取一行数据"><a href="#3-5-1-抽取一行数据" class="headerlink" title="3.5.1　抽取一行数据"></a>3.5.1　抽取一行数据</h4><p>抽取一行数据主要使用loc属性。【</p>
<p>示例19】　抽取一行考试成绩数据。（示例位置：资源包\MR\Code\03\19）抽取一行名为“明日”的考试成绩数据（包括所有列），程序代码如下：</p>
<p><img src="/.com//image-20211018051358694.png" alt="image-20211018051358694">运行程序，输出结果如图3.28所示。<br>使用iloc属性抽取第1行数据，指定行索引即可，如df.iloc[0]，输出结果同图3.28一样。</p>
<p><img src="/.com//image-20211018051441548.png" alt="image-20211018051441548"></p>
<p>​                                                                                                                图3.28　抽取一行数据</p>
<h4 id="3-5-2-抽取多行数据"><a href="#3-5-2-抽取多行数据" class="headerlink" title="3.5.2　抽取多行数据"></a>3.5.2　抽取多行数据</h4><p>1．抽取任意多行数据<br>通过loc属性和iloc属性指定行名和行索引即可实现抽取任意多行数据。</p>
<p>【示例20】　抽取多行考试成绩数据。（示例位置：资源包\MR\Code\03\20）抽取行名为“明日”和“高袁圆”（即第1行和第3行数据）的考试成绩数据，可以使用loc属性，也可以使用iloc属性，其输出结果都是一样的，主要代码如下：</p>
<p>01 df1=df.loc[[‘明日’,’高袁圆’]]<br>02 df1=df.iloc[[0,2]]<br>运行程序，输出结果如图3.29所示。</p>
<p><img src="/.com//image-20211018051606515.png" alt="image-20211018051606515"></p>
<p>​                                                                                                图3.29　抽取多行数据<br>2．抽取连续任意多行数据<br>在loc属性和iloc属性中合理地使用冒号（:），即可抽取连续任意多行数据。</p>
<p>【示例21】　抽取连续几个学生的考试成绩。（示例位置：资源包\MR\Code\03\21）抽取连续几个学生的考试成绩，主要代码如下：</p>
<p><img src="/.com//image-20211018051735968.png" alt="image-20211018051735968"></p>
<p>运行程序，控制台输出结果如图3.30所示。</p>
<p><img src="/.com//image-20211018051746750.png" alt="image-20211018051746750"></p>
<p>​                                                                                 图3.30　抽取连续任意多行数据</p>
<h4 id="3-5-3-抽取指定列数据"><a href="#3-5-3-抽取指定列数据" class="headerlink" title="3.5.3　抽取指定列数据"></a>3.5.3　抽取指定列数据</h4><p>抽取指定列数据，可以直接使用列名，也可以使用loc属性和iloc属性。<br>1．直接使用列名【示例22】　抽取“语文”和“数学”的考试成绩。（示例位置：资源包\MR\Code\03\22）<br>抽取列名为“语文”和“数学”的考试成绩数据，程序代码如下：</p>
<p><img src="/.com//image-20211018051846594.png" alt="image-20211018051846594"></p>
<p>运行程序，输出结果如图3.31所示。</p>
<p>2．使用loc属性和iloc属性<br>前面介绍loc属性和iloc属性均有两个参数：第一个参数代表行；第二个参数代表列。那么这里抽取指定列数据时，行参数不能省略。</p>
<p>【示例23】　抽取指定学科的考试成绩。（示例位置：资源包\MR\Code\03\23）<br>下面使用loc属性和iloc属性抽取指定列数据，主要代码如下：</p>
<p><img src="/.com//image-20211018052009426.png" alt="image-20211018052009426"></p>
<p>运行程序，控制台输出结果如图3.32所示。</p>
<p><img src="/.com//image-20211018052021825.png" alt="image-20211018052021825"></p>
<p>​                                                                                      图3.31　直接使用列名</p>
<p><img src="/.com//image-20211018052041459.png" alt="image-20211018052041459"></p>
<p>​                                                                                          图3.32　loc属性和iloc属性</p>
<h4 id="3-5-4-抽取指定行、列数据"><a href="#3-5-4-抽取指定行、列数据" class="headerlink" title="3.5.4　抽取指定行、列数据"></a>3.5.4　抽取指定行、列数据</h4><p>抽取指定行、列数据主要使用loc属性和iloc属性，这两个方法的两个参数都指定就可以实现指定行、列数据的抽取。</p>
<p>【示例24】　抽取指定学科和指定学生的考试成绩。（示例位置：资源包\MR\Code\03\24）使用loc属性和iloc属性抽取指定行、列数据，程序代码如下：</p>
<p><img src="/.com//image-20211018052200474.png" alt="image-20211018052200474"></p>
<p>运行程序，控制台输出结果如图3.33所示。</p>
<p><img src="/.com//image-20211018052214525.png" alt="image-20211018052214525"></p>
<pre><code>                                                                               图3.33　抽取指定行、列数据
</code></pre>
<p>在上述结果中，第一个输出结果是一个数，不是数据，是由于“df.loc[‘七月流火’,’英语’]”没有使用方括号[]，导致输出的数据不是DataFrame类型。</p>
<h4 id="3-5-5-按指定条件抽取数据"><a href="#3-5-5-按指定条件抽取数据" class="headerlink" title="3.5.5　按指定条件抽取数据"></a>3.5.5　按指定条件抽取数据</h4><p>DataFrame对象实现数据查询有以下3种方式。　取其中的一个元素.iat[x,x]。　基于位置的查询，如.iloc[]、iloc[2,1]。　基于行、列名称的查询，如.loc[x]。</p>
<p>【示例25】　抽取指定学科和指定分数的数据。（示例位置：资源包\MR\Code\03\25）抽取语文成绩大于105，数学成绩大于88的数据，程序代码如下：</p>
<p><img src="/.com//image-20211018052322850.png" alt="image-20211018052322850"></p>
<p>运行程序，输出结果如图3.34所示。</p>
<p><img src="/.com//image-20211018052523463.png" alt="image-20211018052523463">   </p>
<p>​                                                                                             图3.34　按指定条件抽取数据</p>
<h3 id="3-6-数据的增加、修改和删除"><a href="#3-6-数据的增加、修改和删除" class="headerlink" title="3.6　数据的增加、修改和删除"></a>3.6　数据的增加、修改和删除</h3><p>本节主要介绍如何操纵DataFrame对象中的各种数据。例如，数据的增加、修改和删除。</p>
<h4 id="3-6-1-增加数据"><a href="#3-6-1-增加数据" class="headerlink" title="3.6.1　增加数据"></a>3.6.1　增加数据</h4><p>DataFrame对象增加数据主要包括列数据增加和行数据增加。首先看一下原始数据，如图3.35所示。</p>
<p><img src="/.com//image-20211018052637063.png" alt="image-20211018052637063"></p>
<p>图3.35　原始数据</p>
<h5 id="1．按列增加数据"><a href="#1．按列增加数据" class="headerlink" title="1．按列增加数据"></a>1．按列增加数据</h5><p>按列增加数据，可以通过以下3种方式实现。<br>（1）直接为DataFrame对象赋值</p>
<p>【示例26】　增加一列“物理”成绩。（示例位置：资源包\MR\Code\03\26）<br>增加一列“物理”成绩，程序代码如下：</p>
<p><img src="/.com//image-20211018052702267.png" alt="image-20211018052702267"></p>
<p>运行程序，输出结果如图3.36所示。</p>
<p><img src="/.com//image-20211018052756371.png" alt="image-20211018052756371"></p>
<p>​                                                                                   图3.36　按列增加数据<br>（2）使用loc属性在DataFrame对象的最后增加一列</p>
<p>【示例27】　使用loc属性增加一列“物理”成绩。（示例位置：资源包\MR\Code\03\27）使用loc属性在DataFrame对象的最后增加一列。例如，增加“物理”一列，主要代码如下：</p>
<p>df.loc[:,’物理’] = [88,79,60,50]<br>在DataFrame对象最后增加一列“物理”，其值为等号右边数据。</p>
<p>（3）在指定位置插入一列<br>在指定位置插入一列，主要使用insert()方法。</p>
<p>【示例28】　在第1列后面插入“物理”成绩。（示例位置：资源包\MR\Code\03\28）<br>例如，在第1列后面插入“物理”，其值为wl的数值，主要代码如下：</p>
<p>01 wl =[88,79,60,50]<br>02 df.insert(1,’物理’,wl)<br>运行程序，输出结果如图3.37所示。</p>
<p><img src="/.com//image-20211018052920670.png" alt="image-20211018052920670"></p>
<p>​                                                                                                图3.37　使用insert()方法增加一列</p>
<h5 id="2．按行增加数据"><a href="#2．按行增加数据" class="headerlink" title="2．按行增加数据"></a>2．按行增加数据</h5><p>按行增加数据，可以通过以下两种方式实现。<br>（1）增加一行数据<br>增加一行数据主要使用loc属性实现。</p>
<p>【示例29】　在成绩表中增加一行数据。（示例位置：资源包\MR\Code\03\29）在成绩表中增加一行数据，即“钱多多”同学的成绩，主要代码如下：</p>
<p>df.loc[‘钱多多’] = [100,120,99]<br>（2）增加多行数据</p>
<p>增加多行数据主要使用字典结合append()方法实现。</p>
<p>【示例30】　在原有数据中增加几名同学的考试成绩。（示例位置：资源包\MR\Code\03\30）在原有数据中增加“钱多多”“童年”“无名”同学的考试成绩，主要代码如下：</p>
<p>01 df_insert=pd.DataFrame({‘语文’:[100,123,138],’数学’:[99,142,60],’英语’:[98,139,99]},index = [‘钱多多’,’童年’,’无名’])<br>02 df1 = df.append(df_insert)<br>运行程序，输出结果分别如图3.38和图3.39所示。</p>
<p><img src="/.com//image-20211018053145141.png" alt="image-20211018053145141"></p>
<p>​                                                                                       图3.38　增加一行数据</p>
<p><img src="/.com//image-20211018053204251.png" alt="image-20211018053204251"></p>
<p>​                                                                                        图3.39　增加多行数据</p>
<h4 id="3-6-2-修改数据"><a href="#3-6-2-修改数据" class="headerlink" title="3.6.2　修改数据"></a>3.6.2　修改数据</h4><p>修改数据包括行、列标题和数据的修改，首先看一下原始数据，如图3.40所示。</p>
<p><img src="/.com//image-20211018053230905.png" alt="image-20211018053230905"></p>
<p>​                                                                                               图3.40　原始数据</p>
<h5 id="1．修改列标题"><a href="#1．修改列标题" class="headerlink" title="1．修改列标题"></a>1．修改列标题</h5><p>修改列标题主要使用DataFrame对象的cloumns属性，直接赋值即可。</p>
<p>【示例31】　修改“数学”的列名。（示例位置：资源包\MR\Code\03\31）将“数学”修改为“数学（上）”，主要代码如下：</p>
<p>df.columns=[‘语文’,’数学（上）’,’英语’]</p>
<p>上述代码中，即使只修改“数学”为“数学（上）”，但是也要将所有列的标题全部写上；否则将报错。<br>下面再介绍一种方法，使用DataFrame对象的rename()方法修改列标题。</p>
<p>【示例32】　修改多个学科的列名。（示例位置：资源包\MR\Code\03\32）将“语文”修改为“语文（上）”、“数学”修改为“数学（上）”、“英语”修改为“英语（上）”，主要代码如下：</p>
<p>df.rename(columns = {‘语文’:’语文（上）’,’数学’:’数学（上）’,’英语’:’英语（上）’},inplace = True)</p>
<p>上述代码中，参数inplace为True，表示直接修改df；否则，不修改df，只返回修改后的数据。<br>运行程序，输出结果分别如图3.41和图3.42所示。</p>
<h5 id="2．修改行标题"><a href="#2．修改行标题" class="headerlink" title="2．修改行标题"></a>2．修改行标题</h5><p>修改行标题主要使用DataFrame对象的index属性，直接赋值即可。【示例33】　将行标题统一修改为数字编号。（示例位置：资源包\MR\Code\03\33）<br>将行标题统一修改为数字编号，主要代码如下：</p>
<p>df.index=list(‘1234’)</p>
<p><img src="/.com//image-20211018053500036.png" alt="image-20211018053500036"></p>
<p>​                                                                                         图3.41　修改列标题1</p>
<p><img src="/.com//image-20211018053517247.png" alt="image-20211018053517247"></p>
<p>​                                                                                                 图3.42　修改列标题2</p>
<p>使用DataFrame对象的rename()方法也可以修改行标题。例如，将行标题统一修改为数字编号，主要代码如下：</p>
<p>df.rename({‘明日’:1,’七月流火’:2,’高袁圆’:3,’二月二’:4},axis=0,inplace = True)</p>
<h5 id="3．修改数据"><a href="#3．修改数据" class="headerlink" title="3．修改数据"></a>3．修改数据</h5><p>修改数据主要使用DataFrame对象的loc属性和iloc属性。</p>
<p>【示例34】　修改学生成绩数据。（示例位置：资源包\MR\Code\03\34）<br>（1）修改整行数据<br>例如，修改“明日”同学的各科成绩，主要代码如下：</p>
<p>df.loc[‘明日’]=[120,115,109]<br>如果各科成绩均加10分，可以直接在原有值上加10，主要代码如下：</p>
<p>df.loc[‘明日’]=df.loc[‘明日’]+10<br>（2）修改整列数据<br>例如，修改所有同学的“语文”成绩，主要代码如下：</p>
<p>df.loc[:,’语文’]=[115,108,112,118]<br>（3）修改某一数据</p>
<p>例如，修改“明日”同学的“语文”成绩，主要代码如下：</p>
<p>df.loc[‘明日’,’语文’]=115<br>（4）使用iloc属性修改数据<br>通过iloc属性指定行、列位置实现修改数据，主要代码如下：</p>
<p>01 df.iloc[0,0]=115                        #修改某一数据<br>02 df.iloc[:,0]=[115,108,112,118]          #修改整列数据<br>03 df.iloc[0,:]=[120,115,109]              #修改整行数据</p>
<h4 id="3-6-3-删除数据"><a href="#3-6-3-删除数据" class="headerlink" title="3.6.3　删除数据"></a>3.6.3　删除数据</h4><p>删除数据主要使用DataFrame对象的drop()方法。语法如下：</p>
<p>DataFrame.drop(labels=None, axis=0, index=None, columns=None, level=None, inplace=False, errors=’raise’)<br>参数说明：　</p>
<p>labels：表示行标签或列标签。　</p>
<p>axis：axis = 0，表示按行删除；</p>
<p>​            axis = 1，表示按列删除。默认值为0，即按行删除。　</p>
<p>index：删除行，默认值为None。　</p>
<p>columns：删除列，默认值为None。</p>
<p>level：针对有两级索引的数据。level = 0，表示按第1级索引删除整行；level = 1表示按第2级索引删除整行，默认值为None。　inplace：可选参数，对原数组做出修改并返回一个新数组。默认值为False，如果值为True，那么原数组直接就被替换。　</p>
<p>errors：参数值为ignore或raise，默认值为raise，如果值为ignore（忽略），则取消错误。</p>
<h5 id="1．删除行、列数据"><a href="#1．删除行、列数据" class="headerlink" title="1．删除行、列数据"></a>1．删除行、列数据</h5><p>【示例35】　删除学生成绩数据。（示例位置：资源包\MR\Code\03\35）<br>删除指定的学生成绩数据，主要代码如下：</p>
<p><img src="/.com//image-20211018054027938.png" alt="image-20211018054027938"></p>
<h5 id="2．删除特定条件的行"><a href="#2．删除特定条件的行" class="headerlink" title="2．删除特定条件的行"></a>2．删除特定条件的行</h5><p>删除满足特定条件的行，首先找到满足该条件的行索引，然后再使用drop()方法将其删除。</p>
<p>【示例36】　删除符合条件的学生成绩数据。（示例位置：资源包\MR\Code\03\36）<br>删除“数学”成绩中包含88的行、“语文”成绩中小于110的行，主要代码如下：</p>
<p>01 df.drop(index=df[df[‘数学’].isin([88])].index[0],inplace=True)      #删除“数学”成绩中包含88的行<br>02 df.drop(index=df[df[‘语文’]&lt;110].index[0],inplace=True)             #删除“语文”成绩中小于110的行说明<br>以上代码中的方法都可以实现删除指定的行、列数据，读者选择一种即可。</p>
<h3 id="3-7-数据清洗"><a href="#3-7-数据清洗" class="headerlink" title="3.7　数据清洗"></a>3.7　数据清洗</h3><h4 id="3-7-1-缺失值查看与处理"><a href="#3-7-1-缺失值查看与处理" class="headerlink" title="3.7.1　缺失值查看与处理"></a>3.7.1　缺失值查看与处理</h4><p>缺失值是指由于某种原因导致数据为空，这种情况一般有不处理、删除、填充／替换、插值（以均值／中位数／众数等填补）这4种处理方式。</p>
<h5 id="1．缺失值查看"><a href="#1．缺失值查看" class="headerlink" title="1．缺失值查看"></a>1．缺失值查看</h5><p>首先需要找到缺失值，主要使用DataFrame对象的info()方法。</p>
<p>【示例37】　查看数据概况。（示例位置：资源包\MR\Code\03\37）以淘宝销售数据为例，首先输出数据，然后使用info()方法查看数据，程序代码如下：</p>
<p>01 import pandas as pd<br>02 df=pd.read_excel(‘TB2018.xls’)<br>03 print(df)<br>04 print(df.info())</p>
<p>运行程序，控制台输出结果如图3.43所示。</p>
<p><img src="/.com//image-20211018054304916.png" alt="image-20211018054304916"></p>
<p>图3.43　缺失值查看<br>在Python中，缺失值一般用NaN表示，如图3.43所示。通过info()方法可看到“买家会员名”“买家实际支付金额”“宝贝标题”“订单付款时间”的非空数量是10，而“宝贝总数量”和“类别”的非空数量是8，那么说明这两项存在空值。</p>
<p>【示例38】　判断数据是否存在缺失值。（示例位置：资源包\MR\Code\03\38）<br>接下来，判断数据是否存在缺失值还可以使用isnull()方法和notnull()方法，主要代码如下：</p>
<p>01  print(df.isnull())<br>02  print(df.notnull())<br>运行程序，控制台输出结果如图3.44所示。</p>
<p><img src="/.com//image-20211018054406384.png" alt="image-20211018054406384"></p>
<p>​                                                                                              图3.44　判断缺失值<br>使用isnull()方法缺失值返回True，非缺失值返回False；而notnull()方法与isnull()方法正好相反，缺失值返回False，非缺失值返回True。<br>如果使用df[df.isnull() == False]，</p>
<p>则会将所有非缺失值的数据找出来，只针对Series对象。</p>
<h5 id="2．缺失值删除处理"><a href="#2．缺失值删除处理" class="headerlink" title="2．缺失值删除处理"></a>2．缺失值删除处理</h5><p>通过前面的判断得知数据缺失情况，下面将缺失值删除，主要使用dropna()方法，该方法用于删除含有缺失值的行，主要代码如下：</p>
<p>df1=df.dropna()<br>运行程序，输出结果如图3.45所示。说明<br>有些时候数据可能存在整行为空的情况，此时可以在dropna()方法中指定参数how=’all’，删除所有空行。</p>
<p><img src="/.com//image-20211018054531853.png" alt="image-20211018054531853"></p>
<p>​                                                                                   图3.45　缺失值删除处理1<br>从运行结果得知：dropna()方法将所有包含缺失值的数据全部删除了。那么，此时如果我们认为有些数据虽然存在缺失值，但是不影响数据分析，那么可以使用以下方法处理。例如，上述数据中只保留“宝贝总数量”不存在缺失值的数据，而类别是否缺失不关注，则可以使用notnull()方法判断，主要代码如下：</p>
<p>df2=df[df[‘宝贝总数量’].notnull()]<br>运行程序，输出结果如图3.46所示。</p>
<p><img src="/.com//image-20211018054627170.png" alt="image-20211018054627170"></p>
<p>图3.46　缺失值删除处理2</p>
<h5 id="3．缺失值填充处理"><a href="#3．缺失值填充处理" class="headerlink" title="3．缺失值填充处理"></a>3．缺失值填充处理</h5><p>对于缺失数据，如果比例高于30%可以选择放弃这个指标，做删除处理；低于30%尽量不要删除，而是选择将这部分数据填充，一般以0、均值、众数（大多数）填充。DataFrame对象中的fillna()函数可以实现填充缺失数据，pad/ffill表示用前一个非缺失值去填充该缺失值；backfill/bfill表示用下一个非缺失值填充该缺失值；None用于指定一个值去替换缺失值。</p>
<p>【示例39】　将NaN填充为0。（示例位置：资源包\MR\Code\03\39）对于用于计算的数值型数据如果为空，可以选择用0填充。例如，将“宝贝总数量”为空的数据填充为0，主要代码如下：</p>
<p>df[‘宝贝总数量’] = df[‘宝贝总数量’].fillna(0)<br>运行程序，输出结果如图3.47所示。</p>
<p><img src="/.com//image-20211018054749852.png" alt="image-20211018054749852"></p>
<h1 id="replace"><a href="#replace" class="headerlink" title="replace()"></a>replace()</h1><p>既可以替换某列，也可以替换某行，还可以全表替换</p>
<p>df.replace() 或者 df[col]replace()</p>
<pre><code>#参数如下：
df.replace(to_replace=None, value=None, inplace=False, limit=None, regex=False, method=&#39;pad&#39;,)
</code></pre>
<h1 id="参数说明："><a href="#参数说明：" class="headerlink" title="参数说明："></a>参数说明：</h1><ul>
<li>to_replace：被替换的值</li>
<li>value：替换后的值</li>
<li>inplace：是否要改变原数据，False是不改变，True是改变，默认是False</li>
<li>limit：控制填充次数</li>
<li>regex：是否使用正则,False是不使用，True是使用，默认是False</li>
<li>method：填充方式，pad,ffill,bfill分别是向前、向前、向后填充</li>
</ul>
<p>​                                                                                           图3.47　缺失值填充处理</p>
<h4 id="3-7-2-重复值处理"><a href="#3-7-2-重复值处理" class="headerlink" title="3.7.2　重复值处理"></a>3.7.2　重复值处理</h4><p>对于数据中存在的重复数据，包括重复的行或者几行中某几列的值重复一般做删除处理，主要使用DataFrame对象的drop_duplicates()方法。</p>
<p>【示例40】　处理淘宝电商销售数据中的重复数据。（示例位置：资源包\MR\Code\03\40）下面以“1月.xlsx”淘宝销售数据为例，对其中的重复数据进行处理。<br>（1）判断每一行数据是否重复（完全相同），主要代码如下：</p>
<p>df1.duplicated()<br>如果返回值为False表示不重复，返回值为True表示重复。<br>（2）去除全部的重复数据，主要代码如下：</p>
<p>df1.drop_duplicates()<br>（3）去除指定列的重复数据，主要代码如下：</p>
<p>df1.drop_duplicates([‘买家会员名’])<br>（4）保留重复行中的最后一行，主要代码如下：</p>
<p>df1.drop_duplicates([‘买家会员名’],keep=’last’)说明<br>以上代码中参数keep的值有3个。当keep=’first’表示保留第一次出现的重复行，是默认值；当keep为另外两个取值，即last和False时，分别表示保留最后一次出现的重复行和去除所有重复行。<br>（5）直接删除，保留一个副本，主要代码如下：</p>
<p>df1.drop_duplicates([‘买家会员名’,’买家支付宝账号’],inplace=Fasle)<br>inplace=True表示直接在原来的DataFrame上删除重复项，而默认值False表示删除重复项后生成一个副本。</p>
<h4 id="3-7-3-异常值的检测与处理"><a href="#3-7-3-异常值的检测与处理" class="headerlink" title="3.7.3　异常值的检测与处理"></a>3.7.3　异常值的检测与处理</h4><p>首先了解一下什么是异常值。在数据分析中异常值是指超出或低于正常范围的值，如年龄大于200、身高大于3米、宝贝总数量为负数等类似数据。那么这些数据如何检测呢？主要有以下几种方法。<br>（1）根据给定的数据范围进行判断，不在范围内的数据视为异常值。<br>（2）均方差。<br>在统计学中，如果一个数据分布近似正态分布（数据分布的一种形式，正态分布的概率密度函数曲线呈钟形，两头低、中间高、左右对称，因此人们又经常称之为钟形曲线），那么大约68%的数据值会在均值的一个标准差范围内，大约95%会在两个标准差范围内，大约99.7%会在3个标准差范围内。<br>（3）箱形图。<br>箱形图是显示一组数据分散情况资料的统计图。它可以将数据通过四分位数的形式进行图形化描述。箱形图通过上限和下限作为数据分布的边界。任何高于上限或低于下限的数据都可以认为是异常值，如图3.48所示。</p>
<p><img src="/.com//image-20211018055103761.png" alt="image-20211018055103761"></p>
<p>​                                                                                            图3.48　箱形图说明<br>有关箱形图的介绍以及如何通过箱形图识别异常值可参见第6章。<br>了解了异常值的检测，接下来介绍如何处理异常值，主要包括以下几种处理方式。<br>（1）最常用的方式是删除。<br>（2）将异常值当缺失值处理，以某个值填充。<br>（3）将异常值当特殊情况进行分析，研究异常值出现的原因。</p>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
  </entry>
  <entry>
    <title>React context</title>
    <url>/2021/05/16/React-context/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li><code>React</code> 组件之间的通信是基于 <code>props</code> 的单向数据流，即父组件通过 <code>props</code> 向子组件传值，亦或是子组件执行传入的函数来更新父组件的<code>state</code>，这都满足了我们大部分的使用场景</li>
<li>一般地，对于兄弟组件之间的通信，是通过它们共同的祖先组件进行的，即 Lifting State Up，官方文档也有介绍。组件一通过事件将状态变更通知它们共同的祖先组件，祖先组再将状态同步到组件二</li>
<li>但是，如果组件之间嵌套的比较深，即使提升状态到共同父组件，再同步状态到相应的组件还是需要一层一层的传递下去，可能会比较繁琐</li>
<li>在对应的场景中，<code>context</code> 就可以缩短父组件到子组件的属性传递路径</li>
</ul>
<h2 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h2><pre><code>import Parent from &#39;./Parent&#39;
import ChildOne from &#39;../components/ChildOne&#39;
import ChildTwo from &#39;../components/ChildTwo&#39;

export default class Container extends React.Component &#123;
    constructor(props) &#123;
        super(props);
        this.state = &#123; value: &#39;&#39; &#125;
    &#125;

    changeValue = value =&gt; &#123;
        this.setState(&#123; value &#125;)
    &#125;

    getChildContext() &#123;
        return &#123;
            value: this.state.value,
            changeValue: this.changeValue
        &#125;
    &#125;

    render() &#123;
        return (
            &lt;div&gt;
                &lt;Parent&gt;
                    &lt;ChildOne /&gt;
                &lt;/Parent&gt;
                &lt;Parent&gt;
                    &lt;ChildTwo /&gt;
                &lt;/Parent&gt;
            &lt;/div&gt;
        )
    &#125;
&#125;

Container.childContextTypes = &#123;
    value: PropTypes.string,
    changeValue: PropTypes.func
&#125;
</code></pre>
<p>Parent.jsx</p>
<pre><code>import React from &quot;react&quot;

const Parent = (props) =&gt; (
    &lt;div &#123;...props&#125; /&gt;
)

export default Parent
</code></pre>
<p>ChildOne.jsx</p>
<pre><code>export default class ChildOne extends React.Component &#123;

    handleChange = (e) =&gt; &#123;
        const &#123; changeValue &#125; = this.context
        changeValue(e.target.value)
    &#125;

    render() &#123;
        return (
            &lt;div&gt;
                子组件一
                &lt;input onChange=&#123;this.handleChange&#125; /&gt;
            &lt;/div&gt;
        )
    &#125;
&#125;

ChildOne.contextTypes = &#123;
    changeValue: PropTypes.func
&#125;
</code></pre>
<p>ChildTwo.jsx</p>
<pre><code>export default class ChildTwo extends React.Component &#123;
    render() &#123;
        return (
            &lt;div&gt;
                子组件二
                &lt;p&gt;&#123;this.context.value&#125;&lt;/p&gt;
            &lt;/div&gt;
        )
    &#125;
&#125;

ChildTwo.contextTypes = &#123;
    value: PropTypes.string
&#125;
</code></pre>
<blockquote>
<p>在 <code>Container.childContextTypes</code> 中进行接口的声明，通过 <code>getChildContext</code> 返回更新后的<code>state</code>，在 <code>Child.contextTypes</code> 中声明要获取的接口，这样在子组件内部就能通过 <code>this.context</code> 获取到。通过 <code>Context</code> 这样一个中间对象，<code>ChildOne</code> 和 <code>ChildTwo</code> 就可以相互通信了</p>
</blockquote>
<h2 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h2><blockquote>
<p>组件嵌套传递属性，在导航里面引用<code>Page</code>中的变量</p>
</blockquote>
<ul>
<li>使用<code>context</code>来传递</li>
<li>使用props层级传递</li>
</ul>
<blockquote>
<p>使用<code>context</code>组件需要定义<code>propTypes</code>,需要严格校验、声明类型、字段</p>
</blockquote>
<pre><code>class Page extends React.Component &#123;
    static childContextTypes = &#123;
       user:PropTypes.string
    &#125;
    constructor(props)&#123;
        super(props)
        this.state = &#123;user:&#39;poetries&#39;&#125;
    &#125;
    getChildContext()&#123;
        return this.state
    &#125;
    render()&#123;
        return (
          &lt;div&gt;
            &lt;p&gt;我是&#123;this.state.user&#125;&lt;/p&gt;
            &lt;Siderbar /&gt;
          &lt;/div&gt;
        )
    &#125;
&#125;

class Siderbar extends React.Component &#123;
    static childContextTypes = &#123;
       user:PropTypes.string
    &#125;
    render()&#123;
        return (
          &lt;div&gt;
            &lt;p&gt;侧边栏&lt;/p&gt;
            &lt;Navbar /&gt;
          &lt;/div&gt;
        )
    &#125;
&#125;
class Navbar extends React.Component &#123;
    static childContextTypes = &#123;
       user:PropTypes.string
    &#125;
    render()&#123;
        return (
          &lt;div&gt;
            &lt;p&gt;我是&#123;this.context.user&#125;的导航栏&lt;/p&gt;
            &lt;Siderbar /&gt;
          &lt;/div&gt;
        )
    &#125;
&#125;
</code></pre>
<h2 id="context在Provider种应用"><a href="#context在Provider种应用" class="headerlink" title="context在Provider种应用"></a>context在Provider种应用</h2><blockquote>
<pre><code>provider`组件就是使用`context`，把`store`放到`context`里，所有的子元素可以直接取到`store
</code></pre>
</blockquote>
<pre><code>import PropTypes from &#39;prop-types&#39;
class Provider extends Component &#123;
    static childContextTypes = &#123;
        store:Protypes.object
    &#125;
    constructor(props,context)&#123;
        super(props,context)
        this.store = props.store
    &#125;
    getChildContext()&#123;
        //把传进来的store放进全局
        return &#123;store:this.store&#125;
    &#125;
    render()&#123;
        return this.props.children
    &#125;
&#125;
</code></pre>
<blockquote>
<p><code>connect</code> 负责连接组件，给到<code>redux</code>里的数据放到组件的属性里</p>
</blockquote>
<ul>
<li>负责接收一个组件，把<code>state</code>里的一些数据放进去，返回一个组件</li>
<li>数据变化的时候，能够通知组件</li>
</ul>
<pre><code>//高阶组件写法
const connect = (mapStateToProps=state=&gt;state,mapDispatchToProps=&#123;&#125;)=&gt;(wrapperComponent)=&gt;&#123;
    return class ConnectComponent extends React.Component &#123;
        //负责接收组件
        static contextTypes = &#123;
            store:PropTypes.obejct
        &#125;
        constructor(props)&#123;
            super(props, context)&#123;
                this.state = &#123;
                    props:&#123;&#125;
                &#125;
            &#125;
        &#125;
        componentDidMount()&#123;
            const &#123;store&#125; = this.context
            store.subscribe(()=&gt;this.update())
            this.update()
        &#125;
        update()&#123;
            //  获取mapStateToProps、mapDispatchToProps 放入this.props里
            
            const &#123;store&#125;=this.context
            const stateProps = mapStateToProps(store.getState())
            const dispatchProps = bindActionCreators(mapDispatchProps,store.dispatch)
            this.setState(&#123;
                props:&#123;
                    ...this.state.props,
                    ...stateProps,
                    ...dispatchProps
                 &#125;
            &#125;)
        &#125;
        render()&#123;
            // 把数据放入
            return &lt;wrapperComponent &#123;...this.state.props&#125;/&gt;
        &#125;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React新特性</title>
    <url>/2021/04/08/React-%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<p><strong>react 16给我们带来的一些列重要变化</strong></p>
<ul>
<li><code>render</code>/纯组件能够<code>return</code>任何数据结构，以及<code>CreatePortal Api</code></li>
<li>新的<code>context api</code>，尝试代替一部分<code>redux</code>的职责</li>
<li><code>babel</code>的<code>&lt;&gt;</code>操作符，方便用户返回数组</li>
<li>异步渲染/时间切片(time slicing)，成倍提高性能</li>
<li><code>componentDidCatch</code>，错误边界，框架层面上提高用户<code>debug</code>的能力</li>
<li>未来的<code>Suspense</code>，优雅处理异步副作用</li>
<li>未来的<code>hooks</code></li>
</ul>
<h2 id="一、memo"><a href="#一、memo" class="headerlink" title="一、memo"></a>一、memo</h2><blockquote>
<pre><code>React v16.6.0`出了一些新的包装函数(wrapped functions)，一种用于函数组件`PureComponent` / `shouldComponentUpdate`形式的`React.memo()
</code></pre>
</blockquote>
<ul>
<li><code>React.memo()</code>是一个高阶函数，它与 <code>React.PureComponent</code>类似，但是一个函数组件而非一个类</li>
</ul>
<blockquote>
<p>现在有一个显示时间的组件,每一秒都会重新渲染一次，对于<code>Child</code>组件我们肯定不希望也跟着渲染，所有需要用到<code>PureComponent</code></p>
</blockquote>
<pre><code>import React  from &#39;react&#39;;

export default class extends React.Component &#123;
    constructor(props)&#123;
        super(props);
        this.state = &#123;
            date : new Date()
        &#125;
    &#125;

    componentDidMount()&#123;
        setInterval(()=&gt;&#123;
            this.setState(&#123;
                date:new Date()
            &#125;)
        &#125;,1000)
    &#125;

    render()&#123;
        return (
            &lt;div&gt;
                &lt;Child seconds=&#123;1&#125;/&gt;
                &lt;div&gt;&#123;this.state.date.toString()&#125;&lt;/div&gt;
            &lt;/div&gt;
        )
    &#125;
&#125;
</code></pre>
<p><strong>PureComponent</strong></p>
<pre><code>class Child extends React.PureComponent &#123;
    render()&#123;
        console.log(&#39;I am rendering&#39;);
        return (
            &lt;div&gt;I am update every &#123;this.props.seconds&#125; seconds&lt;/div&gt;
        )
    &#125;
&#125;
</code></pre>
<p><strong>现在新出了一个React.memo()可以满足创建纯函数而不是一个类的需求</strong></p>
<pre><code>function Child(&#123;seconds&#125;)&#123;
    console.log(&#39;I am rendering&#39;);
    return (
        &lt;div&gt;I am update every &#123;seconds&#125; seconds&lt;/div&gt;
    )
&#125;;
export default React.memo(Child)
</code></pre>
<blockquote>
<p><code>React.memo()</code>可接受2个参数，第一个参数为纯函数的组件，第二个参数用于对比<code>prop</code>s控制是否刷新，与<code>shouldComponentUpdate()</code>功能类似</p>
</blockquote>
<pre><code>import React from &quot;react&quot;;

function Child(&#123;seconds&#125;)&#123;
    console.log(&#39;I am rendering&#39;);
    return (
        &lt;div&gt;I am update every &#123;seconds&#125; seconds&lt;/div&gt;
    )
&#125;;

function areEqual(prevProps, nextProps) &#123;
    if(prevProps.seconds===nextProps.seconds)&#123;
        return true
    &#125;else &#123;
        return false
    &#125;

&#125;
export default React.memo(Child,areEqual)
</code></pre>
<h2 id="二、lazy"><a href="#二、lazy" class="headerlink" title="二、lazy"></a>二、lazy</h2><blockquote>
<p><code>React.lazy</code> 用于做<code>Code-Splitting</code>，代码拆分。类似于按需加载，渲染的时候才加载代码</p>
</blockquote>
<pre><code>import React, &#123;lazy&#125; from &#39;react&#39;;
const OtherComponent = lazy(() =&gt; import(&#39;./OtherComponent&#39;));

function MyComponent() &#123;
  return (
    &lt;div&gt;
      &lt;OtherComponent /&gt;
    &lt;/div&gt;
  );
&#125;
</code></pre>
<blockquote>
<p><code>lazy(() =&gt; import(&#39;./OtherComponent&#39;))</code>使用<code>es6</code>的<code>import()</code>返回一个<code>promise</code>，类似于：</p>
</blockquote>
<pre><code>lazy(() =&gt; new Promise(resolve =&gt;
  setTimeout(() =&gt;
    resolve(
      // 模拟ES Module
      &#123;
        // 模拟export default 
        default: function render() &#123;
          return &lt;div&gt;Other Component&lt;/div&gt;
        &#125;
      &#125;
    ),
    3000
  )
));
</code></pre>
<p><strong>React.lazy的提出是一种更优雅的条件渲染解决方案</strong></p>
<blockquote>
<p>这里我们引出<code>suspense</code></p>
</blockquote>
<p>当我们组件未渲染完成，需要<code>loading</code>时，可以这么写</p>
<pre><code>const OtherComponent = React.lazy(() =&gt; import(&#39;./OtherComponent&#39;));

function MyComponent() &#123;
  return (
    &lt;div&gt;
      &lt;Suspense fallback=&#123;&lt;div&gt;Loading...&lt;/div&gt;&#125;&gt;
        &lt;OtherComponent /&gt;
      &lt;/Suspense&gt;
    &lt;/div&gt;
  );
&#125;
</code></pre>
<ul>
<li>在我们的业务场景中，<code>OtherComponent</code>可以代表多个条件渲染组件，我们全部加载完成才取消<code>loding</code>。</li>
<li>只要<code>promise</code>没执行到<code>resolve</code>，<code>suspense</code>都会返回<code>fallback</code>中的<code>loading</code>。</li>
<li>代码简洁，<code>loading</code>可提升至祖先组件，易聚合。相当优雅的解决了条件渲染。</li>
</ul>
<h2 id="三、suspense"><a href="#三、suspense" class="headerlink" title="三、suspense"></a>三、suspense</h2><blockquote>
<p><code>Suspense</code>主要解决的就是网络<code>IO</code>问题。网络<code>IO</code>问题其实就是我们现在用<code>Redux+saga</code>等等一系列乱七八糟的库来解决的「副作用」问题。</p>
</blockquote>
<blockquote>
<p>调用<code>render</code>函数-&gt;发现有异步请求-&gt;悬停，等待异步请求结果-&gt;再渲染展示数据</p>
</blockquote>
<ul>
<li>引入新的<code>api</code>，可以使得任何<code>state</code>更新暂停，直到条件满足时，再渲染（像<code>async/await</code>）</li>
<li>在网速非常快的时候，可设置，整个数据到达<code>Dom</code>，更新完毕以后再渲染</li>
<li>在网速非常慢的时候，可设置，精确到单个组件的等待、以及更新，然后再渲染</li>
<li>会给我们提供 <code>high-level</code> (createFetcher)和 <code>low-level</code>(Placeholder, Loading)的 API，可以供给业务代码和一些小组件的书写。</li>
</ul>
<blockquote>
<p><a href="http://blog.poetries.top/2019/08/10/react-good-practice/#%E4%B9%9D%E3%80%81React-%E7%9A%84%E6%9C%AA%E6%9D%A5%EF%BC%882%EF%BC%89%EF%BC%9ASuspense-%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%E9%9D%A9%E5%91%BD">更多详情</a></p>
</blockquote>
<h2 id="四、hooks"><a href="#四、hooks" class="headerlink" title="四、hooks"></a>四、hooks</h2><blockquote>
<p><code>Hooks</code> 的目的，简而言之就是让开发者不需要再用 class 来实现组件</p>
</blockquote>
<blockquote>
<p><code>hooks</code>常用<code>api</code>有：<code>useState</code>、<code>useEffect</code>、<code>useContext</code>、<code>useReducer</code>、<code>useRef</code>等</p>
</blockquote>
<ul>
<li><a href="http://blog.poetries.top/2019/08/10/react-good-practice/#%E5%8D%81%E3%80%81%E5%87%BD%E6%95%B0%E5%8C%96%E7%9A%84-Hooks">参考1</a></li>
<li><a href="http://blog.poetries.top/2019/09/01/react-hooks">更多详情</a></li>
</ul>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV进阶篇</title>
    <url>/2022/02/07/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87/</url>
    <content><![CDATA[<h1 id="OpenCV进阶篇"><a href="#OpenCV进阶篇" class="headerlink" title="OpenCV进阶篇"></a>OpenCV进阶篇</h1><h1 id="第10章-模板匹配"><a href="#第10章-模板匹配" class="headerlink" title="第10章　模板匹配"></a>第10章　模板匹配</h1><p>模板匹配是一种最原始、最基本的识别方法，可以在原始图像中寻找特定图像的位置。模板匹配经常应用于简单的图像查找场景中，例如，在集体合照中找到某个人的位置。本章将介绍如何利用OpenCV实现模板匹配。</p>
<p><img src="/.com//image-20211122082012339.png" alt="image-20211122082012339"></p>
<span id="more"></span>

<h2 id="10-1-模板匹配方法"><a href="#10-1-模板匹配方法" class="headerlink" title="10.1　模板匹配方法"></a>10.1　模板匹配方法</h2><p>模板是被查找目标的图像，查找模板在原始图像中的哪个位置的过程就叫模板匹配。OpenCV提供的matchTemplate()方法就是模板匹配方法，其语法如下：</p>
<pre><code> result = cv2.matchTemplate(image, templ, method, mask)
</code></pre>
<p>参数说明：　</p>
<p>image：原始图像。　</p>
<p>templ：模板图像，尺寸必须小于或等于原始图像。　</p>
<p>method：匹配的方法，可用参数值如表10.1所示。</p>
<p>表10.1　</p>
<p><img src="/.com//image-20211122082047351.png" alt="image-20211122082047351"></p>
<p>匹配方法的参数值　</p>
<p>mask：可选参数。掩模，只有cv2.TM_SQDIFF和cv2.TM_CCORR_NORMED支持此参数，建议采用默认值。</p>
<p>返回值说明：　</p>
<p>result：计算得出的匹配结果。如果原始图像的宽、高分别为W、H，模板图像的宽、高分别为w、h，result就是一个W-w+1列、H-h+1行的32位浮点型数组。数组中每一个浮点数都是原始图像中对应像素位置的匹配结果，其含义需要根据method参数来解读。<br>在模板匹配的计算过程中，模板会在原始图像中移动。模板与重叠区域内的像素逐个对比，最后将对比的结果保存在模板左上角像素点索引位置对应的数组位置中。计算过程如图10.1所示。</p>
<p><img src="/.com//image-20211122082229394.png" alt="image-20211122082229394"></p>
<p>​                                                                         图10.1　模板在原始图像中移动并逐个匹配</p>
<p>使用cv2.TM_SQDIFF（平方差匹配）方法计算出的数组格式如下（其他方法计算出的数组格式相同，仅数值不同）：</p>
<pre><code> [[0.10165964 0.10123613 0.1008469  ... 0.10471864 0.10471849 0.10471849]
  [0.10131165 0.10087635 0.10047968 ... 0.10471849 0.10471834 0.10471849]
  [0.10089004 0.10045089 0.10006084 ... 0.10471849 0.10471819 0.10471849]
  ...
  [0.16168603 0.16291814 0.16366465 ... 0.12178455 0.12198001 0.12187888]
  [0.15859096 0.16000605 0.16096526 ... 0.12245651 0.12261643 0.12248362]
  [0.15512456 0.15672517 0.15791312 ... 0.12315679 0.1232616  0.12308815]]
</code></pre>
<p>模板将原始图像中每一块区域都覆盖一遍，但结果数组的行、列数并不等于原始图像的像素的行、列数。假设模板的宽为w，高为h，原始图像的宽为W，高为H，如图10.2所示。<br>模板移动到原始图像的边缘之后就不会继续移动了，所以模板的移动区域如图10.3所示，该区域的边长为“原始图像边长-模板边长+1”，最后加1是因为移动区域内的上下、左右的2个边都被模板覆盖到了，如果不加1会丢失数据。</p>
<p><img src="/.com//image-20211122085327267.png" alt="image-20211122085327267"></p>
<p>​                                                                                        图10.2　模板和原始图像的宽、高</p>
<p><img src="/.com//image-20211122085350483.png" alt="image-20211122085350483"></p>
<p>​                                                                                                图10.3　模板移动的范围</p>
<h2 id="10-2-单模板匹配"><a href="#10-2-单模板匹配" class="headerlink" title="10.2　单模板匹配"></a>10.2　单模板匹配</h2><p>匹配过程中只用到一个模板场景叫单模板匹配。原始图像中可能只有一个和模板相似的图像，也可能有多个。如果只获取匹配程度最高的那一个结果，这种操作叫作单目标匹配。如果需要同时获取所有匹配程度较高的结果，这种操作叫作多目标匹配。</p>
<h3 id="10-2-1-单目标匹配"><a href="#10-2-1-单目标匹配" class="headerlink" title="10.2.1　单目标匹配"></a>10.2.1　单目标匹配</h3><p>单目标匹配只获取一个结果即可，就是匹配程度最高的结果（如果使用平方差匹配，则为计算出的最小结果；如果使用相关匹配或相关系数匹配，则为计算出的最大结果）。本节以平方差匹配为例介绍。<br>matchTemplate()方法的计算结果是一个二维数组，OpenCV提供了一个minMaxLoc()方法专门用来解析这个二维数组中的最大值、最小值以及这2个值对应的坐标，minMaxLoc()方法的语法如下：</p>
<pre><code> minValue, maxValue, minLoc, maxLoc = cv2.minMaxLoc(src, mask)
</code></pre>
<p>参数说明：　</p>
<p>src：matchTemplate()方法计算得出的数组。　</p>
<p>mask：可选参数，掩模，建议使用默认值。</p>
<p>返回值说明：　</p>
<p>minValue：数组中的最小值。</p>
<p>maxValue：数组中的最大值。　</p>
<p>minLoc：最小值的坐标，格式为(x, y)。　</p>
<p>maxLoc：最大值的坐标，格式为(x, y)。<br>平方差匹配的计算结果越小，匹配程度越高。minMaxLoc()方法返回的minValue值就是模板匹配的最优结果，minLoc就是最优结果区域左上角的点坐标，区域大小与模板大小一致。</p>
<p>【实例10.1】　为原始图片中匹配成功的区域绘制红框。<br>将图10.4作为模板，将图10.5作为原始图像，使用cv2.TM_SQDIFF_NORMED方式进行模板匹配，在原始图像中找到与模板一样的图案，并在该图案上绘制红色方框。</p>
<p><img src="/.com//image-20211122085451979.png" alt="image-20211122085451979"></p>
<p>​                                                                                                                  图10.4　模板</p>
<p><img src="/.com//image-20211122085539068.png" alt="image-20211122085539068"></p>
<p>​                                                                               图10.5　原始图片<br>具体代码如下：</p>
<p><img src="/.com//image-20211122085602382.png" alt="image-20211122085602382"></p>
<p>上述代码的运行结果如图10.6所示。</p>
<p><img src="/.com//image-20211122085749850.png" alt="image-20211122085749850"></p>
<p>​                                                                                        图10.6　模板匹配的效果</p>
<p>在许多综艺节目里，导演组给选手们一幅图像，让选手在指定区域内寻找图像中的某一静物。为了增加游戏难度，导演组可能会让选手们从2个或者多个相似的场景中选择最佳的匹配结果。接下来，使用模板匹配的相应方法模拟这个游戏。</p>
<p>【实例10.2】　从2幅图像中选择最佳的匹配结果。<br>将图10.7作为模板，将图10.8和图10.9作为原始图像，使用cv2.TM_SQDIFF_NORMED方式进行模板匹配，在2幅原始图像中找到与模板匹配结果最好的图像，并在窗口中显示出来。</p>
<p><img src="/.com//image-20211122085811909.png" alt="image-20211122085811909"></p>
<p>​                                                                                                          图10.7　模板</p>
<p><img src="/.com//image-20211122085837681.png" alt="image-20211122085837681"></p>
<p>​                                                                                                  图10.8　原始图像221</p>
<p><img src="/.com//image-20211122085907444.png" alt="image-20211122085907444"></p>
<p>​                                                                                             图10.9　原始图像222<br>具体代码如下：</p>
<p><img src="/.com//image-20211122085934422.png" alt="image-20211122085934422"></p>
<p>上述代码的运行结果如图10.10所示。</p>
<p><img src="/.com//image-20211122090014973.png" alt="image-20211122090014973"></p>
<p>​                                                                            图10.10　从2幅图像中选择最佳的匹配结果</p>
<p>网速的提升让容量较大的文件更容易在互联网上传播，最明显结果就是现在用户计算机里被堆满了各种各样的图像文件。<br>图像文件与其他文件不同，相同内容的图像可能保存在不同大小、不同格式的文件中，这些文件的二进制字节码差别较大，很难用简单的程序识别。在没有高级识别软件的情况下想要找出内容相同的图像就只能一个一个打开用肉眼识别了。<br>OpenCV能够打破图像文件规格、格式的限制来识别图像内容。</p>
<p>【实例10.3】　查找重复的图像。<br>图10.11所示的文件夹中有10幅图像，这些图像不仅有JPG格式的，还有PNG格式的，而且这些图像的分辨率也各不相同。接下来将编写一个程序，在该文件夹中找出哪些是重复的照片。</p>
<p><img src="/.com//image-20211122090116485.png" alt="image-20211122090116485"></p>
<p>​                                                                              图10.11　文件夹中的所有照片文件<br>想要解决这个问题，可以使用OpenCV提供的matchTemplate()方法来判断2幅图像的相似度，如果相似度大于0.9，就认为这2幅图像是相同的。<br>具体代码如下：</p>
<p><img src="/.com//image-20211122090219888.png" alt="image-20211122090219888"></p>
<p>上述代码的运行结果如下：</p>
<pre><code> 相同的照片：10.png, 4.jpg,
 相同的照片：2.jpg, 5.jpg, 9.png,
</code></pre>
<h3 id="10-2-2-多目标匹配"><a href="#10-2-2-多目标匹配" class="headerlink" title="10.2.2　多目标匹配"></a>10.2.2　多目标匹配</h3><p>多目标匹配需要将原始图像中所有与模板相似的图像都找出来，使用相关匹配或相关系数匹配可以很好地实现这个功能。如果计算结果大于某值（例如0.999），则认为匹配区域的图案和模板是相同的。</p>
<p>【实例10.4】　为原始图片中所有匹配成功的图案绘制红框。<br>将图10.12作为模板，将图10.13作为原始图像。原始图像中有很多重复的图案，每一个与模板相似的图案都需要被标记出来。</p>
<p><img src="/.com//image-20211122090300666.png" alt="image-20211122090300666"></p>
<p>​                                                                                                     图10.12　模板</p>
<p><img src="/.com//image-20211122090321173.png" alt="image-20211122090321173"></p>
<p>​                                                                                       图10.13　包含重复内容的原始图像<br>使用cv2.TM_CCOEFF_NORMED方法进行模板匹配，使用for循环遍历matchTemplate()方法返回的结果，找到所有大于0.99的计算结果，在这些结果的对应区域位置绘制红色矩形边框。编写代码时要注意：数组的列数在图像坐标系中为横坐标，数组的行数在图像坐标系中为纵坐标。<br>具体代码如下：</p>
<p><img src="/.com//image-20211122090346039.png" alt="image-20211122090346039"></p>
<p>上述代码的运行结果如图10.14所示，程序找到了3处与模板相似的图案。</p>
<p><img src="/.com//image-20211122090426271.png" alt="image-20211122090426271"></p>
<p>​                                                                                                    图10.14　匹配结果<br>多目标匹配在实际生活中有很多应用场景。例如，统计一条快轨线路的站台总数；同一地点附近有2个地铁站，优先选择直线距离最短的地铁站等。</p>
<p>【实例10.5】　统计一条快轨线路的站台总数。<br>将图10.15作为模板，图10.16作为原始图像，在原始图像中标记快轨线路各个站台，统计这条快轨线路的站台总数。</p>
<p><img src="/.com//image-20211122090450906.png" alt="image-20211122090450906"></p>
<p>​                                                                                                       图10.15　模板</p>
<p><img src="/.com//image-20211122090516424.png" alt="image-20211122090516424"></p>
<p>​                                                                                                 图10.16　原始图像<br>使用cv2.TM_CCOEFF_NORMED方法进行模板匹配，使用for循环遍历matchTemplate()方法返回的结果，找到所有大于0.99的计算结果，在这些结果的对应区域位置绘制蓝色矩形边框，代码如下：       </p>
<p><img src="/.com//image-20211122090545588.png" alt="image-20211122090545588"></p>
<p>上述代码的运行结果如图10.17所示。<br>实例10.5第6行中的results包含所有蓝色矩形边框左上角的横、纵坐标。利用这一特点，还可以模拟“同一地点附近有2个地铁站，优先选择直线距离最短的地铁站”这一生活场景，模板如图10.18所示。</p>
<p><img src="/.com//image-20211122090628716.png" alt="image-20211122090628716"></p>
<p>​                                                                                   图10.17　统计一条快轨线路的站台总数</p>
<p>【实例10.6】　优先选择直线距离最短的地铁站。<br>如图10.19所示，坐标为(62, 150)的地点附近有人民广场和解放大路两个地铁站，如何优先选择直线距离最短的地铁站呢？首先将图10.18作为模板，将图10.19作为原始图像，然后在原始图像中标记出这两个地铁站，最后计算并比较坐标为(62, 150)这个地点与这两个地铁站的直线距离。</p>
<p><img src="/.com//image-20211122090830746.png" alt="image-20211122090830746"></p>
<p>​                                                                                                      图10.18　模板</p>
<p>​                                                                                                 图10.19　原始图像<br>使用cv2.TM_CCOEFF_NORMED方法进行模板匹配，使用for循环遍历matchTemplate()方法返回的结果，找到所有大于0.99的计算结果，在这些结果的对应区域位置绘制蓝色矩形边框，分别计算(62,150)到蓝色矩形边框左上角的距离，用绿色线段标记出直线距离最短的地铁站，代码如下：</p>
<p><img src="/.com//image-20211122091313117.png" alt="image-20211122091313117"></p>
<p>上述代码的运行结果如图10.20所示。</p>
<p><img src="/.com//image-20211122091347963.png" alt="image-20211122091347963"></p>
<p>​                                                                            图10.20　优先选择直线距离最短的地铁站</p>
<h2 id="10-3-多模板匹配"><a href="#10-3-多模板匹配" class="headerlink" title="10.3　多模板匹配"></a>10.3　多模板匹配</h2><p>匹配过程中同时查找多个模板的操作叫多模板匹配。多模板匹配实际上就是进行了n次“单模板多目标匹配”操作，n的数量为模板总数。【实例10.7】　同时匹配3个不同的模板。<br>将图10.21～图10.23作为模板，将图10.24（a）作为原始图像。</p>
<p><img src="/.com//image-20211122091419764.png" alt="image-20211122091419764"></p>
<p>​                                                                                                       图10.21　模板1</p>
<p><img src="/.com//image-20211122091440162.png" alt="image-20211122091440162"></p>
<p>​                                                                                                  图10.22　模板2</p>
<p><img src="/.com//image-20211122091458891.png" alt="image-20211122091458891"></p>
<p>​                                                                                                         图10.23　模板3<br>每一个模板都要做一次“单模板多目标匹配”，最后把所有模板的匹配结果汇总到一起。“单模板多目标匹配”的过程可以封装成一个方法，方法参数为模板和原始图像，方法内部将计算结果再加工一下，直接返回所有红框左上角和右下角两点横纵坐标的列表。在方法之外，将所有模板计算得出的坐标汇总到一个列表中，按照这些汇总的坐标一次性将所有红框都绘制出来。<br>具体代码如下：</p>
<p><img src="/.com//image-20211122091539261.png" alt="image-20211122091539261"></p>
<p>上述代码的运行效果如图10.24（b）所示。</p>
<p><img src="/.com//image-20211122091621151.png" alt="image-20211122091621151"></p>
<p>​                                                                                                图10.24　多模板匹配效果<br>使用多模板匹配能够解决很多生活中的实际问题。例如，一个收费停车场有4个车位，车位上陆续地停放了4辆车，通过多模板匹配，能够知晓这4辆车分别停在了哪个车位上。接下来将模拟这一生活场景。</p>
<p>【实例10.8】　使用多模板匹配让控制台判断4辆车分别停在了哪个车位上。<br>有4辆车按图10.25～图10.28的顺序陆续驶入停车场，这4辆车停在4个车位上的效果如图10.29所示。将图10.25～图10.28作为模板，将图10.29作为原始图像，使用cv2. TM_CCOEFF_NORMED方式进行模板匹配，在原始图像中找到与4个模板一样的图像后，在控制台上输出这4辆车分别停在了哪个车位上。</p>
<p>说明<br>在图10.29中，1号车位水平像素的取值范围是0<del>200，2号车位水平像素的取值范围是200</del>433，3号车位水平像素的取值范围是433<del>656，4号车位水平像素的取值范围是656</del>871。</p>
<p><img src="/.com//image-20211122091712450.png" alt="image-20211122091712450"></p>
<p>​                                                                                                      图10.25　模板1</p>
<p><img src="/.com//image-20211122091731718.png" alt="image-20211122091731718"></p>
<p>​                                                                                                     图10.26　模板2</p>
<p><img src="/.com//image-20211122091750330.png" alt="image-20211122091750330"></p>
<p>​                                                                                                       图10.27　模板3</p>
<p><img src="/.com//image-20211122091808719.png" alt="image-20211122091808719"></p>
<p>​                                                                                                        图10.28　模板4</p>
<p><img src="/.com//image-20211122091825529.png" alt="image-20211122091825529"></p>
<p>​                                                                                                       图10.29　原始图像<br>具体代码如下：</p>
<p><img src="/.com//image-20211122091850011.png" alt="image-20211122091850011"></p>
<p>上述代码的运行结果如下：</p>
<pre><code> 车位编号: 4
 车位编号: 3
 车位编号: 2
 车位编号: 1
</code></pre>
<p>上面的结果可以得出以下结论：图10.25所示的车辆停在了4号车位上，图10.26所示的车辆停在了3号车位上，图10.27所示的车辆停在了2号车位上，图10.28所示的车辆停在了1号车位上。</p>
<h2 id="10-4-小结"><a href="#10-4-小结" class="headerlink" title="10.4　小结"></a>10.4　小结</h2><p>模板匹配包括单模板匹配和多模板匹配，单模板匹配又包括单目标匹配和多目标匹配。实现这些内容的基础方法就是模板匹配方法，即matchTemplate()方法。其中，重点掌握模板匹配方法的6个参数值。此外，为了实现单目标匹配，除了需要使用模板匹配方法matchTemplate()外，还要使用minMaxLoc()方法，这个方法返回的就是单目标匹配的最优结果。对于多目标匹配，要将它和多模板匹配区分开：多目标匹配只有一个模板，而多模板匹配则有多个模板。</p>
<h1 id="第11章-滤波器"><a href="#第11章-滤波器" class="headerlink" title="第11章　滤波器"></a>第11章　滤波器</h1><p>在尽量保留原图像信息的情况下，去除图像内噪声、降低细节层次信息等一系列过程，叫作图像的平滑处理（或图像的模糊处理）。实现平滑处理最常用的工具就是滤波器。通过调节滤波器的参数，可以控制图像的平滑程度。OpenCV提供了种类丰富的滤波器，每种滤波器使用的算法均不同，但都能对图像中的像素值进行微调，让图像呈现平滑效果。本章将介绍均值滤波器、中值滤波器、高斯滤波器和双边滤波器的使用方法。</p>
<p><img src="/.com//image-20211122092213657.png" alt="image-20211122092213657"></p>
<h2 id="11-1-均值滤波器"><a href="#11-1-均值滤波器" class="headerlink" title="11.1　均值滤波器"></a>11.1　均值滤波器</h2><p><img src="/.com//image-20211122092621030.png" alt="image-20211122092621030"></p>
<p>​                                                                                               图11.1　噪声图像<br>图像中可能会出现这样一种像素，该像素与周围像素的差别非常大，导致从视觉上就能看出该像素无法与周围像素组成可识别的图像信息，降低了整个图像的质量。这种“格格不入”的像素就是图像的噪声。如果图像中的噪声都是随机的纯黑像素或者纯白像素，这样的噪声称作“<strong>椒盐噪声”或“盐噪声</strong>”。例如如图7.1所示的就是一幅只有噪声的图像，常称为“雪花点”。<br>以一个像素为核心，其周围像素可以组成一个n行n列（简称n×n）的矩阵，这样的矩阵结构在滤波操作中被称为“滤波核”。矩阵的行、列数决定了滤波核的大小，如图11.2所示的滤波核大小为3×3，包含9个像素；图11.3所示的滤波核大小为5×5，包含25个像素。</p>
<p><img src="/.com//image-20211122092605201.png" alt="image-20211122092605201"></p>
<p>​                                                                                                 图11.2　3×3的滤波核</p>
<p><img src="/.com//image-20211122092712502.png" alt="image-20211122092712502"></p>
<p>​                                                                                                   图11.3　5×5的滤波核<br>均值滤波器（也称为低通滤波器）可以把图像中的每一个像素都当成滤波核的核心，然后计算核内所有像素的平均值，最后让核心像素值等于这个平均值。<br>例如，图11.4就是均值滤波的计算过程。滤波核大小为3×3，核心像素值是35，颜色较深，周围像素值都为110～150，因此可以认为核心像素是噪声。将滤波核中的所有像素值相加，然后除以像素个数，就得出了平均值123（四舍五入取整）。将核心像素的值改成123，其颜色就与周围颜色差别不大，图像就变得平滑了。这就是均值滤波去噪的原理。</p>
<p><img src="/.com//image-20211122092745945.png" alt="image-20211122092745945"></p>
<p>​                                                                               图11.4　均值滤波的计算过程<br>OpenCV将均值滤波器封装成blur()方法，其语法如下：</p>
<pre><code> dst = cv2.blur(src, ksize, anchor, borderType)
</code></pre>
<p>参数说明：　</p>
<p>src：被处理的图像。　</p>
<p>ksize：滤波核大小，其格式为(高度，宽度)，建议使用如(3, 3)、(5, 5)、(7, 7)等宽、高相等的奇数边长。滤波核越大，处理之后的图像就越模糊。　</p>
<p>anchor：可选参数，滤波核的锚点，建议采用默认值，可以自动计算锚点。</p>
<p>borderType：可选参数，边界样式，建议采用默认值。</p>
<p>返回值说明：　</p>
<p>dst：经过均值滤波处理之后的图像。</p>
<p>【实例11.1】　对花朵图像进行均值滤波操作。<br>分别使用大小为3×3、5×5和9×9的滤波核对花朵图像进行均值滤波操</p>
<p>作，具体代码如下：</p>
<p><img src="/.com//image-20211122094217442.png" alt="image-20211122094217442"></p>
<p>上述代码的运行结果如图11.5所示，从这个结果可以看出，滤波核越大，处理之后的图像就越模糊。</p>
<p><img src="/.com//image-20211122092914325.png" alt="image-20211122092914325"></p>
<p>​                                                                                          图11.5　图像均值滤波效果</p>
<h2 id="11-2-中值滤波器"><a href="#11-2-中值滤波器" class="headerlink" title="11.2　中值滤波器"></a>11.2　中值滤波器</h2><p>中值滤波器的原理与均值滤波器非常相似，唯一的不同就是不计算像素的平均值，而是将所有像素值排序，把最中间的像素值取出，赋值给核心像素。</p>
<p>例如，图11.6就是中值滤波的计算过程。滤波核大小为3×3，核心像素值是35，周围像素值都为110～150。将核内所有像素值按升序排列，9个像素值排成一行，最中间位置为第5个位置，这个位置的像素值为131。不需再做任何计算，直接把131赋值给核心像素，其颜色就与周围颜色差别不大，图像就变得平滑了。这就是中值滤波去噪的原理。</p>
<p><img src="/.com//image-20211122095233594.png" alt="image-20211122095233594"></p>
<p>图11.6　中值滤波的计算过程<br>OpenCV将中值滤波器封装成medianBlur()方法，其语法如下：</p>
<pre><code> dst = cv2.medianBlur(src, ksize)
</code></pre>
<p>参数说明：　</p>
<p>src：被处理的图像。　</p>
<p>ksize：滤波核的边长，必须是大于1的奇数，如3、5、7等。该方法根据此边长自动创建一个正方形的滤波核。</p>
<p>返回值说明：　</p>
<p>dst：经过中值滤波处理之后的图像。</p>
<p>注意<br>中值滤波器的ksize参数是边长，而其他滤波器的ksize参数通常为（高，宽）。</p>
<p>【实例11.2】　对花朵图像进行中值滤波操作.<br>分别使用边长为3、5、9的滤波核对花朵图像进行中值滤波操作，具体代码如下：</p>
<p><img src="/.com//image-20211122095347319.png" alt="image-20211122095347319"></p>
<p>上述代码的运行结果如图11.7所示，滤波核的边长越长，处理之后的图像就越模糊。中值滤波处理的图像会比均值滤波处理的图像丢失更多细节。</p>
<p><img src="/.com//image-20211122095440078.png" alt="image-20211122095440078"></p>
<p>​                                                                                      图11.7　图像中值滤波效果</p>
<h2 id="11-3-高斯滤波器"><a href="#11-3-高斯滤波器" class="headerlink" title="11.3　高斯滤波器"></a>11.3　高斯滤波器</h2><p>高斯滤波也被称为高斯模糊或高斯平滑，是目前应用最广泛的平滑处理算法。高斯滤波可以很好地在降低图片噪声、细节层次的同时保留更多的图像信息，经过处理的图像呈现“磨砂玻璃”的滤镜效果。<br>进行均值滤波处理时，核心周围每个像素的权重都是均等的，也就是每个像素都同样重要，所以计算平均值即可。但在高斯滤波中，越靠近核心的像素权重越大，越远离核心的像素权重越小，例如5×5大小的高斯滤波卷积核的权重示意图如图11.8所示。像素权重不同不能取平均值，要从权重大的像素中取较多的信息，从权重小的像素中取较少的信息。简单概括就是“离谁更近，跟谁更像”。<br>高斯滤波的计算过程涉及卷积运算，会有一个与滤波核大小相等的卷积核。本节仅以3×3的滤波核为例，简单地描述一下高斯滤波的计算过程。<br>卷积核中保存的值就是核所覆盖区域的权重值，其遵循图11.8的规律。卷积核中所有权重值相加的结果为1。例如，3×3的卷积核可以是如图11.9所示的值。随着核大小、σ标准差的变化，卷积核中的值也会发生较大变化，图11.9仅是一种最简单的情况。</p>
<p><img src="/.com//image-20211122095530857.png" alt="image-20211122095530857"></p>
<p>​                                                                 图11.8　5×5的高斯滤波卷积核的权重示意图</p>
<p><img src="/.com//image-20211122095559972.png" alt="image-20211122095559972"></p>
<p>​                                                                                   图11.9　简化的3×3的卷积核<br>进行高斯滤波的过程中，滤波核中像素与卷积核进行卷积计算，最后将计算结果赋值给滤波核的核心像素。其计算过程如图11.10所示。</p>
<p><img src="/.com//image-20211122095620790.png" alt="image-20211122095620790"></p>
<p>​                                                                                           图11.10　像素与卷积核进行卷积计算<br>在图11.10的计算过程中，滤波核中的每个像素值都与卷积核对应位置的权重值相乘，最后计算出9个值，计算过程如下：</p>
<pre><code> 137 × 0.05  150 × 0.1  125 × 0.05     6.85  15    6.25
 141 × 0.1   35 × 0.4   131 × 0.1   =  14.1  14    13.1
 119 × 0.05  118 × 0.1  150 × 0.05     5.95  11.8  7.5
</code></pre>
<p>让这9个值相加，再四舍五入取整，计算过程如下：</p>
<pre><code> 6.85 + 15 + 6.25 + 14.1 + 14 + 13.1 + 5.95 + 11.8 + 7.5 = 94.55 ≈ 95
</code></pre>
<p>最后得到的这个结果就是高斯滤波的计算结果，滤波核的核心像素值从35改为95。<br>OpenCV将高斯滤波器封装成了GaussianBlur()方法，其语法如下：</p>
<pre><code> dst = cv2.GaussianBlur(src, ksize, sigmaX, sigmaY, borderType)
</code></pre>
<p>参数说明：　</p>
<p>src：被处理的图像。</p>
<p>ksize：滤波核的大小，宽高必须是奇数，如(3, 3)、(5, 5)等。　</p>
<p>sigmaX：卷积核水平方向的标准差。　</p>
<p>sigmaY：卷积核垂直方向的标准差。　修改sigmaX或sigmaY的值都可以改变卷积核中的权重比例。如果不知道如何设计这2个参数值，就直接把这2个参数的值写成0，该方法就会根据滤波核的大小自动计算合适的权重比例。　</p>
<p>borderType：可选参数，边界样式，建议使用默认值。</p>
<p>返回值说明：　</p>
<p>dst：经过高斯滤波处理之后的图像。</p>
<p>【实例11.3】　对花朵图像进行高斯滤波操作。<br>分别使用大小为5×5、9×9和15×15的滤波核对花朵图像进行高斯滤波操作，水平方向和垂直方向的标准差参数值全部为0，具体代码如下：</p>
<p><img src="/.com//image-20211122095728517.png" alt="image-20211122095728517"></p>
<p>上述代码的运行结果如图11.11所示，滤波核越大，处理之后的图像就越模糊。和均值滤波、中值滤波处理的图像相比，高斯滤波处理的图像更加平滑，保留的图像信息更多，更容易辨认。</p>
<p><img src="/.com//image-20211122095747712.png" alt="image-20211122095747712"></p>
<p><img src="/.com//image-20211122095856218.png" alt="image-20211122095856218"></p>
<p>​                                                                                    图11.11　图像的高斯滤波效果</p>
<h2 id="11-4-双边滤波器"><a href="#11-4-双边滤波器" class="headerlink" title="11.4　双边滤波器"></a>11.4　双边滤波器</h2><p>不管是均值滤波、中值滤波还是高斯滤波，都会使整幅图像变得平滑，图像中的边界会变得模糊不清。双边滤波是一种在平滑处理过程中可以有效保护边界信息的滤波操作方法。<br>双边滤波器自动判断滤波核处于“平坦”区域还是“边缘”区域：如果滤波核处于“平坦”区域，则会使用类似高斯滤波的算法进行滤波；如果滤波核处于“边缘”区域，则加大“边缘”像素的权重，尽可能地让这些像素值保持不变。<br>例如，图11.12是一幅黑白拼接图像，对这幅图像进行高斯滤波，黑白交界处就会变得模糊不清，效果如图11.13所示，但如果对这幅图像进行双边滤波，黑白交界处的边界则可以很好地保留下来，效果如图11.14所示。</p>
<p><img src="/.com//image-20211122095927108.png" alt="image-20211122095927108"></p>
<p>​                                                                                             图11.12　原图</p>
<p><img src="/.com//image-20211122095943849.png" alt="image-20211122095943849"></p>
<p>​                                                                                      图11.13　高斯滤波效果</p>
<p><img src="/.com//image-20211122100141070.png" alt="image-20211122100141070"></p>
<p>​                                                                                      图11.14　双边滤波效果<br>OpenCV将双边滤波器封装成bilateralFilter()方法，其语法如下：</p>
<pre><code> dst = cv2.bilateralFilter(src, d, sigmaColor, sigmaSpace, borderType)
</code></pre>
<p>参数说明：　</p>
<p>src：被处理的图像。　</p>
<p>d：以当前像素为中心的整个滤波区域的直径。如果d&lt;0，则自动根据sigmaSpace参数计算得到。该值与保留的边缘信息数量成正比，与方法运行效率成反比。　</p>
<p>sigmaColor：参与计算的颜色范围，这个值是像素颜色值与周围颜色值的最大差值，只有颜色值之差小于这个值时，周围的像素才进行滤波计算。值为255时，表示所有颜色都参与计算。　</p>
<p>sigmaSpace：坐标空间的σ（sigma）值，该值越大，参与计算的像素数量就越多。　</p>
<p>borderType：可选参数，边界样式，建议默认。<br>返回值说明：　</p>
<p>dst：经过双边滤波处理之后的图像。</p>
<p>【实例11.4】　对比高斯滤波和双边滤波的处理效果。</p>
<p>使用大小为(15, 15)的滤波核对花朵图像进行高斯滤波处理，同样使用15作为范围直径对花朵图像进行双边滤波处理，观察两种滤波处理之后的图像边缘有什么差别，具体代码如下：</p>
<p><img src="/.com//image-20211122100239643.png" alt="image-20211122100239643"></p>
<p>上述代码的运行结果如图11.15所示，可以看出高斯滤波模糊了整个画面，但双边滤波保留了较清晰的边缘信息。</p>
<p><img src="/.com//image-20211122100319332.png" alt="image-20211122100319332"></p>
<p>​                                                                           图11.15　两种滤波方法效果对比</p>
<h2 id="11-5-小结"><a href="#11-5-小结" class="headerlink" title="11.5　小结"></a>11.5　小结</h2><p>噪声指的是一幅图像内部的、高亮度的像素点。图像平滑处理是指在尽量保留原图像信息的情况下，去除图像内部的这些高亮度的像素点（也就是“噪声”）。为了实现图像平滑处理，需要的工具就是滤波器。本章主要讲解了OpenCV中的4种滤波器，虽然每种滤波器的实现原理都不同，但是每种滤波器都能对图像进行图像平滑处理。读者朋友在掌握这4种滤波器的实现方法的同时，也要熟悉这4种滤波器的实现原理。</p>
<h1 id="第12章-腐蚀与膨胀"><a href="#第12章-腐蚀与膨胀" class="headerlink" title="第12章　腐蚀与膨胀"></a>第12章　腐蚀与膨胀</h1><p>腐蚀和膨胀是图像形态学中的两种核心操作，通过这两种操作可以清除或强化图像中的细节。合理使用腐蚀和膨胀，还可以实现图像开运算、闭运算、梯度运算、顶帽运算和黑帽运算等极具特点的操作。下面将对腐蚀、膨胀以及其他形态学操作进行详细的介绍。</p>
<p><img src="/.com//image-20211125193906728.png" alt="image-20211125193906728"></p>
<h2 id="12-1-腐蚀"><a href="#12-1-腐蚀" class="headerlink" title="12.1　腐蚀"></a>12.1　腐蚀</h2><p>腐蚀操作可以让图像沿着自己的边界向内收缩。OpenCV通过“核”来实现收缩计算。“核”的英文名为kernel，在形态学中可以理解为“由n个像素组成的像素块”，像素块包含一个核心（核心通常在中央位置，也可以定义在其他位置）。像素块在图像的边缘移动，在移动过程中，核会将图像边缘那些与核重合但又没有越过核心的像素点都抹除，效果类似图12.1所示的过程，就像削土豆皮一样，将图像一层一层地“削薄”。</p>
<p><img src="/.com//image-20211125193959328.png" alt="image-20211125193959328"></p>
<p>​                                                                                       图12.1　核腐蚀图像中的像素</p>
<p>OpenCV将腐蚀操作封装成erode()方法，该方法的语法如下：</p>
<pre><code> dst = cv2.erode(src, kernel, anchor, iterations, borderType, borderValue)
</code></pre>
<p>参数说明：</p>
<p>src：原始图像。</p>
<p>kernel：腐蚀使用的核。　</p>
<p>anchor：可选参数，核的锚点位置。　</p>
<p>iterations：可选参数，腐蚀操作的迭代次数，默认值为1。　</p>
<p>borderType：可选参数，边界样式，建议默认。　</p>
<p>borderValue：可选参数，边界值，建议默认。</p>
<p>返回值说明：　</p>
<p>dst：经过腐蚀之后的图像。<br>图像经过腐蚀操作之后，可以抹除一些外部的细节，如图12.2所示是一个卡通小蜘蛛，如果用一个5×5的像素块作为核对小蜘蛛进行腐蚀操作，可以得到如图12.3所示的结果。小蜘蛛的腿被当成外部细节抹除了，同时小蜘蛛的眼睛变大了，因为核从内部也“削”了一圈。</p>
<p><img src="/.com//image-20211125194100364.png" alt="image-20211125194100364"></p>
<p>​                                                                                               图12.2　原图</p>
<p><img src="/.com//image-20211125194124001.png" alt="image-20211125194124001"></p>
<p>​                                                                                         图12.3　腐蚀之后的图像<br>在OpenCV做腐蚀或其他形态学操作时，通常使用numpy模块来创建核数组，例如：</p>
<pre><code> import numpy as np
 k = np.ones((5, 5), np.uint8)
</code></pre>
<p>这两行代码就是通过numpy模块的ones()方法创建了一个5行5列（简称5×5）、数字类型为无符号8位整数、每一个数字的值都是1的数组，这个数组作为erode()方法的核参数。除了5×5的结构，还可以使用3×3、9×9、11×11等结构，行列数越大，计算出的效果就越粗糙，行列数越小，计算出的效果就越精细。</p>
<p>【实例12.1】　将仙人球图像中的刺抹除。<br>仙人球的叶子呈针状，茎呈深绿色，如图12.4所示。</p>
<p><img src="/.com//image-20211125194225098.png" alt="image-20211125194225098"></p>
<p>​                                                                                               图12.4　仙人球<br>使用3×3的核对仙人球图像进行腐蚀操作，可以将图像里的刺抹除，具体代码如下：</p>
<p><img src="/.com//image-20211125194308740.png" alt="image-20211125194308740"></p>
<p>上述代码的运行结果如图12.5所示。</p>
<p><img src="/.com//image-20211125194341145.png" alt="image-20211125194341145"></p>
<p>​                                                                              图12.5　图像腐蚀操作效果</p>
<h2 id="12-2-膨胀"><a href="#12-2-膨胀" class="headerlink" title="12.2　膨胀"></a>12.2　膨胀</h2><p>膨胀操作与腐蚀操作相反，膨胀操作可以让图像沿着自己的边界向内扩张。同样是通过核来计算，当核在图像的边缘移动时，核会将图像边缘填补新的像素，效果类似图12.6所示的过程，就像在一面墙上反反复复地涂水泥，让墙变得越来越厚。</p>
<p><img src="/.com//image-20211125194443041.png" alt="image-20211125194443041"></p>
<p>​                                                                                      图12.6　核填补图像中的像素<br>OpenCV将膨胀操作封装成dilate()方法，该方法的语法如下：</p>
<pre><code> dst = cv2.dilate(src, kernel, anchor, iterations, borderType, borderValue)
</code></pre>
<p>参数说明：　</p>
<p>src：原始图像。　</p>
<p>kernel：膨胀使用的核。　</p>
<p>anchor：可选参数，核的锚点位置。　</p>
<p>iterations：可选参数，腐蚀操作的迭代次数，默认值为1。　</p>
<p>borderType：可选参数，边界样式，建议默认。　</p>
<p>borderValue：可选参数，边界值，建议默认。<br>返回值说明：　</p>
<p>dst：经过膨胀之后的图像。<br>图像经过膨胀操作之后，可以放大一些外部的细节，如图12.7（a）所示的卡通小蜘蛛，如果用一个5×5的像素块作为核对小蜘蛛进行膨胀操作，可以得到如图12.7（b）所示的结果，小蜘蛛不仅腿变粗了，而且连眼睛都胖没了。</p>
<p><img src="/.com//image-20211125194535307.png" alt="image-20211125194535307"></p>
<p>​                                                                                图12.7　图像膨胀操作效果</p>
<p>【实例12.2】　将图像加工成“近视眼”效果。<br>近视眼由于聚焦不准，看东西都需要放大并且模模糊糊的，利用膨胀操作可以将正常画面处理成近视眼看到的画面。采用9×9的数组作为核，对图12.8（a）进行膨胀操作。<br>具体代码如下：</p>
<p><img src="/.com//image-20211125194619331.png" alt="image-20211125194619331"></p>
<p>上述代码的运行结果如图12.8所示</p>
<p><img src="/.com//image-20211125194637143.png" alt="image-20211125194637143"></p>
<p>​                                                                   图12.8　图像膨胀操作“近视眼”效果</p>
<h2 id="12-3-开运算"><a href="#12-3-开运算" class="headerlink" title="12.3　开运算"></a>12.3　开运算</h2><p>开运算是将图像<strong>先进行腐蚀操作，再进行膨胀操作</strong>。开运算可以用来抹除图像外部的细节（或者噪声）。<br>例如，图12.9是一个简单的二叉树，父子节点之间都有线连接。如果对此图像进行腐蚀操作，可以得出如图12.10所示的图像，连接线消失了，节点也比原图节点小一圈。此时再执行膨胀操作，让缩小的节点恢复到原来的大小，就得到了如图12.11所示的效果。<br>这3幅图就是开运算的过程，从结果中可以明显地看出：经过开运算之后，二叉树中的连接线消失了，只剩下光秃秃的节点。因为连接线被核当成“细节”抹除了，所以利用检测轮廓的方法可以统计二叉树节点数量，也就是说在某些情况下，开运算的结果还可以用来做数量统计。</p>
<p><img src="/.com//image-20211125194659165.png" alt="image-20211125194659165"></p>
<p>​                                                                                        图12.9　简单的二叉树</p>
<p><img src="/.com//image-20211125194754294.png" alt="image-20211125194754294"></p>
<p>​                                                                      图12.10　二叉树图像腐蚀之后的效果</p>
<p><img src="/.com//image-20211125194813564.png" alt="image-20211125194813564"></p>
<p>​                                                                         图12.11　对腐蚀的图像做膨胀操作</p>
<p>【实例12.3】　抹除黑种草图像中的针状叶子。<br>黑种草如图12.12（a）所示，花呈蓝色，叶子像针一样又细又长，呈羽毛状。要抹除黑种草图像中的叶子，可以使用5×5的核对图像进行开运算。<br>具体代码如下：</p>
<p><img src="/.com//image-20211125194832293.png" alt="image-20211125194832293"></p>
<p>上述代码的运行结果如图12.12（b）所示，经过开运算后黑种草图像虽然略为模糊，但叶子都不见了。</p>
<p><img src="/.com//image-20211125194853964.png" alt="image-20211125194853964"></p>
<p>​                                                                                                   图12.12　图像开运算效果</p>
<h2 id="12-4-闭运算"><a href="#12-4-闭运算" class="headerlink" title="12.4　闭运算"></a>12.4　闭运算</h2><p>闭运算是将图像先进行膨胀操作，再进行腐蚀操作。闭运算可以抹除图像内部的细节（或者噪声）。<br>例如，图12.13（a）是一个身上布满斑点的小蜘蛛，这些斑点就是图像的内部细节。先将图像进行膨胀操作，小蜘蛛身上的斑点（包括眼睛）被抹除，效果如图12.13（b）所示。然后再将图像进行腐蚀操作，膨胀的小蜘蛛恢复到原来的大小，效果如图12.13（c）所示。</p>
<p><img src="/.com//image-20211125194952165.png" alt="image-20211125194952165"></p>
<p>​                                                                                  图12.13　图像闭运算效果<br>这3幅图就是闭运算的过程，从结果中可以明显地看出：经过闭运算后，小蜘蛛身上的花纹都被抹除了，就连眼睛也被当成“细节”抹除了。<br>闭运算除了会抹除图像内部的细节，还会让一些离得较近的区域合并成一块区域。</p>
<p>【实例12.4】　对汉字图片进行闭运算。<br>使用15×15的核对图12.14（a）做闭运算。因为使用的核比较大，很容易导致一些间隔较近的区域合并到一起，观察闭运算对汉字图片造成了哪些影响。<br>具体代码如下：</p>
<p><img src="/.com//image-20211125195012305.png" alt="image-20211125195012305"></p>
<p>上述代码的运行结果如图12.14（b）所示，“田”字经过闭运算之后没有多大变化，但是“野”字经过闭运算之后，许多独立的区域因膨胀操作合并到一起，导致文字很难辨认。</p>
<p><img src="/.com//image-20211125195103765.png" alt="image-20211125195103765"></p>
<p>​                                                                                        图12.14　汉字图片闭运算效果</p>
<h2 id="12-5-形态学运算"><a href="#12-5-形态学运算" class="headerlink" title="12.5　形态学运算"></a>12.5　形态学运算</h2><p>腐蚀和膨胀是形态学的基础操作，除了开运算和闭运算以外，形态学中还有几种比较有特点的运算。OpenCV提供了一个morphologyEx()形态学方法，包含所有常用的运算，其语法如下：</p>
<pre><code> dst = cv2.morphologyEx(src, op, kernel, anchor, iterations, borderType, borderValue)
</code></pre>
<p>参数说明：　</p>
<p>src：原始图像。　</p>
<p>op：操作类型，具体值如表12.1所示。</p>
<p>​                                                                           表12.1　形态学函数的操作类型参数　</p>
<p><img src="/.com//image-20211125195140684.png" alt="image-20211125195140684"></p>
<p>kernel：操作过程中使用的核。　</p>
<p>anchor：可选参数，核的锚点位置。　</p>
<p>iterations：可选参数，迭代次数，默认值为1。　</p>
<p>borderType：可选参数，边界样式，建议默认。　</p>
<p>borderValue：可选参数，边界值，建议默认。</p>
<p>返回值说明：　</p>
<p>dst：操作之后得到的图像。<br>morphologyEx()方法实现的腐蚀、膨胀、开运算和闭运算效果与前文中介绍的效果完全一致，本节不再赘述，下面将介绍3个特点鲜明的操作：梯度运算、顶帽运算和黑帽运算。</p>
<h3 id="12-5-1-梯度运算"><a href="#12-5-1-梯度运算" class="headerlink" title="12.5.1　梯度运算"></a>12.5.1　梯度运算</h3><p>这里的梯度是指图像梯度，可以简单地理解为像素的变化程度。如果几个连续的像素，其像素值跨度越大，则梯度值越大。<br>梯度运算的运算过程如图12.15所示，让原图的膨胀图减原图的腐蚀图。因为膨胀图比原图大，腐蚀图比原图小，利用腐蚀图将膨胀图掏空，就得到了原图的轮廓图。说明<br>梯度运算中得到的轮廓图只是一个大概轮廓，不精准。</p>
<p><img src="/.com//image-20211125195234243.png" alt="image-20211125195234243"></p>
<p>​                                                                                 图12.15　梯度运算过程<br>梯度运算的参数为cv2.MORPH_GRADIENT，下面通过一段代码实现图12.15的效果。</p>
<p>【实例12.5】　通过梯度运算画出小蜘蛛的轮廓。<br>使用5×5的核对小蜘蛛图像进行形态学梯度运算，具体代码如下：</p>
<p><img src="/.com//image-20211125195253240.png" alt="image-20211125195253240"></p>
<p>上述代码的运行结果如图12.16所示。</p>
<p><img src="/.com//image-20211125195322974.png" alt="image-20211125195322974"></p>
<p>​                                                                                           图12.16　图像梯度运算效果</p>
<h3 id="12-5-2-顶帽运算"><a href="#12-5-2-顶帽运算" class="headerlink" title="12.5.2　顶帽运算"></a>12.5.2　顶帽运算</h3><p>顶帽运算的运算过程如图12.17所示，让原图减原图的开运算图。因为开运算抹除图像的外部细节，“有外部细节”的图像减去“无外部细节”的图像，得到的结果就只剩外部细节了，所以经过顶帽运算之后，小蜘蛛就只剩蜘蛛腿了。</p>
<p><img src="/.com//image-20211125195410644.png" alt="image-20211125195410644"></p>
<p>​                                                                                      图12.17　顶帽运算过程<br>顶帽运算的参数为cv2.MORPH_TOPHAT，下面通过一段代码实现图12.18的效果。</p>
<p>【实例12.6】　通过顶帽运算画出小蜘蛛的腿。<br>使用5×5的核对小蜘蛛图像进行顶帽运算，具体代码如下：</p>
<p><img src="/.com//image-20211125195435250.png" alt="image-20211125195435250"></p>
<p>上述代码的运算结果如图12.18所示。</p>
<p><img src="/.com//image-20211125195455237.png" alt="image-20211125195455237"></p>
<p>​                                                                                                图12.18　图像开运算效果</p>
<h3 id="12-5-3-黑帽运算"><a href="#12-5-3-黑帽运算" class="headerlink" title="12.5.3　黑帽运算"></a>12.5.3　黑帽运算</h3><p>黑帽运算的运算过程如图12.19所示，让原图的闭运算图减去原图。因为闭运算抹除图像的内部细节，“无内部细节”的图像减去“有内部细节”的图像，得到的结果就只剩内部细节了，所以经过黑帽运算之后，小蜘蛛就只剩下斑点、花纹和眼睛了。</p>
<p><img src="/.com//image-20211125195549507.png" alt="image-20211125195549507"></p>
<p>​                                                                                  图12.19　黑帽运算过程<br>黑帽运算的参数为cv2.MORPH_BLACKHAT，下面通过一段代码实现图12.19的效果。</p>
<p>【实例12.7】　通过黑帽运算画出小蜘蛛身上的花纹。<br>使用5×5的核对小蜘蛛图像进行黑帽运算，具体代码如下：</p>
<p><img src="/.com//image-20211125195624673.png" alt="image-20211125195624673"></p>
<p>上述代码的运行结果如图20所示。</p>
<p><img src="/.com//image-20211125195644815.png" alt="image-20211125195644815"></p>
<p>​                                                                                    图12.20　图像黑帽运算效果</p>
<h2 id="12-6-小结"><a href="#12-6-小结" class="headerlink" title="12.6　小结"></a>12.6　小结</h2><p>本章介绍的基础内容是腐蚀和膨胀。读者掌握了其用法，就能轻而易举地实现开运算和闭运算。其中，开运算是对图像先进行腐蚀操作，再进行膨胀操作，其作用是抹除图像外部的细节；而闭运算是对图像先进行膨胀操作，再进行腐蚀操作，其作用是抹除图像内部的细节。此外，形态学运算也是构建在腐蚀和膨胀的基础上的。其中，梯度运算是让原图的膨胀图减原图的腐蚀图，得到的结果是原图的轮廓；顶帽运算是让原图减原图的开运算图，得到的结果是图像的外部细节；黑帽运算是让原图的闭运算图减去原图，得到的结果是图像的内部细节。</p>
<h1 id="第13章-图形检测"><a href="#第13章-图形检测" class="headerlink" title="第13章　图形检测"></a>第13章　图形检测</h1><p>图形检测是计算机视觉的一项重要功能。通过图形检测可以分析图像中可能存在的形状，然后对这些形状进行描绘，如搜索并绘制图像的边缘，定位图像的位置，判断图像中有没有直线、圆形等。虽然图形检测涉及非常深奥的数学算法，但OpenCV已经将这些算法封装成简单的方法，开发者只要学会如何调用方法、调整参数即可很好地实现检测功能。<br>本章将介绍如何检测图像的形状、图像所占的区域，以及如何查找图像中出现的几何图形等。</p>
<p><img src="/.com//image-20211125195758972.png" alt="image-20211125195758972"></p>
<h2 id="13-1-图像的轮廓"><a href="#13-1-图像的轮廓" class="headerlink" title="13.1　图像的轮廓"></a>13.1　图像的轮廓</h2><p>轮廓是指图像中图形或物体的外边缘线条。简单的几何图形轮廓是由平滑的线构成的，容易识别，但不规则图形的轮廓可能由许多个点构成，识别起来比较困难。<br>OpenCV提供的findContours()方法可以通过计算图像梯度来判断图像的边缘，然后将边缘的点封装成数组返回。findContours()方法的语法如下：</p>
<pre><code> contours, hierarchy = cv2.findContours(image, mode, methode)
</code></pre>
<p>参数说明：　</p>
<p>image：被检测的图像，必须是8位单通道二值图像。如果原始图像是彩色图像，必须转为灰度图像，并经过二值化处理。　</p>
<p>mode：轮廓的检索模式，具体值如表13.1所示。</p>
<p>​                                                                                              表13.1　轮廓的检索模式参数值</p>
<p><img src="/.com//image-20211125195942347.png" alt="image-20211125195942347"></p>
<p>methode：</p>
<p>检测轮廓时使用的方法，具体值如表13.2所示。</p>
<p>​                                                                                            表13.2　检测轮廓时使用的方法</p>
<p><img src="/.com//image-20211125200003759.png" alt="image-20211125200003759"></p>
<p>返回值说明：　</p>
<p>contours：检测出的所有轮廓，list类型，每一个元素都是某个轮廓的像素坐标数组。　</p>
<p>hierarchy：轮廓之间的层次关系。<br>通过findContours()方法找到图像轮廓后，为了方便开发人员观测，最好能把轮廓画出来，于是OpenCV提供了drawContours()方法用来绘制这些轮廓。drawContours()方法的语法如下：</p>
<pre><code> image = cv2.drawContours(image, contours, contourIdx, color, thickness, lineTypee, hierarchy, maxLevel, offse)
</code></pre>
<p>参数说明：</p>
<p>image：被绘制轮廓的原始图像，可以是多通道图像。　</p>
<p>contours：findContours()方法得出的轮廓列表。　</p>
<p>contourIdx：绘制轮廓的索引，如果为-1则绘制所有轮廓。　</p>
<p>color：绘制颜色，使用BGR格式。　</p>
<p>thickness：可选参数，画笔的粗细程度，如果该值为-1则绘制实心轮廓。　</p>
<p>lineTypee：可选参数，绘制轮廓的线型。　</p>
<p>hierarchy：可选参数，findContours()方法得出的层次关系。　</p>
<p>maxLevel：可选参数，绘制轮廓的层次深度，最深绘制第maxLevel层。　</p>
<p>offse：可选参数，偏移量，可以改变绘制结果的位置。</p>
<p>返回值说明：</p>
<p>image：同参数中的image，执行后原始图中就包含绘制的轮廓了，可以不使用此返回值保存结果。</p>
<p>【实例13.1】　绘制几何图像的轮廓。<br>将如图13.1所示的几何图像转换成二值灰度图像，然后通过findContours()方法找到出现的所有轮廓，再通过drawContours()方法将这些轮廓绘制成红色。轮廓的检索模式采用cv2.RETR_LIST，检测方法采用cv2.CHAIN_APPROX_NONE。</p>
<p><img src="/.com//image-20211125200104772.png" alt="image-20211125200104772"></p>
<p>​                                                                                 图13.1　简单的几何图像<br>具体代码如下：</p>
<p><img src="/.com//image-20211125200222796.png" alt="image-20211125200222796"></p>
<p>上述代码的运行结果如图13.2所示。</p>
<p><img src="/.com//image-20211125200313470.png" alt="image-20211125200313470"></p>
<p>​                                                                                           图13.2　绘制全部轮廓</p>
<p>如果使用cv2.RETR_EXTERNAL做参数则只绘制外轮廓，关键代码如下：</p>
<pre><code> contours, hierarchy = cv2.findContours(binary, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)
 cv2.drawContours(img, contours, -1, (0, 0, 255), 5)
</code></pre>
<p>绘制轮廓的效果如图13.3所示。</p>
<p><img src="/.com//image-20211125200347818.png" alt="image-20211125200347818"></p>
<p>​                                                                               图13.3　只绘制外轮廓的效果</p>
<p>drawContours()方法的第3个参数可以指定绘制哪个索引的轮廓。索引的顺序由轮廓的检索模式决定，例如cv2.RETR_CCOMP模式下绘制索引为0的轮廓的关键代码如下：</p>
<pre><code> contours, hierarchy = cv2.findContours(binary, cv2.RETR_CCOMP, cv2.CHAIN_APPROX_NONE)
 cv2.drawContours(img, contours, 0, (0, 0, 255), 5)
</code></pre>
<p>在同样的检索模式下，绘制索引为1的轮廓的关键代码如下：</p>
<pre><code> cv2.drawContours(img, contours, 1, (0, 0, 255), 5)
</code></pre>
<p>绘制索引为2的轮廓的关键代码如下：</p>
<pre><code> cv2.drawContours(img, contours, 2, (0, 0, 255), 5)
</code></pre>
<p>绘制索引为3的轮廓的关键代码如下：</p>
<pre><code> cv2.drawContours(img, contours, 3, (0, 0, 255), 5)
</code></pre>
<p>绘制的效果如图13.4～图13.7所示。</p>
<p><img src="/.com//image-20211125200419734.png" alt="image-20211125200419734"></p>
<p>​                                                                                 图13.4　绘制索引为0的轮廓</p>
<p><img src="/.com//image-20211125200519831.png" alt="image-20211125200519831"></p>
<p>​                                                                          图13.5　绘制索引为1的轮廓</p>
<p><img src="/.com//image-20211125200538416.png" alt="image-20211125200538416"></p>
<p>​                                                                            图13.6　绘制索引为2的轮廓</p>
<p><img src="/.com//image-20211125200557884.png" alt="image-20211125200557884"></p>
<p>​                                                                                   图13.7　绘制索引为3的轮廓</p>
<p>【实例13.2】　绘制花朵的轮廓。<br>为图13.8（a）所示的花朵图像绘制轮廓，首先要降低图像中的噪声干扰，进行滤波处理，然后将图像处理成二值灰度图像，并检测出轮廓，最后利用绘制轮廓的方法在原始图像中绘制轮廓。<br>具体代码如下：</p>
<p><img src="/.com//image-20211125200623625.png" alt="image-20211125200623625"></p>
<p>上述代码的运行结果如图13.8（b）和图13.8（c）所示。</p>
<p><img src="/.com//image-20211125200704091.png" alt="image-20211125200704091"></p>
<p>​                                                                                  图12.8　绘制花朵轮廓效果</p>
<h2 id="13-2-轮廓拟合"><a href="#13-2-轮廓拟合" class="headerlink" title="13.2　轮廓拟合"></a>13.2　轮廓拟合</h2><p>拟合是指将平面上的一系列点，用一条光滑的曲线连接起来。轮廓的拟合就是将凹凸不平的轮廓用平整的几何图形体现出来。本节将介绍如何按照轮廓绘制矩形包围框和圆形包围框。</p>
<h3 id="13-2-1-矩形包围框"><a href="#13-2-1-矩形包围框" class="headerlink" title="13.2.1　矩形包围框"></a>13.2.1　矩形包围框</h3><p>矩形包围框是指图像轮廓的最小矩形边界。OpenCV提供的boundingRect()方法可以自动计算轮廓最小矩形边界的坐标、宽和高。boundingRect()方法的语法如下：</p>
<pre><code> retval = cv2.boundingRect (array)
</code></pre>
<p>参数说明：　</p>
<p>array：轮廓数组。</p>
<p>返回值说明：</p>
<p>retval：元组类型，包含4个整数值，分别是最小矩形包围框的：左上角顶点的横坐标、左上角顶点的纵坐标、矩形的宽和高。所以也可以写成x, y, w, h = cv2.boundingRect (array)的形式。</p>
<p>【实例13.3】　为爆炸图形绘制矩形包围框。</p>
<p><img src="/.com//image-20211125200758268.png" alt="image-20211125200758268"></p>
<p>​                                                                                        图13.9　爆炸图形<br>为图13.9所示的爆炸图形绘制矩形包围框，首先判断图形的轮廓，使用cv2.RETR_LIST检索所有轮廓，使用cv2.CHAIN_APPROX_SIMPLE检索图形所有的端点，然后利用cv2.boundingRect()方法计算最小矩形包围框，并通过cv2.rectangle()方法将这个矩形绘制出来，具体代码如下：</p>
<p><img src="/.com//image-20211125200901021.png" alt="image-20211125200901021"></p>
<p>上述代码的运行结果如图13.10所示。</p>
<p><img src="/.com//image-20211125200917139.png" alt="image-20211125200917139"></p>
<p>​                                                                                图13.10　爆炸图形的最小矩形包围框</p>
<h3 id="13-2-2-圆形包围框"><a href="#13-2-2-圆形包围框" class="headerlink" title="13.2.2　圆形包围框"></a>13.2.2　圆形包围框</h3><p>圆形包围框与矩形包围框一样，是图像轮廓的最小圆形边界。OpenCV提供的minEnclosingCircle ()方法可以自动计算轮廓最小圆形边界的圆心和半径。minEnclosingCircle()方法的语法如下：</p>
<pre><code> center, radius = cv2.minEnclosingCircle(points)
</code></pre>
<p>参数说明：　</p>
<p>points：轮廓数组。</p>
<p>返回值说明：　</p>
<p>center：元组类型，包含2个浮点值，是最小圆形包围框圆心的横坐标和纵坐标。　</p>
<p>radius：浮点类型，最小圆形包围框的半径。</p>
<p>【实例13.4】　为爆炸图形绘制圆形包围框。<br>为图13.9所示的爆炸图形绘制矩形包围框，首先判断图形的轮廓，使用cv2.RETR_LIST检索所有轮廓，使用cv2.CHAIN_APPROX_SIMPLE检索图形所有的端点，然后利用cv2. minEnclosingCircle()方法计算最小圆形包围框，并通过cv2.circle()方法将这个矩形绘制出来。绘制过程中要注意：圆心坐标和圆半径都是浮点数，在绘制之前要将浮点数转换成整数。<br>具体代码如下：</p>
<p><img src="/.com//image-20211125201112737.png" alt="image-20211125201112737"></p>
<p>上述代码的运行结果如图13.11所示。</p>
<p><img src="/.com//image-20211125201129231.png" alt="image-20211125201129231"></p>
<p>​                                                                                图13.11　爆炸图形的最小圆形包围框</p>
<h2 id="13-3-凸包"><a href="#13-3-凸包" class="headerlink" title="13.3　凸包"></a>13.3　凸包</h2><p>之前介绍了矩形包围框和圆形包围框，这2种包围框虽然已经逼近了图形的边缘，但这种包围框为了保持几何形状，与图形的真实轮廓贴合度较差。如果能找出图形最外层的端点，将这些端点连接起来，就可以围出一个包围图形的最小包围框，这种包围框叫凸包。<br>凸包是最逼近轮廓的多边形，凸包的每一处都是凸出来的，也就是任意3个点组成的内角均小于180°。例如，图13.12就是凸包，而图13.13就不是凸包。</p>
<p><img src="/.com//image-20211125205558522.png" alt="image-20211125205558522"></p>
<p>​                                                                                                    图13.12　凸包</p>
<p><img src="/.com//image-20211125205619316.png" alt="image-20211125205619316"></p>
<p>​                                                                                                  图13.13　不是凸包<br>OpenCV提供的convexHull()方法可以自动找出轮廓的凸包，该方法的语法如下：</p>
<pre><code> hull = cv2.convexHull(points, clockwise, returnPoints)
</code></pre>
<p>参数说明：　</p>
<p>points：轮廓数组。　</p>
<p>clockwise：可选参数，布尔类型。当该值为True时，凸包中的点按顺时针排列，为False时按逆时针排列。　</p>
<p>returnPoints：可选参数，布尔类型。当该值为True时返回点坐标，为False时返回点索引。默认值为True。</p>
<p>返回值说明：　</p>
<p>hull：凸包的点阵数组。<br>下面通过一个例子演示如何绘制凸包。</p>
<p>【实例13.5】　为爆炸图形绘制凸包。<br>为图13.9所示的爆炸图形绘制凸包，首先要先判断图形的轮廓，使用cv2.RETR_LIST检索出图形的轮廓，然后使用convexHull()方法找到轮廓的凸包，最后通过polylines()方法将凸包中各点连接起来，具体代码如下：</p>
<p><img src="/.com//image-20211125205730374.png" alt="image-20211125205730374"></p>
<p>上述代码的运行结果如图13.14所示。</p>
<p><img src="/.com//image-20211125205746309.png" alt="image-20211125205746309"></p>
<p>​                                                                                          图13.14　爆炸图形的凸包</p>
<h2 id="13-4-Canny边缘检测"><a href="#13-4-Canny边缘检测" class="headerlink" title="13.4　Canny边缘检测"></a>13.4　Canny边缘检测</h2><p>Canny边缘检测算法是John F. Canny于1986年开发的一个多级边缘检测算法，该算法根据像素的梯度变化寻找图像边缘，最终可以绘制十分精细的二值边缘图像。<br>OpenCV将Canny边缘检测算法封装在Canny()方法中，该方法的语法如下：</p>
<pre><code> edges = cv2.Canny(image, threshold1, threshold2, apertureSize, L2gradient)
</code></pre>
<p>参数说明：　</p>
<p>image：检测的原始图像。　</p>
<p>threshold1：计算过程中使用的第一个阈值，可以是最小阈值，也可以是最大阈值，通常用来设置最小阈值。　</p>
<p>threshold2：计算过程中使用的第二个阈值，通常用来设置最大阈值。　</p>
<p>apertureSize：可选参数，Sobel算子的孔径大小。　</p>
<p>L2gradient：可选参数，计算图像梯度的标识，默认值为False。值为True时采用更精准的算法进行计算。</p>
<p>返回值说明：　</p>
<p>edges：计算后得出的边缘图像，是一个二值灰度图像。</p>
<p>在开发过程中可以通过调整最小阈值和最大阈值控制边缘检测的精细程度。当2个阈值都较小时，检测出较多的细节；当2个阈值都较大时，忽略较多的细节。</p>
<p>【实例13.6】　使用Canny算法检测花朵边缘。<br>利用Canny()方法检测图13.15（a）所示的花朵图像，分别使用10和50、100和200、400和600作为最低阈值和最高阈值检测3次，具体代码如下：</p>
<p><img src="/.com//image-20211125205855069.png" alt="image-20211125205855069"></p>
<p>上述代码的运行结果如图13.15所示，阈值越小，检测出的边缘越多；阈值越大，检测出的边缘越少，只能检测出一些较明显的边缘。</p>
<p><img src="/.com//image-20211125205918990.png" alt="image-20211125205918990"></p>
<p>​                                                                                   图13.15　图像Canny检测效果</p>
<h2 id="13-5-霍夫变换"><a href="#13-5-霍夫变换" class="headerlink" title="13.5　霍夫变换"></a>13.5　霍夫变换</h2><p>霍夫变换是一种特征检测，通过算法识别图像的特征，从而判断图像中的特殊形状，例如直线和圆。本节将介绍如何检测图像中的直线和圆。</p>
<h3 id="13-5-1-直线检测"><a href="#13-5-1-直线检测" class="headerlink" title="13.5.1　直线检测"></a>13.5.1　直线检测</h3><p>霍夫直线变换是通过霍夫坐标系的直线与笛卡儿坐标系的点之间的映射关系来判断图像中的点是否构成直线。OpenCV将此算法封装成两个方法，分别是cv2.HoughLines()和cv2.HoughLinesP()，前者用于检测无限延长的直线，后者用于检测线段。本节仅介绍比较常用的HoughLinesP()方法。<br>HoughLinesP()方法名称最后有一个大写的P，该方法只能检测二值灰度图像，也就是只有两种像素值的黑白图像。该方法最后把找出的所有线段的两个端点坐标保存成一个数组。<br>HoughLinesP()方法的语法如下：</p>
<pre><code> lines = cv2.HoughLinesP(image, rho, theta, threshold, minLineLength, maxLineGap)
</code></pre>
<p>参数说明：　</p>
<p>image：检测的原始图像。　</p>
<p>rho：检测直线使用的半径步长，值为1时，表示检测所有可能的半径步长。　</p>
<p>theta：搜索直线的角度，值为π/180°时，表示检测所有角度。　</p>
<p>threshold：阈值，该值越小，检测出的直线就越多。　</p>
<p>minLineLength：线段的最小长度，小于该长度的线段不记录到结果中。　</p>
<p>maxLineGap：线段之间的最小距离。</p>
<p>返回值说明：</p>
<p>lines：一个数组，元素为所有检测出的线段，每条线段是一个数组，代表线段两个端点的横、纵坐标，格式为[[[x1, y1, x2, y2], [x1, y1, x2, y2]]]。注意<br>使用该方法前应该为原始图像进行降噪处理，否则会影响检测结果。</p>
<p>【实例13.7】　检测笔图像中出现的直线。</p>
<p>检测如图13.16所示的中性笔照片，先将图像降噪，再对图像进行边缘检测，然后利用HoughLinesP()方法找出边缘图像中的直线线段，最后用cv2.line()方法将找出的线段绘制成红色。</p>
<p><img src="/.com//image-20211125210047560.png" alt="image-20211125210047560"></p>
<p>​                                                                                                图13.16　笔图像<br>具体代码如下：</p>
<p><img src="/.com//image-20211126130401949.png" alt="image-20211126130401949"></p>
<p>上述代码的运行结果如图13.17和图13.18所示。</p>
<p><img src="/.com//image-20211126130420890.png" alt="image-20211126130420890"></p>
<p>​                                                                                   图13.17　笔图像的边缘检测结果</p>
<p><img src="/.com//image-20211126130515954.png" alt="image-20211126130515954"></p>
<p>​                                                                         图13.18　将笔图像中检测出的线段描红</p>
<h3 id="13-5-2-圆环检测"><a href="#13-5-2-圆环检测" class="headerlink" title="13.5.2　圆环检测"></a>13.5.2　圆环检测</h3><p>霍夫圆环变换的原理与霍夫直线变换类似。OpenCV提供的HoughCircles()方法用于检测图像中的圆环，该方法在检测过程中进行两轮筛选：第一轮筛选找出可能是圆的圆心坐标，第二轮筛选计算这些圆心坐标可能对应的半径长度。该方法最后将圆心坐标和半径封装成一个浮点型数组。<br>HoughCircles()方法的语法如下：</p>
<pre><code> circles = cv2.HoughCircles(image, method, dp, minDist, param1, param2, minRadius, maxRadius)
</code></pre>
<p>参数说明：　</p>
<p>image：检测的原始图像。　</p>
<p>method：检测方法，OpenCV 4.0.0及以前版本仅提供了cv2.HOUGH_GRADIENT作为唯一可用方法。　</p>
<p>dp：累加器分辨率与原始图像分辨率之比的倒数。值为1时，累加器与原始图像具有相同的分辨率；值为2时，累加器的分辨率为原始图像的1/2。通常使用1作为参数。　</p>
<p>minDist：圆心之间的最小距离。　</p>
<p>param1：可选参数，Canny边缘检测使用的最大阈值。　</p>
<p>param2：可选参数，检测圆环结果的投票数。第一轮筛选时投票数超过该值的圆环才会进入第二轮筛选。值越大，检测出的圆环越少，但越精准。　</p>
<p>minRadius：可选参数，圆环的最小半径。　</p>
<p>maxRadius：可选参数，圆环的最大半径。</p>
<p>返回值说明：　</p>
<p>circles：一个数组，元素为所有检测出的圆环，每个圆环也是一个数组，内容为圆心的横、纵坐标和半径长度，格式为：[[[x1 ,y1, r1], [x2 ,y2, r2]]]。</p>
<p>注意<br>使用该方法前应该为原始图像进行降噪处理，否则会影响检测结果。</p>
<p>【实例13.8】　检测硬币图像中出现的圆环。<br>检测如图13.19所示的硬币照片，先将图像降噪，再将图像变成单通道灰度图像，然后利用HoughCircles()方法检测图像中可能是圆环的位置，最后通过cv2.circle()方法在这些位置上绘制圆环和对应的圆心。在绘制圆环之前，要将HoughCircles()方法返回的浮点数组元素转换成整数。</p>
<p><img src="/.com//image-20211126130634358.png" alt="image-20211126130634358"></p>
<p>​                                                                                                       图13.19　硬币图像<br>具体代码如下：</p>
<p><img src="/.com//image-20211126130715358.png" alt="image-20211126130715358"></p>
<p>上述代码的运行结果如图13.20所示。</p>
<p><img src="/.com//image-20211126130658457.png" alt="image-20211126130658457"></p>
<p>​                                                                                                   图13.20　检测出的圆环位置</p>
<h2 id="13-6-小结"><a href="#13-6-小结" class="headerlink" title="13.6　小结"></a>13.6　小结</h2><p>图像轮廓指的是将图像的边缘连接起来形成的一个整体，它是图像的一个重要的特征信息，通过对图像的轮廓进行操作，能够得到这幅图像的大小、位置和方向等信息，用于后续的计算。为此，OpenCV提供了findContours()方法，通过计算图像的梯度，判断图像的轮廓。为了绘制图像的轮廓，OpenCV又提供了drawContours()方法。但需要注意的是，Canny()方法虽然能够检测出图像的边缘，但这个边缘是不连续的。</p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
  </entry>
  <entry>
    <title>Redux 中间件</title>
    <url>/2021/04/26/Redux-%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><ul>
<li>在<code>redux</code>里，<code>middleware</code>是发送<code>action</code>和<code>action</code>到达<code>reducer</code>之间的第三方扩展，也就是中间层。也可以这样说，<code>middleware</code>是架在<code>action</code>和<code>store</code>之间的一座桥梁</li>
<li>在<code>redux</code>里，<code>action</code>仅仅是携带了数据的普通<code>js</code>对象</li>
</ul>
<blockquote>
<p><code>Reducer</code> 拆分可以使组件获取其最小属性(<code>state</code>)，而不需要整个<code>Store</code>。中间件则可以在<code>Action Creator</code> 返回最终可供 <code>dispatch</code> 调用的 <code>action</code> 之前处理各种事情，如异步<code>API</code>调用、日志记录等，是扩展 <code>Redux</code> 功能的一种推荐方式</p>
</blockquote>
<ul>
<li><code>Redux</code> 提供了 <code>applyMiddleware(...middlewares)</code> 来将中间件应用到 <code>createStore</code>。<code>applyMiddleware</code>会返回一个函数，该函数接收原来的 <code>creatStore</code> 作为参数，返回一个应用了 <code>middlewares</code> 的增强后的 <code>creatStore</code></li>
</ul>
<pre><code>export default function applyMiddleware(...middlewares) &#123;
  return (createStore) =&gt; (reducer, preloadedState, enhancer) =&gt; &#123;
    //接收createStore参数
    var store = createStore(reducer, preloadedState, enhancer)
    var dispatch = store.dispatch
    var chain = []

    //传递给中间件的参数
    var middlewareAPI = &#123;
      getState: store.getState,
      dispatch: (action) =&gt; dispatch(action)
    &#125;

    //注册中间件调用链
    chain = middlewares.map(middleware =&gt; middleware(middlewareAPI))
    dispatch = compose(...chain)(store.dispatch)

    //返回经middlewares增强后的createStore
    return &#123;
      ...store,
      dispatch
    &#125;
  &#125;
&#125;
</code></pre>
<blockquote>
<p>未应用中间价之前，创建 <code>store</code> 的方式如下</p>
</blockquote>
<pre><code>import &#123;createStore&#125; from &#39;redux&#39;;
import reducers from &#39;./reducers/index&#39;;

export let store = createStore(reducers);
</code></pre>
<blockquote>
<p>应用中间价之后，创建 <code>store</code>的方式如下</p>
</blockquote>
<pre><code>import &#123;createStore，applyMiddleware&#125; from &#39;redux&#39;;
import reducers from &#39;./reducers/index&#39;;

let createStoreWithMiddleware = applyMiddleware(...middleware)(createStore);
export let store = createStoreWithMiddleware(reducers);
</code></pre>
<h2 id="二、为什么要引入middleware"><a href="#二、为什么要引入middleware" class="headerlink" title="二、为什么要引入middleware"></a>二、为什么要引入middleware</h2><ul>
<li><code>action creator</code>返回的值是这个<code>action</code>类型的对象。然后通过<code>store.dispatch()</code>进行分发</li>
</ul>
<pre><code>action ---&gt; dispatcher ---&gt; reducers
</code></pre>
<blockquote>
<p>如果遇到异步情况，比如点击一个按钮，希望2秒之后更新视图，显示消息“Hi”。我们可能这么写<code>ActionCreator</code></p>
</blockquote>
<pre><code>var asyncSayActionCreator = function (message) &#123;
    setTimeout(function () &#123;
        return &#123;
            type: &#39;SAY&#39;,
            message
        &#125;
    &#125;, 2000)
&#125;
</code></pre>
<blockquote>
<p>这会报错，因为这个<code>asyncSayActionCreator</code>返回的不是一个<code>action</code>，而是一个<code>function</code>。这个返回值无法被<code>reducer</code>识别</p>
</blockquote>
<ul>
<li>也就是说，正常来说，<code>action</code>返回的是一个对象，而不是一个函数。如果返回函数，会出现错误</li>
<li>　而异步操作呢，需要<code>action</code>的返回值是一个函数。那么咋办呢，所以需要引入中间件<code>middleware</code>,它在中间起到了桥梁的作用，让<code>action</code>的返回值可以是一个函数，从而传到<code>reducer</code>那里。也就是说，中间件是用在<code>action</code>发起之后，<code>reducer</code>接收到之前的这个时间段</li>
<li>也可以这么说，<code>Middleware</code> 主要是负责改变<code>Store</code>中的<code>dispatch</code>方法，从而能处理不同类型的 <code>action</code> 输入，得到最终的 <code>Javascript Plain Object</code> 形式的 <code>action</code> 对象</li>
</ul>
<blockquote>
<p>因此，上面那个<code>ActionCreator</code>就可以改写为这样：因为<code>action</code>的返回值是一个函数</p>
</blockquote>
<pre><code>var asyncSayActionCreator = function (message) &#123;
    return function (dispatch) &#123;
        setTimeout(function () &#123;
            dispatch(&#123;
                type: &#39;SAY&#39;,
                message
            &#125;)
        &#125;, 2000)
    &#125;
&#125;
</code></pre>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/466.png" alt="img"></p>
<ul>
<li>上图表达的是 <code>redux</code> 中一个简单的同步数据流动的场景，点击<code>button</code> 后，在回调中 <code>dispatch</code> 一个 <code>action</code>，<code>reducer</code> 收到<code>action</code> 后，更新 <code>state</code> 并通知 <code>view</code> 重新渲染</li>
</ul>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/467.png" alt="img"></p>
<ul>
<li><p>上面这张图展示了应用</p>
<pre><code>middleware
</code></pre>
<p>后</p>
<pre><code>redux
</code></pre>
<p>处理事件的逻辑，每一个</p>
<pre><code>middleware
</code></pre>
<p>处理一个相对独立的业务需求，通过串联不同的</p>
<pre><code>middleware
</code></pre>
<p>，实现变化多样的的功能。那么问题来了：</p>
<ul>
<li><code>middleware</code> 怎么写？</li>
<li><code>redux</code>是如何让 <code>middlewares</code> 串联并跑起来的？</li>
</ul>
</li>
</ul>
<h2 id="三、中间件是如何工作的"><a href="#三、中间件是如何工作的" class="headerlink" title="三、中间件是如何工作的"></a>三、中间件是如何工作的</h2><blockquote>
<pre><code>Middleware`的中间件有很多，不过我的这个案例只引用了其中的一个，那就是`redux-thunk
</code></pre>
</blockquote>
<ul>
<li><code>redux-thunk</code>源码如下</li>
</ul>
<pre><code>export default function thunkMiddleware(&#123; dispatch, getState &#125;) &#123;
  return next =&gt; action =&gt;
    typeof action === &#39;function&#39; ?
      action(dispatch, getState) :
      next(action);
&#125;
</code></pre>
<blockquote>
<p>意思是如果<code>action</code>是一个函数，执行这个<code>action</code>函数，如果不是函数，执行<code>next</code>函数</p>
</blockquote>
<h2 id="四、自定义中间件"><a href="#四、自定义中间件" class="headerlink" title="四、自定义中间件"></a>四、自定义中间件</h2><blockquote>
<p>中间件的签名如下</p>
</blockquote>
<pre><code>(&#123; getState, dispatch &#125;) =&gt; next =&gt; action
</code></pre>
<blockquote>
<p>根据<code>applyMiddleware</code> 源码，每个中间件接收 <code>getState &amp; dispatch</code>作为参数，并返回一个函数，该函数会被传入下一个中间件的 dispatch 方法，并返回一个接收 <code>action</code> 的新函数</p>
</blockquote>
<ul>
<li>应用多个中间件时，中间件调用链中任何一个缺少 <code>next(action)</code> 的调用，都会导致<code>action</code> 执行失败</li>
</ul>
<pre><code>function callTraceMiddleware (&#123;dispatch,getState&#125;)&#123;
    return next=&gt; action =&gt;&#123;
        console.trace();
        return next(action);
    &#125;
&#125;
</code></pre>
<ul>
<li>然后在调用中间件部分添加中间件</li>
</ul>
<pre><code>const createStoreWithMiddleware = applyMiddleware(
  thunkMiddleware,
  loggerMiddleware,
  callTraceMiddleware
)(createStore);
</code></pre>
<blockquote>
<p><code>redux</code>的<code>middleware</code>是对<code>action</code>进行扩展处理，这样丰富了应用需求</p>
</blockquote>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title>React-setState原理</title>
    <url>/2021/08/29/React-setstate%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="一、setState异步更新"><a href="#一、setState异步更新" class="headerlink" title="一、setState异步更新"></a>一、setState异步更新</h2><ul>
<li>我们都知道，<code>React</code>通过<code>this.state</code>来访问<code>state</code>，通过<code>this.setState()</code>方法来更新<code>state</code>。当<code>this.setState()</code>方法被调用的时候，<code>React</code>会重新调用<code>render</code>方法来重新渲染<code>UI</code></li>
<li>首先如果直接在<code>setState</code>后面获取<code>state</code>的值是获取不到的。在<code>React</code>内部机制能检测到的地方， <code>setState</code>就是异步的；<code>在React</code>检测不到的地方，例如<code>setInterval</code>,<code>setTimeout</code>，<code>setState</code>就是同步更新的</li>
</ul>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/431.png" alt="img"></p>
<blockquote>
<p>因为<code>setState</code>是可以接受两个参数的，一个<code>state</code>，一个回调函数。因此我们可以在回调函数里面获取值</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/432.png" alt="img"></p>
<ul>
<li><code>setState</code>方法通过一个队列机制实现<code>state</code>更新，当执行<code>setState</code>的时候，会将需要更新的<code>state</code>合并之后放入状态队列，而不会立即更新<code>this.state</code></li>
<li>如果我们不使用<code>setState</code>而是使用<code>this.state.key</code>来修改，将不会触发组件的<code>re-render</code>。</li>
<li>如果将<code>this.state</code>赋值给一个新的对象引用，那么其他不在对象上的<code>state</code>将不会被放入状态队列中，当下次调用<code>setState</code>并对状态队列进行合并时，直接造成了<code>state</code>丢失</li>
</ul>
<h3 id="1-1-setState批量更新的过程"><a href="#1-1-setState批量更新的过程" class="headerlink" title="1.1 setState批量更新的过程"></a>1.1 setState批量更新的过程</h3><blockquote>
<p>在<code>react</code>生命周期和合成事件执行前后都有相应的钩子，分别是<code>pre</code>钩子和<code>post</code>钩子，<code>pre</code>钩子会调用<code>batchedUpdate</code>方法将<code>isBatchingUpdates</code>变量置为<code>true</code>，开启批量更新，而<code>post</code>钩子会将<code>isBatchingUpdates</code>置为<code>false</code></p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/433.png" alt="img"></p>
<ul>
<li><code>isBatchingUpdates</code>变量置为<code>true</code>，则会走批量更新分支，<code>setState</code>的更新会被存入队列中，待同步代码执行完后，再执行队列中的<code>state</code>更新。 <code>isBatchingUpdates</code>为 <code>true</code>，则把当前组件（即调用了 <code>setState</code>的组件）放入 <code>dirtyComponents</code> 数组中；否则 <code>batchUpdate</code> 所有队列中的更新</li>
<li>而在原生事件和异步操作中，不会执行<code>pre</code>钩子，或者生命周期的中的异步操作之前执行了<code>pre</code>钩子，但是<code>pos</code>钩子也在异步操作之前执行完了，<code>isBatchingUpdates</code>必定为<code>false</code>，也就不会进行批量更新</li>
</ul>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/434.png" alt="img"></p>
<blockquote>
<p><code>enqueueUpdate</code>包含了<code>React</code>避免重复<code>render</code>的逻辑。<code>mountComponent</code>和<code>updateComponent</code>方法在执行的最开始，会调用到<code>batchedUpdates</code>进行批处理更新，此时会将<code>isBatchingUpdates</code>设置为<code>true</code>，也就是将状态标记为现在正处于更新阶段了。 <code>isBatchingUpdates</code>为 <code>true</code>，则把当前组件（即调用了 <code>setState</code> 的组件）放入<code>dirtyComponents</code>数组中；否则 <code>batchUpdate</code> 所有队列中的更新</p>
</blockquote>
<h3 id="1-2-为什么直接修改this-state无效"><a href="#1-2-为什么直接修改this-state无效" class="headerlink" title="1.2 为什么直接修改this.state无效"></a>1.2 为什么直接修改this.state无效</h3><ul>
<li>要知道<code>setState</code>本质是通过一个队列机制实现<code>state</code>更新的。 执行<code>setState</code>时，会将需要更新的state合并后放入状态队列，而不会立刻更新<code>state</code>，队列机制可以批量更新<code>state</code>。</li>
<li>如果不通过<code>setState</code>而直接修改<code>this.state</code>，那么这个<code>state</code>不会放入状态队列中，下次调用<code>setState</code>时对状态队列进行合并时，会忽略之前直接被修改的<code>state</code>，这样我们就无法合并了，而且实际也没有把你想要的<code>state</code>更新上去</li>
</ul>
<h3 id="1-3-什么是批量更新-Batch-Update"><a href="#1-3-什么是批量更新-Batch-Update" class="headerlink" title="1.3 什么是批量更新 Batch Update"></a>1.3 什么是批量更新 Batch Update</h3><blockquote>
<p>在一些<code>mv*</code>框架中，，就是将一段时间内对<code>model</code>的修改批量更新到<code>view</code>的机制。比如那前端比较火的<code>React</code>、<code>vue</code>（<code>nextTick</code>机制,视图的更新以及实现）</p>
</blockquote>
<h3 id="1-4-setState之后发生的事情"><a href="#1-4-setState之后发生的事情" class="headerlink" title="1.4 setState之后发生的事情"></a>1.4 setState之后发生的事情</h3><ul>
<li><code>setState</code>操作并不保证是同步的，也可以认为是异步的</li>
<li><code>React</code>在<code>setState</code>之后，会经对<code>state</code>进行<code>diff</code>，判断是否有改变，然后去<code>diff dom</code>决定是否要更新<code>UI</code>。如果这一系列过程立刻发生在每一个<code>setState</code>之后，就可能会有性能问题</li>
<li>在短时间内频繁<code>setState</code>。<code>React</code>会将<code>state</code>的改变压入栈中，在合适的时机，批量更新<code>state</code>和视图，达到提高性能的效果</li>
</ul>
<h3 id="1-5-如何知道state已经被更新"><a href="#1-5-如何知道state已经被更新" class="headerlink" title="1.5 如何知道state已经被更新"></a>1.5 如何知道state已经被更新</h3><blockquote>
<p>传入回调函数</p>
</blockquote>
<pre><code>setState(&#123;
    index: 1
&#125;&#125;, function()&#123;
    console.log(this.state.index);
&#125;)
</code></pre>
<blockquote>
<p>在钩子函数中体现</p>
</blockquote>
<pre><code>componentDidUpdate()&#123;
    console.log(this.state.index);
&#125;
</code></pre>
<h2 id="二、setState循环调用风险"><a href="#二、setState循环调用风险" class="headerlink" title="二、setState循环调用风险"></a>二、setState循环调用风险</h2><ul>
<li>当调用<code>setState</code>时，实际上会执行<code>enqueueSetState</code>方法，并对<code>partialState</code>以及<code>_pending-StateQueue</code>更新队列进行合并操作，最终通过<code>enqueueUpdate</code>执行<code>state</code>更新</li>
<li>而<code>performUpdateIfNecessary</code>方法会获<code>取_pendingElement</code>,<code>_pendingStateQueue</code>，<code>_pending-ForceUpdate</code>，并调用<code>receiveComponent</code>和<code>updateComponent</code>方法进行组件更新</li>
<li>如果在<code>shouldComponentUpdate</code>或者<code>componentWillUpdate</code>方法中调用<code>setState</code>，此时<code>this._pending-StateQueue != null</code>，就会造成循环调用，使得浏览器内存占满后崩溃</li>
</ul>
<h2 id="三、事务"><a href="#三、事务" class="headerlink" title="三、事务"></a>三、事务</h2><ul>
<li>事务就是将需要执行的方法使用<code>wrapper</code>封装起来，再通过事务提供的<code>perform</code>方法执行，先执行<code>wrapper</code>中的<code>initialize</code>方法，执行完<code>perform</code>之后，在执行所有的<code>close</code>方法，一组<code>initialize</code>及<code>close</code>方法称为一个<code>wrapper</code>。</li>
<li>那么事务和<code>setState</code>方法的不同表现有什么关系，首先我们把<code>4</code>次<code>setStat</code>e简单归类，前两次属于一类，因为它们在同一调用栈中执行，<code>setTimeout</code>中的两次<code>setState</code>属于另一类</li>
<li>在<code>setState</code>调用之前，已经处在<code>batchedUpdates</code>执行的事务中了。那么这次<code>batchedUpdates</code>方法是谁调用的呢，原来是<code>ReactMount.js</code>中的<code>_renderNewRootComponent</code>方法。也就是说，整个将<code>React</code>组件渲染到<code>DOM</code>中的过程就是处于一个大的事务中。而在<code>componentDidMount</code>中调用<code>setState</code>时，<code>batchingStrategy</code>的<code>isBatchingUpdates</code>已经被设为了<code>true</code>，所以两次<code>setState</code>的结果没有立即生效</li>
<li>再反观<code>setTimeout</code>中的两次<code>setState</code>，因为没有前置的<code>batchedUpdates</code>调用，所以导致了新的<code>state</code>马上生效</li>
</ul>
<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><ul>
<li>通过<code>setState</code>去更新<code>this.state</code>，不要直接操作<code>this.state</code>，请把它当成不可变的</li>
<li>调用<code>setState</code>更新<code>this.state</code>不是马上生效的，它是异步的，所以不要天真以为执行完<code>setState</code>后<code>this.state</code>就是最新的值了</li>
<li>多个顺序执行的<code>setState</code>不是同步地一个一个执行滴，会一个一个加入队列，然后最后一起执行，即批处理</li>
</ul>
]]></content>
      <categories>
        <category>原理</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/05/01/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;
</code></pre>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server
</code></pre>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate
</code></pre>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy
</code></pre>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>js-domapi(全)</title>
    <url>/2020/10/13/call+apply+bind/</url>
    <content><![CDATA[<ul>
<li><code>call()</code>、<code>apply()</code>、<code>bind()</code>都是函数对象的一个方法，它们的作用都是改变函数的调用对象。它的使用极大的简化了代码的调用</li>
</ul>
<h4 id="一、方法定义"><a href="#一、方法定义" class="headerlink" title="一、方法定义"></a>一、方法定义</h4><ul>
<li><strong>call方法</strong></li>
<li>语法</li>
</ul>
<pre><code>fun.call(thisArg[, arg1[, arg2[, ...]]])
</code></pre>
<ul>
<li><pre><code>thisArg
</code></pre>
<p>：</p>
<pre><code>fun
</code></pre>
<p>函数运行时指定的</p>
<pre><code>this
</code></pre>
<p>值，可能的值为：</p>
<ul>
<li>不传，或者传<code>null</code>，<code>undefined</code>， <code>this</code>指向<code>window</code>对象</li>
<li>传递另一个函数的函数名<code>fun2</code>，<code>this</code>指向函数fun2的引用<br>值为原始值(数字，字符串，布尔值),this会指向该原始值的自动包装对象，如 String、Number、Boolean</li>
<li>传递一个对象，函数中的<code>this</code>指向这个对象</li>
</ul>
</li>
</ul>
<ul>
<li><strong>apply方法</strong></li>
<li>语法：<code>apply([thisObj[,argArray]])</code><ul>
<li>定义：应用某一对象的一个方法，用另一个对象替换当前对象。</li>
<li>说明：<code>apply</code>的第一个参数<code>thisObj</code>和<code>call</code>方法的一样，第二个参数<code>argArray</code>为一个传参数组<code>thisObj</code>如果未传，那么 <code>Global</code>对象被用作 <code>thisObj</code></li>
</ul>
</li>
<li><strong>bind方法</strong><ul>
<li>在<code>ECMAScript5</code>中扩展了叫<code>bind</code>的方法（<code>IE6,7,8</code>不支持）</li>
<li>语法：<code>bind([thisObj[,arg1[, arg2[, [,.argN]]]]])</code></li>
<li>定义：应用某一对象的一个方法，用另一个对象替换当前对象。</li>
<li>说明：<code>bind</code>的<code>thisObj</code>参数也和<code>call</code>方法一样，<code>thisObj</code>如果未传，那么 <code>Global</code>对象被用作 <code>thisObj</code>。arg1 … argN可传可不传。如果不传，可以在调用的时候再传。如果传了，调用的时候则可以不传，调用的时候如果你还是传了，则不生效</li>
</ul>
</li>
</ul>
<pre><code>var person = &#123;
    name:&quot;tsrot&quot;,
    age:24,
    sayHello:function(age)&#123;
        console.log(this.name);
        console.log(age);
    &#125;
    &#125;;
var son = &#123;
 name:&quot;xieliqun&quot;
 &#125;;
var boundFunc = person.sayHello.bind(son);
boundFunc(25);
var boundFunc = person.sayHello.bind(son,25);
boundFunc();
var boundFunc = person.sayHello.bind(son,25);
boundFunc(30);
</code></pre>
<h4 id="二、call、apply、bind的区别"><a href="#二、call、apply、bind的区别" class="headerlink" title="二、call、apply、bind的区别"></a>二、call、apply、bind的区别</h4><ul>
<li><code>call</code>的<code>arg</code>传参需一个一个传，<code>apply</code>则直接传一个数组</li>
</ul>
<pre><code>function hello(name,age)&#123;
 console.log(name);
  console.log(age);
  &#125;
hello.call(this,&quot;tsrot&quot;,24);
hello.apply(this,[&quot;tsrot&quot;,24]);
</code></pre>
<ul>
<li><code>call</code>和<code>apply</code>直接执行函数，而<code>bind</code>需要再一次调用</li>
</ul>
<pre><code>var obj = &#123;
    x: 81,
    &#125;;
var foo = &#123;
    getX: function() &#123;
        return this.x;
    &#125;
    &#125;
console.log(foo.getX.bind(obj)());  
console.log(foo.getX.call(obj));    
console.log(foo.getX.apply(obj));
</code></pre>
<h4 id="三、运用场景"><a href="#三、运用场景" class="headerlink" title="三、运用场景"></a>三、运用场景</h4><ul>
<li>实现继承</li>
</ul>
<pre><code>function Animal(name) &#123;
  this.name = name;
  this.showName = function () &#123;
    console.log(this.name);
  &#125;
  &#125;
function Cat(name) &#123;
  Animal.call(this, name); 
  &#125;
var cat = new Cat(&#39;Black Cat&#39;);
cat.showName();
</code></pre>
<ul>
<li>数组追加</li>
</ul>
<pre><code>var array1 = [1 , 2 , 3, 5];
var array2 = [&quot;xie&quot; , &quot;li&quot; , &quot;qun&quot; , &quot;tsrot&quot;];
Array.prototype.push.apply(array1, array2);
console.log(array1);
</code></pre>
<ul>
<li>获取数组中的最大值和最小值</li>
</ul>
<pre><code>var num = [1,3,5,7,2,-10,11];
var maxNum = Math.max.apply(Math, num);
var minNum = Math.min.apply(Math, num);
console.log(maxNum); 
console.log(minNum);
</code></pre>
<ul>
<li>将伪数组转化为数组</li>
</ul>
<pre><code>var fakeArr = &#123;0:&#39;a&#39;,1:&#39;b&#39;,length:2&#125;;
var arr1 = Array.prototype.slice.call(fakeArr);
console.log(arr1[0]); 
var arr2 = [].slice.call(fakeArr);
console.log(arr2[0]); 
arr1.push(&quot;c&quot;);
console.log(arr1);
</code></pre>
<ul>
<li>保存this变量</li>
</ul>
<pre><code>var foo = &#123;
    bar : 1,
    eventBind: function()&#123;
        var _this = this ;
        $(&#39;.someClass&#39;).on(&#39;click&#39;,function(event) &#123;
            console.log(_this.bar);     
        &#125;);
    &#125;
    &#125;
var foo = &#123;
    bar : 1,
    eventBind: function()&#123;
        $(&#39;.someClass&#39;).on(&#39;click&#39;,function(event) &#123;
            console.log(this.bar);      
        &#125;.bind(this));
    &#125;
    &#125;
</code></pre>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>js-arguments</title>
    <url>/2020/09/19/js-arguments/</url>
    <content><![CDATA[<p>每个函数都会有一个Arguments对象实例arguments，它引用着函数的实参，可以用数组下标的方式”[]”引用arguments的元素。<code>arguments.length</code>为函数实参个数，<code>arguments.callee</code>引用函数自身。</p>
<h3 id="Arguments对象介绍"><a href="#Arguments对象介绍" class="headerlink" title="Arguments对象介绍"></a>Arguments对象介绍</h3><p>Arguments对象是一个伪数组对象，它有length属性，可以arguments[i]来访问对象中的元素，但它不能用数组的一些方法，例如push，pop，slice等。</p>
<h4 id="Arguments的length属性"><a href="#Arguments的length属性" class="headerlink" title="Arguments的length属性"></a>Arguments的length属性</h4><p>Arguments的length属性，表示function函数实际所传参数的个数。函数名点length可以获取函数期望的传参个数。</p>
<pre><code>function argTest(a,b,c)&#123;
    var t = arguments.length; //实际传参个数
    var e = argTest.length;   //期望传参个数

    console.log(t);
    console.log(e);
&#125;

argTest(11,12);       //t=2,e=3
argTest(11,12,13);    //t=3,e=3
argTest(11,12,13,14); //t=4,e=3
</code></pre>
<h4 id="Arguments的参数访问"><a href="#Arguments的参数访问" class="headerlink" title="Arguments的参数访问"></a>Arguments的参数访问</h4><p>Arguments对象的参数访问可以用arguments[i]来访问函数所传的参数。</p>
<pre><code>function argTest(a,b,c)&#123;
    var arg = [];
    for(var i=0;i&lt;arguments.length;i++)&#123;
        arg.push(arguments[i]);
    &#125;
    console.log(arg);
&#125;

argTest(11,12);       //[11, 12]
argTest(11,12,13);    //[11, 12, 13]
argTest(11,12,13,14); //[11, 12, 13, 14]
</code></pre>
<h4 id="Arguments的callee调用"><a href="#Arguments的callee调用" class="headerlink" title="Arguments的callee调用"></a>Arguments的callee调用</h4><p>Arguments的callee属性可以调用函数本身，当函数正在执行时才可调用，可以实现方法的递归调用。</p>
<pre><code>function argTest(a,b,c)&#123;
    var e = arguments.callee.toString();
    console.log(e);
&#125;

argTest(); //打印出函数本身
</code></pre>
<h4 id="Function对象caller属性"><a href="#Function对象caller属性" class="headerlink" title="Function对象caller属性"></a>Function对象caller属性</h4><p>Function对象的caller属性可以指向当前函数的调用者，当调用者函数正在执行时才可调用，</p>
<pre><code>function callerTest()&#123;

    if(callerTest.caller)&#123;
        var caller = callerTest.caller.toString();
        console.log(caller);
    &#125;else&#123;
        console.log(&quot;no caller&quot;)
    &#125;
&#125;

function handler()&#123;
    callerTest();
&#125;

function handlerToHandler()&#123;
    handler();
&#125;

callerTest();        //no caller
handler();           //返回调用者handler函数
handlerToHandler();  //返回调用者handler函数
</code></pre>
<h3 id="Arguments的作用"><a href="#Arguments的作用" class="headerlink" title="Arguments的作用"></a>Arguments的作用</h3><h4 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h4><p>方法重载是指在一个类中定义多个同名的方法，但要求每个方法具有不同的参数的类型或参数的个数。<br>Javascript并没有重载函数的功能，但是Arguments对象能够模拟重载。</p>
<pre><code>//普通方法实现方法重载

function test(a,b,c)&#123;
    if(a &amp;&amp; b &amp;&amp; c)&#123;
        console.log(a + b + c);
    &#125;else if(a &amp;&amp; b)&#123;
        console.log(a + b);
    &#125;else&#123;
        console.log(a);
    &#125;
&#125;

test();           //undefined
test(11,12);      //23
test(11,12,13)    //36
//Arguments对象实现方法重载

function test()&#123;
    var sum = 0;
    for(var i=0;i&lt;arguments.length;i++)&#123;
        sum += arguments[i];
    &#125;
    console.log(sum);
&#125;

test();          //0
test(11,12);     //23
test(11,12,13);  //36
//ES6实现方法重载

function test(...nums)&#123;
    var sum = 0;
    for(var i=0;i&lt;nums.length;i++)&#123;
        sum += nums[i];
    &#125;
    console.log(sum);
&#125;

test();          //0
test(11,12);     //23
test(11,12,13);  //36
</code></pre>
<h4 id="递归调用"><a href="#递归调用" class="headerlink" title="递归调用"></a>递归调用</h4><p>这样的好处就是可以实现匿名函数的递归调用。</p>
<pre><code>//实现一个阶乘函数

function factorial(n)&#123;
    if(n == 1)&#123;
        return 1;
    &#125;else&#123;
        n * arguments.callee(n-1);
    &#125;
&#125;

factorial(1); //1
factorial(5); //120
</code></pre>
<h4 id="不定参问题"><a href="#不定参问题" class="headerlink" title="不定参问题"></a>不定参问题</h4><p>比如说，我想判断你传给我的一些数字的大小，取出最大的那个</p>
<pre><code>function max()&#123;
    var maxNum = Number.NEGATIVE_INFINITY;;
    for(var i=0;i&lt;arguments.length;i++)&#123;
        if(arguments[i]&gt; maxNum)&#123;
            maxNum = arguments[i];
        &#125;
    &#125;
    return maxNum;
&#125;

max(1,2,3,11,4,10); //11
max(2,-10,22,11);   //22
</code></pre>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript-es6</title>
    <url>/2021/11/26/javascript-es6/</url>
    <content><![CDATA[<h1 id="let-定义变量："><a href="#let-定义变量：" class="headerlink" title="let 定义变量："></a>let 定义变量：</h1><p>声明变量</p>
<pre><code class="javascript">let a;

let b,c,d;

let e = 100;

let f = 521, g = &#39;iloveyou&#39;, h = [];
</code></pre>
<ol>
<li>变量不能重复声明</li>
</ol>
<pre><code class="javascript">let star = &#39;罗志祥&#39;;
let star = &#39;小猪&#39;;
</code></pre>
<ol start="2">
<li>块儿级作用域  全局, 函数, eval</li>
</ol>
<pre><code class="javascript">if else while for 

&#123;
    let girl = &#39;周扬青&#39;;
&#125;

console.log(girl);
</code></pre>
<ol start="3">
<li>不存在变量提升</li>
</ol>
<pre><code class="javascript">console.log(song);

let song = &#39;恋爱达人&#39;;
</code></pre>
<ol start="4">
<li>不影响作用域链</li>
</ol>
<pre><code class="javascript">&#123;
    let school = &#39;恋爱学院&#39;;
    function fn()&#123;
        console.log(school);
    &#125;
    fn();
&#125;
</code></pre>
<blockquote>
<p>let 关键字用来声明变量，使用 let 声明的变量有几个特点：</p>
<pre><code>1) 不允许重复声明
2) 块儿级作用域
3) 不存在变量提升
4) 不影响作用域链
</code></pre>
</blockquote>
<h1 id="let-案例"><a href="#let-案例" class="headerlink" title="let 案例"></a>let 案例</h1><p>点击 DIV 换色</p>
<pre><code class="javascript">&lt;style&gt;

    .item &#123;

      width: 100px;

      height: 50px;

      border: solid 1px rgb(42, 156, 156);

      float: left;

      margin-right: 10px;

    &#125;

&lt;/style&gt;

&lt;html&gt;
    &lt;div class=&quot;container&quot;&gt;

    &lt;h2 class=&quot;page-header&quot;&gt;点击切换颜色&lt;/h2&gt;

        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;

        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;

        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;

      &lt;/div&gt;

&lt;script&gt;

    //获取div元素对象
    let items = document.getElementsByClassName(&#39;item&#39;);

    //遍历并绑定事件
    for(let i = 0;i&lt;items.length;i++)&#123;
        items[i].onclick = function()&#123;
        //修改当前元素的背景颜色
        // this.style.background = &#39;pink&#39;;
        items[i].style.background = &#39;pink&#39;;
    &#125;
&#125;

&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h1 id="const-定义常量"><a href="#const-定义常量" class="headerlink" title="const 定义常量"></a>const 定义常量</h1><pre><code class="javascript">//声明常量

const SCHOOL = &#39;恋爱学院&#39;;

//1. 一定要赋初始值

const A;

//2. 一般常量使用大写(潜规则)

const a = 100;

//3. 常量的值不能修改

SCHOOL = &#39;LIANAIXUEYUAN&#39;;

//4. 块儿级作用域

&#123;
    const PLAYER = &#39;UZI&#39;;
&#125;

console.log(PLAYER);

//5. 对于数组和对象的元素修改, 不算做对常量的修改, 不会报错

const TEAM = [&#39;UZI&#39;,&#39;MXLG&#39;,&#39;Ming&#39;,&#39;Letme&#39;];
TEAM.push(&#39;Meiko&#39;);
</code></pre>
<blockquote>
<p>const 关键字用来声明常量，const 声明有以下特点</p>
<pre><code>1) 声明必须赋初始值
2) 标识符一般为大写
3) 不允许重复声明
4) 值不允许修改
5) 块儿级作用域
</code></pre>
</blockquote>
<pre><code>  注意: 对象属性修改和数组元素变化不会出发 const 错误
  应用场景：声明对象类型使用 const，非对象类型声明选择 let
</code></pre>
<h1 id="变量解构赋值"><a href="#变量解构赋值" class="headerlink" title="变量解构赋值"></a>变量解构赋值</h1><pre><code class="javascript">//ES6 允许按照一定模式从数组和对象中提取值，对变量进行赋值，
//这被称为解构赋值。
//1. 数组的结构
const F4 = [&#39;小沈阳&#39;,&#39;刘能&#39;,&#39;赵四&#39;,&#39;宋小宝&#39;];
let [xiao, liu, zhao, song] = F4;
console.log(xiao);
console.log(liu);
console.log(zhao);
console.log(song);

//2. 对象的解构
const zhao = &#123;
    name: &#39;赵本山&#39;,
    age: &#39;不详&#39;,
    xiaopin: function()&#123;
        console.log(&quot;我可以演小品&quot;);
    &#125;
&#125;;

let &#123;name, age, xiaopin&#125; = zhao;
console.log(name);
console.log(age);
console.log(xiaopin);
xiaopin();

let &#123;xiaopin&#125; = zhao;
xiaopin();
</code></pre>
<blockquote>
<p>注意：频繁使用对象方法、数组元素，就可以使用解构赋值形式</p>
</blockquote>
<h1 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h1><blockquote>
<p>模板字符串（template string）是增强版的字符串，用反引号（`）标识，特点：</p>
<pre><code>1) 字符串中可以出现换行符
2) 可以使用 $&#123;xxx&#125; 形式输出变量
   注意：当遇到字符串与变量拼接的情况使用模板字符串
</code></pre>
</blockquote>
<pre><code class="javasciprt">// ES6 引入新的声明字符串的方式 『``』 &#39;&#39; &quot;&quot; 
//1. 声明
let str = `我也是一个字符串哦!`;
console.log(str, typeof str);

//2. 内容中可以直接出现换行符
let str = `&lt;ul&gt;
        &lt;li&gt;沈腾&lt;/li&gt;
        &lt;li&gt;玛丽&lt;/li&gt;
        &lt;li&gt;魏翔&lt;/li&gt;
        &lt;li&gt;艾伦&lt;/li&gt;
        &lt;/ul&gt;`;

//3. 变量拼接
let lovest = &#39;魏翔&#39;;
let out = `$&#123;lovest&#125;是我心目中最搞笑的演员!!`;
console.log(out);
</code></pre>
<h1 id="简化对象写法"><a href="#简化对象写法" class="headerlink" title="简化对象写法"></a>简化对象写法</h1><pre><code class="javascript">//ES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。
//这样的书写更加简洁
let name = &#39;恋爱学院&#39;;
let change = function()&#123;
    console.log(&#39;我们可以改变你!!&#39;);
&#125;

const school = &#123;
    name,
    change,
    improve()&#123;
    console.log(&quot;我们可以提高你的技能&quot;);
    &#125;
&#125;

console.log(school);
</code></pre>
<h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><pre><code class="javascript">// ES6 允许使用「箭头」（=&gt;）定义函数。
//声明一个函数
let fn = function() &#123;

&#125;
let fn = (a, b) =&gt; &#123;
    return a + b;
&#125;

//调用函数
let result = fn(1, 2);
console.log(result);


//1. this 是静态的. this 始终指向函数声明时所在作用域下的 this 的值
function getName() &#123;
    console.log(this.name);
&#125;
let getName2 = () =&gt; &#123;
    console.log(this.name);
&#125;

//设置 window 对象的 name 属性
window.name = &#39;恋爱学院&#39;;
const school = &#123;
    name: &quot;LIANAIXUEYUAN&quot;
&#125;

//直接调用
getName();
getName2();

//call 方法调用
getName.call(school);
getName2.call(school);

//2. 不能作为构造实例化对象
let Person = (name, age) =&gt; &#123;
    this.name = name;
    this.age = age;
    &#125;
let me = new Person(&#39;xiao&#39;, 30);
console.log(me);

//3. 不能使用 arguments 变量
let fn = () =&gt; &#123;
    console.log(arguments);
&#125;
fn(1, 2, 3);

//4. 箭头函数的简写
//1) 省略小括号, 当形参有且只有一个的时候
let add = n =&gt; &#123;
    return n + n;
&#125;
console.log(add(9));
//2) 省略花括号, 当代码体只有一条语句的时候, 此时 return 必须省略
// 而且语句的执行结果就是函数的返回值
let pow = n =&gt; n * n;

console.log(pow(8));
</code></pre>
<h1 id="箭头函数实践"><a href="#箭头函数实践" class="headerlink" title="箭头函数实践"></a>箭头函数实践</h1><pre><code class="javascript">&lt;style&gt;
    div &#123;
        width: 200px;
        height: 200px;
        background: #58a;
    &#125;
&lt;/style&gt;

&lt;html&gt;
    &lt;div id=&quot;ad&quot;&gt;&lt;/div&gt;    
&lt;/html&gt;
&lt;script&gt;
        //需求-1  点击 div 2s 后颜色变成『粉色』
        //获取元素
        let ad = document.getElementById(&#39;ad&#39;);
        //绑定事件
        ad.addEventListener(&quot;click&quot;, function() &#123;
            //保存 this 的值
            // let _this = this;
            //定时器
            setTimeout(() =&gt; &#123;
                //修改背景颜色 this
                // console.log(this);
                // _this.style.background = &#39;pink&#39;;
                this.style.background = &#39;pink&#39;;
            &#125;, 2000);
        &#125;);

        //需求-2  从数组中返回偶数的元素
        const arr = [1, 6, 9, 10, 100, 25];
        // const result = arr.filter(function(item)&#123;
        //     if(item % 2 === 0)&#123;
        //         return true;
        //     &#125;else&#123;
        //         return false;
        //     &#125;
        // &#125;);

        const result = arr.filter(item =&gt; item % 2 === 0);

        console.log(result);

        // 箭头函数适合与 this 无关的回调. 定时器, 数组的方法回调
        // 箭头函数不适合与 this 有关的回调.  事件回调, 对象的方法
    &lt;/script&gt;
</code></pre>
<h1 id="rest-参数"><a href="#rest-参数" class="headerlink" title="rest 参数"></a>rest 参数</h1><blockquote>
<p>ES6 引入 rest 参数，用于获取函数的实参，用来代替 arguments</p>
<p>注意：rest 参数非常适合不定个数参数函数的场景</p>
</blockquote>
<pre><code class="javascript">&lt;script&gt;
    // ES6 引入 rest 参数，用于获取函数的实参，用来代替 arguments
    // ES5 获取实参的方式
    function date() &#123;
        console.log(arguments);
    &#125;
    date(&#39;白芷&#39;, &#39;阿娇&#39;, &#39;思慧&#39;);

    // rest 参数
    function date(...args) &#123;
        console.log(args); // filter some every map 
    &#125;
    date(&#39;阿娇&#39;, &#39;柏芝&#39;, &#39;思慧&#39;);

    // rest 参数必须要放到参数最后
    function fn(a, b, ...args) &#123;
        console.log(a);
        console.log(b);
        console.log(args);
    &#125;
    fn(1, 2, 3, 4, 5, 6);
&lt;/script&gt;
</code></pre>
<h1 id="spread-扩展运算符"><a href="#spread-扩展运算符" class="headerlink" title="spread 扩展运算符"></a>spread 扩展运算符</h1><blockquote>
<p>扩展运算符（spread）也是三个点（…）。它好比 rest 参数的逆运算，将一 9 更多 Java –大数据 –前端 –python 人工智能资料下载，可访问百度：尚硅谷官网 个数组转为用逗号分隔的参数序列，对数组进行解包。</p>
</blockquote>
<pre><code class="javascript">&lt;script&gt;
    // 『...』 扩展运算符能将『数组』转换为逗号分隔的『参数序列』
    //声明一个数组 ...
    const tfboys = [&#39;易烊千玺&#39;,&#39;王源&#39;,&#39;王俊凯&#39;];
    // =&gt; &#39;易烊千玺&#39;,&#39;王源&#39;,&#39;王俊凯&#39;

    // 声明一个函数
    function chunwan()&#123;
        console.log(arguments);
    &#125;

    chunwan(...tfboys);// chunwan(&#39;易烊千玺&#39;,&#39;王源&#39;,&#39;王俊凯&#39;)
&lt;/script&gt;
</code></pre>
<h1 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h1><blockquote>
<p>ES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，是一种类似于字符串的数据类型。</p>
<p>Symbol 特点 </p>
<ol>
<li>Symbol 的值是唯一的，用来解决命名冲突的问题 </li>
<li>Symbol 值不能与其他数据进行运算 </li>
<li>Symbol 定义 的 对象属 性 不能 使 用 for…in 循 环遍 历 ，但 是可 以 使 用 Reflect.ownKeys 来获取对象的所有键名</li>
</ol>
</blockquote>
<pre><code class="javascript">&lt;script&gt;
    //创建Symbol
    let s = Symbol();
    // console.log(s, typeof s);
    let s2 = Symbol(&#39;恋爱学院&#39;);
    let s3 = Symbol(&#39;恋爱学院&#39;);
    //Symbol.for 创建
    let s4 = Symbol.for(&#39;恋爱学院&#39;);
    let s5 = Symbol.for(&#39;恋爱学院&#39;);

    //不能与其他数据进行运算
    //    let result = s + 100;
    //    let result = s &gt; 100;
    //    let result = s + s;

    // USONB  you are so niubility 
    // u  undefined
    // s  string  symbol
    // o  object
    // n  null number
    // b  boolean
&lt;/script&gt;
</code></pre>
<h1 id="Symbol创建对象属性"><a href="#Symbol创建对象属性" class="headerlink" title="Symbol创建对象属性"></a>Symbol创建对象属性</h1><pre><code class="javascript">&lt;script&gt;
    //向对象中添加方法 up down
    let game = &#123;
        name:&#39;俄罗斯方块&#39;,
        up: function()&#123;&#125;,
        down: function()&#123;&#125;
    &#125;;
    
    //声明一个对象
    let methods = &#123;
        up: Symbol(),
        down: Symbol()
    &#125;;

    game[methods.up] = function()&#123;
        console.log(&quot;我可以改变形状&quot;);
    &#125;

    game[methods.down] = function()&#123;
        console.log(&quot;我可以快速下降!!&quot;);
    &#125;

    console.log(game);

    let youxi = &#123;
        name:&quot;狼人杀&quot;,
        [Symbol(&#39;say&#39;)]: function()&#123;
            console.log(&quot;我可以发言&quot;)
        &#125;,
        [Symbol(&#39;zibao&#39;)]: function()&#123;
            console.log(&#39;我可以自爆&#39;);
        &#125;
    &#125;

    console.log(youxi)
&lt;/script&gt;
</code></pre>
<h1 id="Symbol内置属性"><a href="#Symbol内置属性" class="headerlink" title="Symbol内置属性"></a>Symbol内置属性</h1><pre><code class="javascript">&lt;script&gt;
    class Person &#123;
        static[Symbol.hasInstance](param) &#123;
            console.log(param);
            console.log(&quot;我被用来检测类型了&quot;);
            return false;
        &#125;
    &#125;

    let o = &#123;&#125;;

    console.log(o instanceof Person);

    const arr = [1, 2, 3];
    const arr2 = [4, 5, 6];
    arr2[Symbol.isConcatSpreadable] = false;
    console.log(arr.concat(arr2));
&lt;/script&gt; 
    ...
</code></pre>
<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><blockquote>
<p>遍历器（Iterator）就是一种机制。它是一种接口，为各种不同的数据结构提 供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作。 </p>
<p>ES6 创造了一种新的遍历命令 for…of 循环，Iterator 接口主要供 for…of 消费 </p>
<ol start="2">
<li>原生具备 iterator 接口的数据(可用 for of 遍历) <ol>
<li>a) Array</li>
<li>b) Arguments</li>
<li>c) Set </li>
<li>d) Map</li>
<li>e) String</li>
<li>f) TypedArray</li>
<li>g) NodeList </li>
</ol>
</li>
<li><ol start="3">
<li>工作原理 <ol>
<li>a) 创建一个指针对象，指向当前数据结构的起始位置 </li>
<li>b) 第一次调用对象的 next 方法，指针自动指向数据结构的第一个成员 </li>
<li>c) 接下来不断调用 next 方法，指针一直往后移动，直到指向最后一个成员 </li>
<li>d) 每调用 next 方法返回一个包含 value 和 done 属性的对象 注: 需要自定义遍历数据的时候，要想到迭代器。</li>
</ol>
</li>
</ol>
</li>
</ol>
</blockquote>
<pre><code class="javascript">&lt;script&gt;
    //声明一个数组
    const xiyou = [&#39;唐僧&#39;,&#39;孙悟空&#39;,&#39;猪八戒&#39;,&#39;沙僧&#39;];

    //使用 for...of 遍历数组
    // for(let v of xiyou)&#123;
    //     console.log(v);
    // &#125;

    let iterator = xiyou[Symbol.iterator]();

    //调用对象的next方法
    console.log(iterator.next());
    console.log(iterator.next());
    console.log(iterator.next());
    console.log(iterator.next());
    console.log(iterator.next());
&lt;/script&gt;
</code></pre>
<h1 id="迭代器自定义遍历对象"><a href="#迭代器自定义遍历对象" class="headerlink" title="迭代器自定义遍历对象"></a>迭代器自定义遍历对象</h1><pre><code class="javascript">&lt;script&gt;
    //声明一个对象
    const banji = &#123;
        name: &quot;终极一班&quot;,
        stus: [
            &#39;xiaoming&#39;,
            &#39;xiaoning&#39;,
            &#39;xiaotian&#39;,
            &#39;knight&#39;
        ],
        [Symbol.iterator]() &#123;
            //索引变量
            let index = 0;
            //
            let _this = this;
            return &#123;
                next: function () &#123;
                    if (index &lt; _this.stus.length) &#123;
                        const result = &#123; value: _this.stus[index], done: false &#125;;
                        //下标自增
                        index++;
                        //返回结果
                        return result;
                    &#125;else&#123;
                        return &#123;value: undefined, done: true&#125;;
                    &#125;
                &#125;
            &#125;;
        &#125;
    &#125;

    //遍历这个对象 
    for (let v of banji) &#123;
        console.log(v);
    &#125;
&lt;/script&gt;
</code></pre>
<h1 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h1><blockquote>
<ol>
<li>‘*’ 的位置没有限制 </li>
<li>生成器函数返回的结果是迭代器对象，调用迭代器对象的 next 方法可以得到 yield 语句后的值 </li>
<li>yield 相当于函数的暂停标记，也可以认为是函数的分隔符，每调用一次 next 方法，执行一段代码 </li>
<li>next 方法可以传递实参，作为 yield 语句的返回值</li>
</ol>
</blockquote>
<pre><code class="javascript">&lt;script&gt;    
    //生成器其实就是一个特殊的函数
    //异步编程  纯回调函数  node fs  ajax mongodb
    //函数代码的分隔符
    function * gen()&#123;
        // console.log(111);
        yield &#39;一只没有耳朵&#39;;
        // console.log(222);
        yield &#39;一只没有尾部&#39;;
        // console.log(333);
        yield &#39;真奇怪&#39;;
        // console.log(444);
    &#125;

    let iterator = gen();
    console.log(iterator.next());
    console.log(iterator.next());
    console.log(iterator.next());
    console.log(iterator.next());

    //遍历
    // for(let v of gen())&#123;
    //     console.log(v);
    // &#125;

&lt;/script&gt;
</code></pre>
<h1 id="生成器函数参数"><a href="#生成器函数参数" class="headerlink" title="生成器函数参数"></a>生成器函数参数</h1><pre><code class="javascript">&lt;script&gt;
    function * gen(arg)&#123;
        console.log(arg);
        let one = yield 111;
        console.log(one);
        let two = yield 222;
        console.log(two);
        let three = yield 333;
        console.log(three);
    &#125;

    //执行获取迭代器对象
    let iterator = gen(&#39;AAA&#39;);
    console.log(iterator.next());
    //next方法可以传入实参
    console.log(iterator.next(&#39;BBB&#39;));
    console.log(iterator.next(&#39;CCC&#39;));
    console.log(iterator.next(&#39;DDD&#39;));
    
&lt;/script&gt;
</code></pre>
<h1 id="生成器函数实例"><a href="#生成器函数实例" class="headerlink" title="生成器函数实例"></a>生成器函数实例</h1><pre><code class="javascript">&lt;script&gt;
    // 异步编程  文件操作 网络操作(ajax, request) 数据库操作
    // 1s 后控制台输出 111  2s后输出 222  3s后输出 333 
    // 回调地狱
    // setTimeout(() =&gt; &#123;
    //     console.log(111);
    //     setTimeout(() =&gt; &#123;
    //         console.log(222);
    //         setTimeout(() =&gt; &#123;
    //             console.log(333);
    //         &#125;, 3000);
    //     &#125;, 2000);
    // &#125;, 1000);

    function one()&#123;
        setTimeout(()=&gt;&#123;
            console.log(111);
            iterator.next();
        &#125;,1000)
    &#125;

    function two()&#123;
        setTimeout(()=&gt;&#123;
            console.log(222);
            iterator.next();
        &#125;,2000)
    &#125;

    function three()&#123;
        setTimeout(()=&gt;&#123;
            console.log(333);
            iterator.next();
        &#125;,3000)
    &#125;

    function * gen()&#123;
        yield one();
        yield two();
        yield three();
    &#125;

    //调用生成器函数
    let iterator = gen();
    iterator.next();

&lt;/script&gt;
</code></pre>
<h1 id="生成器函数实例-2"><a href="#生成器函数实例-2" class="headerlink" title="生成器函数实例-2"></a>生成器函数实例-2</h1><pre><code class="javascript">&lt;script&gt;
    //模拟获取  用户数据  订单数据  商品数据 
    function getUsers()&#123;
        setTimeout(()=&gt;&#123;
            let data = &#39;用户数据&#39;;
            //调用 next 方法, 并且将数据传入
            iterator.next(data);
        &#125;, 1000);
    &#125;

    function getOrders()&#123;
        setTimeout(()=&gt;&#123;
            let data = &#39;订单数据&#39;;
            iterator.next(data);
        &#125;, 1000)
    &#125;

    function getGoods()&#123;
        setTimeout(()=&gt;&#123;
            let data = &#39;商品数据&#39;;
            iterator.next(data);
        &#125;, 1000)
    &#125;

    function * gen()&#123;
        let users = yield getUsers();
        let orders = yield getOrders();
        let goods = yield getGoods();
    &#125;

    //调用生成器函数
    let iterator = gen();
    iterator.next();
&lt;/script&gt;
</code></pre>
<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><blockquote>
<p>Promise 是 ES6 引入的异步编程的新解决方案。语法上 Promise 是一个构造函数， 用来封装异步操作并可以获取其成功或失败的结果。</p>
<p>\1) Promise 构造函数: Promise (excutor) {}</p>
<p>\2) Promise.prototype.then 方法</p>
<p>\3) Promise.prototype.catch 方法</p>
</blockquote>
<pre><code class="md">   插秧诗
     布袋和尚 
手把青秧插满田，
低头便见水中天。
心地清净方为道，
退步原来是向前。

   观书有感 
    作者：朱熹
半亩方塘一鉴开，
天光云影共徘徊。
问渠那得清如许？
为有源头活水来。

   为学
天下事有难易乎？
为之，则难者亦易矣；
不为，则易者亦难矣
</code></pre>
<h1 id="1-Promise基本语法"><a href="#1-Promise基本语法" class="headerlink" title="1-Promise基本语法"></a>1-Promise基本语法</h1><pre><code class="javascript">&lt;script&gt;
    //实例化 Promise 对象
    const p = new Promise(function(resolve, reject)&#123;
        setTimeout(function()&#123;
            //
            // let data = &#39;数据库中的用户数据&#39;;
            // resolve
            // resolve(data);

            let err = &#39;数据读取失败&#39;;
            reject(err);
        &#125;, 1000);
    &#125;);

    //调用 promise 对象的 then 方法
    p.then(function(value)&#123;
        console.log(value);
    &#125;, function(reason)&#123;
        console.error(reason);
    &#125;)
&lt;/script&gt;
</code></pre>
<h1 id="2-Promise封装读取文件"><a href="#2-Promise封装读取文件" class="headerlink" title="2-Promise封装读取文件"></a>2-Promise封装读取文件</h1><pre><code class="javascript">//1. 引入 fs 模块
const fs = require(&#39;fs&#39;);

//2. 调用方法读取文件
// fs.readFile(&#39;./resources/为学.md&#39;, (err, data)=&gt;&#123;
//     //如果失败, 则抛出错误
//     if(err) throw err;
//     //如果没有出错, 则输出内容
//     console.log(data.toString());
// &#125;);

//3. 使用 Promise 封装
const p = new Promise(function(resolve, reject)&#123;
    fs.readFile(&quot;./resources/为学.mda&quot;, (err, data)=&gt;&#123;
        //判断如果失败
        if(err) reject(err);
        //如果成功
        resolve(data);
    &#125;);
&#125;);

p.then(function(value)&#123;
    console.log(value.toString());
&#125;, function(reason)&#123;
    console.log(&quot;读取失败!!&quot;);
&#125;);
</code></pre>
<h1 id="3-Promise封装AJAX"><a href="#3-Promise封装AJAX" class="headerlink" title="3-Promise封装AJAX"></a>3-Promise封装AJAX</h1><pre><code class="javascript">&lt;script&gt;
    // 接口地址: https://api.apiopen.top/getJoke
    const p = new Promise((resolve, reject) =&gt; &#123;
        //1. 创建对象
        const xhr = new XMLHttpRequest();

        //2. 初始化
        xhr.open(&quot;GET&quot;, &quot;https://api.apiopen.top/getJ&quot;);

        //3. 发送
        xhr.send();

        //4. 绑定事件, 处理响应结果
        xhr.onreadystatechange = function () &#123;
            //判断
            if (xhr.readyState === 4) &#123;
                //判断响应状态码 200-299
                if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) &#123;
                    //表示成功
                    resolve(xhr.response);
                &#125; else &#123;
                    //如果失败
                    reject(xhr.status);
                &#125;
            &#125;
        &#125;
    &#125;)
    
    //指定回调
    p.then(function(value)&#123;
        console.log(value);
    &#125;, function(reason)&#123;
        console.error(reason);
    &#125;);
&lt;/script&gt;
</code></pre>
<h1 id="4-Promise-then方法"><a href="#4-Promise-then方法" class="headerlink" title="4-Promise-then方法"></a>4-Promise-then方法</h1><pre><code class="javascript">&lt;script&gt;
    //创建 promise 对象
    const p = new Promise((resolve, reject)=&gt;&#123;
        setTimeout(()=&gt;&#123;
            resolve(&#39;用户数据&#39;);
            // reject(&#39;出错啦&#39;);
        &#125;, 1000)
    &#125;);

    //调用 then 方法  then方法的返回结果是 Promise 对象, 对象状态由回调函数的执行结果决定
    //1. 如果回调函数中返回的结果是 非 promise 类型的属性, 状态为成功, 返回值为对象的成功的值

    // const result = p.then(value =&gt; &#123;
    //     console.log(value);
    //     //1. 非 promise 类型的属性
    //     // return &#39;iloveyou&#39;;
    //     //2. 是 promise 对象
    //     // return new Promise((resolve, reject)=&gt;&#123;
    //     //     // resolve(&#39;ok&#39;);
    //     //     reject(&#39;error&#39;);
    //     // &#125;);
    //     //3. 抛出错误
    //     // throw new Error(&#39;出错啦!&#39;);
    //     throw &#39;出错啦!&#39;;
    // &#125;, reason=&gt;&#123;
    //     console.warn(reason);
    // &#125;);

    //链式调用
    p.then(value=&gt;&#123;

    &#125;).then(value=&gt;&#123;

    &#125;);
&lt;/script&gt;
</code></pre>
<h1 id="5-Promise-catch方法"><a href="#5-Promise-catch方法" class="headerlink" title="5-Promise-catch方法"></a>5-Promise-catch方法</h1><pre><code class="javascript">&lt;script&gt;
    const p = new Promise((resolve, reject)=&gt;&#123;
        setTimeout(()=&gt;&#123;
            //设置 p 对象的状态为失败, 并设置失败的值
            reject(&quot;出错啦!&quot;);
        &#125;, 1000)
    &#125;);

    // p.then(function(value)&#123;&#125;, function(reason)&#123;
    //     console.error(reason);
    // &#125;);

    p.catch(function(reason)&#123;
        console.warn(reason);
    &#125;);
&lt;/script&gt;
</code></pre>
<h1 id="6-Promise实践-读取多个文件"><a href="#6-Promise实践-读取多个文件" class="headerlink" title="6-Promise实践-读取多个文件"></a>6-Promise实践-读取多个文件</h1><pre><code class="javascript">//引入 fs 模块
const fs = require(&quot;fs&quot;);

// fs.readFile(&#39;./resources/为学.md&#39;, (err, data1)=&gt;&#123;
//     fs.readFile(&#39;./resources/插秧诗.md&#39;, (err, data2)=&gt;&#123;
//         fs.readFile(&#39;./resources/观书有感.md&#39;, (err, data3)=&gt;&#123;
//             let result = data1 + &#39;\r\n&#39; +data2  +&#39;\r\n&#39;+ data3;
//             console.log(result);
//         &#125;);
//     &#125;);
// &#125;);

//使用 promise 实现
const p = new Promise((resolve, reject) =&gt; &#123;
    fs.readFile(&quot;./resources/为学.md&quot;, (err, data) =&gt; &#123;
        resolve(data);
    &#125;);
&#125;);

p.then(value =&gt; &#123;
    return new Promise((resolve, reject) =&gt; &#123;
        fs.readFile(&quot;./resources/插秧诗.md&quot;, (err, data) =&gt; &#123;
            resolve([value, data]);
        &#125;);
    &#125;);
&#125;).then(value =&gt; &#123;
    return new Promise((resolve, reject) =&gt; &#123;
        fs.readFile(&quot;./resources/观书有感.md&quot;, (err, data) =&gt; &#123;
            //压入
            value.push(data);
            resolve(value);
        &#125;);
    &#125;)
&#125;).then(value =&gt; &#123;
    console.log(value.join(&#39;\r\n&#39;));
&#125;);
</code></pre>
<h1 id="set集合"><a href="#set集合" class="headerlink" title="set集合"></a>set集合</h1><pre><code class="javascript">&lt;script&gt;
    //声明一个 set
    let s = new Set();
    let s2 = new Set([&#39;大事儿&#39;,&#39;小事儿&#39;,&#39;好事儿&#39;,&#39;坏事儿&#39;,&#39;小事儿&#39;]);

    //元素个数
    // console.log(s2.size);
    //添加新的元素
    // s2.add(&#39;喜事儿&#39;);
    //删除元素
    // s2.delete(&#39;坏事儿&#39;);
    //检测
    // console.log(s2.has(&#39;糟心事&#39;));
    //清空
    // s2.clear();
    // console.log(s2);

    for(let v of s2)&#123;
        console.log(v);
    &#125;
    
&lt;/script&gt;
</code></pre>
<h1 id="Set集合实践"><a href="#Set集合实践" class="headerlink" title="Set集合实践"></a>Set集合实践</h1><pre><code class="JavaScript">&lt;script&gt;
    let arr = [1,2,3,4,5,4,3,2,1];
    //1. 数组去重
    // let result = [...new Set(arr)];
    // console.log(result);
    //2. 交集
    let arr2 = [4,5,6,5,6];
    // let result = [...new Set(arr)].filter(item =&gt; &#123;
    //     let s2 = new Set(arr2);// 4 5 6
    //     if(s2.has(item))&#123;
    //         return true;
    //     &#125;else&#123;
    //         return false;
    //     &#125;
    // &#125;);
    // let result = [...new Set(arr)].filter(item =&gt; new Set(arr2).has(item));
    // console.log(result);

    //3. 并集
    // let union = [...new Set([...arr, ...arr2])];
    // console.log(union);

    //4. 差集
    let diff = [...new Set(arr)].filter(item =&gt; !(new Set(arr2).has(item)));
    console.log(diff);

&lt;/script&gt;
</code></pre>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><pre><code class="javascript">&lt;script&gt;
    //声明 Map
    let m = new Map();

    //添加元素
    m.set(&#39;name&#39;,&#39;恋爱学院&#39;);
    m.set(&#39;change&#39;, function()&#123;
        console.log(&quot;我们可以改变你!!&quot;);
    &#125;);
    let key = &#123;
        school : &#39;ATGUIGU&#39;
    &#125;;
    m.set(key, [&#39;北京&#39;,&#39;上海&#39;,&#39;深圳&#39;]);

    //size
    // console.log(m.size);

    //删除
    // m.delete(&#39;name&#39;);

    //获取
    // console.log(m.get(&#39;change&#39;));
    // console.log(m.get(key));

    //清空
    // m.clear();

    //遍历
    for(let v of m)&#123;
        console.log(v);
    &#125;

    // console.log(m);

&lt;/script&gt;
</code></pre>
<h1 id="class类"><a href="#class类" class="headerlink" title="class类"></a>class类</h1><pre><code class="JavaScript">&lt;script&gt;
    //手机
    function Phone(brand, price)&#123;
        this.brand = brand;
        this.price = price;
    &#125;

    //添加方法
    Phone.prototype.call = function()&#123;
        console.log(&quot;我可以打电话!!&quot;);
    &#125;

    //实例化对象
    let Huawei = new Phone(&#39;华为&#39;, 5999);
    Huawei.call();
    console.log(Huawei);

    //class
    class Shouji&#123;
        //构造方法 名字不能修改
        constructor(brand, price)&#123;
            this.brand = brand;
            this.price = price;
        &#125;

        //方法必须使用该语法, 不能使用 ES5 的对象完整形式
        call()&#123;
            console.log(&quot;我可以打电话!!&quot;);
        &#125;
    &#125;

    let onePlus = new Shouji(&quot;1+&quot;, 1999);

    console.log(onePlus);
&lt;/script&gt;
</code></pre>
<h1 id="class-的-get-set"><a href="#class-的-get-set" class="headerlink" title="class 的 get-set"></a>class 的 get-set</h1><pre><code class="JavaScript">&lt;script&gt;
    // get 和 set  
    class Phone&#123;
        get price()&#123;
            console.log(&quot;价格属性被读取了&quot;);
            return &#39;iloveyou&#39;;
        &#125;

        set price(newVal)&#123;
            console.log(&#39;价格属性被修改了&#39;);
        &#125;
    &#125;

    //实例化对象
    let s = new Phone();

    // console.log(s.price);
    s.price = &#39;free&#39;;
&lt;/script&gt;
</code></pre>
<h1 id="类继承"><a href="#类继承" class="headerlink" title="类继承"></a>类继承</h1><pre><code class="JavaScript">&lt;script&gt;
    //手机
    function Phone(brand, price)&#123;
        this.brand = brand;
        this.price = price;
    &#125;

    Phone.prototype.call = function()&#123;
        console.log(&quot;我可以打电话&quot;);
    &#125;

    //智能手机
    function SmartPhone(brand, price, color, size)&#123;
        Phone.call(this, brand, price);
        this.color = color;
        this.size = size;
    &#125;

    //设置子级构造函数的原型
    SmartPhone.prototype = new Phone;
    SmartPhone.prototype.constructor = SmartPhone;

    //声明子类的方法
    SmartPhone.prototype.photo = function()&#123;
        console.log(&quot;我可以拍照&quot;)
    &#125;

    SmartPhone.prototype.playGame = function()&#123;
        console.log(&quot;我可以玩游戏&quot;);
    &#125;

    const chuizi = new SmartPhone(&#39;锤子&#39;,2499,&#39;黑色&#39;,&#39;5.5inch&#39;);

    console.log(chuizi);

&lt;/script&gt;
</code></pre>
<h1 id="类继承-2"><a href="#类继承-2" class="headerlink" title="类继承-2"></a>类继承-2</h1><pre><code class="JavaScript">&lt;script&gt;
    class Phone&#123;
        //构造方法
        constructor(brand, price)&#123;
            this.brand = brand;
            this.price = price;
        &#125;
        //父类的成员属性
        call()&#123;
            console.log(&quot;我可以打电话!!&quot;);
        &#125;
    &#125;

    class SmartPhone extends Phone &#123;
        //构造方法
        constructor(brand, price, color, size)&#123;
            super(brand, price);// Phone.call(this, brand, price)
            this.color = color;
            this.size = size;
        &#125;

        photo()&#123;
            console.log(&quot;拍照&quot;);
        &#125;

        playGame()&#123;
            console.log(&quot;玩游戏&quot;);
        &#125;

        call()&#123;
            console.log(&#39;我可以进行视频通话&#39;);
        &#125;
    &#125;

    const xiaomi = new SmartPhone(&#39;小米&#39;,799,&#39;黑色&#39;,&#39;4.7inch&#39;);
    // console.log(xiaomi);
    xiaomi.call();
    xiaomi.photo();
    xiaomi.playGame();
&lt;/script&gt;
</code></pre>
<h1 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h1><pre><code class="JavaScript">&lt;script&gt;
    // function Phone()&#123;

    // &#125;
    // Phone.name = &#39;手机&#39;;
    // Phone.change = function()&#123;
    //     console.log(&quot;我可以改变世界&quot;);
    // &#125;
    // Phone.prototype.size = &#39;5.5inch&#39;;

    // let nokia = new Phone();

    // console.log(nokia.name);
    // // nokia.change();
    // console.log(nokia.size);

    class Phone&#123;
        //静态属性
        static name = &#39;手机&#39;;
        static change()&#123;
            console.log(&quot;我可以改变世界&quot;);
        &#125;
    &#125;

    let nokia = new Phone();
    console.log(nokia.name);
    console.log(Phone.name);
&lt;/script&gt;
</code></pre>
<h1 id="对象方法扩展"><a href="#对象方法扩展" class="headerlink" title="对象方法扩展"></a>对象方法扩展</h1><pre><code class="JavaScript">&lt;script&gt;
    //1. Object.is 判断两个值是否完全相等 
    console.log(Object.is(120, 120));// === 
    console.log(Object.is(NaN, NaN));// === 
    console.log(NaN === NaN);// === 

    //2. Object.assign 对象的合并
    const config1 = &#123;
        host: &#39;localhost&#39;,
        port: 3306,
        name: &#39;root&#39;,
        pass: &#39;root&#39;,
        test: &#39;test&#39;
    &#125;;
    const config2 = &#123;
        host: &#39;http://atguigu.com&#39;,
        port: 33060,
        name: &#39;atguigu.com&#39;,
        pass: &#39;iloveyou&#39;,
        test2: &#39;test2&#39;
    &#125;
    console.log(Object.assign(config1, config2));

    //3. Object.setPrototypeOf 设置原型对象  Object.getPrototypeof
    const school = &#123;
        name: &#39;尚硅谷&#39;
    &#125;
    const cities = &#123;
        xiaoqu: [&#39;北京&#39;,&#39;上海&#39;,&#39;深圳&#39;]
    &#125;
    Object.setPrototypeOf(school, cities);
    console.log(Object.getPrototypeOf(school));
    console.log(school);
&lt;/script&gt;
</code></pre>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title>es6</title>
    <url>/2015/03/14/es6/</url>
    <content><![CDATA[<p><strong>ECMAScript6</strong> </p>
<p>我们现在用的javascript（注意，是javascript语言本身，不包含DOM等其他东西）背后的标准是ECMA-262，也叫ECMAScript 5。它的下一个版本ECMAScript 6（简称es6），已经基本上快定稿了。这个版本里加入了很多开发过程中需要的一些功能，例如： </p>
<ul>
<li>类定义语法，包括super，继承</li>
<li>lambda风格的函数定义，=&gt; block level函数定义内的lexical scope的this，默认参数，rest参数等</li>
<li>destructuring, 类似于ruby里的 [a, b, c] = [1, 2, 3]，同时也适用于map和set，以及函数参数</li>
<li>symbol</li>
<li>iterator迭代器和generator，以及新的for of循环语法</li>
<li>template string，从此可以像在ruby和shell里一样使用多行字符串</li>
<li>module语法，从语言层面上支持了模块</li>
<li>另外还有一系列新东西例如promise，proxy，unicode支持等</li>
</ul>
<p>目前chrome和firefox已经开始逐步支持es6。不过你不用等到所有浏览器都开始支持es6后才可以使用它，因为目前已经有很多把es6代码编译成es5代码的工具，例如babel和traceur等。有很多js的库已经开始使用es6的各种功能了，其中包括angular 2.0。 </p>
<p>很多人应该在用coffeescript，es6的很多功能弥补了之前es5的缺陷，吸收了很多coffeescript的功能，也许以后我们就可以不用coffeescript了，除非你不喜欢大括号小括号，而喜欢python的语法。不过如果coffeescript不进行升级，估计就享受不到将来es6带来的好处，也难以适应HTML5时代各种数值计算的需求。 </p>
]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>ES Promise.all/race</title>
    <url>/2020/07/01/jsPromise%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="一、Promise基础用法"><a href="#一、Promise基础用法" class="headerlink" title="一、Promise基础用法"></a>一、Promise基础用法</h1><h2 id="1-1-基本用法"><a href="#1-1-基本用法" class="headerlink" title="1.1 基本用法"></a>1.1 基本用法</h2><pre><code>new Promise(function(resolve, reject) &#123;
    //待处理的异步逻辑
    //处理结束后，调用resolve或reject方法
&#125;)
</code></pre>
<blockquote>
<ul>
<li>新建一个<code>promise</code>很简单，只需要<code>new</code>一个<code>promise</code>对象即可。所以<code>promise</code>本质上就是一个函数，它接受一个函数作为参数，并且会返回<code>promise</code>对象，这就给链式调用提供了基础</li>
<li>其实<code>Promise</code>函数的使命，就是构建出它的实例，并且负责帮我们管理这些实例。而这些实例有以下三种状态：</li>
</ul>
</blockquote>
<ul>
<li><code>pending</code>: 初始状态，位履行或拒绝</li>
<li><code>fulfilled</code>: 意味着操作成功完成</li>
<li><code>rejected</code>: 意味着操作失败</li>
</ul>
<blockquote>
<p><code>pending</code> 状态的 <code>Promise</code>对象可能以 <code>fulfilled</code>状态返回了一个值，也可能被某种理由（异常信息）拒绝（<code>reject</code>）了。当其中任一种情况出现时，<code>Promise</code> 对象的 <code>then</code> 方法绑定的处理方法（handlers）就会被调用，then方法分别指定了<code>resolve</code>方法和<code>reject</code>方法的回调函数</p>
</blockquote>
<p><img src="https://mengera88.github.io/images/promises.png" alt="img"></p>
<pre><code>var promise = new Promise(function(resolve, reject) &#123;
  if (/* 异步操作成功 */)&#123;
    resolve(value);
  &#125; else &#123;
    reject(error);
  &#125;
&#125;);
promise.then(function(value) &#123;
  // 如果调用了resolve方法，执行此函数
&#125;, function(value) &#123;
  // 如果调用了reject方法，执行此函数
&#125;);
</code></pre>
<blockquote>
<p>上述代码很清晰的展示了<code>promise</code>对象运行的机制。下面再看一个示例：</p>
</blockquote>
<pre><code>var getJSON = function(url) &#123;
  var promise = new Promise(function(resolve, reject)&#123;
    var client = new XMLHttpRequest();
    client.open(&quot;GET&quot;, url);
    client.onreadystatechange = handler;
    client.responseType = &quot;json&quot;;
    client.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);
    client.send();
    function handler() &#123;
      if (this.status === 200) &#123; 
              resolve(this.response); 
          &#125; else &#123; 
              reject(new Error(this.statusText)); 
          &#125;
    &#125;;
  &#125;);
  return promise;
&#125;;
getJSON(&quot;/posts.json&quot;).then(function(json) &#123;
  console.log(&#39;Contents: &#39; + json);
&#125;, function(error) &#123;
  console.error(&#39;出错了&#39;, error);
&#125;);
</code></pre>
<blockquote>
<p>上面代码中，<code>resolve</code>方法和<code>reject</code>方法调用时，都带有参数。它们的参数会被传递给回调函数。<code>reject</code>方法的参数通常是<code>Error</code>对象的实例，而<code>resolve</code>方法的参数除了正常的值以外，还可能是另一个<code>Promise</code>实例，比如像下面这样。</p>
</blockquote>
<pre><code>var p1 = new Promise(function(resolve, reject)&#123;
  // ... some code
&#125;);
var p2 = new Promise(function(resolve, reject)&#123;
  // ... some code
  resolve(p1);
&#125;)
</code></pre>
<blockquote>
<p>上面代码中，<code>p1</code>和<code>p2</code>都是<code>Promise</code>的实例，但是<code>p2</code>的<code>resolve</code>方法将<code>p1</code>作为参数，这时<code>p1</code>的状态就会传递给<code>p2</code>。如果调用的时候，<code>p1</code>的状态是<code>pending</code>，那么<code>p2</code>的回调函数就会等待<code>p1</code>的状态改变；如果<code>p1</code>的状态已经是<code>fulfilled</code>或者<code>rejected</code>，那么<code>p2</code>的回调函数将会立刻执行</p>
</blockquote>
<h2 id="1-2-promise捕获错误"><a href="#1-2-promise捕获错误" class="headerlink" title="1.2 promise捕获错误"></a>1.2 promise捕获错误</h2><blockquote>
<p><code>Promise.prototype.catch</code>方法是<code>Promise.prototype.then(null, rejection)</code>的别名，用于指定发生错误时的回调函数</p>
</blockquote>
<pre><code>getJSON(&quot;/visa.json&quot;).then(function(result) &#123;
  // some code
&#125;).catch(function(error) &#123;
  // 处理前一个回调函数运行时发生的错误
  console.log(&#39;出错啦！&#39;, error);
&#125;);
</code></pre>
<blockquote>
<p><code>Promise</code>对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个<code>catch</code>语句捕获</p>
</blockquote>
<pre><code>getJSON(&quot;/visa.json&quot;).then(function(json) &#123;
  return json.name;
&#125;).then(function(name) &#123;
  // proceed
&#125;).catch(function(error) &#123;
    //处理前面任一个then函数抛出的错误
&#125;);
</code></pre>
<h2 id="1-3-常用的promise方法"><a href="#1-3-常用的promise方法" class="headerlink" title="1.3 常用的promise方法"></a>1.3 常用的promise方法</h2><p><strong>Promise.all方法</strong></p>
<blockquote>
<p><code>Promise.all</code>方法用于将多个<code>Promise</code>实例，包装成一个新的<code>Promise</code>实例</p>
</blockquote>
<pre><code>var p = Promise.all([p1,p2,p3]);
</code></pre>
<ul>
<li>上面代码中，<code>Promise.all</code>方法接受一个数组作为参数，<code>p1</code>、<code>p2</code>、<code>p3</code>都是<code>Promise</code>对象的实例。（<code>Promise.all</code>方法的参数不一定是数组，但是必须具有<code>iterator</code>接口，且返回的每个成员都是<code>Promise</code>实例。）</li>
</ul>
<blockquote>
<p><code>p</code>的状态由<code>p1</code>、<code>p2</code>、<code>p3</code>决定，分成两种情况</p>
</blockquote>
<ul>
<li>只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数</li>
<li>只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给p的回调函数</li>
</ul>
<pre><code>// 生成一个Promise对象的数组
var promises = [2, 3, 5, 7, 11, 13].map(function(id)&#123;
  return getJSON(&quot;/get/addr&quot; + id + &quot;.json&quot;);
&#125;);
Promise.all(promises).then(function(posts) &#123;
  // ...  
&#125;).catch(function(reason)&#123;
  // ...
&#125;);
</code></pre>
<p><strong>Promise.race方法</strong></p>
<blockquote>
<p><code>Promise.race</code>方法同样是将多个<code>Promise</code>实例，包装成一个新的<code>Promise</code>实例。</p>
</blockquote>
<pre><code>var p = Promise.race([p1,p2,p3]);
</code></pre>
<blockquote>
<p>上面代码中，只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的Promise实例的返回值，就传递给p的返回值</p>
</blockquote>
<ul>
<li>如果<code>Promise.all</code>方法和<code>Promise.race</code>方法的参数，不是<code>Promise</code>实例，就会先调用下面讲到的<code>Promise.resolve</code>方法，将参数转为<code>Promise</code>实例，再进一步处理</li>
</ul>
<p><strong>Promise.resolve</strong></p>
<blockquote>
<p>有时需要将现有对象转为<code>Promise</code>对象，<code>Promise.resolve</code>方法就起到这个作用</p>
</blockquote>
<pre><code>var jsPromise = Promise.resolve($.ajax(&#39;/whatever.json&#39;));
</code></pre>
<blockquote>
<p>上面代码将<code>jQuery</code>生成<code>deferred</code>对象，转为一个新的<code>ES6</code>的<code>Promise</code>对象</p>
</blockquote>
<ul>
<li>如果<code>Promise.resolve</code>方法的参数，不是具有<code>then</code>方法的对象（又称<code>thenable</code>对象），则返回一个新的<code>Promise</code>对象，且它的状态为<code>fulfilled</code>。</li>
</ul>
<pre><code>var p = Promise.resolve(&#39;Hello&#39;);
p.then(function (s)&#123;
  console.log(s)
&#125;);
// Hello
</code></pre>
<ul>
<li>上面代码生成一个新的<code>Promise</code>对象的实例<code>p</code>，它的状态为<code>fulfilled</code>，所以回调函数会立即执行，<code>Promise.resolve</code>方法的参数就是回调函数的参数</li>
<li>如果<code>Promise.resolve</code>方法的参数是一个<code>Promise</code>对象的实例，则会被原封不动地返回</li>
<li><code>Promise.reject(reason)</code>方法也会返回一个新的<code>Promise</code>实例，该实例的状态为<code>rejected</code>。<code>Promise.reject</code>方法的参数<code>reason</code>，会被传递给实例的回调函数</li>
</ul>
<pre><code>var p = Promise.reject(&#39;出错啦&#39;);
p.then(null, function (error)&#123;
  console.log(error)
&#125;);
// 出错了
</code></pre>
<h2 id="1-4-Async-await简化写法"><a href="#1-4-Async-await简化写法" class="headerlink" title="1.4 Async/await简化写法"></a>1.4 Async/await简化写法</h2><pre><code>function getDataAsync (url) &#123;
    return new Promise((resolve, reject) =&gt; &#123;
        setTimeout(() =&gt; &#123;
            var res = &#123;
                url: url,
                data: Math.random()
            &#125;
            resolve(res)
        &#125;, 1000)
    &#125;)
&#125;
async function getData () &#123;
    var res1 = await getDataAsync(&#39;/page/1?param=123&#39;)
    console.log(res1)
    var res2 = await getDataAsync(`/page/2?param=$&#123;res1.data&#125;`)
    console.log(res2)
    var res3 = await getDataAsync(`/page/2?param=$&#123;res2.data&#125;`)
    console.log(res3)
&#125;
</code></pre>
<blockquote>
<p><code>async/await</code> 是基于 <code>Promise</code> 的，因为使用 <code>async</code> 修饰的方法最终返回一个 <code>Promise</code>， 实际上，<code>async/await</code> 可以看做是使用 <code>Generator</code> 函数处理异步的语法糖，我们来看看如何使用 <code>Generator</code> 函数处理异步</p>
</blockquote>
<h2 id="1-5-Generator"><a href="#1-5-Generator" class="headerlink" title="1.5 Generator"></a>1.5 Generator</h2><p>首先异步函数依然是：</p>
<pre><code>function getDataAsync (url) &#123;
    return new Promise((resolve, reject) =&gt; &#123;
        setTimeout(() =&gt; &#123;
            var res = &#123;
                url: url,
                data: Math.random()
            &#125;
            resolve(res)
        &#125;, 1000)
    &#125;)
&#125;
</code></pre>
<blockquote>
<p>使用 <code>Generator</code> 函数可以这样写</p>
</blockquote>
<pre><code>function * getData () &#123;
    var res1 = yield getDataAsync(&#39;/page/1?param=123&#39;)
    console.log(res1)
    var res2 = yield getDataAsync(`/page/2?param=$&#123;res1.data&#125;`)
    console.log(res2)
    var res3 = yield getDataAsync(`/page/2?param=$&#123;res2.data&#125;`)
    console.log(res3))
&#125;
</code></pre>
<p>然后我们这样逐步执行</p>
<pre><code>var g = getData()
g.next().value.then(res1 =&gt; &#123;
    g.next(res1).value.then(res2 =&gt; &#123;
        g.next(res2).value.then(() =&gt; &#123;
            g.next()
        &#125;)
    &#125;)
&#125;)
</code></pre>
<blockquote>
<p>上面的代码，我们逐步调用遍历器的 <code>next()</code> 方法，由于每一个 <code>next()</code> 方法返回值的 <code>value</code> 属性为一个 <code>Promise</code> 对象，所以我们为其添加 <code>then</code> 方法， 在 <code>then</code>方法里面接着运行 <code>next</code> 方法挪移遍历器指针，直到 <code>Generator</code> 函数运行完成，实际上，这个过程我们不必手动完成，可以封装成一个简单的执行器</p>
</blockquote>
<pre><code>function run (gen) &#123;
    var g = gen()

    function next (data) &#123;
        var res = g.next(data)
        if (res.done) return res.value
        res.value.then((data) =&gt; &#123;
            next(data)
        &#125;)
    &#125;

    next()

&#125;
</code></pre>
<blockquote>
<p><code>run</code>方法用来自动运行异步的 <code>Generator</code> 函数，其实就是一个递归的过程调用的过程。这样我们就不必手动执行 <code>Generator</code> 函数了。 有了 <code>run</code> 方法，我们只需要这样运行 getData 方法</p>
</blockquote>
<pre><code>run(getData)
</code></pre>
<blockquote>
<p>这样，我们就可以把异步操作封装到 <code>Generator</code> 函数内部，使用 <code>run</code> 方法作为 <code>Generator</code> 函数的自执行器，来处理异步。其实我们不难发现， <code>async/await</code> 方法相比于 <code>Generator</code> 处理异步的方式，有很多相似的地方，只不过 <code>async/await</code> 在语义化方面更加明显，同时 <code>async/await</code> 不需要我们手写执行器，其内部已经帮我们封装好了，这就是为什么说 <code>async/await</code> 是 <code>Generator</code> 函数处理异步的语法糖了</p>
</blockquote>
<h1 id="二、Promise实现原理剖析"><a href="#二、Promise实现原理剖析" class="headerlink" title="二、Promise实现原理剖析"></a>二、Promise实现原理剖析</h1><h2 id="2-1-Promise标准"><a href="#2-1-Promise标准" class="headerlink" title="2.1 Promise标准"></a>2.1 Promise标准</h2><ul>
<li><code>Promise</code> 规范有很多，如<code>Promise/A</code>，<code>Promise/B</code>，<code>Promise/D</code>以及 <code>Promise/A</code> 的升级版 <code>Promise/A+</code>。<code>ES6</code>中采用了 <code>Promise/A+</code> 规范</li>
</ul>
<p>中文版规范: <a href="http://www.ituring.com.cn/article/66566">Promises/A+规范(中文)</a></p>
<p><strong>Promise标准解读</strong></p>
<ul>
<li>一个<code>promise</code>的当前状态只能是<code>pending</code>、<code>fulfilled</code>和<code>rejected</code>三种之一。状态改变只能是<code>pending</code>到<code>fulfilled</code>或者<code>pending</code>到<code>rejected</code>。状态改变不可逆</li>
<li><code>promise</code>的<code>then</code>方法接收两个可选参数，表示该<code>promise</code>状态改变时的回调(<code>promise.then(onFulfilled, onRejected)</code>)。<code>then</code>方法返回一个<code>promise</code>。<code>then</code> 方法可以被同一个 <code>promise</code> 调用多次</li>
</ul>
<h2 id="2-2-实现Promise"><a href="#2-2-实现Promise" class="headerlink" title="2.2 实现Promise"></a>2.2 实现Promise</h2><p><strong>构造函数</strong></p>
<pre><code>function Promise(resolver) &#123;&#125;
</code></pre>
<p><strong>原型方法</strong></p>
<pre><code>Promise.prototype.then = function() &#123;&#125;
Promise.prototype.catch = function() &#123;&#125;
</code></pre>
<p><strong>静态方法</strong></p>
<pre><code>Promise.resolve = function() &#123;&#125;
Promise.reject = function() &#123;&#125;
Promise.all = function() &#123;&#125;
Promise.race = function() &#123;&#125;
</code></pre>
<h2 id="2-3-极简promise雏形"><a href="#2-3-极简promise雏形" class="headerlink" title="2.3 极简promise雏形"></a>2.3 极简promise雏形</h2><pre><code>function Promise(fn) &#123;
    var value = null,
        callbacks = [];  //callbacks为数组，因为可能同时有很多个回调
    this.then = function (onFulfilled) &#123;
        callbacks.push(onFulfilled);
    &#125;;
    function resolve(value) &#123;
        callbacks.forEach(function (callback) &#123;
            callback(value);
        &#125;);
    &#125;
    fn(resolve);
&#125;
</code></pre>
<p><strong>大致的逻辑是这样的</strong></p>
<ul>
<li>调用<code>then</code>方法，将想要在<code>Promise</code>异步操作成功时执行的回调放入<code>callbacks</code>队列，其实也就是注册回调函数，可以向观察者模式方向思考</li>
<li>创建<code>Promise</code>实例时传入的函数会被赋予一个函数类型的参数，即<code>resolve</code>，它接收一个参数<code>value</code>，代表异步操作返回的结果，当一步操作执行成功后，用户会调用<code>resolve</code>方法，这时候其实真正执行的操作是将<code>callbacks</code>队列中的回调一一执行</li>
</ul>
<pre><code>//例1
function getUserId() &#123;
    return new Promise(function(resolve) &#123;
        //异步请求
        http.get(url, function(results) &#123;
            resolve(results.id)
        &#125;)
    &#125;)
&#125;
getUserId().then(function(id) &#123;
    //一些处理
&#125;)
// 结合例子1分析

// fn 就是getUserId函数
function Promise(fn) &#123;
    var value = null,
        callbacks = [];  //callbacks为数组，因为可能同时有很多个回调
    
    // 当用户调用getUserId().then的时候开始注册传进来的回调函数
    // onFulfilled就是例子中的function(id)&#123;&#125;
    // 把then的回调函数收集起来 在resolve的时候调用
    this.then = function (onFulfilled) &#123;
        callbacks.push(onFulfilled);
    &#125;;
    
    // value是fn函数执行后返回的值
    function resolve(value) &#123;
        // callbacks是传给then的回调函数就是例子中的function(id)&#123;&#125;
        // 遍历用户通过then传递进来的回调函数把resolve成功的结果返回给then调用即then(function(data)&#123; console.log(data) &#125;) 这里的data就是通过这里调用返回
        callbacks.forEach(function (callback) &#123;
            callback(value);
        &#125;);
    &#125;
    
    //执行fn函数即getUserId()并且传入函数参数resolve 当fn执行完成返回的值传递给resolve函数
    fn(resolve);
&#125;
</code></pre>
<blockquote>
<p>结合例1中的代码来看，首先<code>new Promise</code>时，传给<code>promise</code>的函数发送异步请求，接着调用<code>promise</code>对象的<code>then</code>属性，注册请求成功的回调函数，然后当异步请求发送成功时，调用<code>resolve(results.id)</code>方法, 该方法执行<code>then</code>方法注册的回调数组</p>
</blockquote>
<ul>
<li><code>then</code>方法应该能够链式调用，但是上面的最基础简单的版本显然无法支持链式调用。想让<code>then</code>方法支持链式调用，其实也是很简单的</li>
</ul>
<pre><code>this.then = function (onFulfilled) &#123;
    callbacks.push(onFulfilled);
    return this;
&#125;;
</code></pre>
<blockquote>
<p>只要简单一句话就可以实现类似下面的链式调用</p>
</blockquote>
<pre><code>// 例2
getUserId().then(function (id) &#123;
    // 一些处理
&#125;).then(function (id) &#123;
    // 一些处理
&#125;);
</code></pre>
<h2 id="2-4-加入延时机制"><a href="#2-4-加入延时机制" class="headerlink" title="2.4 加入延时机制"></a>2.4 加入延时机制</h2><blockquote>
<p>上述代码可能还存在一个问题：如果在<code>then</code>方法注册回调之前，<code>resolve</code>函数就执行了，怎么办？比如<code>promise</code>内部的函数是同步函数</p>
</blockquote>
<pre><code>// 例3
function getUserId() &#123;
    return new Promise(function (resolve) &#123;
        resolve(9876);
    &#125;);
&#125;
getUserId().then(function (id) &#123;
    // 一些处理
&#125;);
</code></pre>
<blockquote>
<p>这显然是不允许的，<code>Promises/A+</code>规范明确要求回调需要通过异步方式执行，用以保证一致可靠的执行顺序。因此我们要加入一些处理，保证在<code>resolve</code>执行之前，<code>then</code>方法已经注册完所有的回调。我们可以这样改造下<code>resolve</code>函数:</p>
</blockquote>
<pre><code>function resolve(value) &#123;
    setTimeout(function() &#123;
        callbacks.forEach(function (callback) &#123;
            callback(value);
        &#125;);
    &#125;, 0)
&#125;
</code></pre>
<blockquote>
<p>上述代码的思路也很简单，就是通过<code>setTimeout</code>机制，将<code>resolve</code>中执行回调的逻辑放置到<code>JS</code>任务队列末尾，以保证在<code>resolve</code>执行时，<code>then</code>方法的回调函数已经注册完成</p>
</blockquote>
<ul>
<li>但是，这样好像还存在一个问题，可以细想一下：如果<code>Promise</code>异步操作已经成功，这时，在异步操作成功之前注册的回调都会执行，但是在<code>Promise</code>异步操作成功这之后调用的<code>then</code>注册的回调就再也不会执行了，这显然不是我们想要的</li>
</ul>
<h2 id="2-5-加入状态"><a href="#2-5-加入状态" class="headerlink" title="2.5 加入状态"></a>2.5 加入状态</h2><p>我们必须加入状态机制，也就是大家熟知的<code>pending</code>、<code>fulfilled</code>、<code>rejected</code></p>
<blockquote>
<p><code>Promises/A+</code>规范中的<code>2.1 Promise States</code>中明确规定了，<code>pending</code>可以转化为<code>fulfilled</code>或<code>rejected</code>并且只能转化一次，也就是说如果<code>pending</code>转化到<code>fulfilled</code>状态，那么就不能再转化到r<code>ejected</code>。并且<code>fulfilled</code>和<code>rejected</code>状态只能由<code>pending</code>转化而来，两者之间不能互相转换</p>
</blockquote>
<p><img src="https://mengera88.github.io/images/promiseState.png" alt="img"></p>
<pre><code>//改进后的代码是这样的：

function Promise(fn) &#123;
    var state = &#39;pending&#39;,
        value = null,
        callbacks = [];
    this.then = function (onFulfilled) &#123;
        if (state === &#39;pending&#39;) &#123;
            callbacks.push(onFulfilled);
            return this;
        &#125;
        onFulfilled(value);
        return this;
    &#125;;
    function resolve(newValue) &#123;
        value = newValue;
        state = &#39;fulfilled&#39;;
        setTimeout(function () &#123;
            callbacks.forEach(function (callback) &#123;
                callback(value);
            &#125;);
        &#125;, 0);
    &#125;
    fn(resolve);
&#125;
</code></pre>
<blockquote>
<p>上述代码的思路是这样的：<code>resolve</code>执行时，会将状态设置为<code>fulfilled</code>，在此之后调用<code>then</code>添加的新回调，都会立即执行</p>
</blockquote>
<h2 id="2-6-链式Promise"><a href="#2-6-链式Promise" class="headerlink" title="2.6 链式Promise"></a>2.6 链式Promise</h2><blockquote>
<p>如果用户在<code>then</code>函数里面注册的仍然是一个<code>Promise</code>，该如何解决？比如下面的例4</p>
</blockquote>
<pre><code>// 例4
getUserId()
    .then(getUserJobById)
    .then(function (job) &#123;
        // 对job的处理
    &#125;);
function getUserJobById(id) &#123;
    return new Promise(function (resolve) &#123;
        http.get(baseUrl + id, function(job) &#123;
            resolve(job);
        &#125;);
    &#125;);
&#125;
</code></pre>
<ul>
<li>这种场景相信用过<code>promise</code>的人都知道会有很多，那么类似这种就是所谓的链式<code>Promise</code></li>
<li>链式<code>Promise</code>是指在当前<code>promise</code>达到<code>fulfilled</code>状态后，即开始进行下一个<code>promise</code>（后邻<code>promise</code>）。那么我们如何衔接当前<code>promise</code>和后邻<code>promise</code>呢？（这是这里的难点</li>
<li>只要在<code>then</code>方法里面<code>return</code>一个<code>promise</code>就好啦。<code>Promises/A+</code>规范中的<code>2.2.7</code>就是这样</li>
</ul>
<blockquote>
<p>下面来看看这段暗藏玄机的<code>then</code>方法和<code>resolve</code>方法改造代码</p>
</blockquote>
<pre><code>function Promise(fn) &#123;
    var state = &#39;pending&#39;,
        value = null,
        callbacks = [];
    this.then = function (onFulfilled) &#123;
        return new Promise(function (resolve) &#123;
            handle(&#123;
                onFulfilled: onFulfilled || null,
                resolve: resolve
            &#125;);
        &#125;);
    &#125;;
    function handle(callback) &#123;
        if (state === &#39;pending&#39;) &#123;
            callbacks.push(callback);
            return;
        &#125;
        //如果then中没有传递任何东西
        if(!callback.onFulfilled) &#123;
            callback.resolve(value);
            return;
        &#125;
        var ret = callback.onFulfilled(value);
        callback.resolve(ret);
    &#125;
    
    function resolve(newValue) &#123;
        if (newValue &amp;&amp; (typeof newValue === &#39;object&#39; || typeof newValue === &#39;function&#39;)) &#123;
            var then = newValue.then;
            if (typeof then === &#39;function&#39;) &#123;
                then.call(newValue, resolve);
                return;
            &#125;
        &#125;
        state = &#39;fulfilled&#39;;
        value = newValue;
        setTimeout(function () &#123;
            callbacks.forEach(function (callback) &#123;
                handle(callback);
            &#125;);
        &#125;, 0);
    &#125;
    fn(resolve);
&#125;
</code></pre>
<blockquote>
<p>我们结合例4的代码，分析下上面的代码逻辑，为了方便阅读，我把例4的代码贴在这里</p>
</blockquote>
<pre><code>// 例4
getUserId()
    .then(getUserJobById)
    .then(function (job) &#123;
        // 对job的处理
    &#125;);
function getUserJobById(id) &#123;
    return new Promise(function (resolve) &#123;
        http.get(baseUrl + id, function(job) &#123;
            resolve(job);
        &#125;);
    &#125;);
&#125;
</code></pre>
<ul>
<li><code>then</code>方法中，创建并返回了新的<code>Promise</code>实例，这是串行<code>Promis</code>e的基础，并且支持链式调用</li>
<li><code>handle</code>方法是<code>promise</code>内部的方法。<code>then</code>方法传入的形参<code>onFulfilled</code>以及创建新<code>Promise</code>实例时传入的<code>resolve</code>均被<code>push</code>到当前<code>promise</code>的<code>callbacks</code>队列中，这是衔接当前<code>promise</code>和后邻<code>promise</code>的关键所在</li>
<li><code>getUserId</code>生成的<code>promise</code>（简称<code>getUserId promise</code>）异步操作成功，执行其内部方法<code>resolve</code>，传入的参数正是异步操作的结果<code>id</code></li>
<li>调用<code>handle</code>方法处理<code>callbacks</code>队列中的回调：<code>getUserJobById</code>方法，生成新的<code>promise</code>（g<code>etUserJobById promise</code>）</li>
<li>执行之前由<code>getUserId promise</code>的<code>then</code>方法生成的新<code>promise</code>(称为<code>bridge promise</code>)的<code>resolve</code>方法，传入参数为<code>getUserJobById promise</code>。这种情况下，会将该<code>resolve</code>方法传入<code>getUserJobById promise</code>的<code>then</code>方法中，并直接返回</li>
<li>在<code>getUserJobById promise</code>异步操作成功时，执行其<code>callbacks</code>中的回调：<code>getUserId bridge promise</code>中的<code>resolve</code>方法</li>
<li>最后执行<code>getUserId bridge promise</code>的后邻<code>promise</code>的<code>callbacks</code>中的回调</li>
</ul>
<h2 id="2-7-失败处理"><a href="#2-7-失败处理" class="headerlink" title="2.7 失败处理"></a>2.7 失败处理</h2><blockquote>
<p>在异步操作失败时，标记其状态为<code>rejected</code>，并执行注册的失败回调</p>
</blockquote>
<pre><code>//例5
function getUserId() &#123;
    return new Promise(function(resolve) &#123;
        //异步请求
        http.get(url, function(error, results) &#123;
            if (error) &#123;
                reject(error);
            &#125;
            resolve(results.id)
        &#125;)
    &#125;)
&#125;
getUserId().then(function(id) &#123;
    //一些处理
&#125;, function(error) &#123;
    console.log(error)
&#125;)
</code></pre>
<blockquote>
<p>有了之前处理<code>fulfilled</code>状态的经验，支持错误处理变得很容易,只需要在注册回调、处理状态变更上都要加入新的逻辑</p>
</blockquote>
<pre><code>function Promise(fn) &#123;
    var state = &#39;pending&#39;,
        value = null,
        callbacks = [];
    this.then = function (onFulfilled, onRejected) &#123;
        return new Promise(function (resolve, reject) &#123;
            handle(&#123;
                onFulfilled: onFulfilled || null,
                onRejected: onRejected || null,
                resolve: resolve,
                reject: reject
            &#125;);
        &#125;);
    &#125;;
    function handle(callback) &#123;
        if (state === &#39;pending&#39;) &#123;
            callbacks.push(callback);
            return;
        &#125;
        var cb = state === &#39;fulfilled&#39; ? callback.onFulfilled : callback.onRejected,
            ret;
        if (cb === null) &#123;
            cb = state === &#39;fulfilled&#39; ? callback.resolve : callback.reject;
            cb(value);
            return;
        &#125;
        ret = cb(value);
        callback.resolve(ret);
    &#125;
    function resolve(newValue) &#123;
        if (newValue &amp;&amp; (typeof newValue === &#39;object&#39; || typeof newValue === &#39;function&#39;)) &#123;
            var then = newValue.then;
            if (typeof then === &#39;function&#39;) &#123;
                then.call(newValue, resolve, reject);
                return;
            &#125;
        &#125;
        state = &#39;fulfilled&#39;;
        value = newValue;
        execute();
    &#125;
    function reject(reason) &#123;
        state = &#39;rejected&#39;;
        value = reason;
        execute();
    &#125;
    function execute() &#123;
        setTimeout(function () &#123;
            callbacks.forEach(function (callback) &#123;
                handle(callback);
            &#125;);
        &#125;, 0);
    &#125;
    fn(resolve, reject);
&#125;
</code></pre>
<blockquote>
<p>上述代码增加了新的<code>reject</code>方法，供异步操作失败时调用，同时抽出了<code>resolve</code>和<code>reject</code>共用的部分，形成<code>execute</code>方法</p>
</blockquote>
<p>错误冒泡是上述代码已经支持，且非常实用的一个特性。在<code>handle</code>中发现没有指定异步操作失败的回调时，会直接将<code>bridge promise</code>(<code>then</code>函数返回的<code>promise</code>，后同)设为<code>rejected</code>状态，如此达成执行后续失败回调的效果。这有利于简化串行Promise的失败处理成本，因为一组异步操作往往会对应一个实际功能，失败处理方法通常是一致的</p>
<pre><code>//例6
getUserId()
    .then(getUserJobById)
    .then(function (job) &#123;
        // 处理job
    &#125;, function (error) &#123;
        // getUserId或者getUerJobById时出现的错误
        console.log(error);
    &#125;);
</code></pre>
<h2 id="2-8-异常处理"><a href="#2-8-异常处理" class="headerlink" title="2.8 异常处理"></a>2.8 异常处理</h2><blockquote>
<p>如果在执行成功回调、失败回调时代码出错怎么办？对于这类异常，可以使用<code>try-catch</code>捕获错误，并将<code>bridge promise</code>设为<code>rejected</code>状态。<code>handle</code>方法改造如下</p>
</blockquote>
<pre><code>function handle(callback) &#123;
    if (state === &#39;pending&#39;) &#123;
        callbacks.push(callback);
        return;
    &#125;
    var cb = state === &#39;fulfilled&#39; ? callback.onFulfilled : callback.onRejected,
        ret;
    if (cb === null) &#123;
        cb = state === &#39;fulfilled&#39; ? callback.resolve : callback.reject;
        cb(value);
        return;
    &#125;
    try &#123;
        ret = cb(value);
        callback.resolve(ret);
    &#125; catch (e) &#123;
        callback.reject(e);
    &#125; 
&#125;
</code></pre>
<blockquote>
<p>如果在异步操作中，多次执行<code>resolve</code>或者<code>reject</code>会重复处理后续回调，可以通过内置一个标志位解决</p>
</blockquote>
<h2 id="2-9-完整实现"><a href="#2-9-完整实现" class="headerlink" title="2.9 完整实现"></a>2.9 完整实现</h2><pre><code>// 三种状态
const PENDING = &quot;pending&quot;;
const RESOLVED = &quot;resolved&quot;;
const REJECTED = &quot;rejected&quot;;
// promise 接收一个函数参数，该函数会立即执行
function MyPromise(fn) &#123;
  let _this = this;
  _this.currentState = PENDING;
  _this.value = undefined;
  // 用于保存 then 中的回调，只有当 promise
  // 状态为 pending 时才会缓存，并且每个实例至多缓存一个
  _this.resolvedCallbacks = [];
  _this.rejectedCallbacks = [];

  _this.resolve = function (value) &#123;
    if (value instanceof MyPromise) &#123;
      // 如果 value 是个 Promise，递归执行
      return value.then(_this.resolve, _this.reject)
    &#125;
    setTimeout(() =&gt; &#123; // 异步执行，保证执行顺序
      if (_this.currentState === PENDING) &#123;
        _this.currentState = RESOLVED;
        _this.value = value;
        _this.resolvedCallbacks.forEach(cb =&gt; cb());
      &#125;
    &#125;)
  &#125;;

  _this.reject = function (reason) &#123;
    setTimeout(() =&gt; &#123; // 异步执行，保证执行顺序
      if (_this.currentState === PENDING) &#123;
        _this.currentState = REJECTED;
        _this.value = reason;
        _this.rejectedCallbacks.forEach(cb =&gt; cb());
      &#125;
    &#125;)
  &#125;
  // 用于解决以下问题
  // new Promise(() =&gt; throw Error(&#39;error))
  try &#123;
    fn(_this.resolve, _this.reject);
  &#125; catch (e) &#123;
    _this.reject(e);
  &#125;
&#125;

MyPromise.prototype.then = function (onResolved, onRejected) &#123;
  var self = this;
  // 规范 2.2.7，then 必须返回一个新的 promise
  var promise2;
  // 规范 2.2.onResolved 和 onRejected 都为可选参数
  // 如果类型不是函数需要忽略，同时也实现了透传
  // Promise.resolve(4).then().then((value) =&gt; console.log(value))
  onResolved = typeof onResolved === &#39;function&#39; ? onResolved : v =&gt; v;
  onRejected = typeof onRejected === &#39;function&#39; ? onRejected : r =&gt; throw r;

  if (self.currentState === RESOLVED) &#123;
    return (promise2 = new MyPromise(function (resolve, reject) &#123;
      // 规范 2.2.4，保证 onFulfilled，onRjected 异步执行
      // 所以用了 setTimeout 包裹下
      setTimeout(function () &#123;
        try &#123;
          var x = onResolved(self.value);
          resolutionProcedure(promise2, x, resolve, reject);
        &#125; catch (reason) &#123;
          reject(reason);
        &#125;
      &#125;);
    &#125;));
  &#125;

  if (self.currentState === REJECTED) &#123;
    return (promise2 = new MyPromise(function (resolve, reject) &#123;
      setTimeout(function () &#123;
        // 异步执行onRejected
        try &#123;
          var x = onRejected(self.value);
          resolutionProcedure(promise2, x, resolve, reject);
        &#125; catch (reason) &#123;
          reject(reason);
        &#125;
      &#125;);
    &#125;));
  &#125;

  if (self.currentState === PENDING) &#123;
    return (promise2 = new MyPromise(function (resolve, reject) &#123;
      self.resolvedCallbacks.push(function () &#123;
        // 考虑到可能会有报错，所以使用 try/catch 包裹
        try &#123;
          var x = onResolved(self.value);
          resolutionProcedure(promise2, x, resolve, reject);
        &#125; catch (r) &#123;
          reject(r);
        &#125;
      &#125;);

      self.rejectedCallbacks.push(function () &#123;
        try &#123;
          var x = onRejected(self.value);
          resolutionProcedure(promise2, x, resolve, reject);
        &#125; catch (r) &#123;
          reject(r);
        &#125;
      &#125;);
    &#125;));
  &#125;
&#125;;
// 规范 2.3
function resolutionProcedure(promise2, x, resolve, reject) &#123;
  // 规范 2.3.1，x 不能和 promise2 相同，避免循环引用
  if (promise2 === x) &#123;
    return reject(new TypeError(&quot;Error&quot;));
  &#125;
  // 规范 2.3.2
  // 如果 x 为 Promise，状态为 pending 需要继续等待否则执行
  if (x instanceof MyPromise) &#123;
    if (x.currentState === PENDING) &#123;
      x.then(function (value) &#123;
        // 再次调用该函数是为了确认 x resolve 的
        // 参数是什么类型，如果是基本类型就再次 resolve
        // 把值传给下个 then
        resolutionProcedure(promise2, value, resolve, reject);
      &#125;, reject);
    &#125; else &#123;
      x.then(resolve, reject);
    &#125;
    return;
  &#125;
  // 规范 2.3.3.3.3
  // reject 或者 resolve 其中一个执行过得话，忽略其他的
  let called = false;
  // 规范 2.3.3，判断 x 是否为对象或者函数
  if (x !== null &amp;&amp; (typeof x === &quot;object&quot; || typeof x === &quot;function&quot;)) &#123;
    // 规范 2.3.3.2，如果不能取出 then，就 reject
    try &#123;
      // 规范 2.3.3.1
      let then = x.then;
      // 如果 then 是函数，调用 x.then
      if (typeof then === &quot;function&quot;) &#123;
        // 规范 2.3.3.3
        then.call(
          x,
          y =&gt; &#123;
            if (called) return;
            called = true;
            // 规范 2.3.3.3.1
            resolutionProcedure(promise2, y, resolve, reject);
          &#125;,
          e =&gt; &#123;
            if (called) return;
            called = true;
            reject(e);
          &#125;
        );
      &#125; else &#123;
        // 规范 2.3.3.4
        resolve(x);
      &#125;
    &#125; catch (e) &#123;
      if (called) return;
      called = true;
      reject(e);
    &#125;
  &#125; else &#123;
    // 规范 2.3.4，x 为基本类型
    resolve(x);
  &#125;
&#125;
</code></pre>
<h2 id="2-10-小结"><a href="#2-10-小结" class="headerlink" title="2.10 小结"></a>2.10 小结</h2><p><strong>这里一定要注意的点是</strong>：<code>promise</code>里面的<code>then</code>函数仅仅是注册了后续需要执行的代码，真正的执行是在<code>resolve</code>方法里面执行的，理清了这层，再来分析源码会省力的多</p>
<blockquote>
<p>现在回顾下<code>Promise</code>的实现过程，其主要使用了设计模式中的观察者模式</p>
</blockquote>
<ul>
<li>通过<code>Promise.prototype.then</code>和<code>Promise.prototype.catch</code>方法将观察者方法注册到被观察者<code>Promise</code>对象中，同时返回一个新的<code>Promise</code>对象，以便可以链式调用</li>
<li>被观察者管理内部<code>pending</code>、<code>fulfilled</code>和<code>rejected</code>的状态转变，同时通过构造函数中传递的<code>resolve</code>和<code>reject</code>方法以主动触发状态转变和通知观察者</li>
</ul>
<h1 id="三、参考"><a href="#三、参考" class="headerlink" title="三、参考"></a>三、参考</h1><ul>
<li><a href="http://es6.ruanyifeng.com/#docs/promise">ruanyifeng-Promise 对象</a></li>
</ul>
]]></content>
      <categories>
        <category>异步</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>if__name__==&#39;__main__&#39; 理解和总结</title>
    <url>/2021/11/24/if-name-main-%E7%90%86%E8%A7%A3%E5%92%8C%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h1><p>在Python当中，如果代码写得规范一些，通常会写上一句“if <strong>name</strong>==’<strong>main</strong>:”作为程序的入口，但似乎没有这么一句代码，程序也能正常运行。这句代码多余吗？原理又在哪里？本篇博文对此进行总结说明。</p>
<h1 id="二、程序入口"><a href="#二、程序入口" class="headerlink" title="二、程序入口"></a>二、程序入口</h1><p> 学过Java、C、C++的程序员应该都知道，每次开启一个程序，都必须写一个主函数作为程序的入口，也就是我们常说的main函数。如下所示， main()就是Java中的一个main函数。</p>
<pre><code class="java">public class HelloWorld &#123;

    public static void main(String[] args) &#123;

        System.out.println(&quot;HelloWorld&quot;);

    &#125;
&#125;    
</code></pre>
<p>与 Java、C、C++ 等几种语言不同的是，Python是一种解释型脚本语言，在执行之前不同要将所有代码先编译成中间代码，Python程序运行时是从模块顶行开始，逐行进行翻译执行，所以，最顶层（没有被缩进）的代码都会被执行，所以Python中并不需要一个统一的main()作为程序的入口。在某种意义上讲，“if <strong>name</strong>==’<strong>main</strong>:”也像是一个标志，象征着Java等语言中的程序主入口，告诉其他程序员，代码入口在此——这是“if <strong>name</strong>==’<strong>main</strong>:”这条代码的意义之一。</p>
<h1 id="三、模块引入"><a href="#三、模块引入" class="headerlink" title="三、模块引入"></a>三、模块引入</h1><p> 我们知道，当我们把模块A中的代码在模块B中进行import A时，只要B模块代码运行到该import语句，模块A的代码会被执行。</p>
<h4 id="模块A："><a href="#模块A：" class="headerlink" title="模块A："></a>模块A：</h4><pre><code class="python"># 模块A

a = 100

print(&#39;你好，我是模块A……&#39;)

print(a)
</code></pre>
<h4 id="模块B："><a href="#模块B：" class="headerlink" title="模块B："></a>模块B：</h4><pre><code class="python"># 模块B

from package01 import A

b = 200

print(&#39;你好，我是模块B……&#39;)

print(b)
</code></pre>
<p>运行模块B时，输出结果如下：</p>
<pre><code class="python">你好，我是模块A……

100

你好，我是模块B……

200
</code></pre>
<p>如果在模块A中，我们有部分的代码不想在被导入到B时直接被运行，但在直接运行A时可直接运行，那该怎么做呢？那就可以用到“if <strong>name</strong>==’<strong>main</strong>:”这行代码了，我们队上面用到的A模块代码进行修改：</p>
<h4 id="A模块代码修改为："><a href="#A模块代码修改为：" class="headerlink" title="A模块代码修改为："></a>A模块代码修改为：</h4><pre><code class="python"># 模块A

a = 100

print(&#39;你好，我是模块A……&#39;)

if __name__==&#39;__main__&#39;:

    print(a)
</code></pre>
<h4 id="B模块不做修改，直接执行B模块，输出结果如下："><a href="#B模块不做修改，直接执行B模块，输出结果如下：" class="headerlink" title="B模块不做修改，直接执行B模块，输出结果如下："></a>B模块不做修改，直接执行B模块，输出结果如下：</h4><pre><code class="python">你好，我是模块A……

你好，我是模块B……

200
</code></pre>
<p>看到了吗，A模块中的a的值就没有再被输出了。所以，当你要导入某个模块，但又不想改模块的部分代码被直接执行，那就可以这一部分代码放在“if <strong>name</strong>==’<strong>main</strong>‘:”内部。</p>
<h1 id="四、’name‘与“-main-”"><a href="#四、’name‘与“-main-”" class="headerlink" title="四、’name‘与“____main____”"></a>四、’<strong><strong>name</strong></strong>‘与“____main____”</h1><p>看到现在也许心中还是疑惑，为什么会这样，那么现在我们来说一说“if <strong>name</strong>==’<strong>main</strong>‘:”的原理。</p>
<p>“____name____”是Python的内置变量，用于指代当前模块。我们修改上面用到的A模块和B模块，在模块中分别输出模块的名称：</p>
<h4 id="模块A"><a href="#模块A" class="headerlink" title="模块A:"></a>模块A:</h4><pre><code class="python"># 模块A

print(&#39;你好，我是模块A……&#39;)

print(&#39;模块A中__name__的值：&#123;&#125;&#39;.format(__name__))

print(&#39;-------------------------&#39;)
</code></pre>
<h4 id="模块B：-1"><a href="#模块B：-1" class="headerlink" title="模块B："></a>模块B：</h4><pre><code class="python"># 模块B

from package01 import A

print(&#39;你好，我是模块B……&#39;)

print(&#39;模块B中__name__的值：&#123;&#125;&#39;.format(__name__))
</code></pre>
<h4 id="执行A模块时，输出结果："><a href="#执行A模块时，输出结果：" class="headerlink" title="执行A模块时，输出结果："></a>执行A模块时，输出结果：</h4><pre><code class="python">你好，我是模块A……

模块A中__name__的值：__main__

-------------------------

执行B模块时，输出结果：

你好，我是模块A……

模块A中__name__的值：package01.A

-------------------------

你好，我是模块B……

模块B中__name__的值：__main__
</code></pre>
<blockquote>
<p>发现神奇之处了吗？当哪个模块被直接执行时，该模块“____name____”的值就是“____main____”，当被导入另一模块时，“__name__”的值就是模块的真实名称。用一个类比来解释一下：记得小时候要轮流打算教室，轮到自己的时候（模块被直接执行的时候），我们会说今天是“我”（__main__）值日，称呼其他人时，我们就会直接喊他们的名字。所以，“__main__”就相当于当事人，或者说第一人称的“我”。</p>
</blockquote>
<blockquote>
<p>所以，当运行“if <strong>name</strong>==’<strong>main</strong>‘:”语句时，如果当前模块时被直接执行，__name__的值就是__main__，条件判断的结果为True，“if <strong>name</strong>==’<strong>main</strong>‘:”下面的代码块就会被执行。</p>
</blockquote>
<h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p>“if <strong>name</strong>==’<strong>main</strong>‘:”语句的用处与原理大概也讲清楚了，如果没说明白，或者是我没理解到位，请给我留言。另外多说一句，“if <strong>name</strong>==’<strong>main</strong>‘:”很多时候看似无用，但是，出于代码的规范性，还是有必要的。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>js-复制+粘贴</title>
    <url>/2019/11/11/js-%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4/</url>
    <content><![CDATA[<h2 id="一、基本使用"><a href="#一、基本使用" class="headerlink" title="一、基本使用"></a>一、基本使用</h2><h3 id="1-1-API-介绍"><a href="#1-1-API-介绍" class="headerlink" title="1.1 API 介绍"></a>1.1 API 介绍</h3><p><strong>复制、剪切、粘贴事件</strong></p>
<ul>
<li><code>copy</code> 发生复制操作时触发;</li>
<li><code>cut</code> 发生剪切操作时触发;</li>
<li><code>paste</code> 发生粘贴操作时触发</li>
</ul>
<blockquote>
<p>每个事件都有一个 <code>before</code> 事件对应：<code>beforecopy</code>、<code>beforecut</code>、<code>beforepaste</code>。这几个 <code>before</code>一般不怎么用，所以我们把注意力放在另外三个事件就可以了</p>
</blockquote>
<p><strong>触发条件</strong></p>
<ul>
<li>鼠标右键菜单的<code>复制</code>、<code>粘贴</code>、<code>剪切</code></li>
<li>使用了相应的键盘组合键，比如:<code>command+c</code>、<code>command+v</code></li>
</ul>
<p><strong>使用姿势</strong></p>
<blockquote>
<p>以 <code>copy</code> 为例</p>
</blockquote>
<pre><code>document.body.oncopy = e =&gt; &#123;
  // 监听全局复制 做点什么
&#125;;
// 还有这种写法：
document.addEventListener(&#39;copy&#39;, e =&gt; &#123;
  // 监听全局复制 做点什么
&#125;);
</code></pre>
<blockquote>
<p>上面是在<code>document.body</code>上全局监听的，然而很多人不知道的是，我们还可以为某些 <code>dom</code> 单独添加剪切板事件</p>
</blockquote>
<pre><code>// html结构
&lt;div id=&quot;test1&quot;&gt;&lt;/div&gt;
&lt;div id=&quot;test2&quot;&gt;&lt;/div&gt;

&lt;script&gt;
    // 写法一样：
    let test1 = document.querySelector(&#39;#test1&#39;);
    test1.oncopy = e =&gt; &#123;
        // 监听test1发生的复制事件 做点什么
        // test1发生的复制事件会触发回调，其他地方不会触发回调
    &#125;
&lt;/script&gt;
</code></pre>
<blockquote>
<p>其他事件也是一样的</p>
</blockquote>
<h3 id="1-2-clipboardData"><a href="#1-2-clipboardData" class="headerlink" title="1.2 clipboardData"></a>1.2 clipboardData</h3><p><strong>clipboardData 对象:用于访问以及修改剪贴板中的数据</strong></p>
<blockquote>
<p>不同浏览器，所属的对象不同：在 <code>IE</code> 中这个对象是<code>window</code>对象的属性，在<code>Chrome</code>、<code>Safari</code>和<code>Firefox</code>中，这个对象是相应的<code>event</code>对象的属性。所以我们在使用的时候，需要做一下如下兼容</p>
</blockquote>
<pre><code>document.body.oncopy = e =&gt; &#123;
  let clipboardData = e.clipboardData || window.clipboardData;
  // 获取clipboardData对象 + do something
&#125;;
</code></pre>
<p><strong>对象方法</strong></p>
<blockquote>
<p>对象有三个方法: <code>getData()</code>、<code>setData()</code>、<code>clearData()</code></p>
</blockquote>
<p><strong>getData() 访问剪切板中的数据</strong></p>
<blockquote>
<p><code>getData()</code>接受一个<code>text</code>参数，即要取得的数据的格式</p>
</blockquote>
<p><strong>在复制、剪切、粘贴触发的事件的数据</strong></p>
<blockquote>
<p>实际上在 <code>chorme</code> 上测试只有<code>paste</code>粘贴的时候才能用<code>getData()</code>访问到数据，用法如下</p>
</blockquote>
<pre><code>// 要粘贴的数据：

document.body.onpaste = e =&gt; &#123;
  let clipboardData = e.clipboardData || window.clipboardData; // 兼容处理
  console.log(&#39;要粘贴的数据&#39;, clipboardData.getData(&#39;text&#39;));
&#125;;
</code></pre>
<p><strong>被复制/剪切的数据</strong>：</p>
<blockquote>
<p>在复制和剪切中的数据，需要通过<code>window.getSelection(0).toString()</code>来访问:</p>
</blockquote>
<pre><code>document.body.oncopy = e =&gt; &#123;
  console.log(&#39;被复制的数据:&#39;, window.getSelection(0).toString());
&#125;;
</code></pre>
<p><strong>setData(): 修改剪切板中的数据</strong></p>
<blockquote>
<p>第一个参数也是<code>text</code>，第二个参数是要放在剪切板中的文本</p>
</blockquote>
<p><strong>clearData()</strong></p>
<h2 id="二、应用"><a href="#二、应用" class="headerlink" title="二、应用"></a>二、应用</h2><h3 id="2-1-复制大段文本"><a href="#2-1-复制大段文本" class="headerlink" title="2.1 复制大段文本"></a>2.1 复制大段文本</h3><p><strong>实现类知乎/掘金复制大段文本添加版权信息</strong></p>
<blockquote>
<p>实现很简单：取消默认复制之后，主要是在被复制的内容后面添加信息，然后根据 <code>clipboardData</code> 的 <code>setData()</code>方法将信息写入剪贴板</p>
</blockquote>
<pre><code>// 掘金这里不是全局监听，应该只是监听文章的dom范围内。
document.body.oncopy = event =&gt; &#123;
  event.preventDefault(); // 取消默认的复制事件
  let textFont,
    copyFont = window.getSelection(0).toString(); // 被复制的文字 等下插入
  // 防知乎掘金 复制一两个字则不添加版权信息 超过一定长度的文字 就添加版权信息
  if (copyFont.length &gt; 10) &#123;
    textFont =
      copyFont +
      &#39;\n&#39; +
      &#39;作者：OBKoro1\n&#39; +
      &#39;链接：https://juejin.im/user/58714f0e325b123db4a2eb95372/posts\n&#39; +
      &#39;来源：掘金\n&#39; +
      &#39;著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。&#39;;
  &#125; else &#123;
    textFont = copyFont; // 没超过十个字 则采用被复制的内容。
  &#125;
  if (event.clipboardData) &#123;
    return event.clipboardData.setData(&#39;text&#39;, textFont); // 将信息写入粘贴板
  &#125; else &#123;
    // 兼容IE
    return window.clipboardData.setData(&#39;text&#39;, textFont);
  &#125;
&#125;;
</code></pre>
<blockquote>
<p>然后 <code>command+c</code>、<code>command+v</code>，输出:</p>
</blockquote>
<pre><code>你复制的内容
作者：OBKoro1
链接：https://juejin.im/user/58714f0eb123db4a2eb95372/posts
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>
<h3 id="2-2-防复制功能"><a href="#2-2-防复制功能" class="headerlink" title="2.2 防复制功能"></a>2.2 防复制功能</h3><ul>
<li>禁止复制+剪切</li>
<li>禁止右键，右键某些选项:全选，复制，粘贴等。</li>
<li>禁用文字选择，能选择却不能复制，体验很差。</li>
<li><code>user-select</code> 用 <code>css</code> 禁止选择文本</li>
</ul>
<pre><code>// 禁止右键菜单
document.body.oncontextmenu = e =&gt; &#123;
    console.log(e, &#39;右键&#39;);
    return false;
    // e.preventDefault();
&#125;;
// 禁止文字选择。
document.body.onselectstart = e =&gt; &#123;
    console.log(e, &#39;文字选择&#39;);
    return false;
    // e.preventDefault();
&#125;;
// 禁止复制
document.body.oncopy = e =&gt; &#123;
    console.log(e, &#39;copy&#39;);
    return false;
    // e.preventDefault();
&#125;
// 禁止剪切
document.body.oncut = e =&gt; &#123;
    console.log(e, &#39;cut&#39;);
    return false;
    // e.preventDefault();
&#125;;
// 禁止粘贴
document.body.onpaste = e =&gt; &#123;
    console.log(e, &#39;paste&#39;);
    return false;
    // e.preventDefault();
&#125;;
/** css 禁止文本选择 这样不会触发js**/
body &#123;
    user-select: none;
    -moz-user-select: none;
    -webkit-user-select: none;
    -ms-user-select: none;
&#125;
</code></pre>
<ul>
<li>使用<code>e.preventDefault()</code>也可以禁用，但建议使用<code>return false</code>这样就不用去访问<code>e</code>和<code>e</code>的方法了。</li>
<li>示例中<code>document.body</code>全局都禁用了，也可以对 <code>dom</code>(某些区域)进行禁用</li>
</ul>
<p><strong>破解防复制</strong></p>
<p>上面的防复制方法通过<code>js+css</code>实现的，所以思路就是：禁用<code>js+取消user-select</code>样式。</p>
<blockquote>
<p><code>Chrome</code>浏览器的话：打开浏览器控制台，按<code>F1</code>进入<code>Setting</code>，勾选<code>Disable</code> <code>JavaScript</code>(禁止 <code>js</code>)。</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/1480597-2f3188629fa5a86d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<blockquote>
<p>此时如果还不能复制的话，就要去找<code>user-select</code>样式,取消这个样式就可以了</p>
</blockquote>
<h3 id="2-3-点击复制功能"><a href="#2-3-点击复制功能" class="headerlink" title="2.3 点击复制功能"></a>2.3 点击复制功能</h3><p><strong>不能使用 clipboardData</strong></p>
<ul>
<li>在 <code>IE</code> 中可以用<code>window.clipboardData.setData(&#39;text&#39;,&#39;内容&#39;)</code>实现</li>
<li>上文提到过，在 <code>IE</code> 中<code>clipboardData</code>是<code>window</code>的属性</li>
<li>而其他浏览器则是相应的<code>event</code>对象的属性，这实际上是一种安全措施，防止未经授权的访问,为了兼容其他浏览器，所以我们不能通过<code>clipboardData</code>来实现这种操作</li>
</ul>
<p><strong>具体做法</strong></p>
<ul>
<li>创建一个隐藏的<code>input</code>框</li>
<li>点击的时候，将要复制的内容放进<code>input</code>框中</li>
<li>选择文本内容<code>input.select()</code>。这里只能用<code>input</code>或者<code>textarea</code>才能选择文本</li>
<li><code>document.execCommand(&quot;copy&quot;)</code>，执行浏览器的复制命令</li>
</ul>
<pre><code>function copyText() &#123;
  var text = document.getElementById(&#39;text&#39;).innerText; // 获取要复制的内容也可以传进来
  var input = document.getElementById(&#39;input&#39;); // 获取隐藏input的dom
  input.value = text; // 修改文本框的内容
  input.select(); // 选中文本
  document.execCommand(&#39;copy&#39;); // 执行浏览器复制命令
  alert(&#39;复制成功&#39;);
&#125;
</code></pre>
<h3 id="2-4-第三方库clipboard"><a href="#2-4-第三方库clipboard" class="headerlink" title="2.4 第三方库clipboard"></a>2.4 第三方库clipboard</h3><blockquote>
<p><a href="https://github.com/zenorocha/clipboard.js">https://github.com/zenorocha/clipboard.js</a></p>
</blockquote>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>js 继承</title>
    <url>/2020/08/24/js-%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<blockquote>
<p>JavaScript继承本质和原型链有关</p>
</blockquote>
<ul>
<li>原型、实例、构造函数、原型链之间的关系</li>
</ul>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/321.png" alt="img"></p>
<h2 id="一、借助构造函数实现继承"><a href="#一、借助构造函数实现继承" class="headerlink" title="一、借助构造函数实现继承"></a>一、借助构造函数实现继承</h2><ul>
<li>缺点：实例无法访问父类原型上的属性</li>
</ul>
<pre><code>function Parent1 () &#123;
    this.name = &#39;parent1&#39;;
&#125;
Parent1.prototype.say = function () &#123;

&#125;;
function Child1 () &#123;
    Parent1.call(this);
    this.type = &#39;child1&#39;;
&#125;
// Parent1原型上的say没法拿到
console.log(new Child1(), new Child1().say());
</code></pre>
<h2 id="二、借助原型链实现继承"><a href="#二、借助原型链实现继承" class="headerlink" title="二、借助原型链实现继承"></a>二、借助原型链实现继承</h2><ul>
<li>缺点：子类和父类公用一个原型,最后导致子类的多个实例都是一样的，无法隔离</li>
</ul>
<pre><code>function Parent2 () &#123;
    this.name = &#39;parent2&#39;;
    this.play = [1, 2, 3];
&#125;
function Child2 () &#123;
    this.type = &#39;child2&#39;;
&#125;
Child2.prototype = new Parent2();

var s1 = new Child2();
var s2 = new Child2();
s1.play.push(4);
console.log(s1.play, s2.play); // [1, 2, 3, 4] [1, 2, 3,4] 结果是一样的，说明两个实例无法隔离
</code></pre>
<h2 id="三、组合继承方式"><a href="#三、组合继承方式" class="headerlink" title="三、组合继承方式"></a>三、组合继承方式</h2><ul>
<li>此方法解决了上面的实例相同的问题，但是父类的构造函数执行了多次</li>
</ul>
<pre><code>function Parent3 () &#123;
    this.name = &#39;parent3&#39;;
    this.play = [1, 2, 3];
&#125;
function Child3 () &#123;
    Parent3.call(this);
    this.type = &#39;child3&#39;;
&#125;
Child3.prototype = new Parent3(); // 把Parent3的实例指向Child3的原型
var s3 = new Child3();
var s4 = new Child3();
s3.play.push(4);
console.log(s3.play, s4.play); // [1, 2, 3, 4] [1, 2, 3]
</code></pre>
<ul>
<li>优化组合继承1：此方法解决了父类的构造函数执行了多次问题，但是无法判断实例是由子类创建的，还是父类创建的</li>
</ul>
<pre><code>function Parent4 () &#123;
    this.name = &#39;parent4&#39;;
    this.play = [1, 2, 3];
&#125;
function Child4 () &#123;
    Parent4.call(this);
    this.type = &#39;child4&#39;;
&#125;
Child4.prototype = Parent4.prototype; // Child4和Parent4公用一个原型了
var s5 = new Child4();
var s6 = new Child4();
console.log(s5, s6);

console.log(s5 instanceof Child4, s5 instanceof Parent4); // 都是返回true
console.log(s5.constructor); // 这里返回的构造函数是Parent4，而不是Child4，问题所在
​``` 


- 优化组合继承2：完美解决方案

​```javascript
function Parent5 () &#123;
    this.name = &#39;parent5&#39;;
    this.play = [1, 2, 3];
&#125;
function Child5 () &#123;
    Parent5.call(this);
    this.type = &#39;child5&#39;;
&#125;
Child5.prototype = Object.create(Parent5.prototype);
Child5.prototype.constructor = Child5;     //重新修改了Child5的构造函数为Child5
</code></pre>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>object.defineProperty</title>
    <url>/2022/05/02/object-defineProperty/</url>
    <content><![CDATA[<h1 id="object-defineProperty"><a href="#object-defineProperty" class="headerlink" title="object.defineProperty"></a>object.defineProperty</h1><h2 id="try-it"><a href="#try-it" class="headerlink" title="try it"></a>try it</h2><p>Object.defineProperty()方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性</p>
<blockquote>
<p>备注：应当直接在Object构造器对象上调用此方法，而不是在任意一个Object类型的实力上调用。</p>
</blockquote>
<pre><code class="js">const object1 = &#123;&#125;;
Object.defineProperty(object1, &#39;property1&#39;, &#123;
    value: 42,
    writable: false
&#125;);
object1.property1 = 77;
// throws an error in strict mode

console.log(object1.property1);
// expected output 42
</code></pre>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><pre><code class="js">Object.defineProperty(obj, prop, descriptor)
</code></pre>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>obj：要定义属性的对象。<br>prop：要定义或修改的属性的名称或Symbol。<br>descriptor：要定义或修改的属性描述符。</p>
<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>被传递给函数的对象</p>
<blockquote>
<p>备注：在ES6中，由于 Symbol类型的特殊性，用Symbol类型的值来做对象的key与常规的定义或修改不同，而Object.defineProperty 是定义key为Symbol的属性的方法之一。</p>
</blockquote>
<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>该方法允许精确地添加或修改对象的属性。通过赋值操作添加的普通属性是可枚举的，在枚举对象属性时会被枚举到（for…in 或 Object.keys 方法），可以改变这些属性的值，也可以删除这些属性。这个方法允许修改默认的额外选项（或配置）。默认情况下，使用 Object.defineProperty() 添加的属性值是不可修改（immutable）的。</p>
<p>对象里目前存在的属性描述符有两种主要形式：数据描述符和存取描述符。数据描述符是一个具有值的属性，该值可以是可写的，也可以是不可写的。存取描述符是由 getter 函数和 setter 函数所描述的属性。一个描述符只能是这两者其中之一；不能同时是两者。</p>
<p>这两种描述符都是对象。它们共享以下可选键值（默认值是指在使用 Object.defineProperty() 定义属性时的默认值）：</p>
<h3 id="configurable"><a href="#configurable" class="headerlink" title="configurable"></a>configurable</h3><p>当且仅当该属性的 configurable 键值为 true 时，该属性的描述符才能够被改变，同时该属性也能从对应的对象上被删除。<br>默认为 false。</p>
<h3 id="enumerable"><a href="#enumerable" class="headerlink" title="enumerable"></a>enumerable</h3><p>当且仅当该属性的 enumerable 键值为 true 时，该属性才会出现在对象的枚举属性中。<br>默认为 false。<br>数据描述符还具有以下可选键值：</p>
<h3 id="value"><a href="#value" class="headerlink" title="value"></a>value</h3><p>该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。<br>默认为 undefined。</p>
<h3 id="writable"><a href="#writable" class="headerlink" title="writable"></a>writable</h3><p>当且仅当该属性的 writable 键值为 true 时，属性的值，也就是上面的 value，才能被赋值运算符 (en-US)改变。<br>默认为 false。<br>存取描述符还具有以下可选键值：</p>
<h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><p>属性的 getter 函数，如果没有 getter，则为 undefined。当访问该属性时，会调用此函数。执行时不传入任何参数，但是会传入 this 对象（由于继承关系，这里的this并不一定是定义该属性的对象）。该函数的返回值会被用作属性的值。<br>默认为 undefined。</p>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>属性的 setter 函数，如果没有 setter，则为 undefined。当属性值被修改时，会调用此函数。该方法接受一个参数（也就是被赋予的新值），会传入赋值时的 this 对象。<br>默认为 undefined。<br>描述符默认值汇总<br>拥有布尔值的键 configurable、enumerable 和 writable 的默认值都是 false。<br>属性值和函数的键 value、get 和 set 字段的默认值为 undefined。</p>
<pre><code class="js">// 使用 __proto__
var obj = &#123;&#125;;
var descriptor = Object.create(null); // 没有继承的属性
// 默认没有 enumerable，没有 configurable，没有 writable
descriptor.value = &#39;static&#39;;
Object.defineProperty(obj, &#39;key&#39;, descriptor);

// 显式
Object.defineProperty(obj, &quot;key&quot;, &#123;
  enumerable: false,
  configurable: false,
  writable: false,
  value: &quot;static&quot;
&#125;);

// 循环使用同一对象
function withValue(value) &#123;
  var d = withValue.d || (
    withValue.d = &#123;
      enumerable: false,
      writable: false,
      configurable: false,
      value: null
    &#125;
  );
  d.value = value;
  return d;
&#125;
// ... 并且 ...
Object.defineProperty(obj, &quot;key&quot;, withValue(&quot;static&quot;));

// 如果 freeze 可用, 防止后续代码添加或删除对象原型的属性
// （value, get, set, enumerable, writable, configurable）
(Object.freeze||Object)(Object.prototype);
</code></pre>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>numpy</title>
    <url>/2020/12/09/numPy/</url>
    <content><![CDATA[<p>测试是否安装成功，程序代码如下：</p>
<p>01  from numpy import *   #导入numpy库<br>02  print(eye(4))          #生成对角矩阵<br>运行程序，输出结果如下：</p>
<p>​                                                                                     图8.7　一维数组一个轴</p>
<h1 id="8-2-创建数组"><a href="#8-2-创建数组" class="headerlink" title="8.2　创建数组"></a>8.2　创建数组</h1><h2 id="8-2-1-创建简单的数组"><a href="#8-2-1-创建简单的数组" class="headerlink" title="8.2.1　创建简单的数组"></a>8.2.1　创建简单的数组</h2><p>NumPy创建简单的数组主要使用array()函数，语法如下：</p>
<p>numpy.array(object,dtype=None,copy=True,order=’K’,subok=False,ndmin=0)<br>参数说明：　</p>
<p>object：任何具有数组接口方法的对象。　</p>
<p>dtype：数据类型。　</p>
<p>copy：布尔型，可选参数，默认值为True，则object对象被复制；否则，只有当__array__返回副本，object参数为嵌套序列，或者需要副本满足数据类型和顺序要求时，才会生成副本。　</p>
<p>order：元素在内存中的出现顺序，值为K、A、C、F。如果object参数不是数组，则新创建的数组将按行排列（C），如果值为F，则按列排列；如果object参数是一个数组，则C（按行）、F（按列）、A（原顺序）、K（元素在内存中的出现顺序）成立。　</p>
<p>subok：布尔型。如果值为True，则将传递子类；否则返回的数组将强制为基类数组（默认值）。　</p>
<p>ndmin：指定生成数组的最小维数。</p>
<p>【示例03】　复制数组。（示例位置：资源包\MR\Code\08\03）<br>当运算和处理数组时，为了不影响到原数组，就需要对原数组进行复制，而对复制后的数组进行修改删除等操作都不会影响到原数组。数组的复制可以通过copy参数实现，程序代码如下：</p>
<p>copy=True 新数组改变 旧数组不改变 否则反之<br>ndmin=3，虽然给出的数组是一维的，但是同样会创建一个三维数组，程序代码如下：<br>运行程序，输出结果如下：</p>
<p>[[[1 2 3]]]</p>
<h3 id="1．创建指定维度和数据类型未初始化的数组"><a href="#1．创建指定维度和数据类型未初始化的数组" class="headerlink" title="1．创建指定维度和数据类型未初始化的数组"></a>1．创建指定维度和数据类型未初始化的数组</h3><p>【示例05】　创建指定维度和未初始化的数组。（示例位置：资源包\MR\Code\08\05）<br>创建指定维度和数据类型未初始化的数组主要使用empty()函数，程序代码如下：</p>
<p>01 import numpy as np<br>02 n = np.empty([2,3])<br>03 print(n)<br>运行程序，输出结果如下：</p>
<p>[[2.22519099e-307 2.33647355e-307 1.23077925e-312]<br>[2.33645827e-307 2.67023123e-307 1.69117157e-306]]<br>这里，数组元素为随机值，因为它们未被初始化。如果要改变数组类型，可以使用dtype参数，如整型，dtype=int。</p>
<h3 id="2．创建指定维度（以0填充）的数组"><a href="#2．创建指定维度（以0填充）的数组" class="headerlink" title="2．创建指定维度（以0填充）的数组"></a>2．创建指定维度（以0填充）的数组</h3><p>【示例06】　创建指定维度（以0填充）的数组。（示例位置：资源包\MR\Code\08\06）<br>创建指定维度并以0填充的数组，主要使用zeros()函数，程序代码如下：</p>
<p>01  import numpy as np<br>02  n = np.zeros(3)<br>03  print(n)<br>运行程序，输出结果如下：</p>
<p>[0. 0. 0.]<br>输出结果默认是浮点型（float）。</p>
<h3 id="3．创建指定维度（以1填充）的数组"><a href="#3．创建指定维度（以1填充）的数组" class="headerlink" title="3．创建指定维度（以1填充）的数组"></a>3．创建指定维度（以1填充）的数组</h3><p>【示例07】　创建指定维度并以1填充的数组。（示例位置：资源包\MR\Code\08\07）<br>创建指定维度并以1填充的数组，主要使用ones()函数，程序代码如下：</p>
<p>01 import numpy as np<br>02 n = np.ones(3)<br>03 print(n)</p>
<p>运行程序，输出结果如下：</p>
<p>[1. 1. 1.]<br>4．创建指定维度和类型的数组并以指定值填充【示例08】　创建以指定值填充的数组。（示例位置：资源包\MR\Code\08\08）<br>创建指定维度和类型的数组并以指定值填充，主要使用full()函数，程序代码如下：</p>
<p>01  import numpy as np<br>02  n = np.full((3,3), 8)<br>03  print(n)<br>运行程序，输出结果如下：</p>
<p>[[8 8 8]<br> [8 8 8]<br> [8 8 8]]</p>
<h2 id="8-2-3-从数值范围创建数组"><a href="#8-2-3-从数值范围创建数组" class="headerlink" title="8.2.3　从数值范围创建数组"></a>8.2.3　从数值范围创建数组</h2><h3 id="1．通过arange-函数创建数组"><a href="#1．通过arange-函数创建数组" class="headerlink" title="1．通过arange()函数创建数组"></a>1．通过arange()函数创建数组</h3><p>arange()函数同Python内置range()函数相似，区别在于返回值，arange()函数返回值是数组，而range()函数返回值是列表。arange()函数的语法如下：</p>
<p>arange([start,] stop[, step,], dtype=None)<br>参数说明：　</p>
<p>start：起始值，默认值为0。　</p>
<p>stop：终止值（不包含）。　</p>
<p>step：步长，默认值为1。　</p>
<p>dtype：创建数组的数据类型，如果不设置数据类型，则使用输入数据的数据类型。</p>
<p>01 import numpy as np<br>02 n=np.arange(1,12,2)<br>03 print(n)<br>运行程序，输出结果如下：</p>
<p>[ 1  3  5  7  9 11]</p>
<h3 id="2．使用linspace-函数创建等差数列"><a href="#2．使用linspace-函数创建等差数列" class="headerlink" title="2．使用linspace()函数创建等差数列"></a>2．使用linspace()函数创建等差数列</h3><p>首先简单了解一下等差数列，等差数列是指如果一个数列从第二项起，每一项与它的前一项的差等于同一个常数，那么这个数列就叫作等差数列。<br>例如，一般成年男鞋的各种尺码，如图8.9所示。</p>
<p>​                                                                                        图8.10　训练计划<br>在Python中创建等差数列可以使用NumPy的linspace()函数，该函数用于创建一个一维的等差数列的数组，它与arange()函数不同，arange()函数是从开始值到结束值的左闭右开区间（即包括开始值不包括结束值），第三个参数（如果存在）是步长；而linspace()函数是从开始值到结束值的闭区间（可以通过参数endpoint=False，使结束值不是闭区间），并且第三个参数是值的个数。</p>
<p>linspace()函数语法如下：</p>
<p>linspace(start,stop,num=50,endpoint=True,retstep=False,dtype=None)<br>参数说明：　</p>
<p>start：序列的起始值。　</p>
<p>stop：序列的终止值，如果endpoint参数的值为True，则该值包含于数列中。　</p>
<p>num：要生成的等步长的样本数量，默认值为50。　</p>
<p>endpoint：如果值为True，数列中包含stop参数的值；反之则不包含。默认值为True。　</p>
<p>retstep：如果值为True，则生成的数组中会显示间距；反之则不显示。　</p>
<p>dtype：数组的数据类型。</p>
<p>01 import numpy as np<br>02 n1 = np.linspace(7500,10000,6)<br>03 print(n1)<br>运行程序，输出结果如下：</p>
<p>[ 7500.  8000.  8500.  9000.  9500. 10000.]</p>
<h3 id="3．使用logspace-函数创建等比数列"><a href="#3．使用logspace-函数创建等比数列" class="headerlink" title="3．使用logspace()函数创建等比数列"></a>3．使用logspace()函数创建等比数列</h3><p>在Python中创建等比数列可以使用NumPy的logspace()函数，语法如下：</p>
<p>numpy.logspace(start, stop, num=50, endpoint=True, base=10.0, dtype=None)<br>参数说明：　</p>
<p>start：序列的起始值。　</p>
<p>stop：序列的终止值。如果endpoint参数值为True，则该值包含于数列中。　</p>
<p>num：要生成的等步长的数据样本数量，默认值为50。　</p>
<p>endpoint：如果值为True，则数列中包含stop参数值；反之则不包含。默认值为True。　</p>
<p>base：对数log的底数。　</p>
<p>dtype：数组的数据类型。                            </p>
<p>01  import numpy as np<br>02  n = np.logspace(0,63,64,base=2,dtype=’int’)<br>03  print(n)</p>
<p>​                                                                                  图8.12　每个格子里放的小麦数</p>
<p>上述举例出现一个问题：后面大数出现负数，而且都是一样的，这是由于程序中指定的数据类型是int，是32位的，数据范围为-2147483648～2147483647，而我们计算后的数据远远超出了这个范围，因此便出现了溢出现象。解决这一问题，需要指定数据类型为uint64（无符号整数，数据范围为0～18446744073709551615），关键代码如下：</p>
<p>n = np.logspace(0,63,64,base=2,dtype=’uint64’)</p>
<h2 id><a href="#" class="headerlink" title></a></h2><p>随机数组的生成主要使用NumPy的random模块，下面介绍几种常用的随机生成数组的函数。</p>
<h3 id="1．rand"><a href="#1．rand" class="headerlink" title="1．rand()"></a>1．rand()</h3><p>rand()函数用于生成(0,1)之间的随机数组，传入一个值随机生成一维数组，传入一对值则随机生成二维数组，语法如下：</p>
<p>numpy.random.rand(d0,d1,d2,d3,…,dn)<br>参数d0，d1，…，dn为整数，表示维度，可以为空。</p>
<p>【示例12】　随机生成0～1的数组。（示例位置：资源包\MR\Code\08\12）<br>随机生成一维数组和二维数组，代码如下：<br>运行程序，输出结果如下：</p>
<h3 id="2．randn"><a href="#2．randn" class="headerlink" title="2．randn()"></a>2．randn()</h3><p>randn()函数用于从正态分布中返回随机生成的数组，语法如下：</p>
<p>numpy.random.randn(d0,d1,d2,d3,…,dn)<br>参数d0，d1，…，dn为整数，表示维度，可以为空。</p>
<p>【示例13】　随机生成满足正态分布的数组。（示例位置：资源包\MR\Code\08\13）<br>随机生成满足正态分布的数组，程序代码如下：<br>运行程序，输出结果如下：</p>
<h3 id="3．randint"><a href="#3．randint" class="headerlink" title="3．randint()"></a>3．randint()</h3><p>randint()函数与NumPy的arange()函数类似。randint()函数用于生成一定范围内的随机数组，左闭右开区间，语法如下：</p>
<p>numpy.random.randint(low,high=None,size=None)</p>
<p>参数说明：　</p>
<p>low：低值（起始值），整数，且当参数high不为空时，参数low应小于参数high；否则程序会出现错误。　</p>
<p>high：高值（终止值），整数。</p>
<p>size：数组维数，整数或者元组，整数表示一维数组，元组表示多维数组。默认值为空，如果为空，则仅返回一个整数。</p>
<h3 id="4．normal"><a href="#4．normal" class="headerlink" title="4．normal()"></a>4．normal()</h3><p>normal()函数用于生成正态分布的随机数，语法如下：</p>
<p>numpy.random.normal(loc,scale,size)<br>参数说明：　</p>
<p>loc：正态分布的均值，对应正态分布的中心。loc=0说明是一个以y轴为对称轴的正态分布。　</p>
<p>scale：正态分布的标准差，对应正态分布的宽度，scale值越大，正态分布的曲线越“矮胖”；scale值越小，曲线越“高瘦”。　size：表示数组维数。</p>
<p>【示例15】　生成正态分布的随机数组。（示例位置：资源包\MR\Code\08\15）<br>生成正态分布的随机数组，程序代码如下：</p>
<p>01 import numpy as np<br>02 n = np.random.normal(0, 0.1, 10)<br>03 print(n)<br>运行程序，输出结果如下：</p>
<p>[ 0.08530096  0.0404147  -0.00358281  0.05405901 -0.01677737 -0.02448481<br> 0.13410224 -0.09780364  0.06095256 -0.0431846 ]</p>
<h2 id="-1"><a href="#-1" class="headerlink" title></a></h2><h3 id="1．asarray-函数"><a href="#1．asarray-函数" class="headerlink" title="1．asarray()函数"></a>1．asarray()函数</h3><p>asarray()函数用于创建数组，其与array()函数类似，语法如下：</p>
<p>numpy.asarray(a,dtype=None,order=None)<br>参数说明：　</p>
<p>a：可以是列表、列表的元组、元组、元组的元组、元组的列表或多维数组。　</p>
<p>dtype：数组的数据类型。　</p>
<p>order：值为C和F，分别代表按行排列和按列排列，即数组元素在内存中的出现顺序。</p>
<h3 id="4．empty-like-函数"><a href="#4．empty-like-函数" class="headerlink" title="4．empty_like()函数"></a>4．empty_like()函数</h3><p>empty_like()函数用于创建一个与给定数组具有相同维度和数据类型且未初始化的数组，语法如下：</p>
<p>numpy.empty_like(prototype,dtype=None,order=’K’,subok=True)<br>参数说明：　</p>
<p>prototype：给定的数组。　</p>
<p>dtype：覆盖结果的数据类型。　</p>
<p>order：指定数组的内存布局。其中C（按行）、F（按列）、A（原顺序）、K（数据元素在内存中的出现顺序）。　</p>
<p>subok：默认情况下，返回的数组被强制为基类数组。如果值为True，则返回子类。</p>
<p>【示例19】　创建未初始化的数组。（示例位置：资源包\MR\Code\08\19）<br>下面使用empty_like()函数创建一个与给定数组具有相同维数、数据类型以及未初始化的数组，程序代码如下：</p>
<p>01 import numpy as np</p>
<p>02 n = np.empty_like([[1, 2], [3, 4]])<br>03 print(n)<br>运行程序，输出结果如下：</p>
<p>[[0 0]<br> [0 0]]</p>
<h3 id="5．zeros-like-函数"><a href="#5．zeros-like-函数" class="headerlink" title="5．zeros_like()函数"></a>5．zeros_like()函数</h3><p>【示例20】　创建以0填充的数组。（示例位置：资源包\MR\Code\08\20）<br>zeros_like()函数用于创建一个与给定数组维度和数据类型相同，并以0填充的数组，程序代码如下：</p>
<p>01 import numpy as np<br>02 n = np.zeros_like([[0.1,0.2,0.3], [0.4,0.5,0.6]])<br>03 print(n)<br>运行程序，输出结果如下：</p>
<p>[[0. 0. 0.]<br> [0. 0. 0.]]说明<br>参数说明请参见empty_like()函数。</p>
<h3 id="6．ones-like-函数"><a href="#6．ones-like-函数" class="headerlink" title="6．ones_like()函数"></a>6．ones_like()函数</h3><p>【示例21】　创建以1填充的数组。（示例位置：资源包\MR\Code\08\21）<br>ones_like()函数用于创建一个与给定数组维度和数据类型相同，并以1填充的数组，程序代码如下：</p>
<p>01 import numpy as np<br>02 n = np.ones_like([[0.1,0.2,0.3], [0.4,0.5,0.6]])</p>
<p>03 print(n)<br>运行程序，输出结果如下：</p>
<p>[[1. 1. 1.]<br>[1. 1. 1.]]说明<br>参数说明请参见empty_like()函数。</p>
<h3 id="7．full-like-函数"><a href="#7．full-like-函数" class="headerlink" title="7．full_like()函数"></a>7．full_like()函数</h3><p>full_like()函数用于创建一个与给定数组维度和数据类型相同，并以指定值填充的数组，语法如下：</p>
<p>numpy.full_like(a, fill_value, dtype=None, order=’K’, subok=True)<br>参数说明：　</p>
<p>a：给定的数组。　</p>
<p>fill_value：填充值。　</p>
<p>dtype：数组的数据类型，默认值为None，则使用给定数组的数据类型。　</p>
<p>order：指定数组的内存布局。其中C（按行）、F（按列）、A（原顺序）、K（数组元素在内存中的出现顺序）。　</p>
<p>subok：默认情况下，返回的数组被强制为基类数组。如果值为True，则返回子类。</p>
<h3 id="8-3-1-数据类型"><a href="#8-3-1-数据类型" class="headerlink" title="8.3.1　数据类型"></a>8.3.1　数据类型</h3><p>在对数组进行基本操作前，首先了解一下NumPy的数据类型。NumPy的数据类型比Python数据类型增加了更多种类的数值类型，如表8.1所示。为了区别Python数据类型，像bool、int、float、complex、str等数据类型的名称末尾都加了短下画线“_”。</p>
<p>每一种数据类型都有相应的数据转换函数。举例如下：</p>
<p>np.int8(3.141)</p>
<p>结果为3。</p>
<p>np.float64(8)<br>结果为8.0。</p>
<p>np.float(True)<br>结果为1.0。</p>
<p>bool(1)<br>结果为True。<br>在创建ndarray数组时，可以直接指定数值类型，关键代码如下：</p>
<p>a = np.arange(8, dtype=float)<br>结果为[0. 1. 2. 3. 4. 5. 6. 7.]。</p>
<p>注意<br>复数不能转换成为整数类型或者浮点数，例如以下的代码会出现错误提示：</p>
<p>float(8+ 1j)</p>
<h3 id="-2"><a href="#-2" class="headerlink" title></a></h3><h3 id="数组索引和切片"><a href="#数组索引和切片" class="headerlink" title="数组索引和切片"></a>数组索引和切片</h3><p>NumPy数组元素是通过数组的索引和切片来访问和修改的，因此索引和切片是NumPy中最重要、最常用的操作。</p>
<h4 id="1．索引"><a href="#1．索引" class="headerlink" title="1．索引"></a>1．索引</h4><p>所谓数组的索引，即用于标记数组中对应元素的唯一数字，从0开始，即数组中的第一个元素的索引是0，以此类推。NumPy数组可以使用标准Python语法x[obj]的语法对数组进行索引，其中x是数组，obj是索引。</p>
<p>【示例28】　获取一维数组中的元素。（示例位置：资源包\MR\Code\08\28）<br>获取一维数组n1中索引为0的元素，程序代码如下：</p>
<p>01  import numpy as np<br>02  n1=np.array([1,2,3])   #创建一维数组<br>03  print(n1[0])           #输出一维数组的第一个元素<br>运行程序，输出结果如下：</p>
<p>1</p>
<p>【示例29】　获取二维数组中的元素。（示例位置：资源包\MR\Code\08\29）<br>再举一个例子，通过索引获取二维数组中的元素，程序代码如下：</p>
<p>01  import numpy as np<br>02  n1=np.array([[1,2,3],[4,5,6]])   #创建二维数组<br>03  print(n1[1] [2])                  #输出二维数组中第2行第3列的元素<br>运行程序，输出结果如下：</p>
<p>6</p>
<h4 id="2．切片式索引"><a href="#2．切片式索引" class="headerlink" title="2．切片式索引"></a>2．切片式索引</h4><p>数组的切片可以理解为对数组的分割，按照等分或者不等分，将一个数组切割为多个片段，它与Python中列表的切片操作一样。NumPy中的切片用冒号分隔切片参数来进行切片操作，语法如下：</p>
<p>[start:stop:step]<br>参数说明：　</p>
<p>start：起始索引。</p>
<p>stop：终止索引。　</p>
<p>step：步长。</p>
<p>【示例30】　实现简单的数组切片操作。（示例位置：资源包\MR\Code\08\30）<br>实现简单的切片操作，对数组n1进行切片式索引操作，如图8.19所示。</p>
<p>切片式索引操作需要注意以下几点。<br>（1）索引是左闭右开区间，如上述代码中的n1[0:2]，只能取到索引从0～1的元素，而取不到索引为2的元素。<br>（2）当没有start参数时，代表从索引0开始取数，如上述代码中的n1[:2]。<br>（3）start、stop和step这3个参数都可以是负数，代表反向索引。以step参数为例，如图8.20所示。</p>
<p>【示例31】　常用的切片式索引操作。（示例位置：资源包\MR\Code\08\31）<br>常用的切片式索引操作，程序代码如下：</p>
<p>运行程序，输出结果如下：</p>
<h4 id="3．二维数组索引"><a href="#3．二维数组索引" class="headerlink" title="3．二维数组索引"></a>3．二维数组索引</h4><p>二维数组索引可以使用array[n,m]的方式，以逗号分隔，表示第n个数组的，第m个元素。</p>
<p>【示例32】　二维数组的简单索引操作。（示例位置：资源包\MR\Code\08\32）<br>创建一个3行4列的二维数组，实现简单的索引操作，效果如图8.21所示。</p>
<p>​                                                                                                图8.21　二维数组索引示意图<br>程序代码如下：</p>
<p>上述代码中，n[1]表示第2个数组，n[1,2]表示第2个数组第3个元素，它等同于n[1][2]，表示数组n中第2行第3列的值，实际上n[1] [2]是先索引第一个维度得到一个数组，然后在此基础上再索引。</p>
<h4 id="4．二维数组切片式索引"><a href="#4．二维数组切片式索引" class="headerlink" title="4．二维数组切片式索引"></a>4．二维数组切片式索引</h4><p>import numpy as np </p>
<p>创建3行3列的二维数组</p>
<p>n=np.array([[1,2,3],[4,5,6],[7,8,9]])</p>
<p>print(n[:2,1:])  #输出第1行至第3行（不包括第三行）的第二列至最后一列的元素</p>
<p>print(n[1,:2])    # 输出第2行的第1列至第3列（不包括第3列）的以元素</p>
<p>pirnt(n[:2,2])   # 输出第1行至第3行（不包括第3行）的第3列的元素</p>
<p>print(n[:,:1])      #输出所有行的第一列至第二列（不包括第2列）的元素</p>
<h3 id="8-3-4-数组重塑"><a href="#8-3-4-数组重塑" class="headerlink" title="8.3.4　数组重塑"></a>8.3.4　数组重塑</h3><p>数组重塑实际是更改数组的形状，例如，将原来2行3列的数组重塑为3行4列的数组。在NumPy中主要使用reshape()方法，该方法用于改变数组的形状。</p>
<h4 id="3．数组转置"><a href="#3．数组转置" class="headerlink" title="3．数组转置"></a>3．数组转置</h4><p>数组转置是指数组的行列转换，可以通过数组的T属性和transpose()函数实现。</p>
<p>01  n = np.array([[‘A’,100],[‘B’,200],[‘C’,300],[‘D’,400],[‘E’,500]])<br>02  print(n.transpose())                           #transpose()函数行列转置</p>
<h4 id="1．数组的增加"><a href="#1．数组的增加" class="headerlink" title="1．数组的增加"></a>1．数组的增加</h4><p>数组数据的增加可以按照水平方向增加数据，也可以按照垂直方向增加数据。水平方向增加数据主要使用hstack()函数，垂直方向增加数据主要使用vstack()函数。</p>
<h4 id="2．数组的删除"><a href="#2．数组的删除" class="headerlink" title="2．数组的删除"></a>2．数组的删除</h4><p>数组的删除主要使用delete()方法。</p>
<p>【示例40】　删除指定的数组。（示例位置：资源包\MR\Code\08\40）<br>删除指定的数组，程序代码如下：</p>
<p>np.delete(n1,2,axis=0)   # 删除第3行</p>
<p>np.delete(n1,(1,2),axis=1)  # 删除第二行和第三行</p>
<h4 id="3．数组的修改"><a href="#3．数组的修改" class="headerlink" title="3．数组的修改"></a>3．数组的修改</h4><p>修改数组或数组元素时，直接为数组或数组元素赋值即可。</p>
<p>【示例41】　修改指定的数组。（示例位置：资源包\MR\Code\08\41）<br>修改指定的数组，程序代码如下：</p>
<p>运行程序，输出结果如下：</p>
<h4 id="4．数组的查询"><a href="#4．数组的查询" class="headerlink" title="4．数组的查询"></a>4．数组的查询</h4><p>数组的查询同样可以使用索引和切片方法来获取指定范围的数组或数组元素，还可以通过where()函数查询符合条件的数组或数组元素。where()函数语法如下：</p>
<p>numpy.where(condition,x,y)<br>上述语法，第一个参数为一个布尔数组，第二个参数和第三个参数可以是标量也可以是数组。满足条件（参数condition），输出参数x，不满足条件输出参数y。</p>
<p>【示例42】　按指定条件查询数组。（示例位置：资源包\MR\Code\08\42）<br>数组查询，大于5输出2，不大于5输出0，程序代码如下：</p>
<p>运行程序，输出结果如下：</p>
<p>[0 1 2 3 4 5 6 7 8 9]<br>[0 0 0 0 0 0 2 2 2 2]<br>如果不指定参数x和y，则输出满足条件的数组元素的坐</p>
<p>标。例如，上述举例不指定参数x和y，关键代码如下：</p>
<p>01  n2=n1[np.where(n1&gt;5)]<br>02  print(n2)<br>运行程序，输出结果如下：</p>
<p>（3）使用random模块的rand()函数创建一个3×3为0～1随机产生的二维数组，并将其转换为矩阵，程序代码如下：</p>
<p>01  import numpy as np</p>
<p>02  data1 = np.mat(np.random.rand(3,3))<br>03  print(data1)</p>
<p>（4）创建一个1～8的随机整数矩阵，程序代码如下：</p>
<p>01 import numpy as np<br>02 data1 = np.mat(np.random.randint(1,8,size=(3,5)))<br>03 print(data1)<br>运行程序，输出结果如下：</p>
<h2 id="矩阵运算"><a href="#矩阵运算" class="headerlink" title="矩阵运算"></a>矩阵运算</h2><p>​                                                                         图8.28　矩阵相乘运算过程示意图<br>数组运算和矩阵运算的一个关键区别是矩阵相乘使用的是点乘。点乘，也称点积，是数组中元素对应位置一一相乘之后求和的操作，在NumPy中专门提供了点乘方法，即dot()方法，该方法返回的是两个数组的点积。</p>
<p>【示例49】　矩阵元素之间的相乘运算。（示例位置：资源包\MR\Code\08\49）<br>要实现矩阵对应元素之间的相乘可以使用multiply()函数，程序代码如下：</p>
<h2 id="8-4-3-矩阵转换"><a href="#8-4-3-矩阵转换" class="headerlink" title="8.4.3　矩阵转换"></a>8.4.3　矩阵转换</h2><h3 id="1．矩阵转置"><a href="#1．矩阵转置" class="headerlink" title="1．矩阵转置"></a>1．矩阵转置</h3><p>【示例50】　使用T属性实现矩阵转置。（示例位置：资源包\MR\Code\08\50）<br>矩阵转置与数组转置一样使用T属性，程序代码如下：</p>
<p>01  import numpy as np<br>02  n1 = np.mat(‘1 3 3;4 5 6;7 12 9’)            #创建矩阵，使用分号隔开数据<br>03  print(‘矩阵转置结果为：\n’,n1.T)             #矩阵转置<br>运行程序，输出结果如下：</p>
<h3 id="2．矩阵求逆"><a href="#2．矩阵求逆" class="headerlink" title="2．矩阵求逆"></a>2．矩阵求逆</h3><p>【示例51】　实现矩阵逆运算。（示例位置：资源包\MR\Code\08\51）<br>矩阵要可逆，否则意味着该矩阵为奇异矩阵（即矩阵的行列式的值为0）。矩阵求逆主要使用I属性，程序代码如下：</p>
<p>01  import numpy as np<br>02  n1 = np.mat(‘1 3 3;4 5 6;7 12 9’)       #创建矩阵，使用分号隔开数据<br>03  print(‘矩阵的逆矩阵结果为：\n’,n1.I)    #逆矩阵<br>运行程序，输出结果如下：</p>
<h2 id="8-5-1-数学运算函数"><a href="#8-5-1-数学运算函数" class="headerlink" title="8.5.1　数学运算函数"></a>8.5.1　数学运算函数</h2><p>NumPy包含大量的数学运算的函数，包括三角函数、算术运算函数、复数处理函数等，如表8.2所示。</p>
<p>下面介绍几个常用的数学运算函数。</p>
<h3 id="1．算术函数"><a href="#1．算术函数" class="headerlink" title="1．算术函数"></a>1．算术函数</h3><h3 id="（1）加、减、乘、除"><a href="#（1）加、减、乘、除" class="headerlink" title="（1）加、减、乘、除"></a>（1）加、减、乘、除</h3><p>NumPy算术函数包含简单的加、减、乘、除运算，如add()函数、subtract()函数、multiply()函数和divide()函数。这里要注意的是，数组必须具有相同的形状或符合数组广播规则。</p>
<p>【示例52】　数组加、减、乘、除运算。（示例位置：资源包\MR\Code\08\52）<br>数组加、减、乘、除运算，程序代码如下：</p>
<p>运行程序，输出结果如下：</p>
<h3 id="（2）倒数"><a href="#（2）倒数" class="headerlink" title="（2）倒数"></a>（2）倒数</h3><p>reciprocal()函数用于返回数组中各元素的倒数。如4/3的倒数是3/4。</p>
<p>【示例53】　计算数组元素的倒数。（示例位置：资源包\MR\Code\08\53）<br>计算数组元素的倒数，程序代码如下：</p>
<p>01 import numpy as np<br>02 a = np.array([0.25, 1.75, 2, 100])<br>03 print(np.reciprocal(a))<br>运行程序，输出结果如下：</p>
<p>[4.  0.57142857 0.5  0.01  ]</p>
<h3 id="（3）求幂"><a href="#（3）求幂" class="headerlink" title="（3）求幂"></a>（3）求幂</h3><p>power()函数将第一个数组中的元素作为底数，计算它与第二个数组中相应元素的幂。</p>
<p>【示例54】　数组元素的幂运算。（示例位置：资源包\MR\Code\08\54）<br>对数组元素幂运算，程序代码如下：</p>
<p>01 import numpy as np<br>02 n1 = np.array([10, 100, 1000])<br>03 print(np.power(n1, 3))<br>04 n2= np.array([1, 2, 3])<br>05 print(np.power(n1, n2))<br>运行程序，输出结果如下：</p>
<p>[  1000  1000000 1000000000]<br>[    10    10000 1000000000]</p>
<h3 id="（4）取余"><a href="#（4）取余" class="headerlink" title="（4）取余"></a>（4）取余</h3><p>mod()函数用于计算数组之间相应元素相除后的余数。</p>
<p>【示例55】　对数组元素取余。（示例位置：资源包\MR\Code\08\55）<br>对数组元素取余，程序代码如下：</p>
<p>01  import numpy as np<br>02  n1 = np.array([10, 20, 30])<br>03  n2 = np.array([4, 5, -8])<br>04  print(np.mod(n1, n2))<br>运行程序，输出结果如下：</p>
<p>[ 2  0 -2]</p>
<h3 id="2．舍入函数"><a href="#2．舍入函数" class="headerlink" title="2．舍入函数"></a>2．舍入函数</h3><h3 id="（1）四舍五入around-函数"><a href="#（1）四舍五入around-函数" class="headerlink" title="（1）四舍五入around()函数"></a>（1）四舍五入around()函数</h3><p>四舍五入在NumPy中应用比较多，主要使用around()函数，该函数返回指定小数位数的四舍五入值，语法如下：</p>
<p>numpy.around(a,decimals)<br>参数说明：　</p>
<p>a：数组。　</p>
<p>decimals：舍入的小数位数，默认值为0，如果为负，整数将四舍五入到小数点左侧的位置。</p>
<h3 id="（2）向上取整ceil-函数"><a href="#（2）向上取整ceil-函数" class="headerlink" title="（2）向上取整ceil()函数"></a>（2）向上取整ceil()函数</h3><p>ceil()函数用于返回大于或者等于指定表达式的最小整数，即向上取整。</p>
<p>【示例57】　对数组元素向上取整。（示例位置：资源包\MR\Code\08\57）<br>对数组元素向上取整，程序代码如下：<br>运行程序，输出结果如下：</p>
<p>[-1.  2. -0.  1. 15.]</p>
<h3 id="（3）向下取整floor-函数"><a href="#（3）向下取整floor-函数" class="headerlink" title="（3）向下取整floor()函数"></a>（3）向下取整floor()函数</h3><p>floor()函数用于返回小于或者等于指定表达式的最大整数，即向下取整。</p>
<p>【示例58】　对数组元素向下取整。（示例位置：资源包\MR\Code\08\58）</p>
<p>对数组元素向下取整，程序代码如下：</p>
<p>01  import numpy as np<br>02  n = np.array([-1.8, 1.66, -0.2, 0.888, 15])     #创建数组<br>03  print(np.floor(n))                              #向下取整<br>运行程序，输出结果如下：</p>
<p>[-2.  1. -1.  0. 15.]</p>
<h2 id="8-5-2-统计分析函数"><a href="#8-5-2-统计分析函数" class="headerlink" title="8.5.2　统计分析函数"></a>8.5.2　统计分析函数</h2><h3 id="4．加权平均average"><a href="#4．加权平均average" class="headerlink" title="4．加权平均average()"></a>4．加权平均average()</h3><p>在日常生活中，常用平均数表示一组数据的“平均水平”。在一组数据里，一个数据出现的次数称为权。将一组数据与出现的次数相乘再平均就是“加权平均”。加权平均能够反映一组数据中各个数据的重要程度，以及对整体趋势的影响。加权平均在日常生活应用非常广泛，如考试成绩、股票价格、竞技比赛等。</p>
<p>【示例64】　计算电商各活动销售的加权平均价。（示例位置：资源包\MR\Code\08\64）<br>某电商在开学季、6.18、双十一、双十二等活动价格均不同，下面计算加权平均价，程序代码如下：</p>
<p><img src="/.com//image-20211026174836425.png" alt="image-20211026174836425"></p>
<p>运行程序，输出结果如下：</p>
<p>加权平均价：<br>34.84920634920635</p>
<h3 id="5．中位数median"><a href="#5．中位数median" class="headerlink" title="5．中位数median()"></a>5．中位数median()</h3><p>中位数用来衡量数据取值的中等水平或一般水平，可以避免极端值的影响。在数据处理过程中，当数据中存在少量异常值时，它不受其影响，基于这一特点，一般使用中位数来评价分析结果。<br>那么，什么是中位数？将各个变量值按大小顺序排列起来，形成一个数列，居于数列中间位置的那个数即为中位数。例如，1、2、3、4、5这5个数，中位数就是中间的数字3，而1、2、3、4、5、6这6个数，中位数则是中间两个数的平均值，即3.5。</p>
<p>知识胶囊<br>中位数与平均数不同，它不受异常值的影响。例如，将1、2、3、4、5、6改为1、2、3、4、5、288，中位数依然是3.5。</p>
<p>【示例65】　计算电商活动价格的中位数。（示例位置：资源包\MR\Code\08\65）<br>计算电商在开学季、6.18、双十一、双十二等活动价格的中位数，程序代码如下：<br>运行程序，输出结果如下：</p>
<p>数组排序：<br>[33.6 34.5 36. 37.8 39. 39.8]数组中位数为：<br>36.9</p>
<h2 id="8-5-3-数组的排序"><a href="#8-5-3-数组的排序" class="headerlink" title="8.5.3　数组的排序"></a>8.5.3　数组的排序</h2><p>数组的排序是对数组元素进行排序。</p>
<h3 id="1．sort"><a href="#1．sort" class="headerlink" title="1．sort()"></a>1．sort()</h3><p>使用sort()函数进行排序，直接改变原数组，参数axis指定按行排序还是按列排序。</p>
<h3 id="2．argsort-函数"><a href="#2．argsort-函数" class="headerlink" title="2．argsort()函数"></a>2．argsort()函数</h3><p>使用argsort()函数对数组进行排序，返回升序排序之后数组值从小到大的索引值。</p>
<h3 id="3．lexsort-函数"><a href="#3．lexsort-函数" class="headerlink" title="3．lexsort()函数"></a>3．lexsort()函数</h3><p>lexsort()函数用于对多个序列进行排序。可以把它当作是对电子表格进行排序，每一列代表一个序列，排序时优先照顾靠后的列。</p>
<h2 id="NumPy用于图像灰度处理"><a href="#NumPy用于图像灰度处理" class="headerlink" title="NumPy用于图像灰度处理"></a>NumPy用于图像灰度处理</h2><p>案例位置：资源包\MR\Code\08\example\02<br>首先了解一下图像，图像其实是由若干像素组成，每一个像素都有明确的位置和被分配的颜色值，因此一张图像也就构成了一个像素矩阵。例如，一张灰度图片的像素块，如图8.32所示。</p>
<p>​                                                                                      图8.32　灰度图片像素矩阵示意图<br>从图8.32得知：灰度图的数据是一个二维数组，颜色取值为0～255，其中，0为黑色，255为白色。从0～255逐渐由暗色变为亮色。由此可见，图像灰度处理是不是就可以通过数组计算来实现呢？<br>接下来，了解一个公式，RGB转换成灰度图像的常用公式：</p>
<p>Gray = R<em>0.299 + G</em>0.587 + B*0.114<br>其中，Gray表示灰度值，R、G、B表示红、绿、蓝颜色值，0.299、0.587、0.114表示灰度公式的固定值。</p>
<p>下面使用NumPy结合Matplotlib实现图像的灰度处理，程序代码如下：</p>
<p>上述代码，显示灰度图时，需要在imshow()函数中设置参数cmap=”gray”。</p>
]]></content>
      <categories>
        <category>数据分析文档</category>
      </categories>
  </entry>
  <entry>
    <title>matplotlib</title>
    <url>/2020/12/09/matplotlib/</url>
    <content><![CDATA[<h3 id="5-3-图表"><a href="#5-3-图表" class="headerlink" title="5.3　图表"></a>5.3　图表</h3><p>数据分析图表有很多种，但每一种图表的绝大组成部分是基本相同的，一张完整的图表一般包括画布、图表标题、绘图区、数据系列、坐标轴、坐标轴标题、图例、文本标签、网格线等，如图5.4所示。</p>
<p>01 import matplotlib.pyplot as plt<br>02 plt.plot([1, 2, 3, 4,5])</p>
<p>01 import matplotlib.pyplot as plt<br>02 plt.plot([1, 2, 3, 4,5], [2, 5, 8, 12,18], ‘ro’)</p>
<h3 id="5-5-图表的常用设置"><a href="#5-5-图表的常用设置" class="headerlink" title="5.5　图表的常用设置"></a>5.5　图表的常用设置</h3><p>本节主要介绍图表的常用设置，主要包括颜色设置、线条样式、标记样式、设置画布、坐标轴、添加文本标签、设置标题和图例、添加注释文本、调整图表与画布边缘间距，以及其他相关设置等。</p>
<h3 id="5-5-1-基本绘图plot-函数"><a href="#5-5-1-基本绘图plot-函数" class="headerlink" title="5.5.1　基本绘图plot()函数"></a>5.5.1　基本绘图plot()函数</h3><p>Matplotlib基本绘图主要使用plot()函数，语法如下：</p>
<p>matplotlib.pyplot.plot(x,y,format_string,**kwargs)<br>参数说明：　**</p>
<p>x：x轴数据。　</p>
<p>y：y轴数据。　</p>
<p>format_string：控制曲线格式的字符串，包括颜色、线条样式和标记样式。　</p>
<p>kwargs：键值参数，相当于一个字典，比如输入参数为(1,2,3,4,k,a=1,b=2,c=3)，*args=(1,2,3,4,k)，**kwargs={‘a’:’1,’b’:2,’c’:3}。</p>
<p>0～1的小数作为灰度值，例如0.5。　</p>
<p>{‘b’, ‘g’, ‘r’, ‘c’, ‘m’, ‘y’, ‘k’, ‘w’}，其中的一个颜色值。　</p>
<p>X11/CSS4规定中的颜色名称。　</p>
<p>Xkcd中指定的颜色名称，例如xkcd:sky blue。　</p>
<p>Tableau调色板中的颜色，例如{‘tab:blue’, ‘tab:orange’, ‘tab:green’, ‘tab:red’, ‘tab:purple’, ‘tab:brown’,’tab:pink’, ‘tab:gray’, ‘tab:olive’, ‘tab:cyan’}。　</p>
<p>CN格式的颜色循环，对应的颜色设置代码如下：</p>
<p>01  from cycler import cycler<br>02  colors=[‘#1f77b4’, ‘#ff7f0e’, ‘#2ca02c’, ‘#d62728’, ‘#9467bd’, ‘#8c564b’, ‘#e377c2’,’#7f7f7f’, ‘#bcbd22’, ‘#17becf’]<br>03  plt.rcParams[‘axes.prop_cycle’] = cycler(color=colors)</p>
<p>1    plt.rcParams[’axes.unicode_minus’] = False    字符显示<br>2    plt.rcParams[’font.sans-serif’] = ‘SimHei’    设置字体<br>线条样式：lines<br>3    plt.rcParams[’lines.linestyle’] = ‘-.’    线条样式<br>4    plt.rcParams[’lines.linewidth’] = 3    线条宽度<br>5    plt.rcParams[’lines.color’] = ‘blue’    线条颜色<br>6    plt.rcParams[’lines.marker’] = None    默认标记<br>7    plt.rcParams[’lines.markersize’] = 6    标记大小<br>8    plt.rcParams[’lines.markeredgewidth’] = 0.5    标记附近的线宽<br>横、纵轴：xtick、ytick<br>9    plt.rcParams[’xtick.labelsize’]    横轴字体大小<br>10    plt.rcParams[’ytick.labelsize’]    纵轴字体大小<br>11    plt.rcParams[’xtick.major.size’]    x轴最大刻度<br>12    plt.rcParams[’ytick.major.size’]    y轴最大刻度<br>figure中的子图：axes<br>13    plt.rcParams[’axes.titlesize’]    子图的标题大小<br>14    plt.rcParams[’axes.labelsize’]    子图的标签大小<br>图像、图片：figure、savefig<br>15    plt.rcParams[’figure.dpi’]    图像分辨率<br>16    plt.rcParams[’figure.figsize’]    图像显示大小<br>17    plt.rcParams[’savefig.dpi’]    图片像素</p>
<h4 id="2．线条样式"><a href="#2．线条样式" class="headerlink" title="2．线条样式"></a>2．线条样式</h4><p>linestyle可选参数可以设置线条的样式，设置值如下，设置后的效果如图5.23所示。　“-”：实线，默认值。　“–”：双画线　“-.”：点画线。　“:”：虚线。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th align="right">描述</th>
</tr>
</thead>
<tbody><tr>
<td>agg_filter</td>
<td align="right">a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array</td>
</tr>
<tr>
<td>alpha</td>
<td align="right">float or None</td>
</tr>
<tr>
<td>animated</td>
<td align="right">bool</td>
</tr>
<tr>
<td>antialiased or aa</td>
<td align="right">bool</td>
</tr>
<tr>
<td>clip_box</td>
<td align="right">Bbox</td>
</tr>
<tr>
<td>clip_on</td>
<td align="right">bool</td>
</tr>
<tr>
<td>clip_path</td>
<td align="right">Patch or (Path, Transform) or None</td>
</tr>
<tr>
<td>color or c</td>
<td align="right">color</td>
</tr>
<tr>
<td>contains</td>
<td align="right">unknown</td>
</tr>
<tr>
<td>dash_capstyle</td>
<td align="right">{‘butt’, ‘round’, ‘projecting’}</td>
</tr>
<tr>
<td>dash_joinstyle</td>
<td align="right">{‘miter’, ‘round’, ‘bevel’}</td>
</tr>
<tr>
<td>dashes</td>
<td align="right">sequence of floats (on/off ink in points) or (None, None)</td>
</tr>
<tr>
<td>data</td>
<td align="right">(2, N) array or two 1D arrays</td>
</tr>
<tr>
<td>drawstyle or ds</td>
<td align="right">{‘default’, ‘steps’, ‘steps-pre’, ‘steps-mid’, ‘steps-post’}, default: ‘default’</td>
</tr>
<tr>
<td>figure</td>
<td align="right">Figure</td>
</tr>
<tr>
<td>fillstyle</td>
<td align="right">{‘full’, ‘left’, ‘right’, ‘bottom’, ‘top’, ‘none’}</td>
</tr>
<tr>
<td>gid</td>
<td align="right">str</td>
</tr>
<tr>
<td>in_layout</td>
<td align="right">bool</td>
</tr>
<tr>
<td>label</td>
<td align="right">object</td>
</tr>
<tr>
<td>linestyle or ls</td>
<td align="right">{’-’, ‘–’, ‘-.’, ‘:’, ‘’, (offset, on-off-seq), …}</td>
</tr>
<tr>
<td>linewidth or lw</td>
<td align="right">float</td>
</tr>
<tr>
<td>marker</td>
<td align="right">marker style string, Path or MarkerStyle</td>
</tr>
<tr>
<td>markeredgecolor or mec</td>
<td align="right">color</td>
</tr>
<tr>
<td>markeredgewidth or mew</td>
<td align="right">float</td>
</tr>
<tr>
<td>markerfacecolor or mfc</td>
<td align="right">color</td>
</tr>
<tr>
<td>markerfacecoloralt or mfcalt</td>
<td align="right">color</td>
</tr>
<tr>
<td>markersize or ms</td>
<td align="right">float</td>
</tr>
<tr>
<td>markevery</td>
<td align="right">None or int or (int, int) or slice or List[int] or float or (float, float) or List[bool]</td>
</tr>
<tr>
<td>path_effects</td>
<td align="right">AbstractPathEffect</td>
</tr>
<tr>
<td>picker</td>
<td align="right">unknown</td>
</tr>
<tr>
<td>pickradius</td>
<td align="right">float</td>
</tr>
<tr>
<td>rasterized</td>
<td align="right">bool or None</td>
</tr>
<tr>
<td>sketch_params</td>
<td align="right">(scale: float, length: float, randomness: float)</td>
</tr>
<tr>
<td>snap</td>
<td align="right">bool or None</td>
</tr>
<tr>
<td>solid_capstyle</td>
<td align="right">{‘butt’, ‘round’, ‘projecting’}</td>
</tr>
<tr>
<td>solid_joinstyle</td>
<td align="right">{‘miter’, ‘round’, ‘bevel’}</td>
</tr>
<tr>
<td>transform</td>
<td align="right">matplotlib.transforms.Transform</td>
</tr>
<tr>
<td>url</td>
<td align="right">str</td>
</tr>
<tr>
<td>visible</td>
<td align="right">bool</td>
</tr>
<tr>
<td>xdata</td>
<td align="right">1D array</td>
</tr>
<tr>
<td>ydata</td>
<td align="right">1D array</td>
</tr>
<tr>
<td>zorder</td>
<td align="right">float</td>
</tr>
</tbody></table>
<h4 id="3．标记样式"><a href="#3．标记样式" class="headerlink" title="3．标记样式"></a>3．标记样式</h4><p>marker可选参数可以设置标记样式，设置值如表5.2所示。</p>
<p>plt.plot(x,y,color=’m’,linestyle=’-‘,marker=’o’,mfc=’w’)</p>
<p>markerfacecolor or mfc：填充颜色</p>
<h3 id><a href="#" class="headerlink" title></a></h3><p>matpoltlib.pyplot.figure(num=None, figsize=None, dpi=None, facecolor=None, edgecolor=None, frameon=True)<br>参数说明：　</p>
<p>num：图像编号或名称，数字为编号，字符串为名称，可以通过该参数激活不同的画布。　</p>
<p>figsize：指定画布的宽和高，单位为英寸。　</p>
<p>dpi：指定绘图对象的分辨率，即每英寸多少个像素，默认值为80。像素越大画布越大。　</p>
<p>facecolor：背景颜色。　</p>
<p>edgecolor：边框颜色。</p>
<p>frameon：是否显示边框，默认值为True，绘制边框；如果为False，则不绘制边框。</p>
<p>【示例05】　自定义画布。（示例位置：资源包\MR\Code\05\05）<br>自定义一个5×3的黄色画布，主要代码如下：</p>
<p>01 import matplotlib.pyplot as plt<br>02 fig=plt.figure(figsize=(5,3),facecolor=’yellow’)<br>运行程序，输出结果如图5.25所示。</p>
<p>figsize=(5,3)，因为实际画布大小是500×300，所以这里不要输入太大的数字。</p>
<h4 id="1．x轴、y轴标题"><a href="#1．x轴、y轴标题" class="headerlink" title="1．x轴、y轴标题"></a>1．x轴、y轴标题</h4><p>设置x轴和y轴标题主要使用xlabel()函数和ylabel()函数。</p>
<p>（1）解决中文乱码问题，代码如下：</p>
<p>plt.rcParams[‘font.sans-serif’]=[‘SimHei’]        #解决中文乱码</p>
<p>（2）解决负号不显示问题，代码如下：</p>
<p>plt.rcParams[‘axes.unicode_minus’] = False       #解决负号不显示</p>
<h4 id="2．坐标轴刻度"><a href="#2．坐标轴刻度" class="headerlink" title="2．坐标轴刻度"></a>2．坐标轴刻度</h4><p>用matplotlib画二维图像时，默认情况下的横坐标（x轴）和纵坐标（y轴）显示的值有时可能达不到我们的需求，需要借助xticks()函数和yticks()函数分别对x轴和y轴的值进行设置。<br>xticks()函数的语法如下：</p>
<p>xticks(locs, [labels], **kwargs)<br>参数说明：　</p>
<p>locs：数组，表示x轴上的刻度。例如，在“学生英语成绩分布图”中，x轴的刻度是2～14的偶数，如果想改变这个值，就可以通过locs参数设置。　</p>
<p>labels：也是数组，默认值和locs相同。locs表示位置，而labels则决定该位置上的标签，如果赋予labels空值，则x轴将只有刻度而不显示任何值。</p>
<p>plt.xticks(range(1,15,1))</p>
<p>运行程序，对比效果如图5.27和图5.28所示。<br>接下来，设置y轴刻度，主要使用yticks()函数。例如，设置体温为35.4～38，主要代码如下：</p>
<p>plt.yticks([35.4,35.6,35.8,36,36.2,36.4,36.6,36.8,37,37.2,37.4,37.6,37.8,38])</p>
<h4 id="3．坐标轴范围"><a href="#3．坐标轴范围" class="headerlink" title="3．坐标轴范围"></a>3．坐标轴范围</h4><p>坐标轴范围是指x轴和y轴的取值范围。设置坐标轴范围主要使用xlim()函数和ylim()函数。</p>
<p>【示例09】　为折线图设置坐标范围。（示例位置：资源包\MR\Code\05\09）<br>设置x轴（日期）范围为1～14，y轴（基础体温）范围为35～45，主要代码如下：</p>
<p>01  plt.xlim(1,14)<br>02  plt.ylim(35,45)</p>
<h4 id="4．网格线"><a href="#4．网格线" class="headerlink" title="4．网格线"></a>4．网格线</h4><p>plt.grid(color=’0.5’,linestyle=’–’,linewidth=1)</p>
<h3 id="5-5-4-添加文本标签"><a href="#5-5-4-添加文本标签" class="headerlink" title="5.5.4　添加文本标签"></a>5.5.4　添加文本标签</h3><p>绘图过程中，为了能够更清晰、直观地看到数据，有时需要给图表中指定的数据点添加文本标签。下面介绍细节之二——文本标签，主要使用**text()**函数，语法如下：</p>
<p>matplotlib.pyplot.text(x, y, s, fontdict=None, withdash=False, **kwargs)<br>参数说明：　**</p>
<p>x：x坐标轴的值。　</p>
<p>y：y坐标轴的值。　</p>
<p>s：字符串，注释内容。　</p>
<p>fontdict：字典，可选参数，默认值为None。用于重写默认文本属性。　</p>
<p>withdash：布尔型，默认值为False，创建一个TexWithDash实例，而不是Text实例。　</p>
<p>kwargs：关键字参数。这里指通用的绘图参数，如字体大小fontsize=12、垂直对齐方式horizontalalignment=’center’（或简写为ha=’center’）、水平对齐方式verticalalignment=’center’（或简写为va=’center’）。</p>
<p>01  for a,b  in zip(x,y):<br>02      plt.text(a,b+3,’%.1f’%b,ha = ‘center’,va = ‘bottom’,fontsize=9)</p>
<p>​                                                                                     图5.31　带文本标签的折线图<br>在本示例代码中，首先，x、y是x轴和y轴的值，它代表了折线图在坐标中的位置，通过for循环找到每一个x、y值相对应的坐标赋值给a、b，再使用plt.text在对应的数据点上添加文本标签，而for循环也保证了折线图中每一个数据点都有文本标签。其中，a,b+3表示每一个数据点（x值对应y值加3）的位置处添加文本标签；%.1f’%b是对y值进行的格式化处理，保留小数点1位；ha=’center’、va=’bottom’代表水平对齐、垂直对齐的方式，fontsize则是字体大小。</p>
<h3 id="5-5-5-设置标题和图例"><a href="#5-5-5-设置标题和图例" class="headerlink" title="5.5.5　设置标题和图例"></a>5.5.5　设置标题和图例</h3><h4 id="1．图表标题"><a href="#1．图表标题" class="headerlink" title="1．图表标题"></a>1．图表标题</h4><p>为图表设置标题主要使用title()函数，语法如下：</p>
<p>matplotlib.pyplot.title(label, fontdict=None, loc=’center’, pad=None, **kwargs)<br>参数说明：　</p>
<p>label：字符串，表示图表标题文本。　</p>
<p>fontdict：字典，用来设置标题字体的样式。如{‘fontsize’: 20,’fontweight’:20,’va’: ‘bottom’,’ha’:’center’}。　</p>
<p>loc：字符串，表示标题水平位置，参数值为center、left或right，分别表示水平居中、水平居左和水平居右，默认为水平居中。　</p>
<p>pad：浮点型，表示标题离图表顶部的距离，默认值为None。</p>
<p>**kwargs：关键字参数，可以设置一些其他文本属性。<br>例如，设置图表标题为“14天基础体温曲线图”，主要代码如下：</p>
<p>plt.title(‘14天基础体温曲线图’,fontsize=’18’)</p>
<h4 id="2．图表图例"><a href="#2．图表图例" class="headerlink" title="2．图表图例"></a>2．图表图例</h4><h5 id="（1）自动显示图例"><a href="#（1）自动显示图例" class="headerlink" title="（1）自动显示图例"></a>（1）自动显示图例</h5><p>plt.legend()<br>（2）手动添加图例</p>
<p>plt.legend(‘基础体温’)</p>
<p>注意<br>当手动添加图例时，有时会出现文本显示不全，解决方法是在文本后面加一个逗号（,），主要代码如下：</p>
<p><strong>plt.legend((‘基础体温’,))</strong><br>（3）设置图例显示位置<br>通过loc参数可以设置图例的显示位置，如在左下方显示，主要代码如下：</p>
<p>plt.legend((‘基础体温’,),loc=’upper right’,fontsize=10)<br>具体图例显示位置的设置如表5.3所示。</p>
<p>plt.legend(bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0)<br>下面来看下设置标题和图例后的“14天基础体温曲线图”，效果如图5.32所示。</p>
<h3 id="5-5-6-添加注释"><a href="#5-5-6-添加注释" class="headerlink" title="5.5.6　添加注释"></a>5.5.6　添加注释</h3><p>01 plt.annotate(‘最高体温’, xy=(9,37.1), xytext=(10.5,37.1),</p>
<p>02               xycoords=’data’,<br>03               arrowprops=dict(facecolor=’r’, shrink=0.05))<br>下面介绍一下本示例中用到的几个主要参数。　</p>
<p>xy：被注释的坐标点，二维元组，如(x,y)。　</p>
<p>xytext：注释文本的坐标点（也就是本示例中箭头的位置），也是二维元组，默认与xy相同。　</p>
<p>xycoords：是被注释点的坐标系属性，设置值如表5.4所示。</p>
<h3 id="5-5-8-其他设置"><a href="#5-5-8-其他设置" class="headerlink" title="5.5.8　其他设置"></a>5.5.8　其他设置</h3><h4 id="1．坐标轴的刻度线"><a href="#1．坐标轴的刻度线" class="headerlink" title="1．坐标轴的刻度线"></a>1．坐标轴的刻度线</h4><p>（1）设置4个方向的坐标轴上的刻度线是否显示，主要代码如下：</p>
<p>plt.tick_params(bottom=False,left=True,right=True,top=True)<br>（2）设置x轴和y轴的刻度线显示方向，其中in表示向内，out表示向外，inout表示在中间，默认刻度线向外，主要代码如下：</p>
<p>plt.rcParams[‘xtick.direction’] = ‘in’         #x轴的刻度线向内显示<br>plt.rcParams[‘ytick.direction’] = ‘in’         #y轴的刻度线向内显示</p>
<h4 id="2．坐标轴相关属性设置"><a href="#2．坐标轴相关属性设置" class="headerlink" title="2．坐标轴相关属性设置"></a>2．坐标轴相关属性设置</h4><p>axis()：返回当前axes范围。　</p>
<p>axis(v)：通过输入v = [xmin, xmax, ymin, ymax]，设置x、y轴的取值范围。　</p>
<p>axis(‘off’)：关闭坐标轴轴线及坐标轴标签。　</p>
<p>axis(‘equal’)：使x、y轴长度一致。　</p>
<p>axis(‘scaled’)：调整图框的尺寸（而不是改变坐标轴取值范围），使x、y轴长度一致。　</p>
<p>axis(‘tight’)：改变x轴和y轴的限制，使所有数据被展示。如果所有的数据已经显示，它将移动到图形的中心而不修改（xmax～xmin）或（ymax～ymin）。　</p>
<p>axis(‘image’)：缩放axis范围（limits），等同于对data缩放范围。　</p>
<p>axis(‘auto’)：自动缩放。　</p>
<p>axis(‘normal’)：不推荐使用。恢复默认状态，轴限的自动缩放以使数据显示在图表中。</p>
<p>​                                                                                               图5.36　多折线图<br>上述举例，用到了几个参数，下面进行说明。</p>
<p>mfc：标记的颜色。　</p>
<p>ms：标记的大小。　</p>
<p>mec：标记边框的颜色。　</p>
<p>alpha：透明度，设置该参数可以改变颜色的深浅。</p>
<h3 id="5-6-2-绘制柱形图"><a href="#5-6-2-绘制柱形图" class="headerlink" title="5.6.2　绘制柱形图"></a>5.6.2　绘制柱形图</h3><p>matplotlib.pyplot.bar(x,height,width,bottom=None,*,align=’center’,data=None,**kwargs)<br>参数说明：　**</p>
<p>x：x轴数据。　</p>
<p>height：柱子的高度，也就是y轴数据。　</p>
<p>width：浮点型，柱子的宽度，默认值为0.8，可以指定固定值。　</p>
<p>bottom：标量或数组，可选参数，柱形图的y坐标，默认值为None。　</p>
<p>*：星号本身不是参数。星号表示其后面的参数为命名关键字参数，命名关键字参数必须传入参数名；否则程序会出现错误。　</p>
<p>align：对齐方式，如center（居中）和edge（边缘），默认值为center。　</p>
<p>data：data关键字参数。如果给定一个数据参数，所有位置和关键字参数将被替换。　</p>
<p>kwargs：关键字参数，其他可选参数，如color（颜色）、alpha（透明度）、label（每个柱子显示的标签）等。</p>
<p>01 import matplotlib.pyplot as plt<br>02 x=[1,2,3,4,5,6]</p>
<p>03 height=[10,20,30,40,50,60]<br>04 plt.bar(x,height)<br>运行程序，输出结果如图5.37所示。</p>
<p>bar()函数可以绘制出各种类型的柱形图，如基本柱形图、多柱形图、堆叠柱形图，只要将bar()函数的主要参数理解透彻，就会达到意想不到的效果。下面介绍几种常见的柱形图。</p>
<h3 id="5-6-3-绘制直方图"><a href="#5-6-3-绘制直方图" class="headerlink" title="5.6.3　绘制直方图"></a>5.6.3　绘制直方图</h3><p>直方图，又称质量分布图，由一系列高度不等的纵向条纹或线段表示数据分布的情况。一般用横轴表示数据类型，纵轴表示分布情况。直方图是数值数据分布的精确图形表示，是一个连续变量（定量变量）的概率分布的估计。<br>绘制直方图主要使用hist()函数，语法如下：</p>
<p>matplotlib.pyplot.hist(x,bins=None,range=None, density=None, bottom=None, histtype=’bar’, align=’mid’, log=<br>False, color=None, label=None, stacked=False, normed=None)<br>参数说明：　</p>
<p>x：数据集，最终的直方图将对数据集进行统计。　</p>
<p>bins：统计数据的区间分布。　</p>
<p>range：元组类型，显示的区间。　</p>
<p>density：布尔型，显示频率统计结果，默认值为None。设置值为False，不显示频率统计结果；设置值为True，则显示频率统计结果。需要注意，频率统计结果=区间数目/(总数×区间宽度)。　</p>
<p>histtype：可选参数，设置值为bar、barstacked、step或stepfilled，默认值为bar，推荐使用默认配置，其中step使用的是梯状，stepfilled则会对梯状内部进行填充，效果与bar类似。　</p>
<p>align：可选参数，控制柱状图的水平分布，设置值为left、mid或right，默认值为mid，其中，left或者right会有部分空白区域，推荐使用默认值。　</p>
<p>log：布尔型，默认值为False，即y坐标轴是否选择指数刻度。</p>
<p>stacked：布尔型，默认值为False，是否为堆积柱状图。</p>
<p>【示例16】　绘制简单直方图。（示例位置：资源包\MR\Code\05\16）<br>绘制简单直方图，程序代码如下：</p>
<p>01 import matplotlib.pyplot as plt<br>02 x=[22,87,5,43,56,73,55,54,11,20,51,5,79,31,27]<br>03 plt.hist(x, bins = [0,25,50,75,100])<br>运行程序，输出结果如图5.40所示。</p>
<h3 id="5-6-4-绘制饼形图"><a href="#5-6-4-绘制饼形图" class="headerlink" title="5.6.4　绘制饼形图"></a>5.6.4　绘制饼形图</h3><p>饼形图常用来显示各个部分在整体中所占的比例。例如，在工作中如果遇到需要计算总费用或金额的各个部分构成比例的情况，一般通过各个部分与总额相除来计算，而且这种比例表示方法很抽象，而通过饼形图将直接显示各个组成部分所占比例，一目了然。<br>Matplotlib绘制饼形图主要使用pie()函数，语法如下：</p>
<p>matplotlib.pyplot.pie(x,explode=None,labels=None,colors=None,autopct=None,pctdistance=0.6,shadow=False,<br>labeldistance=1.1,startangle=None,radius=None,counterclock=True,wedgeprops=None,textprops=None,center=<br>(0, 0), frame=False, rotatelabels=False, hold=None, data=None)<br>参数说明：　</p>
<p>x：每一块饼图的比例，如果sum(x)&gt;1会使用sum(x)归一化。　</p>
<p>explode：每一块饼图离中心的距离。　</p>
<p>labels：每一块饼图外侧显示的说明文字。　</p>
<p>autopct：设置饼图百分比，可以使用格式化字符串或format()函数。如’%1.1f ‘保留小数点前后1位。　</p>
<p>pctdistance：类似于labeldistance参数，指定百分比的位置刻度，默认值为0.6。　</p>
<p>shadow：在饼图下面画一个阴影，默认值为False，即不画阴影。　</p>
<p>labeldistance：标记的绘制位置，相对于半径的比例，默认值为1.1，如&lt;1则绘制在饼图内侧。　</p>
<p>startangle：起始绘制角度，默认是从x轴正方向逆时针画起，如设置值为90则从y轴正方向画起。　</p>
<p>radius：饼图半径，默认值为1。　</p>
<p>counterclock：指定指针方向，布尔型，可选参数。默认值为True，表示逆时针；如果值为False，则表示顺时针。　</p>
<p>wedgeprops：字典类型，可选参数，默认值为None。字典传递给wedge对象，用来画一个饼图。例如wedgeprops={‘linewidth’:2}设置wedge线宽为2。　</p>
<p>textprops：设置标签和比例文字的格式，字典类型，可选参数，默认值为None。传递给text对象的字典参数。　</p>
<p>center：浮点类型的列表，可选参数，默认值为(0,0)，表示图表中心位置。　</p>
<p>frame：布尔型，可选参数，默认值为False，不显示轴框架（也就是网格）；如果值为True，则显示轴框架，与grid()函数配合使用。实际应用中建议使用默认设置，因为显示轴框架会干扰饼形图效果。　</p>
<p>rotatelabels：布尔型，可选参数，默认值为False；如果值为True，则旋转每个标签到指定的角度。</p>
<p>01 import matplotlib.pyplot as plt<br>02 x = [2,5,12,70,2,9]<br>03 plt.pie(x,autopct=’%1.1f%%’)<br>运行程序，输出结果如图5.42所示。</p>
<h4 id="-1"><a href="#-1" class="headerlink" title></a></h4><p>​                                                                                               图5.44　分裂饼形图<br>分裂饼形图主要通过设置explode参数实现，该参数用于设置饼图距中心的距离，我们需要将哪块饼图分裂出来，就设置它与中心的距离即可。例如，图5.43中有10块饼图，我们将占比最多的“广东省”分裂出来，如图5.44（a）所示。广东省在第一位，那么就设置第一位距中心的距离为0.1，其他为0，关键代码如下：</p>
<p>explode = (0.1,0,0,0,0,0,0,0,0,0)</p>
<h4 id="3．立体感带阴影的饼形图"><a href="#3．立体感带阴影的饼形图" class="headerlink" title="3．立体感带阴影的饼形图"></a>3．立体感带阴影的饼形图</h4><p>立体感带阴影的饼形图看起来更美观，效果如图5.45所示。<br>立体感带阴影的饼形图主要通过shadow参数实现，设置该参数值为True即可，主要代码如下：</p>
<p>shadow=True</p>
<h4 id="4．环形图"><a href="#4．环形图" class="headerlink" title="4．环形图"></a>4．环形图</h4><p>​                                                                                                              图5.46　环形图<br>这里还是通过pie()函数实现，一个关键参数wedgeprops，字典类型，用于设置饼形图内、外边界的属性，如环的宽度，环边界颜色和宽度，主要代码如下：</p>
<p>wedgeprops = {‘width’: 0.4, ‘edgecolor’: ‘k’}</p>
<h4 id="5．内嵌"><a href="#5．内嵌" class="headerlink" title="5．内嵌"></a>5．内嵌</h4><p>​                                                                                             图5.47　内嵌环形图<br>绘制内嵌环形图需要注意以下3点。<br>（1）连续使用两次pie()函数。<br>（2）通过wedgeprops参数设置环形边界。<br>（3）通过radius参数设置不同的半径。<br>另外，由于图例内容比较长，为了使图例能够正常显示，图例代码中引入了两个主要参数，即frameon和bbox_to_anchor。其中，frameon参数设置图例有无边框；bbox_to_anchor参数设置图例位置，主要代码如下：</p>
<p><img src="/.com//image-20211022044933255.png" alt="image-20211022044933255"></p>
<h3 id="5-6-5-散点图"><a href="#5-6-5-散点图" class="headerlink" title="5.6.5　散点图"></a>5.6.5　散点图</h3><p>散点图主要用来查看数据的分布情况或相关性，一般用在线性回归分析中，查看数据点在坐标系平面上的分布情况。散点图表示因变量随自变量而变化的大致趋势，据此可以选择合适的函数对数据点进行拟合。<br>散点图与折线图类似，也是一个个点构成的。但不同之处在于，散点图的各点之间不会按照前后关系以线条连接起来。<br>Matplotlib绘制散点图使用plot()函数和scatter()函数都可以实现，本节使用scatter()函数绘制散点图，scatter()函数专门用于绘制散点图，使用方式和plot()函数类似，区别在于前者具有更高的灵活性，可以单独控制每个散点与数据匹配，并让每个散点具有不同的属性。scatter()函数的语法如下：</p>
<p>matplotlib.pyplot.scatter(x,y,s=None,c=None,marker=None,cmap=None,norm=None,vmin=None,vmax=None,<br>alpha=None,linewidths=None,verts=None,edgecolors=None,data=None, **kwargs)<br>参数说明：　</p>
<p>x，y：数据。　</p>
<p>s：标记大小，以平方磅为单位的标记面积，设置值如下。　</p>
<p>​        数值标量：以相同的大小绘制所有标记。　</p>
<p>​        行或列向量：使每个标记具有不同的大小。x、y和sz中的相应元素确定每个标记的位置和面积。sz的长度必须等于x和y的长度。　</p>
<p>​        []：使用36平方磅的默认面积。　</p>
<p>c：标记颜色，可选参数，默认标记颜色为蓝色。　</p>
<p>marker：标记样式，可选参数，默认值为’o’。　</p>
<p>cmap：颜色地图，可选参数，默认值为None。</p>
<p>norm：可选参数，默认值为None</p>
<p>vmin，vmax：标量，可选，默认值为None　</p>
<p>alpha：透明度，可选参数，0～1的数，表示透明度，默认值为None。　</p>
<p>linewidths：线宽，标记边缘的宽度，可选参数，默认值为None。　</p>
<p>verts：(x,y)的序列，可选参数，如果参数marker为None，这些顶点将用于构建标记。标记的中心位置为(0,0)。　</p>
<p>edgecolors：轮廓颜色，与参数c类似，可选参数，默认值为None。　</p>
<p>data：data关键字参数。如果给定一个数据参数，所有位置和关键字参数将被替换。　</p>
<p>**kwargs：关键字参数，其他可选参数。</p>
<p>01 import matplotlib.pyplot as plt<br>02 x=[1,2,3,4,5,6]<br>03 y=[19,24,37,43,55,68]<br>04 plt.scatter(x, y)<br>运行程序，输出结果如图5.48所示。</p>
<p>​                                                                              图5.49　销售收入与广告费散点图</p>
<h3 id="5-6-6-绘制面积图"><a href="#5-6-6-绘制面积图" class="headerlink" title="5.6.6　绘制面积图"></a>5.6.6　绘制面积图</h3><p>面积图用于体现数量随时间而变化的程度，也可用于引起人们对总值趋势的注意。例如，表示随时间而变化的利润的数据可以绘制在面积图中，以强调总利润。<br>Matplotlib绘制面积图主要使用stackplot()函数，语法如下：</p>
<p>matplotlib.pyplot.stackplot(x,*args,data=None,**kwargs)<br>参数说明：　**</p>
<p>x：x轴数据。　</p>
<p><em>args：当传入的参数个数未知时使用</em>args。这里指y轴数据可以传入多个y轴。　</p>
<p>data：data关键字参数。如果给定一个数据参数，所有位置和关键字参数将被替换。　</p>
<p>kwargs：关键字参数，其他可选参数，如color（颜色）、alpha（透明度）等。</p>
<h3 id="5-6-7-绘制热力图"><a href="#5-6-7-绘制热力图" class="headerlink" title="5.6.7　绘制热力图"></a>5.6.7　绘制热力图</h3><p>热力图是通过密度函数进行可视化用于表示地图中点的密度的热图。它使人们能够独立于缩放因子感知点的密度。热力图可以显示不可点击区域发生的事情。利用热力图可以看数据表里多个特征两两的相似度。例如，以特殊高亮的形式显示访客热衷的页面区域和访客所在的地理区域的图示。热力图在网页分析、业务数据分析等其他领域也有较为广泛的应用。</p>
<p>【示例28】　绘制简单热力图。（示例位置：资源包\MR\Code\05\28）<br>热力图是数据分析的常用方法，通过色差、亮度来展示数据的差异，易于理解。下面绘制简单热力图，程序代码如下：</p>
<p>01 import matplotlib.pyplot as plt<br>02 X = [[1,2],[3,4],[5,6],[7,8],[9,10]]<br>03 plt.imshow(X)<br>运行程序，输出结果如图5.53所示。</p>
<p>​                                                                                              图5.53　简单热力图</p>
<p>上述代码中，plt.imshow(X)中传入的数组X=[[1,2],[3,4],[5,6],[7,8],[9,10]]为颜色的对应值，按照矩阵X进行颜色分布，如左上角颜色为深蓝，其对应值为1，右下角颜色为黄色，其对应值为10，具体如下：</p>
<p>[1,2]  [深蓝,蓝色]<br>[3,4]  [蓝绿,深绿]<br>[5,6]  [海藻绿,春绿色]<br>[7,8]  [绿色,浅绿色]<br>[9,10] [草绿色,黄色]</p>
<h3 id="5-6-8-箱形图"><a href="#5-6-8-箱形图" class="headerlink" title="5.6.8　箱形图"></a>5.6.8　箱形图</h3><p>箱形图又称箱线图、盒须图或盒式图，它是一种用作显示一组数据分散情况下的资料的统计图。因形状像箱子而得名。箱形图最大的优点<strong>就是不受异常值的影响（异常值也称为离群值</strong>），可以以一种相对稳定的方式描述数据的离散分布情况，因此在各种领域也经常被使用。另外，箱形图也常用于异常值的识别。Matplotlib绘制箱形图主要使用boxplot()函数，语法如下：</p>
<p>matplotlib.pyplot.boxplot(x,notch=None,sym=None,vert=None,whis=None,positions=None,widths=None,patch_<br>artist=None,meanline=None,showmeans=None,showcaps=None,showbox=None,showfliers=None,boxprops=None,<br>labels=None,flierprops=None,medianprops=None,meanprops=None,capprops=None,whiskerprops=None)<br>参数说明：　</p>
<p>x：指定要绘制箱形图的数据。　</p>
<p>notch：是否以凹口的形式展现箱形图，默认非凹口。　</p>
<p>sym：指定异常点的形状，默认为加号（+）显示。　</p>
<p>vert：是否需要将箱形图垂直摆放，默认垂直摆放。　</p>
<p>whis：指定上下限与上下四分位的距离，默认为1.5倍的四分位差。　</p>
<p>positions：指定箱形图的位置，默认为[0,1,2,…]。　</p>
<p>widths：指定箱形图的宽度，默认为0.5。　</p>
<p>patch_artist：是否填充箱体的颜色。　</p>
<p>meanline：是否用线的形式表示均值，默认用点来表示。　</p>
<p>showmeans：是否显示均值，默认不显示。　</p>
<p>showcaps：是否显示箱形图顶端和末端的两条线，默认显示。　</p>
<p>showbox：是否显示箱形图的箱体，默认显示。　</p>
<p>showfliers：是否显示异常值，默认显示。　</p>
<p>boxprops：设置箱体的属性，如边框色、填充色等。　</p>
<p>labels：为箱形图添加标签，类似于图例的作用。　</p>
<p>filerprops：设置异常值的属性，如异常点的形状、大小、填充色等。　</p>
<p>medianprops：设置中位数的属性，如线的类型、粗细等。　meanprops：设置均值的属性，如点的大小、颜色等。</p>
<p>capprops：设置箱形图顶端和末端线条的属性，如颜色、粗细等。　</p>
<p>whiskerprops：设置须的属性，如颜色、粗细、线的类型等。</p>
<p>【示例30】　绘制简单箱形图。（示例位置：资源包\MR\Code\05\30）<br>绘制简单箱形图，程序代码如下：</p>
<p>01  import matplotlib.pyplot as plt<br>02  x=[1,2,3,5,7,9]<br>03  plt.boxplot(x)<br>运行程序，输出结果如图5.55所示。</p>
<p>01 import matplotlib.pyplot as plt<br>02 x1=[1,2,3,5,7,9]<br>03 x2=[10,22,13,15,8,19]<br>04 x3=[18,31,18,19,14,29]<br>05 plt.boxplot([x1,x2,x3])<br>运行程序，输出结果如图5.56所示。</p>
<p>下四分位<br>        图5.57中的下四分位数指的是数据的25%分位点所对应的值（Q1）。计算分位数可以使用Pandas的quantile()函数。例如，Q1 = df[‘总消费’].quantile(q = 0.25)。　</p>
<p>中位数<br>        中位数即为数据的50%分位点所对应的值（Q2）。　</p>
<p>上四分位数<br>        上四分位数则为数据的75%分位点所对应的值（Q3）。　</p>
<p>上限<br>        <strong>上限的计算公式为Q3+1.5(Q3-Q1)。</strong>　</p>
<p>下限<br>        下限的计算公式为Q1-1.5(Q3-Q1)。其中，Q3-Q1表示四分位差。如果使用箱形图识别异常值，其判断标准是，当变量的数据值大于箱形图的上限或者小于箱线图的下限时，就可以将这样的数据判定为异常值。</p>
<p>​                                                                                          图5.60　异常值</p>
<p>​                                              </p>
<h3 id="-2"><a href="#-2" class="headerlink" title></a></h3><p>Matplotlib可以实现在一张图上绘制多个子图表。Matplotlib提供了3种方法：一是subplot()函数；二是subplots()函数；三是add_subplot()函数，下面分别介绍。</p>
<h4 id="1．subplot-函数"><a href="#1．subplot-函数" class="headerlink" title="1．subplot()函数"></a>1．subplot()函数</h4><p>subplot()函数直接指定划分方式和位置，它可以将一个绘图区域划分为n个子图，每个subplot()函数只能绘制一个子图。语法如下：</p>
<p>matplotlib.pyplot.subplot(*args,**kwargs)<br>参数说明：　**</p>
<p><em>args：当传入的参数个数未知时使用</em>args。　</p>
<p>kwargs：关键字参数，其他可选参数。<br>例如，绘制一个2×3的区域，subplot(2,3,3)，将画布分成2行3列在第3个区域中绘制，用坐标表示如下：</p>
<p>(1,1),(1,2),(1,3)</p>
<p>(2,1),(2,2),(2,3)<br>如果行列的值都小于10，那么可以把它们缩写为一个整数，如subplot(233)。<br>另外，subplot()函数在指定的区域中创建一个轴对象，如果新创建的轴和之前所创建的轴重叠，那么，之前的轴将被删除。</p>
<p>上述举例，以下两个关键点一定要掌握。<br><strong>（1）每绘制一个子图表都要调用一次subplot()函数。</strong><br><strong>（2）绘图区域位置编号</strong>。<br>subplot()函数的前面两个参数指定的是一个画布被分割成的行数和列数，后面一个参数则指的是当前绘制区域位置编号，编号规则是行优先。<br>例如，图5.64中有3个子图表，第1个子图表subplot(2,2,1)，即将画布分成2行2列，在第1个子图中绘制折线图；第2个子图表subplot(2,2,2)，将画布分成2行2列，在第2个子图中绘制散点图；第3个子图表subplot(2,1,2)，将画布分成2行1列，由于第1行已经占用了，所以在第2行也就是第3个子图中绘制柱形图。示意图如图5.65所示。</p>
<p>​                                                                                               图5.65　多个子图示意图<br>subplot()函数在画布中绘图时，每次都要调用它指定绘图区域非常麻烦，而subplots()函数则更直接，它会事先把画布区域分割好。下面介绍subplots()函数。</p>
<h4 id="2．subplots-函数"><a href="#2．subplots-函数" class="headerlink" title="2．subplots()函数"></a>2．subplots()函数</h4><p>subplots()函数用于创建画布和子图，语法如下：</p>
<p>matplotlib.pyplot.subplots(nrows,ncols,sharex,sharey,squeeze,subplot_kw,gridspec_kw,**fig_kw)<br>参数说明：　</p>
<p>nrows和ncols：表示将画布分割成几行几列，例如，nrows=2、ncols=2表示将画布分割为2行2列，起始值均为0。当调用画布中的坐标轴时，ax[0,0]表示调用左上角的坐标，ax[1,1]表示调用右下角的坐标。　</p>
<p>sharex和sharey：布尔值或者值为“none”“all”“row”“col”，默认值为False。用于控制x或y轴之间的属性共享。具体参数值说明如下。　    </p>
<p>​        True或者“all”：表示x或y轴属性在所有子图中共享。　</p>
<p>​        False或者“none”：表示每个子图的x或y轴都是独立的部分。　</p>
<p>​        “row”：表示每个子图在一个x或y轴上共享行（row）。　</p>
<p>​        “col”：表示每个子图在一个x或y轴上共享列（column）　</p>
<p>squeeze：布尔值，默认值为True，额外的维度从返回的axes（轴）对象中挤出，对于n×1或1×n个子图，返回一个一维数组，对于n×m，n&gt;1和m&gt;1返回一个二维数组；如果值为False，则表示不进行挤压操作，返回一个元素为Axes实例的二维数组，即使它最终是1×1。　</p>
<p>subplot_kw：字典类型，可选参数。把字典的关键字传递给add_subplot()函数来创建每个子图。　</p>
<p>gridspec_kw：字典类型，可选参数。把字典的关键字传递给GridSpec()构造函数创建网格区域，然后将子图放在网格（grid）里。　**fig_kw：把所有详细的关键字参数传递给figure。</p>
<p>【示例37】　使用subplots()函数绘制多子图的空图表。（示例位置：资源包\MR\Code\05\37）<br>绘制一个2×3包含6个子图的空图表，使用subplots()函数只需3行代码。</p>
<p>01 import matplotlib.pyplot as plt<br>02 figure,axes=plt.subplots(2,3)<br>03 plt.show()<br>上述代码中，figure和axes是两个关键点。　</p>
<p>figure：绘制图表的画布。　</p>
<p>axes：坐标轴对象，可以理解为在figure（画布）上绘制坐标轴对象，它帮我们规划出了一个个科学作图的坐标轴系统。</p>
<h4 id="3．add-subplot-函数"><a href="#3．add-subplot-函数" class="headerlink" title="3．add_subplot()函数"></a>3．add_subplot()函数</h4><p>【示例39】　使用add_subplot()函数绘制多子图图表。（示例位置：资源包\MR\Code\05\39）<br>add_subplot()函数也可以实现在一张图上绘制多个子图表，用法与subplot()函数基本相同，先来看下列一段代码：</p>
<p>01 import matplotlib.pyplot as plt<br>02 fig = plt.figure()</p>
<p>03 ax1 = fig.add_subplot(2,3,1)<br>04 ax2 = fig.add_subplot(2,3,2)<br>05 ax3 = fig.add_subplot(2,3,3)<br>06 ax4 = fig.add_subplot(2,3,4)<br>07 ax5 = fig.add_subplot(2,3,5)<br>08 ax6 = fig.add_subplot(2,3,6)<br>上述代码同样是绘制一个2×3包含6个子图的空图表。首先创建figure实例（画布），然后通过ax1 =fig.add_subplot(2,3,1)创建第1个子图表，返回Axes实例（坐标轴对象），第1个参数为行数，第2个参数为列数，第3个参数为子图表的位置。<br>以上用3种方法实现了在一张图上绘制多个子图表，3种方法各有所长。subplot()函数和add_subplot()函数比较灵活，定制化效果比较好，可以实现子图表在图中的各种布局（如一张图上可以随意摆放3个或5个图表）；而subplots()函数较为不灵活，但它可以用较少的代码实现绘制多个子图表。</p>
<h3 id="5-6-11-图表的保存"><a href="#5-6-11-图表的保存" class="headerlink" title="5.6.11　图表的保存"></a>5.6.11　图表的保存</h3><p>实际工作中，有时需要将绘制的图表保存为图片放置到报告中。Matplotlib的savefig()函数可以实现这一功能，将图表保存为JPEG、TIFF或PNG格式的图片。<br>例如，保存之前绘制的折线图，主要代码如下：</p>
<p>plt.savefig(‘image.png’)<br>需要注意的一个关键问题：保存代码必须在图表预览前，也就是plt.show()代码前；否则保存后的图片是白色，图表无法保存。<br>运行程序，图表被保存在程序所在路径下，名为image.png，如图5.68所示。</p>
<p>​                                                                                             图5.68　保存后的图表</p>
<h2 id="5-7-综合应用"><a href="#5-7-综合应用" class="headerlink" title="5.7　综合应用"></a>5.7　综合应用</h2><h3 id="5-7-1-案例1：双y轴可视化数据分析图表的实现"><a href="#5-7-1-案例1：双y轴可视化数据分析图表的实现" class="headerlink" title="5.7.1　案例1：双y轴可视化数据分析图表的实现"></a>5.7.1　案例1：双y轴可视化数据分析图表的实现</h3><p>案例位置：资源包\MR\Code\05\example\01<br>双y轴顾名思义就是两个y轴，其特点是通过双y轴可以看出发展情况的同时还可以看到其增长速度。对于产品而言，通过此图可以看到产品销量的同时还可以看到产品增长率，效果如图5.69所示。</p>
<p>​                                                                           图5.69　双y轴可视化数据分析图表<br>双y轴可视化数据分析图表的实现主要使用add_suplot()函数和twinx()函数。twinx()函数表示共享x轴，那么也就是一个x轴、两个y轴，程序代码如下：</p>
]]></content>
      <categories>
        <category>数据分析文档</category>
      </categories>
  </entry>
  <entry>
    <title>matplotlib可视化数据分析图表</title>
    <url>/2020/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="第五章-matplotlib可视化数据分析图表"><a href="#第五章-matplotlib可视化数据分析图表" class="headerlink" title="第五章 matplotlib可视化数据分析图表"></a>第五章 matplotlib可视化数据分析图表</h1><h2 id="5-1数据分析图表的作用"><a href="#5-1数据分析图表的作用" class="headerlink" title="5.1数据分析图表的作用"></a>5.1数据分析图表的作用</h2><p><img src="/.com//image-20211022031956908.png" alt="image-20211022031956908"></p>
<p><img src="/.com//image-20211022032027076.png" alt="image-20211022032027076"></p>
<p>上述举例同是“月销量分析”结果的呈现，您更青睐哪一种？显然，数据分析图表（见图5.2）更加直观、生动和具体，它将复杂的统计数字变得简单化、通俗化、形象化，使人一目了然，便于理解和比较。数据分析图表直观地展示统计信息，使我们能够快速了解数据变化趋势、数据比较结果以及所占比例等，它对数据分析、数据挖掘起到了关键性的作用。</p>
<h2 id="5-2-如何选择适合的图表类型"><a href="#5-2-如何选择适合的图表类型" class="headerlink" title="5.2　如何选择适合的图表类型"></a>5.2　如何选择适合的图表类型</h2><p>数据分析图表的类型包括条形图、柱状图、折线图、饼图、散点图、面积图、环形图、雷达图等。此外，通过图表的相互叠加还可以生成复合型图表。<br>不同类型的图表适用不同的场景，可以按使用目的选择合适的图表类型。下面通过一张框架图来说明，如图5.3所示。</p>
<p><img src="/.com//image-20211022032233461.png" alt="image-20211022032233461"></p>
<p>​                                                                                                    图5.3　图表分类框架图</p>
<h2 id="5-3-图表的基本组成"><a href="#5-3-图表的基本组成" class="headerlink" title="5.3　图表的基本组成"></a>5.3　图表的基本组成</h2><p>数据分析图表有很多种，但每一种图表的绝大组成部分是基本相同的，一张完整的图表一般包括画布、图表标题、绘图区、数据系列、坐标轴、坐标轴标题、图例、文本标签、网格线等，如图5.4所示。</p>
<p><img src="/.com//image-20211022032427628.png" alt="image-20211022032427628"></p>
<p>​                                                                                  图5.4　图表的基本组成部分<br>下面详细介绍各个组成部分的功能。<br>（1）画布：图中最大的白色区域，作为其他图表元素的容器。<br>（2）图表标题：用来概况图表内容的文字，常用的功能有设置字体、字号及字体颜色等。<br>（3）绘图区：画布中的一部分，即显示图形的矩形区域，可改变填充颜色、位置，以便图表展示更好的图形效果。<br>（4）数据系列：在数据区域中，同一列（或同一行）数值数据的集合构成一组数据系列，也就是图表中相关数据点的集合。图表中可以有一组到多组数据系列，多组数据系列之间通常采用不同的图案、颜色或符号来区分。图5.4中，销售额就是数据系列。<br>（5）坐标轴及坐标轴标题：坐标轴是标识数值大小及分类的垂直线和水平线，上面有标定数据值的标志（刻度）。一般情况下，水平轴（x轴）表示数据的分类；坐标轴标题用来说明坐标轴的分类及内容，分为水平坐标轴和垂直坐标轴。图5.4中，x轴的标题是“年份”，y轴的标题是“线上销售额（元）”。<br>（6）图例：是指示图表中系列区域的符号、颜色或形状定义数据系列所代表的内容。图例由两部分构成，即图例标示和图例项。其中，图例标示，代表数据系列的图案，即不同颜色的小方块；图例项，与图例标示对应的数据系列名称。一种图例标示只能对应一种图例项。<br>（7）文本标签：用于为数据系列添加说明文字。<br>（8）网格线：贯穿绘图区的线条，类似标尺可以衡量数据系列数值的标准。常用的功能有设置网格线宽度、样式、颜色、坐标轴等。</p>
<h2 id="5-4-Matplotlib概述"><a href="#5-4-Matplotlib概述" class="headerlink" title="5.4　Matplotlib概述"></a>5.4　Matplotlib概述</h2><p>众所周知，Python绘图库有很多，各有特点，而Maplotlib是最基础的Python可视化库。学习Python数据可视化，应首先从Maplotlib学起，然后再学习其他库作为拓展。</p>
<h3 id="5-4-1-Matplotlib简介"><a href="#5-4-1-Matplotlib简介" class="headerlink" title="5.4.1　Matplotlib简介"></a>5.4.1　Matplotlib简介</h3><p>Matplotlib是一个Python 2D绘图库，常用于数据可视化。它能够以多种硬拷贝格式和跨平台的交互式环境生成出版物质量的图形。<br>Matplotlib非常强大，绘制各种各样的图表游刃有余，它将容易的事情变得更容易，困难的事情变得可能。只需几行代码就可以绘制折线图（见图5.5和图5.6）、柱形图（见图5.7）、直方图（见图5.8）、饼形图（见图5.9）、散点图（见图5.10）等。</p>
<p><img src="/.com//image-20211022032738449.png" alt="image-20211022032738449"></p>
<p>​                                                                                               图5.5　折线图</p>
<p><img src="/.com//image-20211022032809892.png" alt="image-20211022032809892"></p>
<p>​                                                                                                         图5.6　多折线图</p>
<p><img src="/.com//image-20211022032836058.png" alt="image-20211022032836058"></p>
<p>​                                                                                                           图5.7　柱形图</p>
<p><img src="/.com//image-20211022032942254.png" alt="image-20211022032942254"></p>
<p>​                                                                                                                图5.8　直方图</p>
<p><img src="/.com//image-20211022033015707.png" alt="image-20211022033015707"></p>
<p>​                                                                                                   图5.9　饼形图</p>
<p><img src="/.com//image-20211022033048337.png" alt="image-20211022033048337"></p>
<p>​                                                                                                                   图5.10　散点图</p>
<p>Matpoltlib不仅可以绘制以上最基础的图表，还可以绘制一些高级图表，如双y轴可视化数据分析图表（见图5.11）、堆叠柱形图（见图5.12）、渐变饼形图（见图5.13）、等高线图（见图5.14）。</p>
<p><img src="/.com//image-20211022033123470.png" alt="image-20211022033123470"></p>
<p>​                                                                               图5.11　双y轴可视化数据分析图表</p>
<p><img src="/.com//image-20211022033148927.png" alt="image-20211022033148927"></p>
<p>​                                                                                          图5.12　堆叠柱形图</p>
<p><img src="/.com//image-20211022033244197.png" alt="image-20211022033244197"></p>
<p>​                                                                                                图5.13　渐变饼形图</p>
<p><img src="/.com//image-20211022033309035.png" alt="image-20211022033309035"></p>
<p>​                                                                                                     图5.14　等高线图<br>不仅如此，Matplotlib还可以绘制3D图表。例如，三维柱形图（见图5.15）、三维曲面图（见图5.16）。</p>
<p><img src="/.com//image-20211022033338259.png" alt="image-20211022033338259"></p>
<p>​                                                                                           图5.15　三维柱形图</p>
<p><img src="/.com//image-20211022033408168.png" alt="image-20211022033408168"></p>
<p>​                                                                                                  图5.16　三维曲面图</p>
<p>综上所述，只要熟练地掌握Matplotlib的函数，以及各项参数就能够绘制出各种出乎意料的图表，满足数据分析的需求。</p>
<h3 id="5-4-2-安装Matplotlib"><a href="#5-4-2-安装Matplotlib" class="headerlink" title="5.4.2　安装Matplotlib"></a>5.4.2　安装Matplotlib</h3><p>pip install matplotlib</p>
<h3 id="5-4-3-Matplotlib图表之初体验"><a href="#5-4-3-Matplotlib图表之初体验" class="headerlink" title="5.4.3　Matplotlib图表之初体验"></a>5.4.3　Matplotlib图表之初体验</h3><p>创建Matplotlib图表简单的只需两步。下面将绘制第一张图表。</p>
<p>【示例01】　绘制第一张图表。（示例位置：资源包\MR\Code\05\01）<br>（1）引入pyplot模块。</p>
<p>（2）使用Matplotlib模块的plot()方法绘制图表。<br>（3）输出结果，如图5.19和图5.20所示。</p>
<p><img src="/.com//image-20211022034058362.png" alt="image-20211022034058362"></p>
<p>​                                                                                         图5.19　简单折线图</p>
<p><img src="/.com//image-20211022034122814.png" alt="image-20211022034122814"></p>
<p>​                                                                                             图5.20　简单散点图</p>
<p>程序代码如下：</p>
<p>01 import matplotlib.pyplot as plt<br>02 plt.plot([1, 2, 3, 4,5])</p>
<p>【示例02】　绘制散点图。（示例位置：资源包\MR\Code\05\02）<br>将示例01的代码稍作改动以绘制散点图，程序代码如下：</p>
<p>01 import matplotlib.pyplot as plt<br>02 plt.plot([1, 2, 3, 4,5], [2, 5, 8, 12,18], ‘ro’)</p>
<h2 id="5-5-图表的常用设置"><a href="#5-5-图表的常用设置" class="headerlink" title="5.5　图表的常用设置"></a>5.5　图表的常用设置</h2><p>本节主要介绍图表的常用设置，主要包括颜色设置、线条样式、标记样式、设置画布、坐标轴、添加文本标签、设置标题和图例、添加注释文本、调整图表与画布边缘间距，以及其他相关设置等。</p>
<h3 id="5-5-1-基本绘图plot-函数"><a href="#5-5-1-基本绘图plot-函数" class="headerlink" title="5.5.1　基本绘图plot()函数"></a>5.5.1　基本绘图plot()函数</h3><p>Matplotlib基本绘图主要使用plot()函数，语法如下：</p>
<p>matplotlib.pyplot.plot(x,y,format_string,**kwargs)<br>参数说明：　**</p>
<p>x：x轴数据。　</p>
<p>y：y轴数据。　</p>
<p>format_string：控制曲线格式的字符串，包括颜色、线条样式和标记样式。　</p>
<p>kwargs：键值参数，相当于一个字典，比如输入参数为(1,2,3,4,k,a=1,b=2,c=3)，*args=(1,2,3,4,k)，**kwargs={‘a’:’1,’b’:2,’c’:3}。</p>
<p>【示例03】　绘制简单折线图。（示例位置：资源包\MR\Code\05\03）<br>绘制简单的折线图，程序代码如下：</p>
<p><img src="/.com//image-20211022034804845.png" alt="image-20211022034804845"></p>
<p>运行程序，输出结果如图5.21所示。</p>
<p><img src="/.com//image-20211022034902494.png" alt="image-20211022034902494"></p>
<p>​                                                                                     图5.21　简单折线图</p>
<p>【示例04】　绘制体温折线图。（示例位置：资源包\MR\Code\05\04）<br>示例03中数据是通过range()函数随机创建的。下面导入Excel体温表，分析下14天基础体温情况，程序代码如下：</p>
<p><img src="/.com//image-20211022034830689.png" alt="image-20211022034830689"></p>
<p>运行程序，输出结果如图5.22所示。</p>
<p><img src="/.com//image-20211022034948585.png" alt="image-20211022034948585"></p>
<p>​                                                                                     图5.22　体温折线图<br>至此，您可能还是觉得图5.22中的图表不够完美，那么在接下来的学习中，我们将一步一步完善这张图表。下面介绍图表中线条颜色、线条样式和标记样式的设置。</p>
<h4 id="1．颜色设置"><a href="#1．颜色设置" class="headerlink" title="1．颜色设置"></a>1．颜色设置</h4><p>color参数可以设置线条颜色，通用颜色值如表5.1所示。</p>
<p>​                                                                                                表5.1　通用颜色</p>
<p><img src="/.com//image-20211022035138016.png" alt="image-20211022035138016"></p>
<p>其他颜色可以通过十六进制字符串指定，或者指定颜色名称，例如：　</p>
<p>浮点形式的RGB或RGBA元组，例如(0.1, 0.2, 0.5)或(0.1, 0.2, 0.5, 0.3)。　</p>
<p>十六进制的RGB或RGBA字符串，例如#0F0F0F或#0F0F0F0F。　</p>
<p>0～1的小数作为灰度值，例如0.5。　</p>
<p>{‘b’, ‘g’, ‘r’, ‘c’, ‘m’, ‘y’, ‘k’, ‘w’}，其中的一个颜色值。　</p>
<p>X11/CSS4规定中的颜色名称。　</p>
<p>Xkcd中指定的颜色名称，例如xkcd:sky blue。　</p>
<p>Tableau调色板中的颜色，例如{‘tab:blue’, ‘tab:orange’, ‘tab:green’, ‘tab:red’, ‘tab:purple’, ‘tab:brown’,’tab:pink’, ‘tab:gray’, ‘tab:olive’, ‘tab:cyan’}。　</p>
<p>CN格式的颜色循环，对应的颜色设置代码如下：</p>
<p>01  from cycler import cycler<br>02  colors=[‘#1f77b4’, ‘#ff7f0e’, ‘#2ca02c’, ‘#d62728’, ‘#9467bd’, ‘#8c564b’, ‘#e377c2’,’#7f7f7f’, ‘#bcbd22’, ‘#17becf’]<br>03  plt.rcParams[‘axes.prop_cycle’] = cycler(color=colors)</p>
<p>补充：</p>
<ol>
<li><p>matplotlib的依赖包cycler是matplotlib自主开发的属性组合包，功能与内置模块itertools很多函数非常相似，可用于创建特殊的迭代器。matpoltlib在属性设置底层中使用了cycler包，典型的案例就是在多数据系列绘图中循环使用颜色、线条等外观设置。使用cycler可以避免构造多重循环，更简便、灵活的组合属性。</p>
</li>
<li><p>plt（matplotlib.pyplot）使用rc配置文件来自定义图形的各种默认属性，称之为rc配置或rc参数。<br>通过rc参数可以修改默认的属性，包括窗体大小、每英寸的点数、线条宽度、颜色、样式、坐标轴、坐标和网络属性、文本、字体等。rc参数存储在字典变量中，通过字典的方式进行访问。</p>
<p>序号    属性    说明<br>1    plt.rcParams[’axes.unicode_minus’] = False    字符显示<br>2    plt.rcParams[’font.sans-serif’] = ‘SimHei’    设置字体<br>线条样式：lines<br>3    plt.rcParams[’lines.linestyle’] = ‘-.’    线条样式<br>4    plt.rcParams[’lines.linewidth’] = 3    线条宽度<br>5    plt.rcParams[’lines.color’] = ‘blue’    线条颜色<br>6    plt.rcParams[’lines.marker’] = None    默认标记<br>7    plt.rcParams[’lines.markersize’] = 6    标记大小<br>8    plt.rcParams[’lines.markeredgewidth’] = 0.5    标记附近的线宽<br>横、纵轴：xtick、ytick<br>9    plt.rcParams[’xtick.labelsize’]    横轴字体大小<br>10    plt.rcParams[’ytick.labelsize’]    纵轴字体大小<br>11    plt.rcParams[’xtick.major.size’]    x轴最大刻度<br>12    plt.rcParams[’ytick.major.size’]    y轴最大刻度<br>figure中的子图：axes<br>13    plt.rcParams[’axes.titlesize’]    子图的标题大小<br>14    plt.rcParams[’axes.labelsize’]    子图的标签大小<br>图像、图片：figure、savefig<br>15    plt.rcParams[’figure.dpi’]    图像分辨率<br>16    plt.rcParams[’figure.figsize’]    图像显示大小<br>17    plt.rcParams[’savefig.dpi’]    图片像素</p>
</li>
</ol>
<h4 id="2．线条样式"><a href="#2．线条样式" class="headerlink" title="2．线条样式"></a>2．线条样式</h4><p>linestyle可选参数可以设置线条的样式，设置值如下，设置后的效果如图5.23所示。　“-”：实线，默认值。　“–”：双画线　“-.”：点画线。　“:”：虚线。</p>
<p><img src="/.com//image-20211022041509943.png" alt="image-20211022041509943"></p>
<p>​                                                                                          图5.23　线条样式</p>
<p>线条属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th align="right">描述</th>
</tr>
</thead>
<tbody><tr>
<td>agg_filter</td>
<td align="right">a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array</td>
</tr>
<tr>
<td>alpha</td>
<td align="right">float or None</td>
</tr>
<tr>
<td>animated</td>
<td align="right">bool</td>
</tr>
<tr>
<td>antialiased or aa</td>
<td align="right">bool</td>
</tr>
<tr>
<td>clip_box</td>
<td align="right">Bbox</td>
</tr>
<tr>
<td>clip_on</td>
<td align="right">bool</td>
</tr>
<tr>
<td>clip_path</td>
<td align="right">Patch or (Path, Transform) or None</td>
</tr>
<tr>
<td>color or c</td>
<td align="right">color</td>
</tr>
<tr>
<td>contains</td>
<td align="right">unknown</td>
</tr>
<tr>
<td>dash_capstyle</td>
<td align="right">{‘butt’, ‘round’, ‘projecting’}</td>
</tr>
<tr>
<td>dash_joinstyle</td>
<td align="right">{‘miter’, ‘round’, ‘bevel’}</td>
</tr>
<tr>
<td>dashes</td>
<td align="right">sequence of floats (on/off ink in points) or (None, None)</td>
</tr>
<tr>
<td>data</td>
<td align="right">(2, N) array or two 1D arrays</td>
</tr>
<tr>
<td>drawstyle or ds</td>
<td align="right">{‘default’, ‘steps’, ‘steps-pre’, ‘steps-mid’, ‘steps-post’}, default: ‘default’</td>
</tr>
<tr>
<td>figure</td>
<td align="right">Figure</td>
</tr>
<tr>
<td>fillstyle</td>
<td align="right">{‘full’, ‘left’, ‘right’, ‘bottom’, ‘top’, ‘none’}</td>
</tr>
<tr>
<td>gid</td>
<td align="right">str</td>
</tr>
<tr>
<td>in_layout</td>
<td align="right">bool</td>
</tr>
<tr>
<td>label</td>
<td align="right">object</td>
</tr>
<tr>
<td>linestyle or ls</td>
<td align="right">{’-’, ‘–’, ‘-.’, ‘:’, ‘’, (offset, on-off-seq), …}</td>
</tr>
<tr>
<td>linewidth or lw</td>
<td align="right">float</td>
</tr>
<tr>
<td>marker</td>
<td align="right">marker style string, Path or MarkerStyle</td>
</tr>
<tr>
<td>markeredgecolor or mec</td>
<td align="right">color</td>
</tr>
<tr>
<td>markeredgewidth or mew</td>
<td align="right">float</td>
</tr>
<tr>
<td>markerfacecolor or mfc</td>
<td align="right">color</td>
</tr>
<tr>
<td>markerfacecoloralt or mfcalt</td>
<td align="right">color</td>
</tr>
<tr>
<td>markersize or ms</td>
<td align="right">float</td>
</tr>
<tr>
<td>markevery</td>
<td align="right">None or int or (int, int) or slice or List[int] or float or (float, float) or List[bool]</td>
</tr>
<tr>
<td>path_effects</td>
<td align="right">AbstractPathEffect</td>
</tr>
<tr>
<td>picker</td>
<td align="right">unknown</td>
</tr>
<tr>
<td>pickradius</td>
<td align="right">float</td>
</tr>
<tr>
<td>rasterized</td>
<td align="right">bool or None</td>
</tr>
<tr>
<td>sketch_params</td>
<td align="right">(scale: float, length: float, randomness: float)</td>
</tr>
<tr>
<td>snap</td>
<td align="right">bool or None</td>
</tr>
<tr>
<td>solid_capstyle</td>
<td align="right">{‘butt’, ‘round’, ‘projecting’}</td>
</tr>
<tr>
<td>solid_joinstyle</td>
<td align="right">{‘miter’, ‘round’, ‘bevel’}</td>
</tr>
<tr>
<td>transform</td>
<td align="right">matplotlib.transforms.Transform</td>
</tr>
<tr>
<td>url</td>
<td align="right">str</td>
</tr>
<tr>
<td>visible</td>
<td align="right">bool</td>
</tr>
<tr>
<td>xdata</td>
<td align="right">1D array</td>
</tr>
<tr>
<td>ydata</td>
<td align="right">1D array</td>
</tr>
<tr>
<td>zorder</td>
<td align="right">float</td>
</tr>
</tbody></table>
<h4 id="3．标记样式"><a href="#3．标记样式" class="headerlink" title="3．标记样式"></a>3．标记样式</h4><p>marker可选参数可以设置标记样式，设置值如表5.2所示。</p>
<p>​                                                                                                   表5.2　标记设置</p>
<p><img src="/.com//image-20211022041541636.png" alt="image-20211022041541636"></p>
<p>下面为“14天基础体温曲线图”设置颜色和样式，并在实际体温位置进行标记，主要代码如下：</p>
<p>plt.plot(x,y,color=’m’,linestyle=’-‘,marker=’o’,mfc=’w’)</p>
<p>markerfacecolor or mfc：填充颜色</p>
<p>运行程序，输出结果如图5.24所示。</p>
<p><img src="/.com//image-20211022041620444.png" alt="image-20211022041620444"></p>
<p>​                                                                                       图5.24　带标记的折线图</p>
<h3 id="5-5-2-设置画布"><a href="#5-5-2-设置画布" class="headerlink" title="5.5.2　设置画布"></a>5.5.2　设置画布</h3><p>画布就像我们画画的画板一样，在Matplotlib中可以使用figure()方法设置画布大小、分辨率、颜色和边框等，语法如下：</p>
<p>matpoltlib.pyplot.figure(num=None, figsize=None, dpi=None, facecolor=None, edgecolor=None, frameon=True)<br>参数说明：　</p>
<p>num：图像编号或名称，数字为编号，字符串为名称，可以通过该参数激活不同的画布。　</p>
<p>figsize：指定画布的宽和高，单位为英寸。　</p>
<p>dpi：指定绘图对象的分辨率，即每英寸多少个像素，默认值为80。像素越大画布越大。　</p>
<p>facecolor：背景颜色。　</p>
<p>edgecolor：边框颜色。　</p>
<p>frameon：是否显示边框，默认值为True，绘制边框；如果为False，则不绘制边框。</p>
<p>【示例05】　自定义画布。（示例位置：资源包\MR\Code\05\05）<br>自定义一个5×3的黄色画布，主要代码如下：</p>
<p>01 import matplotlib.pyplot as plt<br>02 fig=plt.figure(figsize=(5,3),facecolor=’yellow’)<br>运行程序，输出结果如图5.25所示。</p>
<p><img src="/.com//image-20211022041739742.png" alt="image-20211022041739742"></p>
<p>​                                                                                               图5.25　设置画布注意</p>
<p>注意</p>
<p>figsize=(5,3)，因为实际画布大小是500×300，所以这里不要输入太大的数字。</p>
<h3 id="5-5-3-设置坐标轴"><a href="#5-5-3-设置坐标轴" class="headerlink" title="5.5.3　设置坐标轴"></a>5.5.3　设置坐标轴</h3><p>一张精确的图表，其中不免要用到坐标轴，下面介绍Matplotlib中坐标轴的使用。</p>
<h4 id="1．x轴、y轴标题"><a href="#1．x轴、y轴标题" class="headerlink" title="1．x轴、y轴标题"></a>1．x轴、y轴标题</h4><p>设置x轴和y轴标题主要使用xlabel()函数和ylabel()函数。</p>
<p>【示例06】　为体温折线图设置标题。（示例位置：资源包\MR\Code\05\06）<br>设置x轴标题为“2020年2月”，y轴标题为“基础体温”，程序代码如下：</p>
<p><img src="/.com//image-20211022041923078.png" alt="image-20211022041923078"></p>
<p>运行程序，输出结果如图5.26所示。</p>
<p><img src="/.com//image-20211022041940811.png" alt="image-20211022041940811"></p>
<p>​                                                                                 图5.26　带坐标轴标题的折线图实用技巧<br>在本示例中，应注意两个问题，即中文乱码问题和符号不显示问题。它们在实际编程过程中经常出现。<br>（1）解决中文乱码问题，代码如下：</p>
<p>plt.rcParams[‘font.sans-serif’]=[‘SimHei’]        #解决中文乱码</p>
<p>（2）解决负号不显示问题，代码如下：</p>
<p>plt.rcParams[‘axes.unicode_minus’] = False       #解决负号不显示</p>
<h4 id="2．坐标轴刻度"><a href="#2．坐标轴刻度" class="headerlink" title="2．坐标轴刻度"></a>2．坐标轴刻度</h4><p>用matplotlib画二维图像时，默认情况下的横坐标（x轴）和纵坐标（y轴）显示的值有时可能达不到我们的需求，需要借助xticks()函数和yticks()函数分别对x轴和y轴的值进行设置。<br>xticks()函数的语法如下：</p>
<p>xticks(locs, [labels], **kwargs)<br>参数说明：　</p>
<p>locs：数组，表示x轴上的刻度。例如，在“学生英语成绩分布图”中，x轴的刻度是2～14的偶数，如果想改变这个值，就可以通过locs参数设置。　</p>
<p>labels：也是数组，默认值和locs相同。locs表示位置，而labels则决定该位置上的标签，如果赋予labels空值，则x轴将只有刻度而不显示任何值。</p>
<p>【示例07】　为折线图设置刻度1。（示例位置：资源包\MR\Code\05\07）<br>在“14天基础体温折线图”中，x轴是从2～14的偶数，但实际日期是从1～14的连续数字，下面使用xticks()函数来解决这个问题，将x轴的刻度设置为1～14的连续数字，主要代码如下：</p>
<p>plt.xticks(range(1,15,1))</p>
<p>【示例08】　为折线图设置刻度2。（示例位置：资源包\MR\Code\05\08）<br>在示例07中，日期看起来不是很直观。下面将x轴刻度标签直接改为日，主要代码如下：</p>
<p><img src="/.com//image-20211022042054424.png" alt="image-20211022042054424"></p>
<p>运行程序，对比效果如图5.27和图5.28所示。<br>接下来，设置y轴刻度，主要使用yticks()函数。例如，设置体温为35.4～38，主要代码如下：</p>
<p>plt.yticks([35.4,35.6,35.8,36,36.2,36.4,36.6,36.8,37,37.2,37.4,37.6,37.8,38])</p>
<h4 id="3．坐标轴范围"><a href="#3．坐标轴范围" class="headerlink" title="3．坐标轴范围"></a>3．坐标轴范围</h4><p>坐标轴范围是指x轴和y轴的取值范围。设置坐标轴范围主要使用xlim()函数和ylim()函数。</p>
<p>【示例09】　为折线图设置坐标范围。（示例位置：资源包\MR\Code\05\09）<br>设置x轴（日期）范围为1～14，y轴（基础体温）范围为35～45，主要代码如下：</p>
<p>01  plt.xlim(1,14)<br>02  plt.ylim(35,45)</p>
<p><img src="/.com//image-20211022042147156.png" alt="image-20211022042147156"></p>
<p>​                                                                                           图5.27　更改x轴刻度</p>
<p><img src="/.com//image-20211022042216153.png" alt="image-20211022042216153"></p>
<p>​                                                                                                图5.28　x轴刻度为日<br>运行程序，输出结果如图5.29所示。</p>
<h4 id="4．网格线"><a href="#4．网格线" class="headerlink" title="4．网格线"></a>4．网格线</h4><p>细节决定成败。很多时候为了图表的美观，不得不考虑细节。下面介绍图表细节之一——网格线，主要使用grid()函数，首先生成网格线，代码如下：</p>
<p>plt.grid()<br>grid()函数也有很多参数，如颜色、网格线的方向（参数axis=’x’隐藏x轴网格线，axis=’y’隐藏y轴网格线）、网格线样式和网格线宽度等。下面为图表设置网格线，主要代码如下：</p>
<p>plt.grid(color=’0.5’,linestyle=’–’,linewidth=1)<br>运行程序，输出结果如图5.30所示。</p>
<p><img src="/.com//image-20211022042305653.png" alt="image-20211022042305653"></p>
<p>​                                                                                              图5.29　坐标轴范围</p>
<p><img src="/.com//image-20211022042332316.png" alt="image-20211022042332316"></p>
<pre><code>                                                                                 图5.30　带网格线的折线图实用技巧
</code></pre>
<p>网格线对于饼形图来说，直接使用并不显示，需要与饼形图的frame参数配合使用，设置该参数值为True。详见饼形图。</p>
<h3 id="5-5-4-添加文本标签"><a href="#5-5-4-添加文本标签" class="headerlink" title="5.5.4　添加文本标签"></a>5.5.4　添加文本标签</h3><p>绘图过程中，为了能够更清晰、直观地看到数据，有时需要给图表中指定的数据点添加文本标签。下面介绍细节之二——文本标签，主要使用text()函数，语法如下：</p>
<p>matplotlib.pyplot.text(x, y, s, fontdict=None, withdash=False, **kwargs)<br>参数说明：　**</p>
<p>x：x坐标轴的值。　</p>
<p>y：y坐标轴的值。　</p>
<p>s：字符串，注释内容。　</p>
<p>ontdict：字典，可选参数，默认值为None。用于重写默认文本属性。　</p>
<p>withdash：布尔型，默认值为False，创建一个TexWithDash实例，而不是Text实例。　</p>
<p>kwargs：关键字参数。这里指通用的绘图参数，如字体大小fontsize=12、垂直对齐方式horizontalalignment=’center’（或简写为ha=’center’）、水平对齐方式verticalalignment=’center’（或简写为va=’center’）。</p>
<p>【示例10】　为折线图添加基础体温文本标签。（示例位置：资源包\MR\Code\05\10）<br>为图表中各个数据点添加文本标签，关键代码如下：</p>
<p>01  for a,b  in zip(x,y):<br>02      plt.text(a,b+3,’%.1f’%b,ha = ‘center’,va = ‘bottom’,fontsize=9)<br>运行程序，输出结果如图5.31所示。</p>
<p><img src="/.com//image-20211022042505594.png" alt="image-20211022042505594"></p>
<p>​                                                                                     图5.31　带文本标签的折线图<br>在本示例代码中，首先，x、y是x轴和y轴的值，它代表了折线图在坐标中的位置，通过for循环找到每一个x、y值相对应的坐标赋值给a、b，再使用plt.text在对应的数据点上添加文本标签，而for循环也保证了折线图中每一个数据点都有文本标签。其中，a,b+3表示每一个数据点（x值对应y值加3）的位置处添加文本标签；%.1f’%b是对y值进行的格式化处理，保留小数点1位；ha=’center’、va=’bottom’代表水平对齐、垂直对齐的方式，fontsize则是字体大小。</p>
<h3 id="5-5-5-设置标题和图例"><a href="#5-5-5-设置标题和图例" class="headerlink" title="5.5.5　设置标题和图例"></a>5.5.5　设置标题和图例</h3><p>数据是一个图表所要展示的内容，而有了标题和图例则可以帮助我们更好地理解这个图表的含义和想要传递的信息。下面介绍图表细节之三——标题和图例。</p>
<h4 id="1．图表标题"><a href="#1．图表标题" class="headerlink" title="1．图表标题"></a>1．图表标题</h4><p>为图表设置标题主要使用title()函数，语法如下：</p>
<p>matplotlib.pyplot.title(label, fontdict=None, loc=’center’, pad=None, **kwargs)<br>参数说明：　</p>
<p>label：字符串，表示图表标题文本。　</p>
<p>fontdict：字典，用来设置标题字体的样式。如{‘fontsize’: 20,’fontweight’:20,’va’: ‘bottom’,’ha’:’center’}。　</p>
<p>loc：字符串，表示标题水平位置，参数值为center、left或right，分别表示水平居中、水平居左和水平居右，默认为水平居中。　</p>
<p>pad：浮点型，表示标题离图表顶部的距离，默认值为None。</p>
<p>**kwargs：关键字参数，可以设置一些其他文本属性。<br>例如，设置图表标题为“14天基础体温曲线图”，主要代码如下：</p>
<p>plt.title(‘14天基础体温曲线图’,fontsize=’18’)</p>
<h4 id="2．图表图例"><a href="#2．图表图例" class="headerlink" title="2．图表图例"></a>2．图表图例</h4><p>为图表设置图例主要使用legend()函数。下面介绍图例相关的设置。<br>（1）自动显示图例</p>
<p>plt.legend()<br>（2）手动添加图例</p>
<p>plt.legend(‘基础体温’)注意<br>当手动添加图例时，有时会出现文本显示不全，解决方法是在文本后面加一个逗号（,），主要代码如下：</p>
<p>plt.legend((‘基础体温’,))<br>（3）设置图例显示位置<br>通过loc参数可以设置图例的显示位置，如在左下方显示，主要代码如下：</p>
<p>plt.legend((‘基础体温’,),loc=’upper right’,fontsize=10)<br>具体图例显示位置的设置如表5.3所示。</p>
<p>​                                                                                          表5.3　图例位置参数设置值</p>
<p><img src="/.com//image-20211022042646532.png" alt="image-20211022042646532"></p>
<p>上述参数可以设置大概的图例位置，如果这样可以满足需求，那么第二个参数不设置也可以。第二个参数bbox_to_anchor是元组类型，包括两个值：num1用于控制legend的左右移动，值越大越向右边移动；num2用于控制legend的上下移动，值越大，越向上移动。这两个值用于微调图例的位置。<br>另外，通过该参数还可以设置图例位于图表外面，主要代码如下：</p>
<p>plt.legend(bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0)<br>下面来看下设置标题和图例后的“14天基础体温曲线图”，效果如图5.32所示。</p>
<p><img src="/.com//image-20211022042736618.png" alt="image-20211022042736618"></p>
<p>​                                                                                   图5.32　14天基础体温曲线图</p>
<h3 id="5-5-6-添加注释"><a href="#5-5-6-添加注释" class="headerlink" title="5.5.6　添加注释"></a>5.5.6　添加注释</h3><p>annotate()函数用于在图表上给数据添加文本注释，而且支持带箭头的画线工具，方便我们在合适的位置添加描述信息。</p>
<p>【示例11】　为图表添加注释。（示例位置：资源包\MR\Code\05\11）<br>在“14天基础体温折线图”中用箭头指示最高体温，效果如图5.33所示。</p>
<p><img src="/.com//image-20211022042805728.png" alt="image-20211022042805728"></p>
<p>​                                                                                       图5.33　箭头指示最高体温<br>主要代码如下：</p>
<p>01 plt.annotate(‘最高体温’, xy=(9,37.1), xytext=(10.5,37.1),</p>
<p>02               xycoords=’data’,<br>03               arrowprops=dict(facecolor=’r’, shrink=0.05))<br>下面介绍一下本示例中用到的几个主要参数。　</p>
<p>xy：被注释的坐标点，二维元组，如(x,y)。　</p>
<p>xytext：注释文本的坐标点（也就是本示例中箭头的位置），也是二维元组，默认与xy相同。　</p>
<p>xycoords：是被注释点的坐标系属性，设置值如表5.4所示。</p>
<p>​                                                                                    表5.4　xycoords参数设置值　</p>
<p><img src="/.com//image-20211022042954410.png" alt="image-20211022042954410"></p>
<p>arrowprops：箭头的样式，dict（字典）型数据。如果该属性非空，则会在注释文本和被注释点之间画一个箭头。arrowprops参数设置值如表5.5所示。</p>
<p>​                                                                               表5.5　arrowprops参数设置值说明</p>
<p><img src="/.com//image-20211022043118148.png" alt="image-20211022043118148"></p>
<p>关于annotate()函数的内容还有很多，这里不再赘述，感兴趣的读者可以以上述举例为基础，尝试更多的属性和样式。</p>
<h3 id="5-5-7-调整图表与画布边缘间距"><a href="#5-5-7-调整图表与画布边缘间距" class="headerlink" title="5.5.7　调整图表与画布边缘间距"></a>5.5.7　调整图表与画布边缘间距</h3><p>很多时候发现绘制出的图表出现显示不全的情况，其原因在于，x轴、y轴标题与画布边缘距离太近，如图5.34所示。<br>这种情况可以使用subplots_adjust()函数来调整，该函数主要用于调整图表与画布的间距，也可以调整子图表的间距。语法如下：</p>
<p>subplots_adjust(left=None, bottom=None,right=None, top=None,wspace=None,hspace=None)<br>参数说明：　left、bottom、right和top：这4个参数是用来调整上、下、左、右的空白，如图5.35所示。注意这里是从画布的左下角开始标记，取值为0～1。left和bottom值越小，则空白越少；而right和top值越大，则空白越少。</p>
<p><img src="/.com//image-20211022043238508.png" alt="image-20211022043238508"></p>
<p>​                                                                                          图5.34　显示不全的情况</p>
<p><img src="/.com//image-20211022043308669.png" alt="image-20211022043308669"></p>
<p>​                                                                                      图5.35　调整间距示意图　</p>
<p>wspace和hspace：用于调整列间距和行间距。<br>举个简单的例子，调整图表上、下、左、右的空白，主要代码如下：</p>
<p>plt.subplots_adjust(left=0.2, right=0.9, top=0.9, bottom=0.2)<br>如果只显示图片，坐标轴及标题都不显示，可以使用如下代码：</p>
<p>plt.subplots_adjust(left=0, bottom=0, right=1, top=1,hspace=0.1,wspace=0.1)</p>
<h3 id="5-5-8-其他设置"><a href="#5-5-8-其他设置" class="headerlink" title="5.5.8　其他设置"></a>5.5.8　其他设置</h3><h4 id="1．坐标轴的刻度线"><a href="#1．坐标轴的刻度线" class="headerlink" title="1．坐标轴的刻度线"></a>1．坐标轴的刻度线</h4><p>（1）设置4个方向的坐标轴上的刻度线是否显示，主要代码如下：</p>
<p>plt.tick_params(bottom=False,left=True,right=True,top=True)<br>（2）设置x轴和y轴的刻度线显示方向，其中in表示向内，out表示向外，inout表示在中间，默认刻度线向外，主要代码如下：</p>
<p>plt.rcParams[‘xtick.direction’] = ‘in’         #x轴的刻度线向内显示<br>plt.rcParams[‘ytick.direction’] = ‘in’         #y轴的刻度线向内显示</p>
<h4 id="2．坐标轴相关属性设置"><a href="#2．坐标轴相关属性设置" class="headerlink" title="2．坐标轴相关属性设置"></a>2．坐标轴相关属性设置</h4><p>axis()：返回当前axes范围。　</p>
<p>axis(v)：通过输入v = [xmin, xmax, ymin, ymax]，设置x、y轴的取值范围。　</p>
<p>axis(‘off’)：关闭坐标轴轴线及坐标轴标签。　</p>
<p>axis(‘equal’)：使x、y轴长度一致。　</p>
<p>axis(‘scaled’)：调整图框的尺寸（而不是改变坐标轴取值范围），使x、y轴长度一致。　</p>
<p>axis(‘tight’)：改变x轴和y轴的限制，使所有数据被展示。如果所有的数据已经显示，它将移动到图形的中心而不修改（xmax～xmin）或（ymax～ymin）。　</p>
<p>axis(‘image’)：缩放axis范围（limits），等同于对data缩放范围。　</p>
<p>axis(‘auto’)：自动缩放。　</p>
<p>axis(‘normal’)：不推荐使用。恢复默认状态，轴限的自动缩放以使数据显示在图表中。</p>
<h2 id="5-6-常用图表的绘制"><a href="#5-6-常用图表的绘制" class="headerlink" title="5.6　常用图表的绘制"></a>5.6　常用图表的绘制</h2><p>本节介绍常用图表的绘制，主要包括绘制折线图、绘制柱形图、绘制直方图、绘制饼形图、绘制散点图、绘制面积图、绘制热力图、绘制箱形图、绘3D图表、绘制多个子图表以及图表的保存。对于常用的图表类型以绘制多种类型图表进行举例，以适应不同应用场景的需求。</p>
<h3 id="5-6-1-绘制折线图"><a href="#5-6-1-绘制折线图" class="headerlink" title="5.6.1　绘制折线图"></a>5.6.1　绘制折线图</h3><p>折线图可以显示随时间而变化的连续数据，因此非常适用于显示在相等时间间隔下数据的趋势。如基础体温曲线图、学生成绩走势图、股票月成交量走势图，月销售统计分析图、微博、公众号、网站访问量统计图等都可以用折线图体现。在折线图中，类别数据沿水平轴均匀分布，所有值数据沿垂直轴均匀分布。<br>Matplotlib绘制折线图主要使用plot()函数，相信通过前面的学习，您已经了解了plot()函数的基本用法，并能够绘制一些简单的折线图，下面尝试绘制多折线图。</p>
<p>【示例12】　绘制学生语数外各科成绩分析图。（示例位置：资源包\MR\Code\05\12）<br>使用plot()函数绘制多折线图。例如，绘制学生语数外各科成绩分析图，程序代码如下：</p>
<p><img src="/.com//image-20211022043506478.png" alt="image-20211022043506478"></p>
<p>运行程序，输出结果如图5.36所示。</p>
<p><img src="/.com//image-20211022043526985.png" alt="image-20211022043526985"></p>
<p>​                                                                                               图5.36　多折线图<br>上述举例，用到了几个参数，下面进行说明。</p>
<p>mfc：标记的颜色。　</p>
<p>ms：标记的大小。　</p>
<p>mec：标记边框的颜色。　</p>
<p>alpha：透明度，设置该参数可以改变颜色的深浅。</p>
<h3 id="5-6-2-绘制柱形图"><a href="#5-6-2-绘制柱形图" class="headerlink" title="5.6.2　绘制柱形图"></a>5.6.2　绘制柱形图</h3><p>柱形图，又称长条图、柱状图、条状图等，是一种以长方形的长度为变量的统计图表。柱形图用来比较两个或两个以上的数据（不同时间或者不同条件），只有一个变量，通常用于较小的数据集分析。<br>Matplotlib绘制柱形图主要使用bar()函数，语法如下：</p>
<p>matplotlib.pyplot.bar(x,height,width,bottom=None,*,align=’center’,data=None,**kwargs)<br>参数说明：　**</p>
<p>x：x轴数据。　</p>
<p>height：柱子的高度，也就是y轴数据。　</p>
<p>width：浮点型，柱子的宽度，默认值为0.8，可以指定固定值。　</p>
<p>bottom：标量或数组，可选参数，柱形图的y坐标，默认值为None。　</p>
<p>*：星号本身不是参数。星号表示其后面的参数为命名关键字参数，命名关键字参数必须传入参数名；否则程序会出现错误。　</p>
<p>align：对齐方式，如center（居中）和edge（边缘），默认值为center。　</p>
<p>data：data关键字参数。如果给定一个数据参数，所有位置和关键字参数将被替换。　</p>
<p>kwargs：关键字参数，其他可选参数，如color（颜色）、alpha（透明度）、label（每个柱子显示的标签）等。</p>
<p>【示例13】　4行代码绘制简单的柱形图。（示例位置：资源包\MR\Code\05\13）<br>4行代码绘制简单的柱形图，程序代码如下：</p>
<p>01 import matplotlib.pyplot as plt<br>02 x=[1,2,3,4,5,6]</p>
<p>03 height=[10,20,30,40,50,60]<br>04 plt.bar(x,height)<br>运行程序，输出结果如图5.37所示。</p>
<p><img src="/.com//image-20211022043752815.png" alt="image-20211022043752815"></p>
<p>​                                                                                     图5.37　简单柱形图<br>bar()函数可以绘制出各种类型的柱形图，如基本柱形图、多柱形图、堆叠柱形图，只要将bar()函数的主要参数理解透彻，就会达到意想不到的效果。下面介绍几种常见的柱形图。</p>
<h4 id="1．基本柱形图"><a href="#1．基本柱形图" class="headerlink" title="1．基本柱形图"></a>1．基本柱形图</h4><p>【示例14】　绘制2013—2019年线上图书销售额分析图。（示例位置：资源包\MR\Code\05\14）<br>使用bar()函数绘制“2013—2019年线上图书销售额分析图”，程序代码如下：</p>
<p><img src="/.com//image-20211022043825693.png" alt="image-20211022043825693"></p>
<p>运行程序，输出结果如图5.38所示。</p>
<p><img src="/.com//image-20211022043843723.png" alt="image-20211022043843723"></p>
<p>​                                                                                                 图5.38　基本柱形图</p>
<p>本示例应用了前面所学习的知识，例如标题、图例、文本标签和坐标轴标签等。</p>
<h4 id="2．多柱形图"><a href="#2．多柱形图" class="headerlink" title="2．多柱形图"></a>2．多柱形图</h4><p>【示例15】　绘制各平台图书销售额分析图。（示例位置：资源包\MR\Code\05\15）<br>对于线上图书销售额的统计，如果要统计各个平台的销售额，可以使用多柱形图，不同颜色的柱子代表不同的平台，如京东、天猫、自营等，程序代码如下：</p>
<p><img src="/.com//image-20211022043936078.png" alt="image-20211022043936078"></p>
<p>在本示例中，柱形图中若显示n个柱子，则柱子宽度值需小于1/n；否则柱子会出现重叠现象。<br>运行程序，输出结果如图5.39所示。</p>
<p><img src="/.com//image-20211022044011167.png" alt="image-20211022044011167"></p>
<p>​                                                                                                  图5.39　多柱形图</p>
<h3 id="5-6-3-绘制直方图"><a href="#5-6-3-绘制直方图" class="headerlink" title="5.6.3　绘制直方图"></a>5.6.3　绘制直方图</h3><p>直方图，又称质量分布图，由一系列高度不等的纵向条纹或线段表示数据分布的情况。一般用横轴表示数据类型，纵轴表示分布情况。直方图是数值数据分布的精确图形表示，是一个连续变量（定量变量）的概率分布的估计。<br>绘制直方图主要使用hist()函数，语法如下：</p>
<p>matplotlib.pyplot.hist(x,bins=None,range=None, density=None, bottom=None, histtype=’bar’, align=’mid’, log=<br>False, color=None, label=None, stacked=False, normed=None)<br>参数说明：　</p>
<p>x：数据集，最终的直方图将对数据集进行统计。　</p>
<p>bins：统计数据的区间分布。　</p>
<p>range：元组类型，显示的区间。　</p>
<p>density：布尔型，显示频率统计结果，默认值为None。设置值为False，不显示频率统计结果；设置值为True，则显示频率统计结果。需要注意，频率统计结果=区间数目/(总数×区间宽度)。　</p>
<p>histtype：可选参数，设置值为bar、barstacked、step或stepfilled，默认值为bar，推荐使用默认配置，其中step使用的是梯状，stepfilled则会对梯状内部进行填充，效果与bar类似。　</p>
<p>align：可选参数，控制柱状图的水平分布，设置值为left、mid或right，默认值为mid，其中，left或者right会有部分空白区域，推荐使用默认值。　</p>
<p>log：布尔型，默认值为False，即y坐标轴是否选择指数刻度。</p>
<p>stacked：布尔型，默认值为False，是否为堆积柱状图。</p>
<p>【示例16】　绘制简单直方图。（示例位置：资源包\MR\Code\05\16）<br>绘制简单直方图，程序代码如下：</p>
<p>01 import matplotlib.pyplot as plt<br>02 x=[22,87,5,43,56,73,55,54,11,20,51,5,79,31,27]<br>03 plt.hist(x, bins = [0,25,50,75,100])<br>运行程序，输出结果如图5.40所示。</p>
<p><img src="/.com//image-20211022044122751.png" alt="image-20211022044122751"></p>
<p>​                                                                                          图5.40　简单直方图</p>
<p>【示例17】　直方图分析学生数学成绩分布情况。（示例位置：资源包\MR\Code\05\17）<br>再举一个例子，通过直方图分析学生数学成绩分布情况，程序代码如下：</p>
<p><img src="/.com//image-20211022044146025.png" alt="image-20211022044146025"></p>
<p>运行程序，输出结果如图5.41所示。</p>
<p><img src="/.com//image-20211022044204373.png" alt="image-20211022044204373"></p>
<pre><code>                                                                            图5.41　数学成绩分布直方图
</code></pre>
<p>上述举例，通过直方图可以清晰地看到高一数学成绩分布情况。基本呈现正态分布，两边低中间高，高分段学生缺失，说明试卷有难度。那么，通过直方图还可以分析以下内容。<br>（1）对学生进行比较。呈正态分布的测验便于选拔优秀，甄别落后，通过直方图一目了然。<br>（2）确定人数和分数线。测验成绩符合正态分布可以帮助等级评定时确定人数和估计分数段内的人数，确定录取分数线、各学科的优生率等。<br>（3）测验试题难度。</p>
<h3 id="5-6-4-绘制饼形图"><a href="#5-6-4-绘制饼形图" class="headerlink" title="5.6.4　绘制饼形图"></a>5.6.4　绘制饼形图</h3><p>饼形图常用来显示各个部分在整体中所占的比例。例如，在工作中如果遇到需要计算总费用或金额的各个部分构成比例的情况，一般通过各个部分与总额相除来计算，而且这种比例表示方法很抽象，而通过饼形图将直接显示各个组成部分所占比例，一目了然。<br>Matplotlib绘制饼形图主要使用pie()函数，语法如下：</p>
<p>matplotlib.pyplot.pie(x,explode=None,labels=None,colors=None,autopct=None,pctdistance=0.6,shadow=False,<br>labeldistance=1.1,startangle=None,radius=None,counterclock=True,wedgeprops=None,textprops=None,center=<br>(0, 0), frame=False, rotatelabels=False, hold=None, data=None)<br>参数说明：　</p>
<p>x：每一块饼图的比例，如果sum(x)&gt;1会使用sum(x)归一化。　</p>
<p>explode：每一块饼图离中心的距离。　</p>
<p>labels：每一块饼图外侧显示的说明文字。　</p>
<p>autopct：设置饼图百分比，可以使用格式化字符串或format()函数。如’%1.1f ‘保留小数点前后1位。　</p>
<p>pctdistance：类似于labeldistance参数，指定百分比的位置刻度，默认值为0.6。　</p>
<p>shadow：在饼图下面画一个阴影，默认值为False，即不画阴影。　</p>
<p>labeldistance：标记的绘制位置，相对于半径的比例，默认值为1.1，如&lt;1则绘制在饼图内侧。　</p>
<p>startangle：起始绘制角度，默认是从x轴正方向逆时针画起，如设置值为90则从y轴正方向画起。　</p>
<p>radius：饼图半径，默认值为1。　</p>
<p>counterclock：指定指针方向，布尔型，可选参数。默认值为True，表示逆时针；如果值为False，则表示顺时针。　</p>
<p>wedgeprops：字典类型，可选参数，默认值为None。字典传递给wedge对象，用来画一个饼图。例如wedgeprops={‘linewidth’:2}设置wedge线宽为2。　</p>
<p>textprops：设置标签和比例文字的格式，字典类型，可选参数，默认值为None。传递给text对象的字典参数。　</p>
<p>center：浮点类型的列表，可选参数，默认值为(0,0)，表示图表中心位置。　</p>
<p>frame：布尔型，可选参数，默认值为False，不显示轴框架（也就是网格）；如果值为True，则显示轴框架，与grid()函数配合使用。实际应用中建议使用默认设置，因为显示轴框架会干扰饼形图效果。　</p>
<p>rotatelabels：布尔型，可选参数，默认值为False；如果值为True，则旋转每个标签到指定的角度。</p>
<p>【示例18】　绘制简单饼形图。（示例位置：资源包\MR\Code\05\18）<br>绘制简单饼形图，程序代码如下：</p>
<p>01 import matplotlib.pyplot as plt<br>02 x = [2,5,12,70,2,9]<br>03 plt.pie(x,autopct=’%1.1f%%’)<br>运行程序，输出结果如图5.42所示。<br>饼形图也存在各种类型，主要包括基础饼形图、分裂饼形图、立体感带阴影的饼形图、环形图等。下面分别进行介绍。</p>
<h4 id="1．基础饼形图"><a href="#1．基础饼形图" class="headerlink" title="1．基础饼形图"></a>1．基础饼形图</h4><p>【示例19】　通过饼形图分析各地区销量占比情况。（示例位置：资源包\MR\Code\05\19）<br>下面通过饼形图分析2020年1月各地区销量占比情况，程序代码如下：</p>
<p><img src="/.com//image-20211022044422975.png" alt="image-20211022044422975"></p>
<p>运行程序，输出结果如图5.43所示。</p>
<p><img src="/.com//image-20211022044438588.png" alt="image-20211022044438588"></p>
<p>​                                                                                              图5.42　简单饼形图</p>
<p><img src="/.com//image-20211022044506316.png" alt="image-20211022044506316"></p>
<p>​                                                                                                图5.43　基础饼形图</p>
<h4 id="2．分裂饼形图"><a href="#2．分裂饼形图" class="headerlink" title="2．分裂饼形图"></a>2．分裂饼形图</h4><p>分裂饼形图是将您认为主要的饼图部分分裂出来，以达到突出显示的目的。</p>
<p>【示例20】　绘制分裂饼形图。（示例位置：资源包\MR\Code\05\20）<br>将销量占比最多的广东省分裂显示，效果如图5.44（a）所示。分裂饼形图可以同时分裂多块，效果如图5.44（b）所示。</p>
<p><img src="/.com//image-20211022044615077.png" alt="image-20211022044615077"></p>
<p>​                                                                                               图5.44　分裂饼形图<br>分裂饼形图主要通过设置explode参数实现，该参数用于设置饼图距中心的距离，我们需要将哪块饼图分裂出来，就设置它与中心的距离即可。例如，图5.43中有10块饼图，我们将占比最多的“广东省”分裂出来，如图5.44（a）所示。广东省在第一位，那么就设置第一位距中心的距离为0.1，其他为0，关键代码如下：</p>
<p>explode = (0.1,0,0,0,0,0,0,0,0,0)</p>
<h4 id="3．立体感带阴影的饼形图"><a href="#3．立体感带阴影的饼形图" class="headerlink" title="3．立体感带阴影的饼形图"></a>3．立体感带阴影的饼形图</h4><p>立体感带阴影的饼形图看起来更美观，效果如图5.45所示。<br>立体感带阴影的饼形图主要通过shadow参数实现，设置该参数值为True即可，主要代码如下：</p>
<p>shadow=True</p>
<h4 id="4．环形图"><a href="#4．环形图" class="headerlink" title="4．环形图"></a>4．环形图</h4><p>【示例21】　环形图分析各地区销量占比情况。（示例位置：资源包\MR\Code\05\21）<br>环形图是由两个及两个以上大小不一的饼图叠在一起，挖去中间的部分所构成的图形，效果如图5.46所示。</p>
<p><img src="/.com//image-20211022044639552.png" alt="image-20211022044639552"></p>
<p>​                                                                                图5.45　立体感带阴影的饼形图</p>
<p><img src="/.com//image-20211022044721819.png" alt="image-20211022044721819"></p>
<p>​                                                                                                              图5.46　环形图<br>这里还是通过pie()函数实现，一个关键参数wedgeprops，字典类型，用于设置饼形图内、外边界的属性，如环的宽度，环边界颜色和宽度，主要代码如下：</p>
<p>wedgeprops = {‘width’: 0.4, ‘edgecolor’: ‘k’}</p>
<h4 id="5．内嵌环形图"><a href="#5．内嵌环形图" class="headerlink" title="5．内嵌环形图"></a>5．内嵌环形图</h4><p>【示例22】　内嵌环形图分析各地区销量占比情况。（示例位置：资源包\MR\Code\05\22）<br>内嵌环形图实际是双环形图，效果如图5.47所示。</p>
<p><img src="/.com//image-20211022044800617.png" alt="image-20211022044800617"></p>
<p>​                                                                                             图5.47　内嵌环形图<br>绘制内嵌环形图需要注意以下3点。<br>（1）连续使用两次pie()函数。<br>（2）通过wedgeprops参数设置环形边界。<br>（3）通过radius参数设置不同的半径。<br>另外，由于图例内容比较长，为了使图例能够正常显示，图例代码中引入了两个主要参数，即frameon和bbox_to_anchor。其中，frameon参数设置图例有无边框；bbox_to_anchor参数设置图例位置，主要代码如下：</p>
<p><img src="/.com//image-20211022044933255.png" alt="image-20211022044933255"></p>
<h3 id="5-6-5-绘制散点图"><a href="#5-6-5-绘制散点图" class="headerlink" title="5.6.5　绘制散点图"></a>5.6.5　绘制散点图</h3><p>散点图主要用来查看数据的分布情况或相关性，一般用在线性回归分析中，查看数据点在坐标系平面上的分布情况。散点图表示因变量随自变量而变化的大致趋势，据此可以选择合适的函数对数据点进行拟合。<br>散点图与折线图类似，也是一个个点构成的。但不同之处在于，散点图的各点之间不会按照前后关系以线条连接起来。<br>Matplotlib绘制散点图使用plot()函数和scatter()函数都可以实现，本节使用scatter()函数绘制散点图，scatter()函数专门用于绘制散点图，使用方式和plot()函数类似，区别在于前者具有更高的灵活性，可以单独控制每个散点与数据匹配，并让每个散点具有不同的属性。scatter()函数的语法如下：</p>
<p>matplotlib.pyplot.scatter(x,y,s=None,c=None,marker=None,cmap=None,norm=None,vmin=None,vmax=None,<br>alpha=None,linewidths=None,verts=None,edgecolors=None,data=None, **kwargs)<br>参数说明：　</p>
<p>x，y：数据。　</p>
<p>​        s：标记大小，以平方磅为单位的标记面积，设置值如下。　</p>
<p>​        数值标量：以相同的大小绘制所有标记。　</p>
<p>​        行或列向量：使每个标记具有不同的大小。x、y和sz中的相应元素确定每个标记的位置和面积。sz的长度必须等于x和y的长度。　</p>
<p>​        []：使用36平方磅的默认面积。　</p>
<p>c：标记颜色，可选参数，默认标记颜色为蓝色。　</p>
<p>marker：标记样式，可选参数，默认值为’o’。　</p>
<p>cmap：颜色地图，可选参数，默认值为None。　</p>
<p>norm：可选参数，默认值为None</p>
<p>vmin，vmax：标量，可选，默认值为None　alpha：透明度，可选参数，0～1的数，表示透明度，默认值为None。　</p>
<p>linewidths：线宽，标记边缘的宽度，可选参数，默认值为None。　</p>
<p>verts：(x,y)的序列，可选参数，如果参数marker为None，这些顶点将用于构建标记。标记的中心位置为(0,0)。　</p>
<p>edgecolors：轮廓颜色，与参数c类似，可选参数，默认值为None。　</p>
<p>data：data关键字参数。如果给定一个数据参数，所有位置和关键字参数将被替换。　</p>
<p>**kwargs：关键字参数，其他可选参数。</p>
<p>【示例23】　绘制简单散点图。（示例位置：资源包\MR\Code\05\23）<br>绘制简单散点图，程序代码如下：</p>
<p>01 import matplotlib.pyplot as plt<br>02 x=[1,2,3,4,5,6]<br>03 y=[19,24,37,43,55,68]<br>04 plt.scatter(x, y)<br>运行程序，输出结果如图5.48所示。</p>
<p>【示例24】　散点图分析销售收入与广告费的相关性。（示例位置：资源包\MR\Code\05\24）<br>接下来，绘制销售收入与广告费散点图，用以观察销售收入与广告费的相关性，主要代码如下：</p>
<p><img src="/.com//image-20211022045035911.png" alt="image-20211022045035911"></p>
<p>运行程序，输出结果如图5.49所示</p>
<p><img src="/.com//image-20211022045051433.png" alt="image-20211022045051433"></p>
<p>​                                                                                          图5.48　简单散点图</p>
<p><img src="/.com//image-20211022045135206.png" alt="image-20211022045135206"></p>
<p>​                                                                              图5.49　销售收入与广告费散点图</p>
<h3 id="5-6-6-绘制面积图"><a href="#5-6-6-绘制面积图" class="headerlink" title="5.6.6　绘制面积图"></a>5.6.6　绘制面积图</h3><p>面积图用于体现数量随时间而变化的程度，也可用于引起人们对总值趋势的注意。例如，表示随时间而变化的利润的数据可以绘制在面积图中，以强调总利润。<br>Matplotlib绘制面积图主要使用stackplot()函数，语法如下：</p>
<p>matplotlib.pyplot.stackplot(x,*args,data=None,**kwargs)<br>参数说明：　**</p>
<p>x：x轴数据。　</p>
<p><em>args：当传入的参数个数未知时使用</em>args。这里指y轴数据可以传入多个y轴。　</p>
<p>data：data关键字参数。如果给定一个数据参数，所有位置和关键字参数将被替换。　</p>
<p>kwargs：关键字参数，其他可选参数，如color（颜色）、alpha（透明度）等。</p>
<p>【示例25】　绘制简单面积图。（示例位置：资源包\MR\Code\05\25）<br>绘制简单面积图，程序代码如下：</p>
<p><img src="/.com//image-20211022045229225.png" alt="image-20211022045229225"></p>
<p>运行程序，输出结果如图5.50所示。<br>面积图也有很多种，如标准面积图、堆叠面积图和百分比堆叠面积图等。下面主要介绍标准面积图和堆叠面积图。</p>
<h4 id="1．标准面积图"><a href="#1．标准面积图" class="headerlink" title="1．标准面积图"></a>1．标准面积图</h4><p>【示例26】　面积图分析线上图书销售情况。（示例位置：资源包\MR\Code\05\26）<br>通过标准面积图分析2013—2019年线上图书销售情况，通过该图可以看出每一年线上图书销售的一个趋势，效果如图5.51所示。</p>
<p><img src="/.com//image-20211022045332684.png" alt="image-20211022045332684"></p>
<p>​                                                                                          图5.50　简单面积图</p>
<p><img src="/.com//image-20211022045356189.png" alt="image-20211022045356189"></p>
<p>​                                                                                           图5.51　标准面积图<br>程序代码如下：</p>
<p><img src="/.com//image-20211022045417324.png" alt="image-20211022045417324"></p>
<h4 id="2．堆叠面积图"><a href="#2．堆叠面积图" class="headerlink" title="2．堆叠面积图"></a>2．堆叠面积图</h4><p>【示例27】　堆叠面积图分析各平台图书销售情况。（示例位置：资源包\MR\Code\05\27）<br>通过堆叠面积图分析2013—2019年线上各平台图书销售情况。堆叠面积图不仅可以看到各平台每年销售变化趋势，通过将各平台数据堆叠到一起还可以看到整体的变化趋势，效果如图5.52所示。<br>实现堆叠面积图的关键在于增加y轴，通过增加多个y轴数据，形成堆叠面积图，主要代码如下：</p>
<p><img src="/.com//image-20211022045506121.png" alt="image-20211022045506121"></p>
<p><img src="/.com//image-20211022045521071.png" alt="image-20211022045521071"></p>
<p>​                                                                                                  图5.52　堆叠面积图</p>
<h3 id="5-6-7-绘制热力图"><a href="#5-6-7-绘制热力图" class="headerlink" title="5.6.7　绘制热力图"></a>5.6.7　绘制热力图</h3><p>热力图是通过密度函数进行可视化用于表示地图中点的密度的热图。它使人们能够独立于缩放因子感知点的密度。热力图可以显示不可点击区域发生的事情。利用热力图可以看数据表里多个特征两两的相似度。例如，以特殊高亮的形式显示访客热衷的页面区域和访客所在的地理区域的图示。热力图在网页分析、业务数据分析等其他领域也有较为广泛的应用。</p>
<p>【示例28】　绘制简单热力图。（示例位置：资源包\MR\Code\05\28）<br>热力图是数据分析的常用方法，通过色差、亮度来展示数据的差异，易于理解。下面绘制简单热力图，程序代码如下：</p>
<p>01 import matplotlib.pyplot as plt<br>02 X = [[1,2],[3,4],[5,6],[7,8],[9,10]]<br>03 plt.imshow(X)<br>运行程序，输出结果如图5.53所示。</p>
<p><img src="/.com//image-20211022045548445.png" alt="image-20211022045548445"></p>
<p>​                                                                                              图5.53　简单热力图</p>
<p>上述代码中，plt.imshow(X)中传入的数组X=[[1,2],[3,4],[5,6],[7,8],[9,10]]为颜色的对应值，按照矩阵X进行颜色分布，如左上角颜色为深蓝，其对应值为1，右下角颜色为黄色，其对应值为10，具体如下：</p>
<p>[1,2]  [深蓝,蓝色]<br>[3,4]  [蓝绿,深绿]<br>[5,6]  [海藻绿,春绿色]<br>[7,8]  [绿色,浅绿色]<br>[9,10] [草绿色,黄色]</p>
<p>【示例29】　热力图对比分析学生各科成绩。（示例位置：资源包\MR\Code\05\29）<br>根据学生成绩统计数据绘制热力图，通过热力图可清晰直观地对比每名学生各科成绩的高低。程序代码如下：</p>
<p><img src="/.com//image-20211022045644366.png" alt="image-20211022045644366"></p>
<p>运行程序，输出结果如图5.54所示。</p>
<p><img src="/.com//image-20211022045702905.png" alt="image-20211022045702905"></p>
<p>​                                                                                        图5.54　学生成绩统计热力图<br>从图5.54中可以看到，颜色以高亮显示的，成绩越高；反之，成绩越低。</p>
<h3 id="5-6-8-绘制箱形图"><a href="#5-6-8-绘制箱形图" class="headerlink" title="5.6.8　绘制箱形图"></a>5.6.8　绘制箱形图</h3><p>箱形图又称箱线图、盒须图或盒式图，它是一种用作显示一组数据分散情况下的资料的统计图。因形状像箱子而得名。箱形图最大的优点就是不受异常值的影响（异常值也称为离群值），可以以一种相对稳定的方式描述数据的离散分布情况，因此在各种领域也经常被使用。另外，箱形图也常用于异常值的识别。Matplotlib绘制箱形图主要使用boxplot()函数，语法如下：</p>
<p>matplotlib.pyplot.boxplot(x,notch=None,sym=None,vert=None,whis=None,positions=None,widths=None,patch_<br>artist=None,meanline=None,showmeans=None,showcaps=None,showbox=None,showfliers=None,boxprops=None,<br>labels=None,flierprops=None,medianprops=None,meanprops=None,capprops=None,whiskerprops=None)<br>参数说明：　</p>
<p>x：指定要绘制箱形图的数据。　</p>
<p>notch：是否以凹口的形式展现箱形图，默认非凹口。　</p>
<p>sym：指定异常点的形状，默认为加号（+）显示。　</p>
<p>vert：是否需要将箱形图垂直摆放，默认垂直摆放。　</p>
<p>whis：指定上下限与上下四分位的距离，默认为1.5倍的四分位差。　</p>
<p>positions：指定箱形图的位置，默认为[0,1,2,…]。　</p>
<p>widths：指定箱形图的宽度，默认为0.5。　</p>
<p>patch_artist：是否填充箱体的颜色。　</p>
<p>meanline：是否用线的形式表示均值，默认用点来表示。　</p>
<p>showmeans：是否显示均值，默认不显示。　</p>
<p>showcaps：是否显示箱形图顶端和末端的两条线，默认显示。　</p>
<p>showbox：是否显示箱形图的箱体，默认显示。　</p>
<p>showfliers：是否显示异常值，默认显示。　</p>
<p>boxprops：设置箱体的属性，如边框色、填充色等。　</p>
<p>labels：为箱形图添加标签，类似于图例的作用。　</p>
<p>filerprops：设置异常值的属性，如异常点的形状、大小、填充色等。　</p>
<p>medianprops：设置中位数的属性，如线的类型、粗细等。　meanprops：设置均值的属性，如点的大小、颜色等。</p>
<p>capprops：设置箱形图顶端和末端线条的属性，如颜色、粗细等。　</p>
<p>whiskerprops：设置须的属性，如颜色、粗细、线的类型等。</p>
<p>【示例30】　绘制简单箱形图。（示例位置：资源包\MR\Code\05\30）<br>绘制简单箱形图，程序代码如下：</p>
<p>01  import matplotlib.pyplot as plt<br>02  x=[1,2,3,5,7,9]<br>03  plt.boxplot(x)<br>运行程序，输出结果如图5.55所示。</p>
<p><img src="/.com//image-20211022045845005.png" alt="image-20211022045845005"></p>
<p>​                                                                                              图5.55　简单箱形图</p>
<p>【示例31】　绘制多组数据的箱形图。（示例位置：资源包\MR\Code\05\31）<br>上述举例是一组数据的箱形图，还可以绘制多组数据的箱形图，需要指定多组数据。例如，为三组数据绘制箱形图，程序代码如下：</p>
<p>01 import matplotlib.pyplot as plt<br>02 x1=[1,2,3,5,7,9]<br>03 x2=[10,22,13,15,8,19]<br>04 x3=[18,31,18,19,14,29]<br>05 plt.boxplot([x1,x2,x3])<br>运行程序，输出结果如图5.56所示。</p>
<p><img src="/.com//image-20211022045922170.png" alt="image-20211022045922170"></p>
<p>​                                                                                       图5.56　多组数据的箱形图<br>箱形图将数据切割分离（实际上就是将数据分为4大部分），如图5.57所示。</p>
<p><img src="/.com//image-20211022050015245.png" alt="image-20211022050015245"></p>
<p>​                                                                               图5.57　箱形图组成<br>下面介绍箱形图每部分具体含义以及如何通过箱形图识别异常值。　</p>
<p>下四分位<br>        图5.57中的下四分位数指的是数据的25%分位点所对应的值（Q1）。计算分位数可以使用Pandas的quantile()函数。例如，Q1 = df[‘总消费’].quantile(q = 0.25)。　</p>
<p>中位数<br>        中位数即为数据的50%分位点所对应的值（Q2）。　</p>
<p>上四分位数<br>        上四分位数则为数据的75%分位点所对应的值（Q3）。　</p>
<p>上限<br>        上限的计算公式为Q3+1.5(Q3-Q1)。　</p>
<p>下限<br>        下限的计算公式为Q1-1.5(Q3-Q1)。其中，Q3-Q1表示四分位差。如果使用箱形图识别异常值，其判断标准是，当变量的数据值大于箱形图的上限或者小于箱线图的下限时，就可以将这样的数据判定为异常值。<br>下面了解一下判断异常值的算法，如图5.58所示。</p>
<p><img src="/.com//image-20211022050132143.png" alt="image-20211022050132143"></p>
<p>​                                                                                      图5.58　异常值判断标准</p>
<p>【示例32】　通过箱形图判断异常值。（示例位置：资源包\MR\Code\05\32）<br>通过箱形图查找客人总消费数据中存在的异常值，程序代码如下：</p>
<p><img src="/.com//image-20211022050217773.png" alt="image-20211022050217773"></p>
<p>运行程序，输出结果如图5.59和图5.60所示。</p>
<p><img src="/.com//image-20211022050241397.png" alt="image-20211022050241397"></p>
<p>​                                                                                                      图5.59　箱形图</p>
<p><img src="/.com//image-20211022050303942.png" alt="image-20211022050303942"></p>
<p>​                                                                                          图5.60　异常值</p>
<h3 id="5-6-9-绘制3D图表"><a href="#5-6-9-绘制3D图表" class="headerlink" title="5.6.9　绘制3D图表"></a>5.6.9　绘制3D图表</h3><p>3D图表有立体感也比较美观，看起来更加“高大上”。下面介绍两种3D图表，即三维柱形图和三维曲面图。</p>
<p>绘制3D图表，我们仍使用Matplotlib，但需要安装mpl_toolkits工具包，使用pip安装命令，语法如下：</p>
<p>pip install –upgrade matplotlib<br>安装好这个模块后，即可调用mpl_tookits下的mplot3d类进行3D图表的绘制。</p>
<h4 id="1．3D柱形图"><a href="#1．3D柱形图" class="headerlink" title="1．3D柱形图"></a>1．3D柱形图</h4><p>【示例33】　绘制3D柱形图。（示例位置：资源包\MR\Code\05\33）<br>绘制3D柱形图，程序代码如下：</p>
<p><img src="/.com//image-20211022050416166.png" alt="image-20211022050416166"></p>
<p>运行程序，输出结果如图5.61所示。</p>
<h4 id="2．3D曲面图"><a href="#2．3D曲面图" class="headerlink" title="2．3D曲面图"></a>2．3D曲面图</h4><p>【示例34】　绘制3D曲面图。（示例位置：资源包\MR\Code\05\34）<br>绘制3D曲面图，程序代码如下：</p>
<p><img src="/.com//image-20211022050435386.png" alt="image-20211022050435386"></p>
<p>运行程序，输出结果如图5.62所示。</p>
<p><img src="/.com//image-20211022050517722.png" alt="image-20211022050517722"></p>
<p>​                                                                                                图5.61　3D柱形图</p>
<p><img src="/.com//image-20211022050540268.png" alt="image-20211022050540268"></p>
<p>​                                                                                                图5.62　3D曲面图</p>
<h3 id="5-6-10-绘制多个子图表"><a href="#5-6-10-绘制多个子图表" class="headerlink" title="5.6.10　绘制多个子图表"></a>5.6.10　绘制多个子图表</h3><p>Matplotlib可以实现在一张图上绘制多个子图表。Matplotlib提供了3种方法：一是subplot()函数；二是subplots()函数；三是add_subplot()函数，下面分别介绍。</p>
<h4 id="1．subplot-函数"><a href="#1．subplot-函数" class="headerlink" title="1．subplot()函数"></a>1．subplot()函数</h4><p>subplot()函数直接指定划分方式和位置，它可以将一个绘图区域划分为n个子图，每个subplot()函数只能绘制一个子图。语法如下：</p>
<p>matplotlib.pyplot.subplot(*args,**kwargs)<br>参数说明：　**</p>
<p><em>args：当传入的参数个数未知时使用</em>args。　</p>
<p>kwargs：关键字参数，其他可选参数。<br>例如，绘制一个2×3的区域，subplot(2,3,3)，将画布分成2行3列在第3个区域中绘制，用坐标表示如下：</p>
<p>(1,1),(1,2),(1,3)</p>
<p>(2,1),(2,2),(2,3)<br>如果行列的值都小于10，那么可以把它们缩写为一个整数，如subplot(233)。<br>另外，subplot()函数在指定的区域中创建一个轴对象，如果新创建的轴和之前所创建的轴重叠，那么，之前的轴将被删除。</p>
<p>【示例35】　使用subplot()函数绘制多个子图的空图表。（示例位置：资源包\MR\Code\05\35）<br>绘制一个2×3包含6个子图的空图表，程序代码如下：</p>
<p><img src="/.com//image-20211022050641579.png" alt="image-20211022050641579"></p>
<p>运行程序，输出结果如图5.63所示。</p>
<p><img src="/.com//image-20211022050704636.png" alt="image-20211022050704636"></p>
<p>​                                                                                        图5.63　6个子图的空图表</p>
<p>【示例36】　绘制包含多个子图的图表。（示例位置：资源包\MR\Code\05\36）<br>通过上述举例了解了subplot()函数的基本用法，接下来将前面所学的简单图表整合到一张图表上，结果如图5.64所示。</p>
<p><img src="/.com//image-20211022050726379.png" alt="image-20211022050726379"></p>
<p>​                                                                                                图5.64　多个子图<br>程序代码如下：</p>
<p><img src="/.com//image-20211022050819496.png" alt="image-20211022050819496"></p>
<p>上述举例，以下两个关键点一定要掌握。<br>（1）每绘制一个子图表都要调用一次subplot()函数。<br>（2）绘图区域位置编号。<br>subplot()函数的前面两个参数指定的是一个画布被分割成的行数和列数，后面一个参数则指的是当前绘制区域位置编号，编号规则是行优先。<br>例如，图5.64中有3个子图表，第1个子图表subplot(2,2,1)，即将画布分成2行2列，在第1个子图中绘制折线图；第2个子图表subplot(2,2,2)，将画布分成2行2列，在第2个子图中绘制散点图；第3个子图表subplot(2,1,2)，将画布分成2行1列，由于第1行已经占用了，所以在第2行也就是第3个子图中绘制柱形图。示意图如图5.65所示。</p>
<p><img src="/.com//image-20211022050957651.png" alt="image-20211022050957651"></p>
<p>​                                                                                               图5.65　多个子图示意图<br>subplot()函数在画布中绘图时，每次都要调用它指定绘图区域非常麻烦，而subplots()函数则更直接，它会事先把画布区域分割好。下面介绍subplots()函数。</p>
<h4 id="2．subplots-函数"><a href="#2．subplots-函数" class="headerlink" title="2．subplots()函数"></a>2．subplots()函数</h4><p>subplots()函数用于创建画布和子图，语法如下：</p>
<p>matplotlib.pyplot.subplots(nrows,ncols,sharex,sharey,squeeze,subplot_kw,gridspec_kw,**fig_kw)<br>参数说明：　</p>
<p>nrows和ncols：表示将画布分割成几行几列，例如，nrows=2、ncols=2表示将画布分割为2行2列，起始值均为0。当调用画布中的坐标轴时，ax[0,0]表示调用左上角的坐标，ax[1,1]表示调用右下角的坐标。　</p>
<p>sharex和sharey：布尔值或者值为“none”“all”“row”“col”，默认值为False。用于控制x或y轴之间的属性共享。具体参数值说明如下。　    </p>
<p>​        True或者“all”：表示x或y轴属性在所有子图中共享。　</p>
<p>​        False或者“none”：表示每个子图的x或y轴都是独立的部分。　</p>
<p>​        “row”：表示每个子图在一个x或y轴上共享行（row）。　</p>
<p>​        “col”：表示每个子图在一个x或y轴上共享列（column）　</p>
<p>squeeze：布尔值，默认值为True，额外的维度从返回的axes（轴）对象中挤出，对于n×1或1×n个子图，返回一个一维数组，对于n×m，n&gt;1和m&gt;1返回一个二维数组；如果值为False，则表示不进行挤压操作，返回一个元素为Axes实例的二维数组，即使它最终是1×1。　</p>
<p>subplot_kw：字典类型，可选参数。把字典的关键字传递给add_subplot()函数来创建每个子图。　</p>
<p>gridspec_kw：字典类型，可选参数。把字典的关键字传递给GridSpec()构造函数创建网格区域，然后将子图放在网格（grid）里。　**fig_kw：把所有详细的关键字参数传递给figure。</p>
<p>【示例37】　使用subplots()函数绘制多子图的空图表。（示例位置：资源包\MR\Code\05\37）<br>绘制一个2×3包含6个子图的空图表，使用subplots()函数只需3行代码。</p>
<p>01 import matplotlib.pyplot as plt<br>02 figure,axes=plt.subplots(2,3)<br>03 plt.show()<br>上述代码中，figure和axes是两个关键点。　</p>
<p>figure：绘制图表的画布。　</p>
<p>axes：坐标轴对象，可以理解为在figure（画布）上绘制坐标轴对象，它帮我们规划出了一个个科学作图的坐标轴系统。<br>通过图5.66中的示意图可以明白，外面的是画布（figure），里面带坐标轴的是坐标轴对象（axes）。</p>
<p><img src="/.com//image-20211022051256063.png" alt="image-20211022051256063"></p>
<p>​                                                                                                 图5.66　坐标系统示意图</p>
<p>【示例38】　使用subplots()函数绘制多子图图表。（示例位置：资源包\MR\Code\05\38）<br>使用subplots()函数将前面所学的简单图表整合到一张图表上，结果如图5.67所示。<br>程序代码如下：</p>
<p><img src="/.com//image-20211022051345468.png" alt="image-20211022051345468"></p>
<p>​    <img src="/.com//image-20211022051430897.png" alt="image-20211022051430897">                                                                                                    </p>
<p>​                                                                                                  图5.67　多子图图表</p>
<h4 id="3．add-subplot-函数"><a href="#3．add-subplot-函数" class="headerlink" title="3．add_subplot()函数"></a>3．add_subplot()函数</h4><p>【示例39】　使用add_subplot()函数绘制多子图图表。（示例位置：资源包\MR\Code\05\39）<br>add_subplot()函数也可以实现在一张图上绘制多个子图表，用法与subplot()函数基本相同，先来看下列一段代码：</p>
<p>01 import matplotlib.pyplot as plt<br>02 fig = plt.figure()</p>
<p>03 ax1 = fig.add_subplot(2,3,1)<br>04 ax2 = fig.add_subplot(2,3,2)<br>05 ax3 = fig.add_subplot(2,3,3)<br>06 ax4 = fig.add_subplot(2,3,4)<br>07 ax5 = fig.add_subplot(2,3,5)<br>08 ax6 = fig.add_subplot(2,3,6)<br>上述代码同样是绘制一个2×3包含6个子图的空图表。首先创建figure实例（画布），然后通过ax1 =fig.add_subplot(2,3,1)创建第1个子图表，返回Axes实例（坐标轴对象），第1个参数为行数，第2个参数为列数，第3个参数为子图表的位置。<br>以上用3种方法实现了在一张图上绘制多个子图表，3种方法各有所长。subplot()函数和add_subplot()函数比较灵活，定制化效果比较好，可以实现子图表在图中的各种布局（如一张图上可以随意摆放3个或5个图表）；而subplots()函数较为不灵活，但它可以用较少的代码实现绘制多个子图表。</p>
<h3 id="5-6-11-图表的保存"><a href="#5-6-11-图表的保存" class="headerlink" title="5.6.11　图表的保存"></a>5.6.11　图表的保存</h3><p>实际工作中，有时需要将绘制的图表保存为图片放置到报告中。Matplotlib的savefig()函数可以实现这一功能，将图表保存为JPEG、TIFF或PNG格式的图片。<br>例如，保存之前绘制的折线图，主要代码如下：</p>
<p>plt.savefig(‘image.png’)<br>需要注意的一个关键问题：保存代码必须在图表预览前，也就是plt.show()代码前；否则保存后的图片是白色，图表无法保存。<br>运行程序，图表被保存在程序所在路径下，名为image.png，如图5.68所示。</p>
<p><img src="/.com//image-20211022051548738.png" alt="image-20211022051548738"></p>
<p>​                                                                                             图5.68　保存后的图表</p>
<h2 id="5-7-综合应用"><a href="#5-7-综合应用" class="headerlink" title="5.7　综合应用"></a>5.7　综合应用</h2><h3 id="5-7-1-案例1：双y轴可视化数据分析图表的实现"><a href="#5-7-1-案例1：双y轴可视化数据分析图表的实现" class="headerlink" title="5.7.1　案例1：双y轴可视化数据分析图表的实现"></a>5.7.1　案例1：双y轴可视化数据分析图表的实现</h3><p>案例位置：资源包\MR\Code\05\example\01<br>双y轴顾名思义就是两个y轴，其特点是通过双y轴可以看出发展情况的同时还可以看到其增长速度。对于产品而言，通过此图可以看到产品销量的同时还可以看到产品增长率，效果如图5.69所示。</p>
<p><img src="/.com//image-20211022051701232.png" alt="image-20211022051701232"></p>
<p>​                                                                           图5.69　双y轴可视化数据分析图表<br>双y轴可视化数据分析图表的实现主要使用add_suplot()函数和twinx()函数。twinx()函数表示共享x轴，那么也就是一个x轴、两个y轴，程序代码如下：</p>
<p><img src="/.com//image-20211022051736548.png" alt="image-20211022051736548"></p>
<h3 id="5-7-2-案例2：颜色渐变饼形图的实现"><a href="#5-7-2-案例2：颜色渐变饼形图的实现" class="headerlink" title="5.7.2　案例2：颜色渐变饼形图的实现"></a>5.7.2　案例2：颜色渐变饼形图的实现</h3><p>案例位置：资源包\MR\Code\05\example\03<br>在绘制图表的过程中，每一次都苦于颜色设置问题，数据较多的情况下，不知道该如何配色，手动配色费时费力。下面绘制渐变颜色的饼形图，根据所占比例自动配置渐变色，占比越大颜色越深，占比越小颜色越浅，省去了手动配色的麻烦，而且占比情况一目了然，效果如图5.70所示。</p>
<p><img src="/.com//image-20211022051826217.png" alt="image-20211022051826217"></p>
<p>​                                                                                           图5.70　渐变色饼形图<br>颜色渐变主要使用了Matplotlib内置颜色地图模块cm，在该模块中指定一组数据可以生成多种颜色，由浅入深。例如，渐变蓝色，cmap=plt.cm.Blues。<br>下面来绘制颜色渐变的饼形图，程序代码如下：</p>
<p><img src="/.com//image-20211022051859149.png" alt="image-20211022051859149"></p>
<h3 id="5-7-3-案例3：等高线图的实现"><a href="#5-7-3-案例3：等高线图的实现" class="headerlink" title="5.7.3　案例3：等高线图的实现"></a>5.7.3　案例3：等高线图的实现</h3><p>案例位置：资源包\MR\Code\05\example\04<br>等高线图是在地理课中讲述山峰山谷时绘制的图形，在机器学习中也会被用在绘制梯度下降算法的图形中。等高线图实现结果如图5.71所示。</p>
<p><img src="/.com//image-20211022052019277.png" alt="image-20211022052019277"></p>
<p>程序代码如下：</p>
<p><img src="/.com//image-20211022052044728.png" alt="image-20211022052044728"></p>
<p>关键代码解析：</p>
<p>要画出等高线，核心函数是Matplotlib的contourf()函数，但该函数中参数x和y对应的值是二维数据，因此需要使用NumPy的meshgrid()函数将x和y值转换成二维数据，代码如下：</p>
<p>np.meshgrid(x, y)</p>
<h2 id="5-8-小结"><a href="#5-8-小结" class="headerlink" title="5.8　小结"></a>5.8　小结</h2><p>数据统计得再好都不如一张图表清晰、直观。本章用大量的举例详细地介绍了Matplotlib图表，其根本在于能够使读者全面透彻地了解和掌握最基础的图表，并应用到实际数据统计分析工作中，同时也为以后学习其他绘图库奠定坚实的基础。</p>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
  </entry>
  <entry>
    <title>opencv</title>
    <url>/2022/01/15/opencv/</url>
    <content><![CDATA[<h1 id="Python-OpenCV基础篇"><a href="#Python-OpenCV基础篇" class="headerlink" title="Python OpenCV基础篇"></a>Python OpenCV基础篇</h1><h1 id="第一章-OpenCV简介"><a href="#第一章-OpenCV简介" class="headerlink" title="第一章 OpenCV简介"></a>第一章 OpenCV简介</h1><h2 id="1-1-OpenCV概述"><a href="#1-1-OpenCV概述" class="headerlink" title="1.1 OpenCV概述"></a>1.1 OpenCV概述</h2><p>OpenCV是一个开源的计算机视觉库，可以在windows，Linux，MacOS等操作系统上运行，它起源于英特尔性能实验室研究，由俄罗斯的专家负责实现和优化，并以计算机视觉提供通用性接口为目标。</p>
<p>人类由于被赋予了视觉，因此很容易认为“计算机视觉是一种很容易实现的功能”。但是，这种想法是错误的。<br>如图1.7所示，人类的视觉能够很轻易地从这幅图像中识别花朵。但是，计算机视觉不会像人类视觉那样能够对图像进行感知和识别，更不会自动控制焦距和光圈，而是把图像解析为按照栅格状排列的数字。以图1.7为例，计算机视觉将其解析为如图1.8所示的按照栅格状排列的数字（图1.8只是图1.7的一部分）。</p>
<p><img src="/.com//1.1.jpg" alt="1.1"></p>
<p>​                                                                                        图1.7　一幅显示花朵的彩色图像</p>
<p><img src="/.com//image-20211117145923429.png" alt="image-20211117145923429"></p>
<p>​                                                                                          图1.8　计算机视觉中的图1.7<br>这些按照栅格状排列的数字包含大量的噪声，噪声在图像上常表现为引起较强视觉效果的孤立像素点或像素块，使得图像模糊不清。因此，噪声是计算机视觉面临的一个难题。要让图片变得清晰，就需要对抗噪声。<br>计算机视觉使用统计的方法对抗噪声，例如，计算机视觉虽然很难通过某个像素或者这个像素的相邻像素判断这个像素是否在图像主体的边缘上，但是如果对图像某一区域内的像素做统计，那么上述判断就变得简单了，即在指定区域内，图像主体的边缘应该表现为一连串独立的像素，而且这一连串像素的方向应该是一致的。<br>为了有效地解决计算机视觉面临的难题，OpenCV提供了许多模块，这些模块中的方法具有很好的完备性。</p>
<h3 id="1-1-1-OpenCV包含的模块"><a href="#1-1-1-OpenCV包含的模块" class="headerlink" title="1.1.1　OpenCV包含的模块"></a>1.1.1　OpenCV包含的模块</h3><p>OpenCV是由很多模块组成的，这些模块可以分为很多层，具体如图1.11所示。<br>那么，OpenCV包含的模块有哪些呢？表1.1列举的是OpenCV常用的模块。</p>
<p><img src="/.com//image-20211118043722625.png" alt="image-20211118043722625"></p>
<p>​                                                                                        图1.11　OpenCV包含的模块的层级结构</p>
<p>​                                                                                       表1.1　OpenCV常用的模块及其说明说明</p>
<p><img src="/.com//image-20211118043819255.png" alt="image-20211118043819255"></p>
<p>表1.1中的模块随着OpenCV的版本不断地更新而发生变化，有的可能被取消，有的可能被融合到其他模块中。</p>
<p>为了快速建立精巧的视觉应用，OpenCV提供了许多模块和方法。开发人员不必过多关注这些模块和方法的具体实现细节，只需关注图像处理本身，就能够很方便地使用它们对图像进行相应的处理。</p>
<h3 id="1-1-2-OpenCV的发展历程"><a href="#1-1-2-OpenCV的发展历程" class="headerlink" title="1.1.2　OpenCV的发展历程"></a>1.1.2　OpenCV的发展历程</h3><p><img src="/.com//image-20211118044141267.png" alt="image-20211118044141267"></p>
<p>​                                                                          图1.12　自2009年OpenCV的发展历程<br>从2009年3月至今，OpenCV的发展历程如图1.12所示。随着OpenCV被越来越多的用户认可并提供越来越多的技术支持，OpenCV的研发团队也加大了研究人员和研究经费的投入，这使得OpenCV的下载量逐年增长。<br>OpenCV的发展不是一帆风顺的。OpenCV在发展历程中，不仅受到了互联网行业泡沫经济的冲击，还受到了管理层和管理方向不断变更的影响，有时甚至没有研究人员和研究经费的投入。但是，随着多核处理器的出现以及计算机视觉的应用越来越广泛，OpenCV的应用价值开始上升。<br>截至目前，OpenCV已经得到了基金会、一些上市公司和私人机构的支持。OpenCV的宗旨是促进商业（利用OpenCV构建商业产品）和研究，因此OpenCV是开源并且免费的。这不仅使得OpenCV拥有着庞大的用户群体，还使得OpenCV在世界各国逐渐流行起来。</p>
<h3 id="1-1-3-OpenCV的应用"><a href="#1-1-3-OpenCV的应用" class="headerlink" title="1.1.3　OpenCV的应用"></a>1.1.3　OpenCV的应用</h3><p>因为OpenCV是一个开源的计算机视觉库，所以在举例介绍OpenCV的应用之前，先对计算机视觉的应用进行介绍。<br>计算机视觉不仅被广泛地应用到安保行业（见图1.13中的监控摄像头），还被应用到网页端的图像和视频处理以及游戏交互中，甚至在某些现代化工厂里，被应用到产品质检工作上。此外，计算机视觉还被应用到一些高精尖领域，包括无人机领域和航空航天领域等，这些领域使用计算机视觉中的图像拼接技术获取街景图像（见图1.14）或者航空图像（见图1.15）。</p>
<p><img src="/.com//image-20211118044301194.png" alt="image-20211118044301194"></p>
<p>​                                                                                             图1.13　监控摄像头</p>
<p><img src="/.com//image-20211118044402545.png" alt="image-20211118044402545"></p>
<p>​                                                                                            图1.14　街景图像</p>
<p><img src="/.com//image-20211118044454076.png" alt="image-20211118044454076"></p>
<p>​                                                                                               图1.15　航空图像<br>OpenCV自发布起便得到广泛应用，其中包括在安保以及工业检测系统，网络产品以及科研工作，医学、卫星和网络地图（例如，医学图像的降噪，街景图像或者航空图像的拼接及其扫描校准等），汽车自动驾驶，相机校正等。此外，OpenCV还被应用到处理声音的频谱图像上，进而实现对声音的识别。</p>
<h3 id="1-1-4-Python-OpenCV的开发工具"><a href="#1-1-4-Python-OpenCV的开发工具" class="headerlink" title="1.1.4　Python OpenCV的开发工具"></a>1.1.4　Python OpenCV的开发工具</h3><p>Python相比Java、C、C++等编程语言，其优势在于集成度高。虽然Python的执行效率低，但是可以调用大量免费使用的类库。Java、C、C++语言如果要实现一个功能，那么需要先实现其中的基本功能模块。Python直接调用相应的类库就能将这个功能轻松实现。简单地说，Python通过简短的代码就能够实现很强大的功能。<br>此外，Python在OpenCV、Web、爬虫、数据分析等方向都有很好的发展前景。Python OpenCV的优势在于Python能够借助OpenCV库轻轻松松地实现对图像的处理操作。<br>Python OpenCV的开发工具如图1.16所示。</p>
<p><img src="/.com//image-20211118044618479.png" alt="image-20211118044618479"></p>
<p>​                                                                          图1.16　Python OpenCV的开发工具</p>
<h1 id="第2章-搭建开发环境"><a href="#第2章-搭建开发环境" class="headerlink" title="第2章　搭建开发环境"></a>第2章　搭建开发环境</h1><p>第1章介绍了本书要使用的开发工具，它们分别是Python解释器、OpenCV-Contrib-Python库、Numpy库和集成开发工具PyCharm。使用这些开发工具前，需先对它们进行下载和安装。</p>
<p><img src="/.com//image-20211118044843794.png" alt="image-20211118044843794"></p>
<h2 id="2-1-Python的下载和安装"><a href="#2-1-Python的下载和安装" class="headerlink" title="2.1　Python的下载和安装"></a>2.1　Python的下载和安装</h2><p>工欲善其事，必先利其器。为了使用Python OpenCV对图像进行处理，本节介绍Python的下载和安装。Python是跨平台的开发工具，可以在Windows、Linux和MacOS等操作系统上使用。说明<br>本节使用的是64位的Windows 10操作系统。</p>
<h3 id="2-1-1-下载Python"><a href="#2-1-1-下载Python" class="headerlink" title="2.1.1　下载Python"></a>2.1.1　下载Python</h3><p>在Python的官网中，可以很方便地下载Python的开发工具，具体下载步骤如下。<br>（1）打开浏览器，在浏览器的地址栏中输入Python的官网地址<a href="https://www.python.org/%EF%BC%8C%E6%8C%89Enter%E9%94%AE%E5%90%8E%EF%BC%8C%E8%BF%9B%E5%85%A5Python%E7%9A%84%E5%AE%98%E7%BD%91%E9%A6%96%E9%A1%B5%EF%BC%9B%E5%B0%86%E9%BC%A0%E6%A0%87%E7%A7%BB%E5%8A%A8%E5%88%B0Downloads%E8%8F%9C%E5%8D%95%E4%B8%8A%EF%BC%8C%E6%98%BE%E7%A4%BA%E5%A6%82%E5%9B%BE2.1%E6%89%80%E7%A4%BA%E7%9A%84%E8%8F%9C%E5%8D%95%E9%A1%B9%E3%80%82%E8%AF%B4%E6%98%8E">https://www.python.org/，按Enter键后，进入Python的官网首页；将鼠标移动到Downloads菜单上，显示如图2.1所示的菜单项。说明</a><br>推荐使用Python 3.8.2及其以上版本。<br>（2）单击图2.1中的Windows菜单项后，将进入详细的下载列表，如图2.2所示。</p>
<p><img src="/.com//image-20211118045031864.png" alt="image-20211118045031864"></p>
<p>​                                                                              图2.1　Downloads菜单中的菜单项</p>
<p><img src="/.com//image-20211118045054226.png" alt="image-20211118045054226"></p>
<p>​                                                                   图2.2　适合Windows系统的Python下载列表说明<br>在如图2.2所示的下载列表中，带有“x86”字样的压缩包，表示该开发工具可以在Windows 32位系统上使用；而带有“x86-64”字样的压缩包，则表示该开发工具可以在Windows 64位系统上使用。另外，标记为“web-based installer”字样的压缩包，表示需要通过联网完成安装；标记为“executable installer”字样的压缩包，表示通过可执行文件（*.exe）方式离线安装；标记为“embeddable zip file”字样的压缩包，表示嵌入式版本，可以集成到其他应用中。<br>（3）在如图2.2所示的下载列表中，列出了各个版本的下载链接，可以根据需要选择相应的版本进行下载。因为本书使用的是64位的Windows 10操作系统，所以选择并单击Windows x86-64 executable installer超链接进行下载。<br>（4）下载完成后，将得到一个名为python-3.8.2-amd64.exe的安装文件。</p>
<h3 id="2-1-2-安装Python"><a href="#2-1-2-安装Python" class="headerlink" title="2.1.2　安装Python"></a>2.1.2　安装Python</h3><p>安装Python的步骤如下。<br>（1）双击下载完成后得到的安装文件python-3.8.2-amd64.exe，将显示如图2.3所示的安装向导对话框；选中当前对话框中的Add Python 3.8 to PATH复选框，表示自动配置环境变量。<br>（2）单击图2.3中的Customize installation按钮，进行自定义安装；在弹出的如图2.4所示的安装选项对话框中，都采用默认设置。</p>
<p><img src="/.com//image-20211118045151983.png" alt="image-20211118045151983"></p>
<p>​                                                                               图2.3　Python安装向导对话框</p>
<p><img src="/.com//image-20211118045216258.png" alt="image-20211118045216258"></p>
<p>​                                                                                        图2.4　安装选项对话框<br>（3）单击图2.4中的Next按钮，弹出如图2.5所示的高级选项对话框。在当前对话框中，除了默认设置外，选中Install for all users复选框（表示当前计算机的所有用户都可以使用）；单击Browse按钮，设置Python的安装路径。注意<br>在设置安装路径时，建议路径中不要使用中文或空格，避免使用过程中出现错误。<br>（4）单击图2.5中的Install按钮后，将显示如图2.6所示的Python安装进度。</p>
<p><img src="/.com//image-20211118045243028.png" alt="image-20211118045243028"></p>
<p>​                                                                            图2.5　高级选项对话框</p>
<p><img src="/.com//image-20211118045323265.png" alt="image-20211118045323265"></p>
<p>​                                                                              图2.6　Python安装进度<br>（5）安装完成后，将显示如图2.7所示的对话框，单击Close按钮关闭当前对话框即可。</p>
<p><img src="/.com//image-20211118045349459.png" alt="image-20211118045349459"></p>
<p>​                                                                                   图2.7　安装完成对话框</p>
<h3 id="2-1-3-测试Python是否安装成功"><a href="#2-1-3-测试Python是否安装成功" class="headerlink" title="2.1.3　测试Python是否安装成功"></a>2.1.3　测试Python是否安装成功</h3><p>测试Python是否安装成功的步骤如下。<br>（1）单击开始菜单，直接输入cmd，如图2.8所示。<br>（2）按Enter键后，打开“命令提示符”窗口，如图2.9所示。</p>
<p><img src="/.com//image-20211118045430521.png" alt="image-20211118045430521"></p>
<p>​                                                                                    图2.8　单击开始菜单输入cmd</p>
<p><img src="/.com//image-20211118045450877.png" alt="image-20211118045450877"></p>
<p>​                                                                                   图2.9　“命令提示符”窗口<br>（3）在“命令提示符”窗口中的光标处输入python，按Enter键；如果当前窗口显示如图2.10所示的信息，说明Python安装成功。</p>
<p><img src="/.com//image-20211118045511638.png" alt="image-20211118045511638"></p>
<p>​                                                            图2.10　安装成功后输入python显示的信息说明<br>图2.10中的信息是在“命令提示符”窗口中的光标处输入python后显示的。如果读者朋友选择的版本不同，测试时显示的信息会与图2.10中显示的有所差异。当“命令提示符”窗口出现&gt;&gt;&gt;时，说明Python已经安装成功，而且已经进入Python，正在等待用户输入Python命令。</p>
<h2 id="2-2-Python-OpenCV的下载和安装"><a href="#2-2-Python-OpenCV的下载和安装" class="headerlink" title="2.2　Python OpenCV的下载和安装"></a>2.2　Python OpenCV的下载和安装</h2><p>为了更快速、更简单地下载和安装Python OpenCV，从清华镜像下载和安装OpenCV-Contrib-Python库。在这个库中，除包括OpenCV-Contrib-Python库外，还包括Numpy库。Numpy库是Python语言的一个扩展程序库，支持大量的维度数组与矩阵运算。</p>
<p>opencv-python 是只包含了主要模块的包，opencv-contrib-python包含了主要模块以及扩展模块，扩展模块主要是包含了一些带专利的收费算法（如shift特征检测）以及一些在测试的新的算法（稳定后会合并到主要模块）。</p>
<h3 id="2-2-1-下载和安装OpenCV-Contrib-Python库"><a href="#2-2-1-下载和安装OpenCV-Contrib-Python库" class="headerlink" title="2.2.1　下载和安装OpenCV-Contrib-Python库"></a>2.2.1　下载和安装OpenCV-Contrib-Python库</h3><p>从清华镜像下载和安装OpenCV-Contrib-Python库的步骤如下。<br>（1）可以参照图2.8和图2.9，打开“命令提示符”窗口。<br>（2）在“命令提示符”窗口中的光标处输入pip install -i <a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a> opencv-contrib-python，如图2.11所示。</p>
<p><img src="/.com//image-20211118045621571.png" alt="image-20211118045621571"></p>
<p>​                                                                                    图2.11　输入pip命令</p>
<p>说明</p>
<p>​            （1）<a href="https://pypi.tuna.tsinghua.edu.cn/simple%E6%98%AF%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E6%8F%90%E4%BE%9B%E7%9A%84%E7%94%A8%E4%BA%8E%E4%B8%8B%E8%BD%BD%E5%92%8C%E5%AE%89%E8%A3%85OpenCV-Contrib-Python%E5%BA%93%E7%9A%84%E9%95%9C%E5%83%8F%E5%9C%B0%E5%9D%80%E3%80%82">https://pypi.tuna.tsinghua.edu.cn/simple是清华大学提供的用于下载和安装OpenCV-Contrib-Python库的镜像地址。</a></p>
<p>​            （2）pip命令是用于查找、下载、安装和卸载Python库的管理工具。如果图2.11中的pip命令得不到如图2.12所示的界面，那么要将pip命令修改为pip install opencv-python。</p>
<p>（3）按Enter键后，系统将自动从<a href="https://pypi.tuna.tsinghua.edu.cn/simple%E5%85%88%E4%B8%8B%E8%BD%BDOpenCV-Contrib-Python%E5%BA%93%EF%BC%8C%E5%86%8D%E4%B8%8B%E8%BD%BDNumpy%E5%BA%93%E3%80%82%E5%BE%85OpenCV-Contrib-Python%E5%BA%93%E5%92%8CNumpy%E5%BA%93%E9%83%BD%E4%B8%8B%E8%BD%BD%E5%AE%8C%E6%88%90%E5%90%8E%EF%BC%8C%E7%B3%BB%E7%BB%9F%E5%B0%86%E8%87%AA%E5%8A%A8%E5%AE%89%E8%A3%85Numpy%E5%BA%93%E5%92%8COpenCV-Contrib-Python%E5%BA%93%EF%BC%8C%E5%A6%82%E5%9B%BE2.12%E6%89%80%E7%A4%BA%E3%80%82">https://pypi.tuna.tsinghua.edu.cn/simple先下载OpenCV-Contrib-Python库，再下载Numpy库。待OpenCV-Contrib-Python库和Numpy库都下载完成后，系统将自动安装Numpy库和OpenCV-Contrib-Python库，如图2.12所示。</a></p>
<p><img src="/.com//image-20211118050033294.png" alt="image-20211118050033294"></p>
<p>​                                                图2.12　安装Numpy库和OpenCV-Contrib-Python库</p>
<h3 id="2-2-2-测试OpenCV-Contrib-Python库和Numpy库是否安装成功"><a href="#2-2-2-测试OpenCV-Contrib-Python库和Numpy库是否安装成功" class="headerlink" title="2.2.2　测试OpenCV-Contrib-Python库和Numpy库是否安装成功"></a>2.2.2　测试OpenCV-Contrib-Python库和Numpy库是否安装成功</h3><p>测试OpenCV-Contrib-Python库和Numpy库是否安装成功的步骤如下。<br>（1）如图2.13所示，在光标处输入python，按Enter键，进入Python。<br>（2）当“命令提示符”窗口出现&gt;&gt;&gt;时，在光标处输入import cv2，按Enter键。如果“命令提示符”窗口在新的一行出现&gt;&gt;&gt;，说明OpenCV-Contrib-Python库安装成功。<br>（3）在新的一行的&gt;&gt;&gt;后的光标处输入import numpy as np，按Enter键。如果“命令提示符”窗口在新的一行出现&gt;&gt;&gt;，说明Numpy库安装成功。<br>（4）在新的一行的&gt;&gt;&gt;后的光标处输入exit()，按Enter键，退出Python。<br>（5）在“命令提示符”窗口的光标处输入exit或者exit()，按Enter键，退出“命令提示符”窗口。说明<br>exit()用于退出Python，exit或exit()用于退出“命令提示符”窗口。</p>
<p><img src="/.com//image-20211118050138981.png" alt="image-20211118050138981"></p>
<p>​                                       图2.13　测试OpenCV-Contrib-Python库和Numpy库是否安装成功</p>
<h1 id="第3章-图像处理的基本操作"><a href="#第3章-图像处理的基本操作" class="headerlink" title="第3章　图像处理的基本操作"></a>第3章　图像处理的基本操作</h1><p>OpenCV的作用在于让开发人员更容易地通过编码来处理图像。那么，处理图像需要执行哪些操作呢？图像处理的基本操作包含4个方面的内容：读取图像、显示图像、保存图像和获取图像属性。其中，常用的图像属性有3个：shape、size和dtype。本章将依次详解实现图像处理的4个基本操作，并分别阐明常用的3个图像属性各自的含义及其使用方法。</p>
<h2 id="3-1-读取图像"><a href="#3-1-读取图像" class="headerlink" title="3.1　读取图像"></a>3.1　读取图像</h2><p>要对一幅图像进行处理，首先要做的就是读取这幅图像。那么，如何才能读取这幅图像呢？OpenCV提供了用于读取图像的imread()方法，其语法格式如下：</p>
<pre><code> image = cv2.imread(filename, flags)
</code></pre>
<p>参数说明：　</p>
<p>image：imread()方法的返回值，返回的是读取到的图像。　</p>
<p>filename：要读取的图像的完整文件名。例如，要读取当前项目目录下的3.1.jpg，filename的值为”3.1.jpg”（双引号是英文格式的）。　</p>
<p>flags：读取图像颜色类型的标记。当flags的默认值为1时，表示读取的是彩色图像，此时的flags值可以省略；当flags的值为0时，表示读取的是灰度图像（如果读取的是彩色图像，也将转换为与彩色图像对应的灰度图像）。</p>
<p>flags对应的全部属性：</p>
<p><a href="https://docs.opencv.org/3.4.2/d4/da8/group__imgcodecs.html#ga461f9ac09887e47797a54567df3b8b63">https://docs.opencv.org/3.4.2/d4/da8/group__imgcodecs.html#ga461f9ac09887e47797a54567df3b8b63</a></p>
<p><img src="/.com//工作/振涛/课件-郭溪溪/20课时讲义/专高四-机器学习算法与opencv/Day07.assets/image-20211208115112743.png" alt="image-20211208115112743"></p>
<p>说明</p>
<p>灰度图像是一种每个像素都是从黑到白，被处理为256个灰度级别的单色图像。256个灰度级别分别用0（纯黑色）～255（纯白色）的数值表示。</p>
<p>【实例3.1】　读取当前项目目录下的图像。（实例位置：资源包\TM\sl\3\01）<br>如图3.1所示，在PyCharm中的PythonDevelop项目下，有一幅名为3.1.jpg的图像。在ImageTest.py文件中，先使用imread()方法读取3.1.jpg，再使用print()方法打印3.1.jpg，代码如下：</p>
<pre><code> import cv2
 # 读取3.1.jpg，等价于image = cv2.imread(&quot;3.1.jpg&quot;，1)
 image = cv2.imread(&quot;3.1.jpg&quot;)
 print(image) # 打印3.1.jpg
</code></pre>
<p>上述代码打印的部分结果如图3.2所示。</p>
<p><img src="/.com//image-20211118050941447.png" alt="image-20211118050941447"></p>
<p>​                                                                    图3.1　PythonDevelop项目下的3.1.jpg</p>
<p><img src="/.com//image-20211118051005696.png" alt="image-20211118051005696"></p>
<p>​                                                                                 图3.2　打印3.1.jpg说明<br>图3.2输出的数字是3.1.jpg的部分像素值。<br>如果3.1.jpg在D盘的根目录下，应该如何使用imread()方法进行读取呢？<br>只需将实例3.1代码：</p>
<p>image = cv2.imread(“3.1.jpg”)<br>修改为如下代码：</p>
<pre><code> image = cv2.imread(&quot;D:/3.1.jpg&quot;) # 路径中不能出现中文注意
</code></pre>
<p>“D:/3.1.jpg”等价于”D:\3.1.jpg”。</p>
<h2 id="3-2-显示图像"><a href="#3-2-显示图像" class="headerlink" title="3.2　显示图像"></a>3.2　显示图像</h2><p>相比图3.2中密密麻麻的数字，如果能够将这幅图像显示出来，就可以更加直观地看到它。为此，OpenCV提供了imshow()方法、waitKey()方法和destroyAllWindows()方法。<br>（1）imshow()方法用于显示图像，其语法格式如下：</p>
<pre><code> cv2.imshow(winname, mat)
</code></pre>
<p>参数说明：　</p>
<p>winname：显示图像的窗口名称。　</p>
<p>mat：要显示的图像。<br>（2）waitKey()方法用于等待用户按下键盘上按键的时间。当用户按下键盘上的任意按键时，将执行waitKey()方法，并且获取waitKey()方法的返回值。其语法格式如下：</p>
<pre><code> retval = cv2.waitKey(delay)
</code></pre>
<p>参数说明：　</p>
<p>retval：与被按下的按键对应的ASCII码。例如，Esc键的ASCII码是27，当用户按Esc键时，waitKey()方法的返回值是27。如果没有按键被按下，waitKey()方法的返回值是-1。　</p>
<p>delay：等待用户按下键盘上按键的时间，单位为毫秒（ms）。</p>
<p>当delay的值为负数、0或者空时，表示无限等待用户按下键盘上按键的时间。</p>
<p>(4)</p>
<pre><code>cv2.namedWindow(&#39;窗口名称&#39;,cv2.WINDOW_NORMAL)#窗口可以缩放
</code></pre>
<p>（3）destroyAllWindows()方法用于销毁所有正在显示图像的窗口，其语法格式如下：</p>
<pre><code> cv2.destroyAllWindows()【实例3.2】　显示图像。（实例位置：资源包\TM\sl\3\02）
</code></pre>
<p>编写一个程序，使用imread()方法、imshow()方法、waitKey()方法和destroyAllWindows()方法，读取并显示PythonDevelop项目下的3.1.jpg，代码如下：</p>
<pre><code> import cv2
 image = cv2.imread(&quot;3.1.jpg&quot;)       # 读取3.1.jpg
 cv2.imshow(&quot;flower&quot;, image)         # 在名为flower的窗口中显示3.1.jpg
 cv2.waitKey()                       # 按下任何键盘按键后
 cv2.destroyAllWindows()             # 销毁所有窗口
</code></pre>
<p>上述代码的运行结果如图3.3所示。注意<br>（1）显示图像的窗口名称不能使用中文（例如，把实例3.2第4行代码中的”flower”修改为”鲜花”），否则会出现如图3.4所示的乱码。<br>（2）为了能够正常显示图像，要在cv2.imshow()之后紧跟着cv2.waitKey()。</p>
<p><img src="/.com//1.1.jpg" alt="1.1"></p>
<p>​                                                                                               图3.3　显示3.1.jpg</p>
<p>依据imread()方法的语法，如果把实例3.2第3行代码：</p>
<pre><code> image = cv2.imread(&quot;3.1.jpg&quot;)
</code></pre>
<p>修改为如下代码：</p>
<pre><code> image = cv2.imread(&quot;3.1.jpg&quot;, 0)
</code></pre>
<p>如果想设置窗口显示图像的时间为5s，又该如何编写代码呢？<br>只需将实例3.2第5行代码：</p>
<pre><code> cv2.waitKey()
</code></pre>
<p>修改为如下代码：</p>
<pre><code> cv2.waitKey(5000) # 1000ms为1s，5000ms为5s
</code></pre>
<h2 id="3-3-保存图像"><a href="#3-3-保存图像" class="headerlink" title="3.3　保存图像"></a>3.3　保存图像</h2><p>在实际开发的过程中，对一幅图像进行一系列的处理后，需要保存处理图像后的结果。为此，OpenCV提供了用于按照指定路径保存图像的imwrite()方法，其语法格式如下：</p>
<pre><code> cv2.imwrite(filename, img)
</code></pre>
<p>参数说明：　</p>
<p>filename：保存图像时所用的完整路径。　</p>
<p>img：要保存的图像。</p>
<p>【实例3.3】　保存图像。（实例位置：资源包\TM\sl\3\03）<br>编写一个程序，把PythonDevelop项目下的3.1.jpg保存为E盘根目录下的、Pictures文件夹中的1.jpg，代码如下：</p>
<pre><code> import cv2
 image = cv2.imread(&quot;3.1.jpg&quot;) # 读取3.1.jpg
 # 把3.1.jpg保存为E盘根目录下的、Pictures文件夹中的1.jpg
 cv2.imwrite(&quot;E:/Pictures/1.jpg&quot;, image)
</code></pre>
<p>运行上述代码前，确认E盘根目录下有Pictures文件夹。如果没有，在E盘根目录下新建一个空的Pictures文件夹。<br>运行上述代码后，打开E盘根目录下的Pictures文件夹，即可看到1.jpg。</p>
<h2 id="3-4-获取图像属性"><a href="#3-4-获取图像属性" class="headerlink" title="3.4　获取图像属性"></a>3.4　获取图像属性</h2><p>在处理图像的过程中，经常需要获取图像的大小、类型等图像属性。为此，OpenCV提供了shape、size和dtype 3个常用属性，具体含义分别如下。</p>
<p>shape：如果是彩色图像，那么获取的是一个包含图像的水平像素、垂直像素和通道数的数组，即（垂直像素，水平像素，通道数）；如果是灰度图像，那么获取的是一个包含图像的水平像素和垂直像素的数组，即（垂直像素，水平像素）。说明<br>垂直像素指的是垂直方向上的像素，水平像素指的是水平方向上的像素。有关像素、灰度图像和通道的内容，将在本书的第4章和第5章进行讲解。　</p>
<p>size：获取的是图像包含的像素个数，其值为“水平像素×垂直像素×通道数”。灰度图像的通道数为1。　</p>
<p>dtype：获取的是图像的数据类型。</p>
<p>【实例3.4】　分别获取彩色图像和灰度图像的属性。（实例位置：资源包\TM\sl\3\04）<br>编写一个程序，先获取PythonDevelop项目下的3.1.jpg的属性，再获取由3.1.jpg转换得到的灰度图像的属性。代码如下：<br>上述代码的运行结果如图3.7所示。</p>
<p><img src="/.com//image-20211118052254399.png" alt="image-20211118052254399"></p>
<p>​                                                         图3.7　获取并打印彩色图像的属性说明</p>
<p>图3.7中（292, 219, 3）的含义是3.1.jpg的垂直像素是292，水平像素是219，通道数是3。（292,219）的含义是由3.1.jpg转换得到的灰度图像的垂直像素是292，水平像素是219，通道数是1。</p>
<h2 id="3-5-图像编解码"><a href="#3-5-图像编解码" class="headerlink" title="3.5 图像编解码"></a>3.5 图像编解码</h2><p>cv2.imdecode()函数从指定的内存缓存中读取数据，并把数据转换(解码)成图像格式;主要用于从网络传输数据中恢复出图像。<br>cv2.imencode()函数是将图片格式转换(编码)成流数据，赋值到内存缓存中;主要用于图像数据格式的压缩，方便网络传输。</p>
<p>![image-20211208115449554](C:\Users\123\Desktop\专高四\Python opencv\image-20211208115449554.png)</p>
<p>imdecode()使用</p>
<p>从网络读取图像数据并转换成图片格式：</p>
<pre><code># -*- coding: utf-8 -*-
import numpy as np
import urllib
import cv2

url = &#39;http://www.pyimagesearch.com/wp-content/uploads/2015/01/google_logo.png&#39;
resp = urllib.urlopen(url)
image = np.asarray(bytearray(resp.read()), dtype=&quot;uint8&quot;)
image = cv2.imdecode(image, cv2.IMREAD_COLOR)
cv2.imshow(&#39;URL2Image&#39;,image)
cv2.waitKey()
</code></pre>
<p>imenconde()使用</p>
<pre><code># -*- coding: utf-8 -*-
import numpy as np
import urllib
import cv2

img = cv2.imread(&#39;0122.jpg&#39;)
# &#39;.jpg&#39;表示把当前图片img按照jpg格式编码，按照不同格式编码的结果不一样
img_encode = cv2.imencode(&#39;.jpg&#39;, img)[1]
# imgg = cv2.imencode(&#39;.png&#39;, img)

data_encode = np.array(img_encode)
str_encode = data_encode.tostring()

# 缓存数据保存到本地
with open(&#39;img_encode.txt&#39;, &#39;w&#39;) as f:
    f.write(str_encode)
    f.flush
</code></pre>
<h2 id="3-5-图像编解码-1"><a href="#3-5-图像编解码-1" class="headerlink" title="3.5 图像编解码"></a>3.5 图像编解码</h2><p>cv2.imdecode()函数从指定的内存缓存中读取数据，并把数据转换(解码)成图像格式;主要用于从网络传输数据中恢复出图像。<br>cv2.imencode()函数是将图片格式转换(编码)成流数据，赋值到内存缓存中;主要用于图像数据格式的压缩，方便网络传输。</p>
<p><img src="/.com//工作\振涛\课件-郭溪溪\20课时讲义\专高四-机器学习算法与opencv\Day07.assets\image-20211208115449554.png" alt="image-20211208115449554"></p>
<p>imdecode()使用</p>
<p>从网络读取图像数据并转换成图片格式：</p>
<pre><code># -*- coding: utf-8 -*-
import numpy as np
import urllib
import cv2

url = &#39;http://www.pyimagesearch.com/wp-content/uploads/2015/01/google_logo.png&#39;
resp = urllib.urlopen(url)
image = np.asarray(bytearray(resp.read()), dtype=&quot;uint8&quot;)
image = cv2.imdecode(image, cv2.IMREAD_COLOR)
cv2.imshow(&#39;URL2Image&#39;,image)
cv2.waitKey()
</code></pre>
<p>imenconde()使用</p>
<pre><code># -*- coding: utf-8 -*-
import numpy as np
import urllib
import cv2

img = cv2.imread(&#39;0122.jpg&#39;)
# &#39;.jpg&#39;表示把当前图片img按照jpg格式编码，按照不同格式编码的结果不一样
img_encode = cv2.imencode(&#39;.jpg&#39;, img)[1]
# imgg = cv2.imencode(&#39;.png&#39;, img)

data_encode = np.array(img_encode)
str_encode = data_encode.tostring()

# 缓存数据保存到本地
with open(&#39;img_encode.txt&#39;, &#39;w&#39;) as f:
    f.write(str_encode)
    f.flush
</code></pre>
<h1 id="第4章-像素的操作"><a href="#第4章-像素的操作" class="headerlink" title="第4章　像素的操作"></a>第4章　像素的操作</h1><p>像素是图像的最小单位。每一幅图像都是由M行N列的像素组成的，其中每一个像素都存储一个像素值。以灰度图像为例，计算机通常把灰度图像的像素处理为256个灰度级别，256个灰度级别分别使用区间[0, 255]中的整数数值表示。其中，“0”表示纯黑色；“255”表示纯白色。本章将围绕着像素展开，介绍如何使用NumPy模块操作像素。</p>
<p><img src="/.com//image-20211118052436390.png" alt="image-20211118052436390"></p>
<h2 id="4-1-像素"><a href="#4-1-像素" class="headerlink" title="4.1　像素"></a>4.1　像素</h2><p>像素是构成数字图像的基本单位。现有一幅显示花朵的图像（见图4.1），在花瓣边缘提取一个小圆圈圈住的区域，将得到一幅如图4.2所示的图像。</p>
<p><img src="/.com//image-20211118052508759.png" alt="image-20211118052508759"></p>
<p>​                                                                              图4.1　一幅显示花朵的图像</p>
<p><img src="/.com//image-20211118052529006.png" alt="image-20211118052529006"></p>
<p>​                                                                    图4.2　提取并放大图4.1中被圆圈圈住的区域</p>
<p>不难发现，图4.2所示的图像是由许多小方块组成的，通常把一个小方块称作一个像素。因此，一个像素是具有一定面积的一个块，而不是一个点。需要注意的是，像素的形状是不固定的，大多数情况下，像素被认为是方形的，但有时也可能是圆形的或者是其他形状的。</p>
<h3 id="4-1-1-确定像素的位置"><a href="#4-1-1-确定像素的位置" class="headerlink" title="4.1.1　确定像素的位置"></a>4.1.1　确定像素的位置</h3><p>以图4.1为例，在访问图4.1中的某个像素前，要确定这个像素在图4.1中的位置。那么，这个位置应该如何确定呢？<br>首先，确定图4.1在水平方向和垂直方向的像素个数。图4.1的水平方向和垂直方向如图4.3所示。<br>在Windows 10系统的“画图”工具中打开图4.1，得到如图4.4所示的界面。在这个界面中，就会得到图4.1在水平方向的像素是219个，在垂直方向的像素是292个。</p>
<p><img src="/.com//image-20211118052630446.png" alt="image-20211118052630446"></p>
<p>​                                                                                       图4.3　图4.1的水平方向和垂直方向</p>
<p><img src="/.com//image-20211118052657074.png" alt="image-20211118052657074"></p>
<p>​                                                                                                       图4.4　用“画图”工具打开图4.1</p>
<p>然后，根据图4.1在水平方向和垂直方向的像素，绘制如图4.5所示的坐标系。</p>
<p><img src="/.com//image-20211118052750858.png" alt="image-20211118052750858"></p>
<p>​                                                                  图4.5　根据图4.1在水平方向和垂直方向的像素绘制坐标系</p>
<p>说明<br>图4.1在水平方向的像素是219个，与其对应的是x轴的取值范围，即0～218；同理，在垂直方向的像素是292个，与其对应的是y轴的取值范围，即0～291。<br>这样，就能够通过坐标来确定某个像素在图4.1中的位置。在OpenCV中，正确表示图4.1中某个像素坐标的方式是(y, x)。例如，在如图4.5所示的坐标系中，图4.1右下角的像素坐标是(291, 218)。</p>
<p>【实例4.1】　表示图4.1中的指定像素。（实例位置：资源包\TM\sl\4\01）<br>编写一段代码，先读取D盘根目录下的4.1.jpg，再表示坐标(291, 218)上的像素，具体如下：</p>
<pre><code> import cv2
 image = cv2.imread(&quot;D:/4.1.jpg&quot;)  # 读取D盘根目录下的4.1.jpg
 px = image[291, 218]              # 坐标(291, 218)上的像素
</code></pre>
<h3 id="4-1-2-获取像素的BGR值"><a href="#4-1-2-获取像素的BGR值" class="headerlink" title="4.1.2　获取像素的BGR值"></a>4.1.2　获取像素的BGR值</h3><p>在4.1.1节中，已经得到了坐标(291, 218)上的像素px。现使用print()方法打印这个像素，将得到这个像素的BGR值，代码如下：</p>
<pre><code> print(&quot;坐标(291, 218)上的像素的BGR值是&quot;, px)
</code></pre>
<p>上述代码的运行结果如下：</p>
<pre><code> 坐标(291, 218)上的像素的BGR值是 [36 42 49]
</code></pre>
<p>不难发现，坐标(291, 218)上的像素的BGR值是由36、42和49这3个数值组成的。在讲解这3个数值各自代表的含义之前，先了解什么是三基色。<br>如图4.6所示，人眼能够感知红色、绿色和蓝色3种不同的颜色，因此把这3种颜色称作三基色。如果将这3种颜色以不同的比例进行混合，人眼就会感知到丰富多彩的颜色。<br>那么，对于计算机而言，是如何对这些颜色进行编码的呢？答案就是利用色彩空间。也就是说，色彩空间是计算机对颜色进行编码的模型。</p>
<p>以较为常用的RGB色彩空间为例，在RGB色彩空间中，存在3个通道，即R通道、G通道和B通道。其中，R通道指的是红色通道；G通道指的是绿色通道；B通道指的是蓝色通道；并且每个色彩通道都在区间[0, 255]内取值。<br>这样，计算机将利用3个色彩通道的不同组合来表示不同的颜色。如图4.7所示，通过截图工具，能够得到坐标(291, 218)上的像素值为(49, 42, 36)。</p>
<p><img src="/.com//image-20211118053134133.png" alt="image-20211118053134133"></p>
<p>​                                                                                              图4.6　三基色</p>
<p><img src="/.com//image-20211118053208551.png" alt="image-20211118053208551"></p>
<p>​                                                                           图4.7　坐标(291, 218)上的像素的像素值<br>使用print()方法打印图4.1中坐标(291, 218)上的像素px，其结果是(36, 42, 49)。而图4.7中这个坐标上的像素值为(49, 42, 36)。这时会发现这两个结果中的数值是相同的，但顺序是相反的，这是为什么呢？<br>原因是在RGB色彩空间中，彩色图像的通道顺序是R（49）→G（42）→B（36）；但是，在OpenCV中，RGB色彩空间被BGR色彩空间取代，使得彩色图像的通道顺序变为了B（36）→G（42）→R（49）。<br>从上文能够知晓，在BGR色彩空间的图像中，每3个数值表示一个像素，这3个数值分别表示蓝色、绿色和红色3种颜色分量，把每一种颜色分量所在的区域称作通道。那么，OpenCV是如何获取指定位置上的像素的B通道、G通道和R通道的值呢？<br>有如下两种方式（以坐标(291, 218)上的像素为例）。<br>（1）同时获取坐标(291, 218)上的像素的B通道、G通道和R通道的值，代码如下：</p>
<pre><code> import cv2
 image = cv2.imread(&quot;D:/4.1.jpg&quot;)
 px = image[291, 218]              # 坐标(291, 218)上的像素
 print(px)
</code></pre>
<p>上述代码的运行结果如下：</p>
<pre><code> [36 42 49]
</code></pre>
<p>（2）分别获取坐标(291, 218)上的像素的B通道、G通道和R通道的值，代码如下：</p>
<pre><code> import cv2
 image = cv2.imread(&quot;D:/4.1.jpg&quot;)
 blue = image[291, 218, 0]         # 坐标(291, 218)上的像素的B通道的值
 green = image[291, 218, 1]        # 坐标(291, 218)上的像素的G通道的值
 red = image[291, 218, 2]          # 坐标(291, 218)上的像素的R通道的值
 print(blue, green, red)
</code></pre>
<p>上述代码的运行结果如下：</p>
<pre><code> 36 42 49说明
</code></pre>
<p>（1）image[291, 218, 0]中的最后一个数值0表示B通道。<br>（2）image[291, 218, 1]中的最后一个数值1表示G通道。<br>（3）image[291, 218, 2]中的最后一个数值2表示R通道。</p>
<h3 id="4-1-3-修改像素的BGR值"><a href="#4-1-3-修改像素的BGR值" class="headerlink" title="4.1.3　修改像素的BGR值"></a>4.1.3　修改像素的BGR值</h3><p>在4.1.2节中，已经获取了图4.5中坐标(291, 218)上的像素px的BGR值，即(36, 42, 49)。现要将像素px的BGR值由原来的(36, 42, 49)修改为(255, 255, 255)，代码如下：</p>
<pre><code> import cv2
 image = cv2.imread(&quot;D:/4.1.jpg&quot;)
 px = image[291, 218]
 print(&quot;坐标(291, 218)上的像素的初始BGR值是&quot;, px)
 px = [255, 255, 255]                # 把坐标(291, 218)上的像素的值修改为[255, 255, 255]
 print(&quot;坐标(291, 218)上的像素修改后的BGR值是&quot;, px)
</code></pre>
<p>上述代码的运行结果如下：</p>
<pre><code> 坐标(291, 218)上的像素的初始BGR值是 [36 42 49]
 坐标(291, 218)上的像素修改后的BGR值是 [255, 255, 255]说明
</code></pre>
<p>对于BGR色彩空间的图像，当每个像素的B、G、R的3个数值相等时，就可以得到灰度图像。其中，B=G=R=0为纯黑色，B=G=R=255为纯白色。</p>
<p>【实例4.2】　修改图4.1中指定区域内的所有像素。<br>编写一个程序，将图4.1中的坐标(241, 168)、(241, 218)、(291, 168)和(291, 218)的4个点所围成的区域内的所有像素都修改为纯白色，代码如下：</p>
<p><img src="/.com//image-20211118053821109.png" alt="image-20211118053821109">上述代码的运行结果如图4.8所示（左侧的图片是原图)。</p>
<p><img src="/.com//image-20211118054002437.png" alt="image-20211118054002437"></p>
<p>​                                                           图4.8　把指定区域内的所有像素都修改为白色</p>
<h2 id="4-2-使用NumPy模块操作像素"><a href="#4-2-使用NumPy模块操作像素" class="headerlink" title="4.2　使用NumPy模块操作像素"></a>4.2　使用NumPy模块操作像素</h2><p>图像在OpenCV中以二维或三维数组表示，数组中的每一个值就是图像的像素值。善于操作数组的NumPy模块就成了OpenCV的依赖包。OpenCV中很多操作都要依赖NumPy模块，例如创建纯色图像、创建掩模和创建卷积核等。本节将简单介绍NumPy模块的常用操作方法，并演示如何利用NumPy模块创建图像。</p>
<h3 id="4-2-1-NumPy概述"><a href="#4-2-1-NumPy概述" class="headerlink" title="4.2.1　NumPy概述"></a>4.2.1　NumPy概述</h3><p>NumPy（见图4.9）更像是一个魔方（见图4.10），它是Python数组计算、矩阵运算和科学计算的核心库，NumPy来源于Numerical和Python两个单词。NumPy提供了一个高性能的数组对象，以及可以轻松创建一维数组、二维数组和多维数组等大量实用方法，帮助开发者轻松地进行数组计算，从而广泛地应用于数据分析、机器学习、图像处理和计算机图形学、数学任务等领域中。由于NumPy是由C语言实现的，所以其运算速度非常快。具体功能如下。　</p>
<p>有一个强大的N维数组对象ndarray。　</p>
<p>广播功能方法。　</p>
<p>线性代数、傅里叶变换、随机数生成、图形操作等功能。　</p>
<p>整合C/C++/Fortran代码的工具。</p>
<p><img src="/.com//image-20211118054232190.png" alt="image-20211118054232190"></p>
<p>​                                                                                              图4.9　NumPy</p>
<p><img src="/.com//image-20211118054256857.png" alt="image-20211118054256857"></p>
<p>​                                                                                                      图4.10　魔方</p>
<h3 id="4-2-2-数组的类型"><a href="#4-2-2-数组的类型" class="headerlink" title="4.2.2　数组的类型"></a>4.2.2　数组的类型</h3><p>在对数组进行基本操作前，首先了解一下NumPy的数据类型。NumPy比Python增加了更多种类的数值类型，如表4.1所示，为了区别于Python数据类型，NumPy中的bool、int、float、complex等数据类型名称末尾都加了短下画线“_”。</p>
<p>表4.1　NumPy数据类型</p>
<p><img src="/.com//image-20211118054337712.png" alt="image-20211118054337712"></p>
<p>每一种数据类型都有相应的数据转换方法。举例如下：</p>
<pre><code> np.int8(3.141)
 np.float64(8)
 np.float(True)
</code></pre>
<p>结果为：</p>
<p>​     3<br>​     8.0<br>​     1.0</p>
<h3 id="4-2-3-创建数组"><a href="#4-2-3-创建数组" class="headerlink" title="4.2.3　创建数组"></a>4.2.3　创建数组</h3><p>NumPy提供了很多创建数组的方法，下面分别介绍。</p>
<p>1．最常规的array()方法<br>NumPy创建简单的数组主要使用array()方法，通过传递列表、元组来创建NumPy数组，其中的元素可以是任何对象，语法如下：</p>
<pre><code> numpy.array(object, dtype, copy, order, subok, ndmin)
</code></pre>
<p>参数说明：　</p>
<p>object：任何具有数组接口方法的对象。　</p>
<p>dtype：数据类型。　</p>
<p>copy：可选参数，布尔型，默认值为True，则object对象被复制；否则，只有当__array__返回副本，object参数为嵌套序列，或者需要副本满足数据类型和顺序要求时，才会生成副本。　</p>
<p>order：元素在内存中的出现顺序，其值为K、A、C、F。如果object参数不是数组，则新创建的数组将按行排列（C），如果值为F，则按列排列；如果object参数是一个数组，则以下顺序成立：C（按行）、F（按列）、A（原顺序）、K（元素在内存中的出现顺序）。</p>
<p>说明<br>当order是’ A ‘，object是一个既不是’ C ‘也不是’ F ‘ order的数组，并且由于dtype的更改而强制执行了一个副本时，那么结果的顺序不一定是’ C ‘。这可能是一个bug。</p>
<p>subok：布尔型。如果值为True，则传递子类，否则返回的数组将强制为基类数组（默认值）。　</p>
<p>ndmin：指定生成数组的最小维数。<br>下面通过一个实例演示如何创建一维数组和二维数组。</p>
<p>【实例4.3】　创建一维和二维数组。（实例位置：资源包\TM\sl\4\03）<br>分别创建一维数组和二维数组，效果如图4.11所示。</p>
<p><img src="/.com//image-20211118054551232.png" alt="image-20211118054551232"></p>
<p>​                                                                                                  图4.11　简单数组<br>具体代码如下：</p>
<pre><code> import numpy as np            #导入numpy模块
 n1 = np.array([1,2,3])        #创建一个简单的一维数组
 n2 = np.array([0.1,0.2,0.3])  #创建一个包含小数的一维数组
 n3 = np.array([[1,2],[3,4]])  #创建一个简单的二维数组
</code></pre>
<p>【实例4.4】　创建浮点类型数组。（实例位置：资源包\TM\sl\4\04）</p>
<p>NumPy支持比Python更多种类的数据类型，通过dtype参数可以指定数组的数据类型，具体代码如下：<br>运行结果如下：</p>
<pre><code>  [1. 2. 3.]
 float64
 &lt;class &#39;numpy.float64&#39;&gt;
</code></pre>
<p> 【实例4.5】　创建三维数组。（实例位置：资源包\</p>
<p>创建三维数组是将ndmin参数值设为3即可得到三维数组，具体代码如下：</p>
<pre><code> import numpy as np
 nd1 = [1, 2, 3]
 nd2 = np.array(nd1, ndmin=3)  #三维数组
 print(nd2)
</code></pre>
<p>运行结果如下：</p>
<pre><code> [[[1 2 3]]]
</code></pre>
<p>由此结果可以看出一维数组被转换成了三维数组。2．创建指定维度和数据类型未初始化的数组<br>创建指定维度和数据类型未初始化的数组主要使用empty()方法，数组元素因为未被初始化会自动取随机值。如果要改变数组类型，可以使用dtype参数，如将数组类型设为整型，dtype=int。【实例4.6】　创建2行3列的未初始化数组。（实例位置：资源包\TM\sl\4\06）<br>创建2行3列的未初始化数组，具体代码如下：</p>
<pre><code> import numpy as np
 n = np.empty([2, 3])
 print(n)
</code></pre>
<p>运行结果如下：</p>
<pre><code> [[2.22519099e-307 2.33647355e-307 1.23077925e-312]
  [2.33645827e-307 2.67023123e-307 1.69117157e-306]]
</code></pre>
<p>5．创建随机数组<br>randint()方法用于生成一定范围内的随机整数数组，左闭右开区间（[low,high)），语法如下：</p>
<pre><code> numpy.random.randint(low,high,size)
</code></pre>
<p>参数说明：　</p>
<p>low：随机数最小取值范围。　</p>
<p>high：可选参数，随机数最大取值范围。若high为空，取值范围为（0，low）。若high不为空，则high必须大于low。　</p>
<p>size：可选参数，数组维数。</p>
<p>【实例4.9】　创建随机数组。（实例位置：资源包\TM\sl\4\09）<br>生成一定范围内的随机数组，具体代码如下：</p>
<pre><code> import numpy as np
 n1 = np.random.randint(1, 3, 10)
 print(&#39;随机生成10个1～3且不包括3的整数：&#39;)
 print(n1)
 n2 = np.random.randint(5, 10)
 print(&#39;size数组大小为空随机返回一个整数：&#39;)
 print(n2)
 n3 = np.random.randint(5, size=(2, 5))
 print(&#39;随机生成5以内二维数组：&#39;)
 print(n3)
</code></pre>
<p>运行结果如下：</p>
<pre><code> 随机生成10个1～3且不包括3的整数：
 [1 1 2 1 1 1 2 2 2 1]
 size数组大小为空随机返回一个整数：
 7
</code></pre>
<h3 id="4-2-4-操作数组"><a href="#4-2-4-操作数组" class="headerlink" title="4.2.4　操作数组"></a>4.2.4　操作数组</h3><p>不用编写循环即可对数据执行批量运算，这就是NumPy数组运算的特点，NumPy称为矢量化。大小相等的数组之间的任何算术运算都可以用NumPy实现。本节主要介绍如何复制数组和简单的数组运算。</p>
<p>1．加法运算<br>例如，加法运算是数组中对应位置的元素相加（即每行对应相加），如图4.12所示。</p>
<p><img src="/.com//image-20211118054822245.png" alt="image-20211118054822245"></p>
<p>​                                                                                 图4.12　数组加法运算示意图</p>
<p>【实例4.10】　对数组做加法运算。（实例位置：资源包\TM\sl\4\10）<br>使用NumPy创建2个数组，并让2个数据进行加法运算，具体代码如下：</p>
<pre><code> import numpy as np
 n1 = np.array([1, 2])  # 创建一维数组
 n2 = np.array([3, 4])
 print(n1 + n2)         # 加法运算
</code></pre>
<p>运行结果如下：</p>
<pre><code> [4 6]2．减法和乘除法运算
</code></pre>
<p>除了加法运算，还可以实现数组的减法、乘法和除法，如图4.13所示。</p>
<p><img src="/.com//image-20211118054909470.png" alt="image-20211118054909470"></p>
<p>​                                                                                图4.13　数组减法和乘除法运算示意图</p>
<p>【实例4.11】　对数组做减法、乘法和除法运算。（实例位置：资源包\TM\sl\4\11）<br>使用NumPy创建2个数组，并让2个数组进行减法、乘法和除法运算，具体代码如下：</p>
<p><img src="/.com//image-20211118054951102.png" alt="image-20211118054951102">运行结果如下：</p>
<pre><code> [-2 -2]
 [3 8]
 [0.33333333 0.5  ]3．幂运算
</code></pre>
<p>幂是数组中对应位置元素的幂运算，使用“**”运算符进行运算，效果如图4.14所示。从图中得出：数组n1的元素1和数组n2的元素3，通过幂运算得到的是1的3次幂；数组n1的元素2和数组n2的元素4，通过幂运算得到的是2的4次幂。</p>
<p><img src="/.com//image-20211118055007461.png" alt="image-20211118055007461"></p>
<p>​                                                                                  图4.14　数组幂运算示意图</p>
<p>【实例4.12】　两个数组做幂运算。（实例位置：资源包\TM\sl\4\12）<br>使用NumPy创建2个数组，并让2个数组做幂运算，具体代码如下：</p>
<pre><code> import numpy as np
 n1 = np.array([1, 2])  # 创建一维数组
 n2 = np.array([3, 4])
 print(n1 ** n2)        # 幂运算
</code></pre>
<p>运行结果如下：</p>
<pre><code> [ 1 16]4．比较运算
</code></pre>
<p>NumPy创建的数组可以使用逻辑运算符进行比较运算，运算的结果是布尔值数组，数组中的布尔值为相比较的数组在相同位置元素的比较结果。</p>
<p>【实例4.13】　使用逻辑运算符比较数组。（实例位置：资源包\TM\sl\4\13）<br>使用NumPy创建2个数组，分别使用“&gt;=”“==”“&lt;=”和“!=”运算符比较2个数组，具体代码如下：</p>
<p><img src="/.com//image-20211118055106239.png" alt="image-20211118055106239"></p>
<p>运行结果如下：</p>
<pre><code> [False False]
 [False False]
 [ True  True]
 [ True  True]5．复制数组
</code></pre>
<p>NumPy提供的array()方法可以使用如下语法复制数据：</p>
<pre><code> n2 = np.array(n1, copy=True)
</code></pre>
<p>但开发过程中更常用的是copy()方法，其语法如下：</p>
<pre><code> n2 = n1.copy()
</code></pre>
<p>这两种方法都可以按照原数组的结构、类型、元素值创建出一个副本，修改副本中的元素不会影响到原数组。</p>
<p>【实例4.14】　复制数据，比较复制的结果与原数组是否相同。（实例位置：资源包\TM\sl\4\14）<br>使用copy()方法复制数组，比较2个数组是否相同。修改副本数组中的元素值后，再查看2个数组是否相同，具体代码如下：</p>
<p><img src="/.com//image-20211118055207036.png" alt="image-20211118055207036"></p>
<p>运行结果如下：</p>
<pre><code> [ True  True]
 [1 2]
 [9 2]
 [False  True]
</code></pre>
<h3 id="4-2-5-数组的索引和切片"><a href="#4-2-5-数组的索引和切片" class="headerlink" title="4.2.5　数组的索引和切片"></a>4.2.5　数组的索引和切片</h3><p>NumPy数组元素是通过数组的索引和切片来访问和修改的，因此索引和切片是NumPy中最重要、最常用的操作。</p>
<p>1．索引<br>所谓数组的索引，即用于标记数组中对应元素的唯一数字，从0开始，即数组中的第一个元素的索引是0，依次类推。NumPy数组可以使用标准Python语法x[obj]的语法对数组进行索引，其中x是数组，obj是选择方式。</p>
<p>【实例4.15】　查找一维数组索引为0的元素。（实例位置：资源包\TM\sl\4\15）<br>查找数组n1索引为0的元素，具体代码如下：</p>
<pre><code> import numpy as np
 n1=np.array([1,2,3])  #创建一维数组
 print(n1[0])
</code></pre>
<p>运行结果如下：</p>
<p>1</p>
<p>2．切片式索引<br>数组的切片可以理解为对数组的分割，按照等分或者不等分，将一个数组切割为多个片段，与Python中列表的切片操作一样。NumPy中用冒号分隔切片参数来进行切片操作，语法如下：</p>
<pre><code> [start:stop:step]
</code></pre>
<p>参数说明：　</p>
<p>start：起始索引，若不写任何值，则表示从0开始的全部索引。　</p>
<p>stop：终止索引，若不写任何值，则表示直到末尾的全部索引。　</p>
<p>step：步长。<br>例如，对数组n1进行一系列切片式索引操作的示意图如图4.15所示。</p>
<p><img src="/.com//image-20211118055256979.png" alt="image-20211118055256979"></p>
<p>​                                                                                图4.15　切片式索引示意图</p>
<p>【实例4.16】　获取数组中某范围内的元素。（实例位置：资源包\TM\sl\4\16）<br>按照图4.15所示的切片式索引操作获取数据中某范围的元素，具体代码如下：<br>运行结果如下：</p>
<pre><code> 1
 2
 [1 2]
 [2 3]
</code></pre>
<p>[1 2]<br>切片式索引操作需要注意以下几点。<br>（1）索引是左闭右开区间，如上述代码中的n1[0:2]，只能取到索引从0～1的元素，而取不到索引为2的元素。<br>（2）当没有start参数时，代表从索引0开始取数，如上述代码中的n1[:2]。<br>（3）start、stop和step 3个参数都可以是负数，代表反向索引。以step参数为例，如图4.16所示。</p>
<p><img src="/.com//image-20211118055352405.png" alt="image-20211118055352405"></p>
<p>​                                                                                      图4.16　反向索引示意图</p>
<p>【实例4.17】　使用不同的切片式索引操作获取数组中的元素。（实例位置：资源包\TM\sl\4\17）<br>分别演示start、stop、step 3种索引的切片场景，具体代码如下：</p>
<p><img src="/.com//image-20211118055419253.png" alt="image-20211118055419253"></p>
<p>运行结果如下：</p>
<pre><code> [0 1 2 3 4 5 6 7 8 9]
 [0 1 2]
 [3 4 5]
 [6 7 8 9]
 [0 1 2 3 4 5 6 7 8 9]
 [0 1 2 3 4 5 6 7 8 9]
 [0 2 4 6 8]
 [1 6]
 [2 8]
 [9 8 7 6 5 4 3 2 1 0]
 [9 8]
 [7 6]
 [5 4 3 2 1 0]
</code></pre>
<p>3．二维数组索引<br>二维数组索引可以使用array[n,m]的方式，以逗号分隔，表示第n个数组的第m个元素。<br>例如，创建一个3行4列二维数组，实现简单的索引操作，效果如图4.17所示。</p>
<p><img src="/.com//image-20211118055517374.png" alt="image-20211118055517374"></p>
<p>图4.17　二维数组索引示意图</p>
<p>【实例4.18】　用3种方式获取二维数组中的元素。（实例位置：资源包\TM\sl\4\18）<br>分别获取二维数组中索引为1的元素、第2行第3列的元素、索引为-1的元素，具体代码如下：</p>
<pre><code> import numpy as np
 #创建3行4列的二维数组
 n=np.array([[0,1,2,3],[4,5,6,7],[8,9,10,11]])
 print(n[1])
 print(n[1,2])
 print(n[-1])
</code></pre>
<p>运行结果如下：</p>
<pre><code> [4 5 6 7]
 6
 [ 8  9 10 11]
</code></pre>
<p>上述代码中，n[1]表示第2个数组，n[1,2]表示第2个数组第3个元素，它等同于n[1][2]，表示数组n中第2行第3列的值，即n[1][2]先索引第一个维度得到一个数组，然后在此基础上再索引。</p>
<p>4．二维数组切片式索引<br>二维数组也支持切片式索引操作，如图4.18所示就是获取二维数组中某一块区域的索引。</p>
<p><img src="/.com//image-20211118055605378.png" alt="image-20211118055605378"></p>
<p>​                                                              图4.18　二维数组切片式索引示意图</p>
<p>【实例4.19】　对二维数组进行切片式索引操作。（实例位置：资源包\TM\sl\4\19）<br>参照图4.18创建二维数组，对该数组进行切片式索引操作，具体代码如下：</p>
<pre><code> import numpy as np
 # 创建3行3列的二维数组
 n = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
 print(n[:2, 1:])
 print(n[1, :2])
 print(n[:2, 2])
 print(n[:, :1])
</code></pre>
<p>运行结果如下：</p>
<pre><code> [[2 3]
  [5 6]]
 [4 5]
 [3 6]
 [[1]
  [4]
  [7]]注意
</code></pre>
<p>数组索引、像素行列和像素坐标的关系如下。</p>
<p>数组行索引=像素所在行数-1=像素纵坐标。<br>数组列索引=像素所在列数-1=像素横坐标。</p>
<h3 id="4-2-6-创建图像"><a href="#4-2-6-创建图像" class="headerlink" title="4.2.6　创建图像"></a>4.2.6　创建图像</h3><p>在OpenCV中，黑白图像实际上就是一个二维数组，彩色图像是一个三维数组。数组中每个元素就是图像对应位置的像素值。因此修改图像像素的操作实际上就是修改数组的操作。本节将介绍几个在OpenCV中常用的操作。</p>
<p>1．创建黑白图像<br>在黑白图像中，像素值为0表示纯黑，像素值为255表示纯白。</p>
<p>【实例4.20】　创建纯黑图像。（实例位置：资源包\TM\sl\4\20）<br>创建一个100行、200列（即宽200、高100）的数组，数组元素格式为无符号8位整数，用0填充整个数组，将该数组当作图像显示出来，具体代码如下：</p>
<p><img src="/.com//image-20211118055711105.png" alt="image-20211118055711105"></p>
<p>运行结果如图4.19所示。</p>
<p><img src="/.com//image-20211118055728732.png" alt="image-20211118055728732"></p>
<p>​                                                                                  图4.19　宽200、高100的纯黑图像<br>创建纯白图像有两种方式：第一种是先纯黑图像，然后将图像中所有的像素值改为255；第二种使用NumPy提供的ones()方法创建一个像素值均为1的数组，然后让数组乘以255。</p>
<p>【实例4.21】　创建纯白图像。（实例位置：资源包\TM\sl\4\21）<br>创建一个100行、200列（即宽200、高100）的数组，数组元素格式为无符号8位整数，用1填充整个数组，然后让数组乘以255，最后将该数组当作图像显示出来，具体代码如下：</p>
<p><img src="/.com//image-20211118055838709.png" alt="image-20211118055838709"></p>
<p>运行结果如图4.20所示。</p>
<p><img src="/.com//image-20211118055855352.png" alt="image-20211118055855352"></p>
<p>​                                                                         图4.20　宽200、高100的纯白图像<br>通过切片式索引操作可以修改图像中指定区域内的像素，从而达到修改图像内容的效果，下面通过实例来展示。</p>
<p>【实例4.22】　在黑图像内部绘制白色矩形。（实例位置：资源包\TM\sl\4\22）<br>先绘制纯黑图像作为背景，然后使用切片式索引操作将图像中横坐标为50<del>100、纵坐标为25</del>75的矩形区域颜色改为纯白色，具体代码如下：</p>
<p><img src="/.com//image-20211118055923134.png" alt="image-20211118055923134"></p>
<p>运行结果如图4.21所示。</p>
<p><img src="/.com//image-20211118055940627.png" alt="image-20211118055940627"></p>
<p>​                                                                              图4.21　在黑色图像内部绘制白色矩形<br>若将切片式索引操作引入循环内，则可以绘制带有规律的几何图像，下面通过实例来展示。</p>
<p>【实例4.23】　创建黑白相间的图像。（实例位置：资源包\TM\sl\4\23）<br>先绘制纯黑图像作为背景，然后在循环中使用切片式索引操作绘制黑白间隔图像，具体代码如下：</p>
<p><img src="/.com//image-20211118060035152.png" alt="image-20211118060035152"></p>
<p>运行结果如图4.22所示。</p>
<p><img src="/.com//image-20211118060052474.png" alt="image-20211118060052474"></p>
<p>​                                                                                 图4.22　黑白相间的图像</p>
<p>2．创建彩色图像<br>以上实例演示的都是用二维数组表示的黑白图像，而当显示生活中丰富多彩的颜色需要引入光谱三基色的概念时，无法用二维数组表示，而要用到三维数组。OpenCV中彩色图像默认为BGR格式，彩色图像的第三个索引表示的就是蓝、绿、红3种颜色的分量。</p>
<p>【实例4.24】　创建彩色图像。（实例位置：资源包\TM\sl\4\24）<br>创建彩色图像数组时要将数组创建成三维数组，元素类型仍然为无符号8位整数。创建好表示纯黑图像的三维数组后，复制出3个副本，3个副本分别修改最后一个索引代表的元素值。根据BGR的顺序，索引0表示蓝色分量，索引1表示绿色分量，索引2表示红色分量，让3个副本分别显示纯蓝、纯绿和纯红，具体代码如下：</p>
<p><img src="/.com//image-20211118060117266.png" alt="image-20211118060117266"></p>
<p>运行结果如图4.23～图4.25所示。</p>
<p><img src="/.com//image-20211118060249284.png" alt="image-20211118060249284"></p>
<pre><code>         图4.23　纯蓝图像图                 4.24　纯绿图像图                                 4.25　纯红图像
</code></pre>
<p>3．创建随机图像<br>随机图像是指图像中每一个像素值都是随机生成的，因为像素之间不会组成有效的视觉信息，所以这样的图像看上去就像杂乱无章的沙子。虽然随机图像没有任何视觉信息，但对于图像处理技术仍然很重要，毫无规律的像素数组被称为干扰图像的噪声，可以当作图像加密的密钥。<br>下面介绍如何利用NumPy创建随机图像。</p>
<p>【实例4.25】　创建随机像素的雪花点图像。（实例位置：资源包\TM\sl\4\25）<br>使用NumPy提供的random.randint()方法就可以创建随机数组，将随机值的取值范围设定在0～256（即像素值范围），元素类型设定为无符号8位整数，具体代码如下：</p>
<p><img src="/.com//image-20211118060413130.png" alt="image-20211118060413130"></p>
<p>运行结果如图4.26所示。<br>这个实例演示的是随机的黑白图像，random.randint()方法在指定数组行列后默认创建的是二维数组，如果创建的是三维数组，就可以获得随机彩色图像。创建三维随机数组仅需修改size参数中的维度参数，修改后的代码如下：</p>
<pre><code> img = np.random.randint(256, size=(height, width, 3), dtype=np.uint8)
</code></pre>
<p>再次运行后随机彩色图像效果如图4.27所示。</p>
<p><img src="/.com//image-20211118060503763.png" alt="image-20211118060503763"></p>
<p>图4.26　随机黑白图像</p>
<p><img src="/.com//image-20211118060553084.png" alt="image-20211118060553084"></p>
<p>图4.27　随机彩色图像</p>
<h3 id="4-2-7-拼接图像"><a href="#4-2-7-拼接图像" class="headerlink" title="4.2.7　拼接图像"></a>4.2.7　拼接图像</h3><p>NumPy提供了两种拼接数组的方法，分别是hstack()方法和vstack()方法。这两种拼接方法同样可用于拼接图像，下面分别介绍。1．水平拼接数组<br>hstack()方法可以对数组进行水平拼接（或叫横向拼接），其语法如下：</p>
<pre><code> array = numpy.hstack(tup)
</code></pre>
<p>参数说明：　</p>
<p>tup：要拼接的数组元组。<br>返回值说明：　</p>
<p>array：将参数元组中的数组水平拼接后生成的新数组。<br>hstack()方法可以拼接多个数组，拼接效果如图4.28所示。被拼接的数组必须在每一个维度都具有相同的长度，也就是数组“形状相同”，例如2行2列的数组只能拼接2行2列的数组，否则会出现错误。</p>
<p><img src="/.com//image-20211118060627002.png" alt="image-20211118060627002"></p>
<p>图4.28　水平拼接2个数组<br>例如，创建3个一维数组，将这3个数组进行水平拼接，代码如下：</p>
<p>import numpy as np<br>     a = np.array([1, 2, 3])<br>     b = np.array([4, 5, 6])<br>     c = np.array([7, 8, 9])<br>     result = np.hstack((a, b, c))<br>     print(result)<br>运行结果如下：</p>
<pre><code> [1 2 3 4 5 6 7 8 9]
</code></pre>
<p>从这个结果可以看出，一维数组进行水平拼接之后，会生成一个较长的、包含所有元素的新一维数组。2．垂直拼接数组<br>vstack()方法可以对数组进行垂直拼接（或叫纵向拼接），其语法如下：</p>
<pre><code> array = numpy.vstack(tup)
</code></pre>
<p>参数说明：　</p>
<p>tup：要拼接的数组元组。<br>返回值说明：　</p>
<p>array：将参数元组中的数组垂直拼接后生成的新数组。<br>vstack()方法可以拼接多个数组，拼接效果如图4.29所示。被拼接的数组的格式要求与hstack()方法相同。</p>
<p><img src="/.com//image-20211118060727628.png" alt="image-20211118060727628"></p>
<p>图4.29　垂直拼接2个数组<br>例如，创建3个一维数组，将这3个数组进行垂直拼接，代码如下：</p>
<pre><code> import numpy as np
 a = np.array([1, 2, 3])
 b = np.array([4, 5, 6])
 c = np.array([7, 8, 9])
 result = np.vstack((a, b, c))
 print(result)
</code></pre>
<p>运行结果如下：</p>
<pre><code> [[1 2 3]
  [4 5 6]
  [7 8 9]]
</code></pre>
<p>从这个结果可以看出，一维数组进行垂直拼接后，生成一个三维数组，每一个被拼接的一维数组都形成三维数组中的一行。</p>
<p>3．在图像处理中的应用</p>
<p>在OpenCV中，图像就是一个二维或三维的像素数组，这些数组同样可以被NumPy拼接，下面通过一个实例展示图像拼接的效果。</p>
<p>【实例4.26】　按照水平和垂直2种方式拼接2幅图像。（实例位置：资源包\TM\sl\4\26）<br>读取一幅图像，让该图像拼接自身图像，分别用水平和垂直2种方式拼接，具体代码如下：</p>
<p><img src="/.com//image-20211118060817990.png" alt="image-20211118060817990"></p>
<p>运行效果如图4.30和图4.31所示。</p>
<p><img src="/.com//image-20211118061009035.png" alt="image-20211118061009035"></p>
<p>​                                                            图4.30　水平拼接的效果</p>
<p><img src="/.com//image-20211118061107773.png" alt="image-20211118061107773"></p>
<p>​                                                                                  图4.31　垂直拼接的效果</p>
<h2 id="4-3-小结"><a href="#4-3-小结" class="headerlink" title="4.3　小结"></a>4.3　小结</h2><p>本章详细讲解了像素和使用NumPy模块操作像素两个方面的内容。</p>
<p>注意掌握以下几个内容：一是在表示图像某一个像素的坐标的时候，正确的表示方式是（垂直像素，水平像素）；二是在OpenCV中，彩色图像的通道顺序是B→G→R；三是重点掌握且灵活运用NumPy模块实现图像的创建和图像的拼接。</p>
<h1 id="第5章-色彩空间与通道"><a href="#第5章-色彩空间与通道" class="headerlink" title="第5章　色彩空间与通道"></a>第5章　色彩空间与通道</h1><p>色彩是人类的眼睛对于不同频率的光线的不同感受，不同频率的光线既是客观存在的又是人类主观感知的。为了表示这些不同频率的光线的色彩，人类建立了多种色彩模型，把这些色彩模型称作色彩空间。OpenCV中的BGR色彩空间有3个通道，即表示蓝色的B通道、表示绿色的G通道和表示红色的R通道。本章将具体讲解色彩空间和通道，以及二者之间的紧密联系。</p>
<p><img src="/.com//image-20211118061230858.png" alt="image-20211118061230858"></p>
<h2 id="5-1-色彩空间"><a href="#5-1-色彩空间" class="headerlink" title="5.1　色彩空间"></a>5.1　色彩空间</h2><p>虽然Photoshop把一幅彩色图像的色彩空间默认为RGB色彩空间，但是OpenCV把一幅彩色图像的色彩空间默认为BGR色彩空间，这是因为OpenCV拆分一幅彩色图像的通道后，默认的通道顺序是B→G→R。熟悉了BGR色彩空间后，本节将结合如图5.1所示的图像（本书彩色图像见资源包），介绍另外两个比较常见的色彩空间：GRAY色彩空间和HSV色彩空间。</p>
<p><img src="/.com//1.1-16371871184721.jpg" alt="1.1"></p>
<p>​                                                                                                图5.1　一幅彩色图像</p>
<h3 id="5-1-1-GRAY色彩空间"><a href="#5-1-1-GRAY色彩空间" class="headerlink" title="5.1.1　GRAY色彩空间"></a>5.1.1　GRAY色彩空间</h3><p>1．什么是GRAY色彩空间<br>GRAY色彩空间通常指的是灰度图像，灰度图像是一种每个像素都是从黑到白，被处理为256个灰度级别的单色图像。这256个灰度级别分别用区间[0, 255]中的数值表示。其中，“0”表示纯黑色，“255”表示纯白色，0～255的数值表示</p>
<p>不同亮度（即色彩的深浅程度）的深灰色或者浅灰色。因此，一幅灰度图像也能够展现丰富的细节信息，如图5.2所示。</p>
<p><img src="/.com//image-20211118061419144.png" alt="image-20211118061419144"></p>
<p>​                                                   图5.2　一幅灰度图像</p>
<p>2．从BGR色彩空间转换到GRAY色彩空间<br>读者朋友很容易就会发现，图5.1和图5.2是同一幅图像。只不过，图5.1是彩色图像，而图5.2是灰度图像。OpenCV能够将同一幅图像从一个色彩空间转换到另一个色彩空间。例如，图5.1从BGR色彩空间转换到图5.2所示的GRAY色彩空间。<br>那么，OpenCV是如何实现从BGR色彩空间转换到GRAY色彩空间的呢？答案就是OpenCV中用于转换图像色彩空间的cvtColor()方法，其语法格式如下：</p>
<pre><code> dst = cv2.cvtColor(src, code)
</code></pre>
<p>参数说明：　</p>
<p>dst：转换后的图像。　</p>
<p>src：转换前的初始图像。　</p>
<p>code：色彩空间转换码。</p>
<p>说明<br>当图像从BGR色彩空间转换到GRAY色彩空间时，常用的色彩空间转换码是cv2.COLOR_BGR2GRAY。</p>
<p>【实例5.1】　从BGR色彩空间转换到GRAY色彩空间。（实例位置：资源包\TM\sl\5\01）<br>编写一个程序，将图5.1从BGR色彩空间转换到GRAY色彩空间，代码如下：</p>
<p><img src="/.com//image-20211118061511239.png" alt="image-20211118061511239"></p>
<p>上述代码的运行结果如图5.3所示。</p>
<p><img src="/.com//image-20211118061629219.png" alt="image-20211118061629219"></p>
<p>​                                                      图5.3从BGR色彩空间转换到GRAY色彩空间</p>
<p>说明<br>虽然色彩空间类型转换是双向的，而且OpenCV也提供了cv2.COLOR_GRAY2BGR（从GRAY色彩空间转换到BGR色彩空间）和cv2.COLOR_ BGR2GRAY（从BGR色彩空间转换到GRAY色彩空间）2个色彩空间转换码，但是灰度图像是无法转换成彩色图像的。这是因为在彩色图像转换成灰度图像的过程中，丢失了颜色比例（即红色、绿色和蓝色之间的混合比例）。这些比例一旦丢失，就再也找不回来了。</p>
<h3 id="5-1-2-HSV色彩空间"><a href="#5-1-2-HSV色彩空间" class="headerlink" title="5.1.2　HSV色彩空间"></a>5.1.2　HSV色彩空间</h3><p>1．什么是HSV色彩空间<br>BGR色彩空间是基于三基色而言的，三基色指的是红色、绿色和蓝色。而HSV色彩空间则是基于色调、饱和度和亮度而言的。<br>其中，色调（H）是指光的颜色，例如，彩虹中的赤、橙、黄、绿、青、蓝、紫分别表示不同的色调，如图5.4所示。在OpenCV中，色调在区间[0, 180]内取值。例如，代表红色、黄色、绿色和蓝色的色调值分别为0、30、60和120。<br>饱和度（S）是指色彩的深浅。在OpenCV中，饱和度在区间[0, 255]内取值。当饱和度为0时，图像将变为灰度图像。例如，图5.1是用手机拍摄的原图像，图5.5是把图5.1的饱和度调为0时的效果。</p>
<p><img src="/.com//image-20211118061921187.png" alt="image-20211118061921187"></p>
<p>​                                                                                        图5.4　彩虹中的色调</p>
<p><img src="/.com//image-20211118061951173.png" alt="image-20211118061951173"></p>
<p>​                                                                          图5.5　图5.1的饱和度调为0时的效果<br>如图5.6所示，亮度（V）是指光的明暗。与饱和度相同，在OpenCV中，亮度在区间[0, 255]内取值。亮度值越大，图像越亮；当亮度值为0时，图像呈纯黑色。</p>
<p><img src="/.com//image-20211118062031261.png" alt="image-20211118062031261"></p>
<p>​                                                                                                 图5.6　光的明暗</p>
<p>2．从BGR色彩空间转换到HSV色彩空间<br>OpenCV提供的cvtColor()方法不仅能将图像从BGR色彩空间转换到GRAY色彩空间，还能将图像从BGR色彩空间转换到HSV色彩空间。当图像在BGR色彩空间和HSV色彩空间之间转换时，常用的色彩空间转换码是cv2.COLOR_BGR2HSV和cv2.COLOR_HSV2BGR。</p>
<p>【实例5.2】　从BGR色彩空间转换到HSV色彩空间。（实例位置：资源包\TM\sl\5\02）<br>编写一个程序，将图5.1从BGR色彩空间转换到HSV色彩空间，代码如下：</p>
<pre><code> import cv2
 image = cv2.imread(&quot;D:/5.1.jpg&quot;)
 cv2.imshow(&quot;5.1&quot;, image)                 # 显示图5.1
 # 将图5.1从BGR色彩空间转换到HSV色彩空间
 hsv_image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
 cv2.imshow(&quot;HSV&quot;, hsv_image)             # 用HSV色彩空间显示的图像
 cv2.waitKey()
 cv2.destroyAllWindows()
</code></pre>
<p>上述代码的运行结果如图5.7所示。</p>
<p><img src="/.com//image-20211118062234401.png" alt="image-20211118062234401"></p>
<p>图5.7　把图5.1从BGR色彩空间转换到HSV色彩空间</p>
<h2 id="5-2-通道"><a href="#5-2-通道" class="headerlink" title="5.2　通道"></a>5.2　通道</h2><p>在BGR色彩空间中，图像的通道由B通道、G通道和R通道构成。本节将介绍如何使用OpenCV提供的方法拆分和合并通道。</p>
<h3 id="5-2-1-拆分通道"><a href="#5-2-1-拆分通道" class="headerlink" title="5.2.1　拆分通道"></a>5.2.1　拆分通道</h3><p>为了拆分图像中的通道，OpenCV提供了split()方法。</p>
<p>1．拆分一幅BGR图像中的通道<br>当使用split()方法拆分一幅BGR图像中的通道时，split()方法的语法如下：</p>
<pre><code> b, g, r = cv2.split(bgr_image)
</code></pre>
<p>参数说明：　</p>
<p>b：B通道图像。　</p>
<p>g：G通道图像。</p>
<p>r：R通道图像。　</p>
<p>bgr_image：一幅BGR图像。</p>
<p>【实例5.3】　拆分一幅BGR图像中的通道。（实例位置：资源包\TM\sl\5\03）<br>编写一个程序，先拆分图5.1中的通道，再显示拆分后的通道图像，代码如下：</p>
<p><img src="/.com//image-20211118062257967.png" alt="image-20211118062257967"></p>
<p>运行上述代码后，得到如图5.8所示的4个窗口。其中，图5.8（a）是原图像（见图5.1），图5.8（b）是图5.1中的B通道图像，图5.8（c）是图5.1中的G通道图像，图5.8（d）是图5.1中的R通道图像。</p>
<p>图5.8　拆分BGR图像中通道的效果</p>
<p>R通道是红色通道，G通道是绿色通道，B通道是蓝色通道。但是图5.9中的B通道图像、G通道图像和R通道图像是3幅不同亮度的灰度图像，这是为什么呢？<br>原因是当程序执行到cv2.imshow(“B”, b)时，原图像B、G、R这3个通道的值都会被修改为B通道图像的值，即(b, b, b)。同理，当程序执行到cv2.imshow(“G”, g)和cv2.imshow(“R”, r)时，原图像R、G、B这3个通道的值将依次被修改为G通道图像的值(g, g, g)和R通道图像的值(r, r, r)。对于BGR图像，只要B、G、R这3个通道的值都相同，就可以得到灰度图像。</p>
<p>2．拆分一幅HSV图像中的通道<br>当使用split()方法拆分一幅HSV图像中的通道时，split()方法的语法如下：</p>
<pre><code> h, s, v = cv2.split(hsv_image)
</code></pre>
<p>参数说明：　</p>
<p>h：H通道图像。　</p>
<p>s：S通道图像。　</p>
<p>v：V通道图像。　</p>
<p>hsv_image：一幅HSV图像。</p>
<p>【实例5.4】　拆分一幅HSV图像中的通道。（实例位置：资源包\TM\sl\5\04）<br>编写一个程序，首先将图5.1从BGR色彩空间转换到HSV色彩空间，然后拆分得到的HSV图像中的通道，最后显示拆分后的通道图像，代码如下：</p>
<p><img src="/.com//image-20211118062529046.png" alt="image-20211118062529046"></p>
<p>运行上述代码后，得到如图5.9所示的4个窗口。其中，图5.9（a）是原图像（见图5.1），图5.9（b）是图5.1中的H通道图像，图5.9（c）是图5.1中的S通道图像，图5.9（d）是图5.1中的V通道图像。</p>
<p><img src="/.com//image-20211118062558943.png" alt="image-20211118062558943"></p>
<p>​                                                                    图5.9　拆分HSV图像中通道的效果</p>
<h3 id="5-2-2-合并通道"><a href="#5-2-2-合并通道" class="headerlink" title="5.2.2　合并通道"></a>5.2.2　合并通道</h3><p>合并通道是拆分通道的逆过程。以图5.1为例，虽然拆分通道后，会得到3幅不同亮度的灰度图像；但是将这3幅不同亮度的灰度图像合并后，又重新得到图5.1。下面将使用OpenCV中用于合并通道的merge()方法，验证一下上述说法。</p>
<p>1．合并B通道图像、G通道图像和R通道图像<br>当使用merge()方法按B→G→R的顺序合并通道时，merge()方法的语法如下：</p>
<pre><code> bgr = cv2.merge([b, g, r])
</code></pre>
<p>参数说明：　</p>
<p>bgr：按B→G→R的顺序合并通道后得到的图像。</p>
<p>b：B通道图像。</p>
<p>g：G通道图像。　</p>
<p>r：R通道图像。</p>
<p>【实例5.5】　合并B通道图像、G通道图像和R通道图像。（实例位置：资源包\TM\sl\5\05）<br>编写一个程序，按B→G→R的顺序对图5.1执行先拆分通道，再合并通道，代码如下：</p>
<p><img src="/.com//image-20211118062834827.png" alt="image-20211118062834827"></p>
<p>上述代码的运行结果如图5.10所示。</p>
<p><img src="/.com//image-20211118062855098.png" alt="image-20211118062855098"></p>
<p>​                                                                       图5.10　按B→G→R的顺序合并通道后的图像</p>
<p>2．合并H通道图像、S通道图像和V通道图像<br>当使用merge()方法合并H通道图像、S通道图像和V通道图像时，merge()方法的语法如下：</p>
<pre><code> hsv = cv2.merge([h, s, v])
</code></pre>
<p>参数说明：　</p>
<p>hsv：合并H通道图像、S通道图像和V通道图像后得到的图像。　</p>
<p>h：H通道图像。　</p>
<p>s：S通道图像。　</p>
<p>v：V通道图像。</p>
<p>【实例5.6】　合并H通道图像、S通道图像和V通道图像。（实例位置：资源包\TM\sl\5\06）<br>编写一个程序，首先将图5.1从BGR色彩空间转换到HSV色彩空间，然后拆分得到的HSV图像中的通道，接着合并拆分后的通道图像，最后将合并通道后的图像从HSV色彩空间转换到BGR色彩空间，代码如下：</p>
<p><img src="/.com//image-20211118062943783.png" alt="image-20211118062943783"></p>
<p>上述代码的运行结果如图5.11所示。</p>
<p><img src="/.com//image-20211118063132901.png" alt="image-20211118063132901"></p>
<p>​                                                         图5.11　合并H通道、S通道和V通道图像后的图像</p>
<p>说明<br>实例5.5和实例5.6分别对BGR色彩空间和HSV色彩空间的图5.1执行先拆分通道，再合并通道的操作，执行操作后的结果图像均与图5.1保持一致，印证了“以图5.1为例，虽然拆分通道后，得到3幅不同亮度的灰度图像，但是将这3幅不同亮度的灰度图像合并后，又重新得到图5.1”这一说法的正确性。</p>
<h3 id="5-2-3-综合运用拆分通道和合并通道"><a href="#5-2-3-综合运用拆分通道和合并通道" class="headerlink" title="5.2.3　综合运用拆分通道和合并通道"></a>5.2.3　综合运用拆分通道和合并通道</h3><p>在HSV色彩空间内，如果保持其中两个通道的值不变，调整第3个通道的值，会得到相应的艺术效果。</p>
<p>【实例5.7】　只把H通道的值调整为180。（实例位置：资源包\TM\sl\5\07）<br>编写一个程序，首先将图5.1从BGR色彩空间转换到HSV色彩空间；然后拆分HSV图像中的通道；接着让S通道和V通道的值保持不变，把H通道的值调整为180；再接着合并拆分后的通道图像，把这个图像从HSV色彩空间转换到BGR色彩空间；最后显示得到的BGR图像。代码如下：</p>
<p><img src="/.com//image-20211118063157781.png" alt="image-20211118063157781"></p>
<p>上述代码的运行结果如图5.12所示。</p>
<p><img src="/.com//image-20211118063242770.png" alt="image-20211118063242770"></p>
<p>​                                                 图5.12　原图像把H通道的值调整为180的效果<br>如果让H通道和S通道的值保持不变，把V通道的值调整为255，会得到什么样的效果呢？把实例5.7第8行代码：</p>
<pre><code> h[:, :] = 180 # 将H通道的值调整为180
</code></pre>
<p>修改为如下代码：</p>
<pre><code> v[:, :] = 255 # 将V通道的值调整为255
</code></pre>
<p>上述代码的运行结果如图5.13所示。</p>
<p><img src="/.com//image-20211118063302849.png" alt="image-20211118063302849"></p>
<p>​                                                     图5.13　原图像把V通道的值调整为255的效果<br>如果让H通道和V通道的值保持不变，把S通道的值调整为255，又会得到什么样的效果呢？把实例5.7第8行代码：</p>
<pre><code> h[:, :] = 180 # 将H通道的值调整为180
</code></pre>
<p>修改为如下代码：</p>
<pre><code> s[:, :] = 255 # 将S通道的值调整为255
</code></pre>
<p>上述代码的运行结果如图5.14所示。</p>
<p><img src="/.com//image-20211118063503250.png" alt="image-20211118063503250"></p>
<p>图5.14　原图像把S通道的值调整为255的效果</p>
<h3 id="5-2-4-alpha通道"><a href="#5-2-4-alpha通道" class="headerlink" title="5.2.4　alpha通道"></a>5.2.4　alpha通道</h3><p>BGR色彩空间包含了3个通道，即B通道、G通道和R通道。OpenCV在BGR色彩空间的基础上，又增加了一个用于设置图像透明度的A通道，即alpha通道。这样，形成一个由B通道、G通道、R通道和A通道4个通道构成的色彩空间，即BGRA色彩空间。在BGRA色彩空间中，alpha通道在区间[0, 255]内取值；其中，0表示透明，255表示不透明。</p>
<p>【实例5.8】　调整A通道的值。（实例位置：资源包\TM\sl\5\08）<br>编写一个程序，首先将图5.1从BGR色彩空间转换到BGRA色彩空间；然后拆分BGRA图像中的通道；接着把BGRA图像的透明度调整为172后，合并拆分后的通道图像；再接着把BGRA图像的透明度调整为0后，合并拆分后的通道图像；最后分别显示BGRA图像、透明度为172的BGRA图像和透明度为0的BGRA图像，代码如下：</p>
<p><img src="/.com//image-20211118063529768.png" alt="image-20211118063529768"></p>
<p>运行上述代码后，得到如图5.15所示的3个窗口。其中，图5.15（a）是BGRA图像（见图5.1），图5.15（b）是把BGRA图像的透明度调整为172后的图像，图5.15（c）是把BGRA图像的透明度调整为0后的图像。</p>
<p><img src="/.com//image-20211118063625877.png" alt="image-20211118063625877"></p>
<p>​                                                                              图5.15　调整A通道的值后的效果<br>虽然在代码中已经调整了BGRA图像中A通道的值，但是显示图像的效果是一样的。为了显示3幅图像的不同效果，需要使用imwrite()方法将3幅图像保存在D盘根目录下，代码如下：</p>
<p><img src="/.com//image-20211118063708689.png" alt="image-20211118063708689"></p>
<p>运行上述代码后，在D盘根目录下，依次双击打开bgra_image.png、bgra_172.png和bgra_0.png，3幅图像的显示效果如图5.16～图5.18所示。<br><img src="/.com//image-20211118063742930.png" alt="image-20211118063742930"><br>PNG图像是一种典型的4通道（即B通道、G通道、R通道和A通道)图像，因此被保存的3幅图像的格式均为.png。</p>
<h2 id="5-3-小结"><a href="#5-3-小结" class="headerlink" title="5.3　小结"></a>5.3　小结</h2><p>当使用cvtColor()方法转换色彩空间时，虽然彩色图像能够转换为灰度图像，但是灰度图像不能转换为彩色图像。对于HSV色彩空间，如果保持其中两个通道的值不变，调整第3个通道的值，会得到相应的艺术效果。为了能够显示艺术效果，要把合并通道后的图像从HSV色彩空间转换到BGR色彩空间。当使用alpha通道设置图像的透明度时，为了能够直观地看到图像的透明效果，需先保存已经设置透明度的图像。</p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
  </entry>
  <entry>
    <title>pandas统计分析</title>
    <url>/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>第四章 Pandas统计分析</p>
<h2 id="4-1-数据计算"><a href="#4-1-数据计算" class="headerlink" title="4.1 数据计算"></a>4.1 数据计算</h2><p>Pandas提供了大量的数据计算函数，可以实现求和、求均值、求最大值、求最小值、求中位数、求众数、求方差、标准差等，从而使得数据统计变得简单高效。</p>
<h3 id="4-1-1求和函数（sum"><a href="#4-1-1求和函数（sum" class="headerlink" title="4.1.1求和函数（sum())"></a>4.1.1求和函数（sum())</h3><p>DataFrame.sum(axis=None, skipna=None, level=None, numeric_only=None, min_count=0, **kwargs)<br>参数说明：　</p>
<p>axis：axis=1表示行，axis=0表示列，默认值为None（无）。　skipna：布尔型，表示计算结果是否排除NaN/Null值，默认值为None。</p>
<p>level：表示索引层级，默认值为None。　</p>
<p>numeric_only：仅数字，布尔型，默认值为None。　</p>
<p>min_count：表示执行操作所需的数目，整型，默认值为0。　**kwargs：要传递给函数的附加关键字参数。　</p>
<p>返回值：返回Series对象或DataFrame对象。行或列求和数据。</p>
<p>【示例01】　计算语文、数学和英语三科的总成绩。（示例位置：资源包\MR\Code\04\01）<br>首先，创建一组DataFrame类型的数据，包括语文、数学和英语三科的成绩，如图4.1所示。<br>程序代码如下：</p>
<p><img src="/.com//image-20211020032035450.png" alt="image-20211020032035450">下面使用sum()函数计算三科的总成绩，代码如下：</p>
<p>df[‘总成绩’]=df.sum(axis=1)</p>
<p>运行程序，输出结果如图4.2所示。</p>
<p><img src="/.com//image-20211020032210845.png" alt="image-20211020032210845"></p>
<p>​                                        图4.1　DataFrame数据</p>
<p><img src="/.com//image-20211020032230748.png" alt="image-20211020032230748"></p>
<p>​                                  图4.2　sum()函数计算三科的总成绩</p>
<h3 id="4-1-2-求均值（mean-函数）"><a href="#4-1-2-求均值（mean-函数）" class="headerlink" title="4.1.2　求均值（mean()函数）"></a>4.1.2　求均值（mean()函数）</h3><p>DataFrame.mean(axis=None, skipna=None, level=None, numeric_only=None, kwargs)<br>参数说明：　</p>
<p>axis：axis=1表示行，axis=0表示列，默认值为None（无）。　</p>
<p>skipna：布尔型，表示计算结果是否排除NaN/Null值，默认值为None。　</p>
<p>level：表示索引层级，默认值为None。　</p>
<p>numeric_only：仅数字，布尔型，默认值为None。　</p>
<p>kwargs：要传递给函数的附加关键字参数。　</p>
<p>返回值：返回Series对象或DataFrame对象。行或列平均值数据。</p>
<p>【示例02】　计算语文、数学和英语各科的平均分。（示例位置：资源包\MR\Code\04\02）<br>计算语文、数学和英语各科成绩的平均值，程序代码如下：</p>
<p><img src="/.com//image-20211020032641368.png" alt="image-20211020032641368"></p>
<p>运行程序，输出结果如图4.3所示。</p>
<p><img src="/.com//image-20211020032714762.png" alt="image-20211020032714762"></p>
<p>​                             图4.3　mean()函数计算三科成绩的平均值<br>从运行结果得知：语文平均分109，数学平均分107，英语平均分114.667。</p>
<h3 id="4-1-3-求最大值（max-函数）"><a href="#4-1-3-求最大值（max-函数）" class="headerlink" title="4.1.3　求最大值（max()函数）"></a>4.1.3　求最大值（max()函数）</h3><p>在Python中通过调用DataFrame对象的max()函数实现行／列数据最大值运算，语法如下：</p>
<p>DataFrame.max(axis=None, skipna=None, level=None, numeric_only=None, **kwargs)<br>参数说明：　**</p>
<p>**axis：axis=1表示行，axis=0表示列，默认值为None（无）。　skipna：布尔型，表示计算结果是否排除NaN/Null值，默认值为None。　</p>
<p>**level：表示索引层级，默认值为None。　</p>
<p>**numeric_only：仅数字，布尔型，默认值为None。　</p>
<p>kwargs：要传递给函数的附加关键字参数。　</p>
<p>返回值：返回Series对象或DataFrame对象。行或列最大值数据。</p>
<p>【示例03】　计算语文、数学和英语各科的最高分。（示例位置：资源包\MR\Code\04\03）<br>计算语文、数学和英语各科成绩的最大值，程序代码如下：</p>
<p><img src="/.com//image-20211020032850843.png" alt="image-20211020032850843"></p>
<p>运行程序，输出结果如图4.4所示。</p>
<p><img src="/.com//image-20211020033031795.png" alt="image-20211020033031795"></p>
<p>​                       图4.4　max()函数计算三科成绩的最大值</p>
<p>4.1.4　求最小值（min()函数）<br>在Python中通过调用DataFrame对象的min()函数实现行／列数据最小值运算，语法如下：</p>
<p>DataFrame.min(axis=None, skipna=None, level=None, numeric_only=None, **kwargs)<br>参数说明：　**</p>
<p>**axis：axis=1表示行，axis=0表示列，默认值为None（无）。　skipna：布尔型，表示计算结果是否排除NaN/Null值，默认值为None。　</p>
<p>**level：表示索引层级，默认值为None。　</p>
<p>**numeric_only：仅数字，布尔型，默认值为None。　</p>
<p>kwargs：要传递给函数的附加关键字参数。　</p>
<p>返回值：返回Series对象或DataFrame对象。行或列最小值数据。</p>
<p>【示例04】　计算语文、数学和英语各科的最低分。（示例位置：资源包\MR\Code\04\04）<br>计算语文、数学和英语各科成绩的最小值，程序代码如下：</p>
<p><img src="/.com//image-20211020033254349.png" alt="image-20211020033254349"></p>
<p>运行程序，输出结果如图4.5所示。</p>
<p><img src="/.com//image-20211020033314763.png" alt="image-20211020033314763"></p>
<h3 id="4-1-5-求中位数（median-函数）"><a href="#4-1-5-求中位数（median-函数）" class="headerlink" title="4.1.5　求中位数（median()函数）"></a>4.1.5　求中位数（median()函数）</h3><p>中位数又称中值，是统计学专有名词，是指按顺序排列的一组数据中位于中间位置的数，其不受异常值的影响。例如，年龄23、45、35、25、22、34、28这7个数，中位数就是排序后位于中间的数字，即28；而年龄23、45、35、25、22、34、28、27这8个数，中位数则是排序后位于中间两个数的平均值，即27.5。在Python中直接调用DataFrame对象的median()函数就可以轻松实现中位数的运算，语法如下：</p>
<p>DataFrame.median(axis=None,skipna=None,level=None,numeric_only=None,**kwargs)<br>参数说明：　**</p>
<p>**axis：axis=1表示行，axis=0表示列，默认值为None（无）。　skipna：布尔型，表示计算结果是否排除NaN/Null值，默认值为None。　</p>
<p>**level：表示索引层级，默认值为None。　</p>
<p>**numeric_only：仅数字，布尔型，默认值为None。　</p>
<p>kwargs：要传递给函数的附加关键字参数。　</p>
<p>返回值：返回Series对象或DataFrame对象。</p>
<p>【示例05】　计算学生各科成绩的中位数1。（示例位置：资源包\MR\Code\04\05）<br>下面给出一组数据（3条记录），然后使用median()函数计算语文、数学和英语各科成绩的中位数，程序代码如下：</p>
<p><img src="/.com//image-20211020033458773.png" alt="image-20211020033458773"></p>
<p>运行程序，控制台输出结果如下：</p>
<p>语文    130.0数学    120.0英语    130.0</p>
<p>【示例06】　计算学生各科成绩的中位数2。（示例位置：资源包\MR\Code\04\06）<br>下面再给出一组数据（4条记录），同样使用median()函数计算语文、数学和英语各科成绩的中位数，程序代码如下：</p>
<p><img src="/.com//image-20211020033625031.png" alt="image-20211020033625031"></p>
<p>运行程序，控制台输出结果如下：</p>
<p>语文    121.5数学    121.5英语    120.0</p>
<h3 id="4-1-6-求众数（mode-函数）"><a href="#4-1-6-求众数（mode-函数）" class="headerlink" title="4.1.6　求众数（mode()函数）"></a>4.1.6　求众数（mode()函数）</h3><p>什么是众数？众数的众字有多的意思，顾名思义，众数就是一组数据中出现最多的数称为众数，它代表了数据的一般水平。<br>在Python中通过调用DataFrame对象的mode()函数可以实现众数运算，语法如下：</p>
<p>DataFrame.mode(axis=0,numeric_only=False,dropna=True)<br>参数说明：　</p>
<p>axis：axis=1表示行，axis=0表示列，默认值为0。　</p>
<p>numeric_only：仅数字，布尔型，默认值为False。如果值为True，则仅适用于数字列。　</p>
<p>dropna：是否删除缺失值，布尔型，默认值为True。　</p>
<p>返回值：返回Series对象或DataFrame对象。<br>首先看一组原始数据，如图4.6所示。</p>
<p><img src="/.com//image-20211020033849240.png" alt="image-20211020033849240"></p>
<p>【示例07】　计算学生各科成绩的众数。（示例位置：资源包\MR\Code\04\07）<br>计算语文、数学和英语三科成绩的众数、每一行的众数和“数学”成绩的众数，程序代码如下：</p>
<p><img src="/.com//image-20211020034005721.png" alt="image-20211020034005721"></p>
<p>三科成绩的众数：<br>每一行的众数：</p>
<p>0  110<br>1  130<br>2  130<br>数学成绩的众数：</p>
<p>0  120</p>
<h3 id="4-1-7-求方差（var-函数）"><a href="#4-1-7-求方差（var-函数）" class="headerlink" title="4.1.7　求方差（var()函数）"></a>4.1.7　求方差（var()函数）</h3><p>方差用于衡量一组数据的离散程度，即各组数据与它们的平均数的差的平方，那么我们用这个结果来衡量这组数据的波动大小，并把它叫作这组数据的方差，方差越小越稳定。通过方差可以了解一个问题的波动性。下面简单介绍下方差的意义，相信通过一个简单的举例您就会了解。<br>例如，某校两名同学的物理成绩都很优秀，而参加物理竞赛的名额只有一个，那么选谁去获得名次的机率更大呢？于是根据历史数据计算出了两名同学的平均成绩，但结果是实力相当，平均成绩都是107.6，怎么办呢？这时让方差帮决定，看看谁的成绩更稳定。首先汇总物理成绩，如图4.7所示。</p>
<p><img src="/.com//image-20211020034219502.png" alt="image-20211020034219502"></p>
<p>​                                            图4.7　物理成绩<br>通过方差对比两名同学物理成绩的波动，如图4.8所示。</p>
<p><img src="/.com//image-20211020034235082.png" alt="image-20211020034235082"></p>
<p>​                                                   图4.8　方差<br>接着来看一下总体波动（方差和），“小黑”的数据是73.2，“小白”的数据是949.2，很明显“小黑”的物理成绩波动较小，发挥更稳定，所以应该选“小黑”参加物理竞赛。<br>以上举例就是方差的意义。大数据时代，它能够帮助我们解决很多身边的问题、协助我们做出合理的决策。<br>在Python中通过调用DataFrame对象的var()函数可以实现方差运算，语法如下：</p>
<p><strong>DataFrame.var(axis=None,skipna=None,level=None,ddof=1,numeric_only=None,kwargs)</strong><br>参数说明：　</p>
<p>axis：axis=1表示行，axis=0表示列，默认值为None（无）。　skipna：布尔型，表示计算结果是否排除NaN/Null值，默认值为None。　</p>
<p>level：表示索引层级，默认值为None。　</p>
<p>ddof：整型，默认值为1。自由度，计算中使用的除数是N-ddof，其中N表示元素的数量。　</p>
<p>numeric_only：仅数字，布尔型，默认值为None。　</p>
<p>kwargs：要传递给函数的附加关键字参数。　</p>
<p>返回值：返回Series对象或DataFrame对象。</p>
<p>【示例08】　通过方差判断谁的物理成绩更稳定。（示例位置：资源包\MR\Code\04\08）<br>计算“小黑”和“小白”物理成绩的方差，程序代码如下：</p>
<p><img src="/.com//image-20211020034435272.png" alt="image-20211020034435272"></p>
<p>运行程序，控制台输出结果如下：</p>
<p>小黑     18.3小白    237.3<br>从运行结果得知：“小黑”的物理成绩波动较小，发挥更稳定。这里需要注意的是，Pandas中计算的方差为无偏样本方差（即方差和／样本数-1），NumPy中计算的方差就是样本方差本身（即方差和／样本数）。</p>
<h3 id="4-1-8-标准差（数据标准化std-函数）"><a href="#4-1-8-标准差（数据标准化std-函数）" class="headerlink" title="4.1.8　标准差（数据标准化std()函数）"></a>4.1.8　标准差（数据标准化std()函数）</h3><p>标准差又称均方差，是方差的平方根，用来表示数据的离散程度。<br>在Python中通过调用DataFrame对象的std()函数求标准差，语法如下：</p>
<p>DataFrame.std(axis=None,skipna=None,level=None,ddof=1,numeric_only=None,**kwargs)<br>std()函数的参数与var()函数一样，这里不再赘述。</p>
<p>【示例09】　计算各科成绩的标准差。（示例位置：资源包\MR\Code\04\09）<br>使用std()函数计算标准差，程序代码如下：</p>
<p><img src="/.com//image-20211020034453875.png" alt="image-20211020034453875"></p>
<p>运行程序，控制台输出结果如下：</p>
<p>语文    11.547005数学     5.773503英语    11.5547005</p>
<h3 id="4-1-9-求分位数（quantile-函数）"><a href="#4-1-9-求分位数（quantile-函数）" class="headerlink" title="4.1.9　求分位数（quantile()函数）"></a>4.1.9　求分位数（quantile()函数）</h3><p>分位数也称分位点，它以概率依据将数据分割为几个等份，常用的有中位数（即二分位数）、四分位数、百分位数等。分位数是数据分析中常用的一个统计量，经过抽样得到一个样本值。例如，经常会听老师说：“这次考试竟然有20%的同学不及格！”，那么这句话就体现了分位数的应用。在Python中通过调用DataFrame对象的quantile()函数求分位数，语法如下：</p>
<p><strong>DataFrame.quantile(q=0.5,axis=0,numeric_only=True, interpolation=’linear’)</strong><br>参数说明：　</p>
<p>q：浮点型或数组，默认为0.5（50%分位数），其值为0～1。　</p>
<p>axis：axis=1表示行，axis=0表示列。默认值为0。　</p>
<p>numeric_only：仅数字，布尔型，默认值为True。　</p>
<p>interpolation：内插值，可选参数[{‘linear’,‘lower’,‘higher’,‘midpoint’,‘nearest’}]用于指定要使用的插值方法，当期望的分位数为数据点i～j时。　</p>
<p>​    linear’：i+(j-i)×分数，其中分数是指数被i和j包围的小数部分。　</p>
<p>​    lower：i。　</p>
<p>​    higher：j。　 </p>
<p>​    nearest：i或j二者以最近者为准。　</p>
<p>​    midpoint：(i+j)/2。　</p>
<p>返回值：返回Series或DataFrame对象。</p>
<p>【示例10】　通过分位数确定被淘汰的35%的学生。（示例位置：资源包\MR\Code\04\10）<br>以学生成绩为例，数学成绩分别为120、89、98、78、65、102、112、56、79、45的10名同学，现根据分数淘汰35%的学生，该如何处理？首先使用quantile()函数计算35%的分位数，然后将学生成绩与分位数比较，筛选小于等于分位数的学生，程序代码如下：</p>
<p><img src="/.com//image-20211020035437337.png" alt="image-20211020035437337"></p>
<p>运行程序，控制台输出结果如下：</p>
<p><img src="/.com//image-20211020035513992.png" alt="image-20211020035513992"></p>
<p>从运行结果得知：即将被淘汰的学生有4名，分数分别为78、65、56和45。</p>
<p>【示例11】　计算日期、时间和时间增量数据的分位数。（示例位置：资源包\MR\Code\04\11）<br>如果参数numeric_only=False，将计算日期、时间和时间增量数据的分位数，程序代码如下：<br>运行程序，控制台输出结果如下：</p>
<p>A                  1.5<br>B 2019-07-02 12:00:00<br>C          1 days 12:00:00<br>Name: 0.5, dtype: object</p>
<h2 id="4-2-数据格式化"><a href="#4-2-数据格式化" class="headerlink" title="4.2　数据格式化"></a>4.2　数据格式化</h2><p>在进行数据处理时，尤其是在数据计算中应用求均值（mean()函数）后，发现结果中的小数位数增加了许多。此时就需要对数据进行格式化，以增加数据的可读性。例如，保留小数点位数、百分号、千位分隔符等。首先来看一组数据，如图4.9所示。</p>
<p><img src="/.com//image-20211020035851798.png" alt="image-20211020035851798"></p>
<p>​                                         图4.9　原始数据</p>
<h3 id="4-2-1-设置小数位数"><a href="#4-2-1-设置小数位数" class="headerlink" title="4.2.1　设置小数位数"></a>4.2.1　设置小数位数</h3><p>设置小数位数主要使用DataFrame对象的round()函数，该函数可以实现四舍五入，而它的decimals参数则用于设置保留小数的位数，设置后数据类型不会发生变化，依然是浮点型。语法如下：</p>
<p>DataFrame.round(decimals=0, *args, **kwargs)　**</p>
<p>decimals：每一列四舍五入的小数位数，整型、字典或Series对象。如果是整数，则将每一列四舍五入到相同的位置。否则，将字典和Series舍入到可变数目的位置；如果小数是类似于字典的，那么列名应该在键中；如果小数是级数，列名应该在索引中。没有包含在小数中的任何列都将保持原样。非输入列的小数元素将被忽略。　</p>
<p>args：附加的关键字参数。　</p>
<p>kwargs：附加的关键字参数。　</p>
<p>返回值：返回DataFrame对象。</p>
<p>【示例12】　四舍五入保留指定的小数位数。（示例位置：资源包\MR\Code\04\12）<br>使用round()函数四舍五入保留小数位数，程序代码如下：</p>
<p><img src="/.com//image-20211020040002742.png" alt="image-20211020040002742"></p>
<p>运行程序，控制台输出结果如下：</p>
<p><img src="/.com//image-20211020040023289.png" alt="image-20211020040023289"></p>
<p>当然，保留小数位数也可以用自定义函数，例如，为DataFrame对象中的各个浮点值保留两位小数，主要代码如下：</p>
<p>df.applymap(lambda x: ‘%.2f’%x)</p>
<p>注意<br>经过自定义函数处理过的数据将不再是浮点型而是对象型，如果后续计算需要数据，则应先进行数据类型转换。</p>
<h3 id="4-2-2-设置百分比"><a href="#4-2-2-设置百分比" class="headerlink" title="4.2.2　设置百分比"></a>4.2.2　设置百分比</h3><p>在数据分析过程中，有时需要百分比数据。那么，利用自定义函数将数据进行格式化处理，处理后的数据就可以从浮点型转换成带指定小数位数的百分比数据，主要使用apply()函数与format()函数。</p>
<p>【示例13】　将指定数据格式化为百分比数据。（示例位置：资源包\MR\Code\04\13）<br>将A1列的数据格式化为百分比数据，程序代码如下：</p>
<p><img src="/.com//image-20211020040234891.png" alt="image-20211020040234891"></p>
<p>运行程序，控制台输出结果如下：</p>
<p><img src="/.com//image-20211020040335780.png" alt="image-20211020040335780"></p>
<h3 id="4-2-3-设置千位分隔符"><a href="#4-2-3-设置千位分隔符" class="headerlink" title="4.2.3　设置千位分隔符"></a>4.2.3　设置千位分隔符</h3><p>由于业务需要，有时需要将数据格式化为带千位分隔符的数据。那么，处理后的数据将不再是浮点型而是对象型。</p>
<p>【示例14】　将金额格式化为带千位分隔符的数据。（示例位置：资源包\MR\Code\04\14）<br>将图书销售码洋格式化为带千位分隔符的数据，程序代码如下：</p>
<p><img src="/.com//image-20211020040604750.png" alt="image-20211020040604750"></p>
<p>运行程序，控制台输出结果如下：</p>
<p><img src="/.com//image-20211020040623599.png" alt="image-20211020040623599"></p>
<p>注意<br>设置千位分隔符后，对于程序来说，这些数据将不再是数值型，而是数字和逗号组成的字符串，如果由于程序需要再变成数值型就会很麻烦，因此设置千位分隔符要慎重。</p>
<h2 id="4-3-数据分组统计"><a href="#4-3-数据分组统计" class="headerlink" title="4.3　数据分组统计"></a>4.3　数据分组统计</h2><p>本节主要介绍分组统计函数groupby()的各种应用。</p>
<h3 id="4-3-1-分组统计groupby-函数"><a href="#4-3-1-分组统计groupby-函数" class="headerlink" title="4.3.1　分组统计groupby()函数"></a>4.3.1　分组统计groupby()函数</h3><p>对数据进行分组统计，主要使用DataFrame对象的groupby()函数，其功能如下。<br>（1）根据给定的条件将数据拆分成组。</p>
<p>（2）每个组都可以独立应用函数（如求和函数sum()、求平均值函数mean()等）。</p>
<p>（3）将结果合并到一个数据结构中。</p>
<p>groupby()函数用于将数据按照一列或多列进行分组，一般与计算函数结合使用，实现数据的分组统计，语法如下：</p>
<p><strong>DataFrame.groupby(by=None,axis=0,level=None,as_index=True,sort=True,group_keys=True,squeeze=False,observed=False)</strong></p>
<p>参数说明：　</p>
<p>by：映射、字典或Series对象、数组、标签或标签列表。如果by是一个函数，则对象索引的每个值都调用它；如果传递了一个字典或Series对象，则使用该字典或Series对象值来确定组；如果传递了数组ndarray，则按原样使用这些值来确定组。　</p>
<p>axis：axis=1表示行，axis=0表示列。默认值为0。　</p>
<p>level：表示索引层级，默认值为None（无）。　</p>
<p>as_index：布尔型，默认值为True，返回以组标签为索引的对象。　sort：对组进行排序，布尔型，默认值为True。　</p>
<p>group_keys：布尔型，默认值为True，调用apply()函数时，将分组的键添加到索引以标识片段。　</p>
<p>squeeze：布尔型，默认值为False。如果可能，减少返回类型的维度；否则返回一致类型。　</p>
<p>observed： <em>bool, default False</em> 布尔型, 观察者, 默认为False。当以石斑鱼为分类时，才会使用该参数。如果参数值为True，则仅显示分类石斑鱼的观测值；如果参数值为False，则显示分类石斑鱼的所有值。</p>
<p>返回值：返回DataFrameGroupBy，返回包含有关组的信息的groupby对象。</p>
<h4 id="1．按照一列分组统计"><a href="#1．按照一列分组统计" class="headerlink" title="1．按照一列分组统计"></a>1．按照一列分组统计</h4><p>【示例15】　根据“一级分类”统计订单数据。（示例位置：资源包\MR\Code\04\15）<br>按照图书“一级分类”对订单数据进行分组统计求和，程序代码如下：</p>
<p><img src="/.com//image-20211020042705196.png" alt="image-20211020042705196"></p>
<p>运行程序，输出结果如图4.10所示。</p>
<p><img src="/.com//image-20211020042744863.png" alt="image-20211020042744863"></p>
<p>​                                 图4.10　按照一列分组统计</p>
<h4 id="2．按照多列分组统计"><a href="#2．按照多列分组统计" class="headerlink" title="2．按照多列分组统计"></a>2．按照多列分组统计</h4><p>多列分组统计，以列表形式指定列。</p>
<p>【示例16】　根据两级分类统计订单数据。（示例位置：资源包\MR\Code\04\16）<br>按照图书“一级分类”和“二级分类”对订单数据进行分组统计求和，主要代码如下：</p>
<p>01 #抽取数据<br>02 df1=df[[‘一级分类’,’二级分类’,’7天点击量’,’订单预定’]]<br>03 df1=df1.groupby([‘一级分类’,’二级分类’]).sum()    #分组统计求和</p>
<p>运行程序，输出结果如图4.11所示。</p>
<p><img src="/.com//image-20211020042906442.png" alt="image-20211020042906442"></p>
<p>​                                    图4.11　按照多列分组统计</p>
<h4 id="3．分组并按指定列进行数据计算"><a href="#3．分组并按指定列进行数据计算" class="headerlink" title="3．分组并按指定列进行数据计算"></a>3．分组并按指定列进行数据计算</h4><p>前面介绍的分组统计是按照所有列进行汇总计算的，那么如何按照指定列汇总计算呢？</p>
<p>【示例17】　统计各编程语言的7天点击量。（示例位置：资源包\MR\Code\04\17）<br>统计各编程语言的7天点击量，首先按“二级分类”分组，然后抽取“7天点击量”列并对该列进行求和运算，主要代码如下：</p>
<p>df1=df1.groupby(‘二级分类’)[‘7天点击量’].sum()<br>运行程序，输出结果如图4.12所示。</p>
<p><img src="/.com//image-20211020043023795.png" alt="image-20211020043023795"></p>
<p>图4.12　分组并按指定列进行数据计算</p>
<h3 id="4-3-2-对分组数据进行迭代"><a href="#4-3-2-对分组数据进行迭代" class="headerlink" title="4.3.2　对分组数据进行迭代"></a>4.3.2　对分组数据进行迭代</h3><p>通过for循环对分组统计数据进行迭代（遍历分组数据）。</p>
<p>【示例18】　迭代一级分类的订单数据。（示例位置：资源包\MR\Code\04\18）<br>按照“一级分类”分组，并输出每一分类中的订单数据，主要代码如下：</p>
<p><img src="/.com//image-20211020043149194.png" alt="image-20211020043149194"></p>
<p>运行程序，控制台输出结果如图4.13所示。<br>上述代码中，name是groupby()函数中“一级分类”的值，group是分组后的数据。如果groupby()函数对多列进行分组，那么需要在for循环中指定多列。</p>
<p>【示例19】　迭代两级分类的订单数据。（示例位置：资源包\MR\Code\04\19）<br>迭代“一级分类”和“二级分类”的订单数据，主要代码如下：</p>
<p><img src="/.com//image-20211020043219251.png" alt="image-20211020043219251"></p>
<p><img src="/.com//image-20211020043328145.png" alt="image-20211020043328145"></p>
<p>​                          图4.13　对分组数据进行迭代</p>
<h3 id="4-3-3-对分组的某列或多列使用聚合函数（agg-函数）"><a href="#4-3-3-对分组的某列或多列使用聚合函数（agg-函数）" class="headerlink" title="4.3.3　对分组的某列或多列使用聚合函数（agg()函数）"></a>4.3.3　对分组的某列或多列使用聚合函数（agg()函数）</h3><p>Python也可以实现像SQL中的分组聚合运算操作，主要通过groupby()函数与agg()函数实现。【示例20】　对分组统计结果使用聚合函数。（示例位置：资源包\MR\Code\04\20）<br>按“一级分类”分组统计“7天点击量”“订单预定”的平均值和总和，主要代码如下：</p>
<p>print(df1.groupby(‘一级分类’).agg([‘mean’,’sum’]))<br>运行程序，控制台输出结果如图4.14所示。</p>
<p><img src="/.com//image-20211020043531227.png" alt="image-20211020043531227"></p>
<p>​                 图4.14　分组统计“7天点击量”“订单预定”的平均值和总和</p>
<p>【示例21】　针对不同的列使用不同的聚合函数。（示例位置：资源包\MR\Code\04\21）<br>在上述示例中，还可以针对不同的列使用不同的聚合函数。例如，按“一级分类”分组统计“7天点击量”的平均值和总和、“订单预定”的总和，主要代码如下：</p>
<p>print(df1.groupby(‘一级分类’).agg({‘7天点击量’:[‘mean’,’sum’], ‘订单预定’:[‘sum’]}))<br>运行程序，控制台输出结果如图4.15所示。</p>
<p><img src="/.com//image-20211020043554534.png" alt="image-20211020043554534"></p>
<p>​           图4.15　分组统计“7天点击量”的平均值和总和、“订单预定”的总和</p>
<p>【示例22】　通过自定义函数实现分组统计。（示例位置：资源包\MR\Code\04\22）<br>通过自定义函数也可以实现数据分组统计。例如，统计1月份销售数据中，购买次数最多的产品，主要代码如下：</p>
<p><img src="/.com//image-20211020043631773.png" alt="image-20211020043631773"></p>
<p>运行程序，控制台输出结果如图4.16所示。</p>
<p><img src="/.com//image-20211020043647886.png" alt="image-20211020043647886"></p>
<p>​                             图4.16　统计购买次数最多的产品</p>
<p>从运行结果得知：“零基础学Python”是用户购买次数最多的产品。实用技巧<br>在图4.16显示的输出结果中可以看到，lambda()函数名称<lambda>被输出出来，看上去不是很美观，那么如何去掉它？方法是使用__name__方法修改函数名称，主要代码如下：</lambda></p>
<p>max.<strong>name</strong> = “购买次数最多”<br>运行程序，控制台输出结果如图4.17所示。</p>
<p><img src="/.com//image-20211020043747160.png" alt="image-20211020043747160"></p>
<p>​                         图4.17　使用__name__方法修改函数名称</p>
<h3 id="4-3-4-通过字典和Series对象进行分组统计"><a href="#4-3-4-通过字典和Series对象进行分组统计" class="headerlink" title="4.3.4　通过字典和Series对象进行分组统计"></a>4.3.4　通过字典和Series对象进行分组统计</h3><h4 id="1．通过字典进行分组统计"><a href="#1．通过字典进行分组统计" class="headerlink" title="1．通过字典进行分组统计"></a>1．通过字典进行分组统计</h4><p>首先创建字典建立对应关系，然后将字典传递给groupby()函数从而实现数据分组统计。</p>
<p>【示例23】　通过字典分组统计“北上广”销量。（示例位置：资源包\MR\Code\04\23）<br>统计各地区销量，业务要求将“北京”“上海”“广州”3个一线城市放在一起统计。那么首先创建一个字典将“北京出库销量”“上海出库销量”“广州出库销量”都对应“北上广”；然后使用groupby()函数进行分组统计。主要代码如下：</p>
<p><img src="/.com//image-20211020043824543.png" alt="image-20211020043824543"></p>
<p>运行程序，控制台输出结果如图4.18所示。</p>
<p><img src="/.com//image-20211020043847244.png" alt="image-20211020043847244"></p>
<p>​                                 图4.18　通过字典进行分组统计</p>
<h4 id="2．通过Series对象进行分组统计"><a href="#2．通过Series对象进行分组统计" class="headerlink" title="2．通过Series对象进行分组统计"></a>2．通过Series对象进行分组统计</h4><p>通过Series对象进行分组统计与字典的方法类似。</p>
<p>【示例24】　通过Series对象分组统计“北上广”销量。（示例位置：资源包\MR\Code\04\24）<br>首先，创建一个Series对象，主要代码如下：</p>
<p><img src="/.com//image-20211020043933019.png" alt="image-20211020043933019"></p>
<p>运行程序，输出结果如图4.19所示。<br>然后，将Series对象传递给groupby()函数实现数据分组统计，主要代码如下：</p>
<p>01  df1=df.groupby(s1,axis=1).sum()<br>02  print(df1)<br>运行程序，控制台输出结果如图4.20所示。</p>
<p><img src="/.com//image-20211020043959963.png" alt="image-20211020043959963"></p>
<p>​                             图4.19　通过Series对象进行分组统计</p>
<p><img src="/.com//image-20211020044040014.png" alt="image-20211020044040014"></p>
<p>​                             图4.20　分组统计结果</p>
<h2 id="4-4-数据移位"><a href="#4-4-数据移位" class="headerlink" title="4.4　数据移位"></a>4.4　数据移位</h2><p>什么是数据移位？例如，分析数据时需要上一条数据怎么办？当然是移动至上一条，从而得到该条数据，这就是数据移位。在Pandas中，使用shift()方法可以获得上一条数据，该方法返回向下移位后的结果，从而得到上一条数据。例如，获取某学生上一次英语成绩，如图4.21所示。</p>
<p><img src="/.com//image-20211020044117875.png" alt="image-20211020044117875"></p>
<p>​                              图4.21　获取学生上一次英语成绩<br>shift()方法是一个非常有用的方法，用于数据位移与其他方法结合，能实现很多难以想象的功能，语法格式如下：</p>
<p>DataFrame.shift(periods=1, freq=None, axis=0)<br>参数说明：　</p>
<p>periods：表示移动的幅度，可以是正数，也可以是负数，默认值是1，1表示移动一次。注意这里移动的都是数据，而索引是不移动的，移动之后是没有对应值的，赋值为NaN。　</p>
<p>freq：可选参数，默认值为None，只适用于时间序列，如果这个参数存在，那么会按照参数值移动时间索引，而数据值没有发生变化。　</p>
<p>axis：axis=1表示行，axis=0表示列。默认值为0。</p>
<p>【示例25】　统计学生英语周测成绩的升降情况。（示例位置：资源包\MR\Code\04\25）<br>使用shift()方法统计学生每周英语测试成绩的升降情况，程序代码如下：</p>
<p><img src="/.com//image-20211020044313140.png" alt="image-20211020044313140"></p>
<p>运行程序，控制台输出结果如图4.22所示。<br>从运行结果得知：第2次比第1次下降5分，第3次比第2次下降6分，第4次比第3次提升21分，第5次比第4次下降5分。<br>这里再扩展下，通过10次周测来一看下学生整体英语成绩的升降情况，如图4.23和图4.24所示。</p>
<p><img src="/.com//image-20211020044330897.png" alt="image-20211020044330897"></p>
<p>​                                     图4.22　英语升降情况</p>
<p><img src="/.com//image-20211020044547566.png" alt="image-20211020044547566"></p>
<p>​                               图4.23　10次周测英语成绩升降情况</p>
<p><img src="/.com//image-20211020044603814.png" alt="image-20211020044603814"></p>
<p>​                     图4.24　图表展示英语成绩升降情况</p>
<p>说明</p>
<p>有关图表的知识将在第6章介绍，这里先简单了解。</p>
<p>shift()方法还有很多方面的应用。例如这样一个场景：分析股票数据，获取的股票数据中有股票的实时价格，也有每日的收盘价“close”，此时需要将实时价格和上一个工作日的收盘价进行对比，那么通过shift()方法就可以轻松解决。shift()方法还可以应用于时间序列，感兴趣的读者可以在学习完成后续章节进行尝试和探索。</p>
<h2 id="4-5-数据转换"><a href="#4-5-数据转换" class="headerlink" title="4.5　数据转换"></a>4.5　数据转换</h2><p>数据转换一般包括一列数据转换为多列数据、行列转换、DataFrame转换为字典、DataFrame转换为列表和DataFrame转换为元组等。</p>
<h3 id="4-5-1-一列数据转换为多列数据"><a href="#4-5-1-一列数据转换为多列数据" class="headerlink" title="4.5.1　一列数据转换为多列数据"></a>4.5.1　一列数据转换为多列数据</h3><p>一列数据转换为多列数据的情况在日常工作中经常会用到，从各种系统中导出的订单号、名称、地址很多都是复合组成的（即由多项内容组成），那么，这些列在查找、统计、合并时就没办法使用，需要将它们拆分开。例如，地址信息由省市区街道门牌号等信息组成，如果按省、市或区统计数据，就需要将地址信息中的“省”“市”“区”拆分开，此时就应用到了一列数据转多列数据，通常使用以下方法。</p>
<h4 id="1．split-方法"><a href="#1．split-方法" class="headerlink" title="1．split()方法"></a>1．split()方法</h4><p>Pandas的DataFrame对象中的str.split()内置方法可以实现分割字符串，语法如下：</p>
<p>Series.str.split(pat=None, n=-1, expand=False)<br>参数说明：　</p>
<p>pat：字符串、符号或正则表达式，字符串分割的依据，默认以空格分割字符串。　</p>
<p>n：整型，分割次数，默认值是-1，0或-1都将返回所有拆分。　expand：布尔型，分割后的结果是否转换为DataFrame，默认值是False。　</p>
<p>返回值：系列、索引、DataFrame或多重索引。<br>首先，我们来看一组淘宝销售订单数据（部分数据），如图4.25所示。</p>
<p><img src="/.com//image-20211020044753477.png" alt="image-20211020044753477"></p>
<p>图4.25　淘宝销售订单数据（部分数据）<br>从图4-25中数据得知：不仅“收货地址”是复合的，“宝贝标题”也是复合的，即由多种产品组成。</p>
<p>【示例26】　分割“收货地址”数据中的“省、市、区”。（示例位置：资源包\MR\Code\04\26）<br>使用split()方法先对“收货地址”进行分割，程序代码如下：</p>
<p><img src="/.com//image-20211020044817707.png" alt="image-20211020044817707"></p>
<p>运行程序，输出结果如图4.26所示。</p>
<p><img src="/.com//image-20211020044931041.png" alt="image-20211020044931041"></p>
<p>​                                  图4.26　分割后的收货地址</p>
<h4 id="2．join-方法与split-方法结合"><a href="#2．join-方法与split-方法结合" class="headerlink" title="2．join()方法与split()方法结合"></a>2．join()方法与split()方法结合</h4><p>【示例27】　以逗号分隔多种产品数据。（示例位置：资源包\MR\Code\04\27）<br>通过join()方法与split()方法结合，以逗号“,”分隔“宝贝标题”，主要代码如下：</p>
<p>df = df.join(df[‘宝贝标题’].str.split(‘, ‘, expand=True))</p>
<p>运行程序，输出结果如图4.27所示。</p>
<p><img src="/.com//image-20211020044959881.png" alt="image-20211020044959881"></p>
<p>​                                   图4.27　分隔后的“宝贝标题”<br>从运行结果得知：“宝贝标题”中含有多种产品的数据被拆分开，这样操作便于日后对每种产品的销量进行统计。<br>将DataFrame中的tuple（元组）类型数据分隔成多列</p>
<p>【示例28】　对元组数据进行分隔。（示例位置：资源包\MR\Code\04\28）<br>首先，创建一组包含元组的数据，程序代码如下：</p>
<p>01  import pandas as pd<br>02  df = pd.DataFrame({‘a’:[1,2,3,4,5], ‘b’:[(1,2), (3,4),(5,6),(7,8),(9,10)]})<br>03  print(df)</p>
<p>然后，使用apply()函数对元组进行分隔，主要代码如下：</p>
<p>df[[‘b1’, ‘b2’]] = df[‘b’].apply(pd.Series)<br>或者使用join()方法结合apply()函数，主要代码如下：</p>
<p>df= df.join(df[‘b’].apply(pd.Series))<br>运行程序，控制台输出原始数据如图4.28所示，结果如图4.29和图4.30所示。</p>
<p><img src="/.com//image-20211020045110497.png" alt="image-20211020045110497"></p>
<p>​                                            图4.28　原始数据</p>
<p><img src="/.com//image-20211020045122797.png" alt="image-20211020045122797"></p>
<p>​                             图4.29　apply()函数分隔元组</p>
<p><img src="/.com//image-20211020045146968.png" alt="image-20211020045146968"></p>
<p>​                       图4.30　join()方法结合apply()函数分隔元组</p>
<h3 id="4-5-2-行列转换"><a href="#4-5-2-行列转换" class="headerlink" title="4.5.2　行列转换"></a>4.5.2　行列转换</h3><p>在Pandas处理数据过程中，有时需要对数据进行行列转换或重排，主要使用stack()方法、unstack()方法和pivot()方法，下面介绍这3种方法的应用。</p>
<h4 id="1．stack-方法"><a href="#1．stack-方法" class="headerlink" title="1．stack()方法"></a>1．stack()方法</h4><p>stack()方法用于将原来的<strong>列索引转换成最内层的行索引</strong>，转换效果对比示意图如图4.31所示。</p>
<p><img src="/.com//image-20211020045215351.png" alt="image-20211020045215351"></p>
<p>​                               图4.31　转换效果对比示意图<br>stack()方法的语法如下：</p>
<p>DataFrame.stack(level=-1, dropna=True)<br>参数说明：　</p>
<p>level：索引层级，定义为一个索引或标签，或索引或标签列表，默认值是-1。　</p>
<p>dropna：布尔型，默认值是True，　</p>
<p>返回值：DataFrame对象或Series对象。</p>
<p>【示例29】　对英语成绩表进行行列转换。（示例位置：资源包\MR\Code\04\29）<br>将学生英语成绩表进行行列转换，程序代码如下：</p>
<p><img src="/.com//image-20211020045321517.png" alt="image-20211020045321517"></p>
<h4 id="2．unstack-方法"><a href="#2．unstack-方法" class="headerlink" title="2．unstack()方法"></a>2．unstack()方法</h4><p>unstack()方法与stack()方法相反，它是stack()方法的逆操作，即将最内层的行索引转换成列索引，转换效果对比如图4.32所示。</p>
<p><img src="/.com//image-20211020045341690.png" alt="image-20211020045341690"></p>
<p>​                   图4.32　unstack()方法转换数据示意图<br>unstack()方法的语法如下：</p>
<p>DataFrame.unstack(level=-1, fill_value=None)<br>参数说明：　</p>
<p>level：索引层级，定义为一个索引或标签，或索引或标签列表，默认值是-1。　</p>
<p>fill_value：整型、字符串或字典，如果unstack()方法产生丢失值，则用这个值替换NaN。　返回值：DataFrame对象或Series对象。</p>
<p>【示例30】　使用unstack()方法转换学生成绩表。（示例位置：资源包\MR\Code\04\30）<br>同样转换学生成绩表，主要代码如下：</p>
<p>01 df=pd.read_excel(‘grade.xls’,sheet_name=’英语2’)      #导入Excel文件<br>02 df = df.set_index([‘班级’,’序号’,’Unnamed: 2’])       #设置多级索引<br>03 print(df.unstack())<br>unstack()方法中有一个参数可以指定转换第几层索引，例如，unstack(0)就是把第一层行索引转换为列索引，默认是将最内层索引转换为列索引。</p>
<h4 id="3．pivot-方法"><a href="#3．pivot-方法" class="headerlink" title="3．pivot()方法"></a>3．pivot()方法</h4><p>pivot()方法针对列的值，即指定某列的值作为行索引，指定某列的值作为列索引，然后再指定哪些列作为索引对应的值。unstack()方法针对索引进行操作，pivot()方法针对值进行操作。但实际上，二者的功能往往可以互相实现。<br>pivot()方法的语法如下：</p>
<p>DataFrame.pivot(index=None, columns=None, values=None)<br>参数说明：　</p>
<p>index：字符串或对象，可选参数。列用于创建新DataFrame数据的索引。如果没有，则使用现有索引。　</p>
<p>columns：字符串或对象，列用于创建新DataFrame的列。　</p>
<p>values：列用于填充新DataFrame的值，如果未指定，则将使用所有剩余的列，结果将具有分层索引列。　</p>
<p>返回值：DataFrame对象或Series对象。</p>
<p>【示例31】　使用pivot()方法转换学生成绩表。（示例位置：资源包\MR\Code\04\31）<br>使用pivot()方法转换学生成绩表，主要代码如下：</p>
<p>01 df=pd.read_excel(‘grade.xls’,sheet_name=’英语3’)         #导入Excel文件<br>02 df1=df.pivot(index=’序号’,columns=’班级’,values=’得分’)<br>运行程序，输出结果如图4.33所示。</p>
<p><img src="/.com//image-20211020045550818.png" alt="image-20211020045550818"></p>
<p>图4.33　使用pivot()方法转换学生成绩表</p>
<h3 id="4-5-3-DataFrame转换为字典"><a href="#4-5-3-DataFrame转换为字典" class="headerlink" title="4.5.3　DataFrame转换为字典"></a>4.5.3　DataFrame转换为字典</h3><p>DataFrame转换为字典主要使用DataFrame对象的to_dict()方法，以索引作为字典的键（key），以列作为字典的值（value）。例如，有一个DataFrame对象（索引为“类别”、列为“数量”），通过to_dict()方法就会生成一个字典，示意图如图4.34所示。如果DataFrame对象包含两列，那么to_dict()方法就会生成一个两层的字典（dict），第一层是列名作为字典的键（key），第二层以索引列的值作为字典的键（key），以列值作为字典的值（value）。</p>
<p>【示例32】　将Excel销售数据转换为字典。（示例位置：资源包\MR\Code\04\32）<br>使用to_dict()方法将按“宝贝标题”分组统计后的部分数据转换为字典，程序代码如下：</p>
<p><img src="/.com//image-20211020045613721.png" alt="image-20211020045613721"></p>
<p>运行程序，控制台输出结果如图4.35所示。</p>
<p><img src="/.com//image-20211020045643137.png" alt="image-20211020045643137"></p>
<p>​                       图4.34　DataFrame转换为字典示意图</p>
<p><img src="/.com//image-20211020045702961.png" alt="image-20211020045702961"></p>
<p>​                           图4.35　DataFrame转换为字典</p>
<h3 id="4-5-4-DataFrame转换为列表"><a href="#4-5-4-DataFrame转换为列表" class="headerlink" title="4.5.4　DataFrame转换为列表"></a>4.5.4　DataFrame转换为列表</h3><p>DataFrame转换为列表主要使用DataFrame对象的tolist()方法。</p>
<p>【示例33】　将电商数据转换为列表。（示例位置：资源包\MR\Code\04\33）<br>将淘宝销售数据中的“买家会员名”转换为列表，程序代码如下：</p>
<p><img src="/.com//image-20211020045737401.png" alt="image-20211020045737401"></p>
<p>运行程序，控制台输出结果如图4.36所示。</p>
<p><img src="/.com//image-20211020045806297.png" alt="image-20211020045806297"></p>
<p>图4.36　DataFrame转换为列表</p>
<h3 id="4-5-5-DataFrame转换为元组"><a href="#4-5-5-DataFrame转换为元组" class="headerlink" title="4.5.5　DataFrame转换为元组"></a>4.5.5　DataFrame转换为元组</h3><p>DataFrame转换为元组，首先通过循环语句按行读取DataFrame数据，然后使用元组函数tuple()将其转换为元组。</p>
<p>【示例34】　将Excel数据转换为元组。（示例位置：资源包\MR\Code\04\34）<br>将Excel表中的人物关系部分数据转换成元组，程序代码如下：</p>
<p><img src="/.com//image-20211020045832962.png" alt="image-20211020045832962"></p>
<p>运行程序，控制台输出结果如图4.37所示。</p>
<p><img src="/.com//image-20211020045913740.png" alt="image-20211020045913740"></p>
<p>​                            图4.37　DataFrame转换为元组</p>
<h3 id="4-5-6-Excel转换为HTML网页格式"><a href="#4-5-6-Excel转换为HTML网页格式" class="headerlink" title="4.5.6　Excel转换为HTML网页格式"></a>4.5.6　Excel转换为HTML网页格式</h3><p>日常工作中，有时会涉及财务数据的处理，而Excel应用最为广泛，但是对于展示数据来说，Excel并不友好，如果你想用其他格式的文件来向用户展示，那么，HTML网页格式是不错的选择。首先使用read_excel()方法导入Excel文件，然后使用to_html()方法将DataFrame数据导出为HTML格式，这样便实现了Excel转换为HTML格式。</p>
<p>【示例35】　将Excel订单数据转换为HTML网页格式。（示例位置：资源包\MR\Code\04\35）<br>将淘宝部分订单数据转换为HTML网页格式，效果如图4.38所示。</p>
<p><img src="/.com//image-20211020045939834.png" alt="image-20211020045939834"></p>
<p>​                              图4.38　Excel转换为HTML网页格式<br>程序代码如下：</p>
<p>01 import pandas as pd<br>02 df=pd.read_excel(‘mrbooks.xls’)<br>03 df.to_html(‘mrbook.html’,header = True,index = False)</p>
<h2 id="4-6-数据合并"><a href="#4-6-数据合并" class="headerlink" title="4.6　数据合并"></a>4.6　数据合并</h2><p>DataFrame数据合并主要使用merge()方法和concat()方法。</p>
<h3 id="4-6-1-数据合并（merge-方法）"><a href="#4-6-1-数据合并（merge-方法）" class="headerlink" title="4.6.1　数据合并（merge()方法）"></a>4.6.1　数据合并（merge()方法）</h3><p>Pandas模块的merge()方法是按照两个DataFrame对象列名相同的列进行连接合并，两个DataFrame对象必须具有同名的列。merge()方法的语法如下：</p>
<p>pandas.merge(right,how=’inner’,on=None,left_on=None,right_on=None,left_index=False,right_index=False,sort=<br>False,suffixes=(‘_x’,’_y’),copy=True,indicator=False,validate=None)<br>参数说明：　</p>
<p>right：合并对象，DataFrame对象或Series对象。　</p>
<p>how：合并类型，参数值可以是left（左合并）、right（右合并）、outer（外部合并）或inner（内部合并），默认值为inner。各个值的说明如下。　</p>
<p>​        left：只使用来自左数据集的键，类似于SQL左外部联接，保留键的顺序。　</p>
<p>​        right：只使用来自右数据集的键，类似于SQL右外部联接，保留键的顺序。　</p>
<p>​        outer：使用来自两个数据集的键，类似于SQL外部联接，按字典顺序对键进行排序。　</p>
<p>​        inner：使用来自两个数据集的键的交集，类似于SQL内部连接，保持左键的顺序。</p>
<p>on：标签、列表或数组，默认值为None。DataFrame对象连接的列或索引级别名称。也可以是DataFrame对象长度的数组或数组列表。</p>
<p>left_on：标签、列表或数组，默认值为None。要连接的左数据集的列或索引级名称，也可以是左数据集长度的数组或数组列表。　</p>
<p>right_on：标签、列表或数组，默认值为None。要连接的右数据集的列或索引级名称，也可以是右数据集长度的数组或数组列表。　left_index：布尔型，默认值为False。使用左数据集的索引作为连接键。如果是多重索引，则其他数据中的键数（索引或列数）必须匹配索引级别数。</p>
<p>right_index：布尔型，默认值为False，使用右数据集的索引作为连接键。　</p>
<p>sort：布尔型，默认值为False，在合并结果中按字典顺序对连接键进行排序。如果值为False，则连接键的顺序取决于连接类型how参数。　</p>
<p>suffixes：元组类型，默认值为(‘_x’,’_y’)。当左侧数据集和右侧数据集的列名相同时，数据合并后列名将带上“_x”和“_y”后缀。　</p>
<p>copy：是否复制数据，默认值为True。如果值为False，则不复制数据。　</p>
<p>indicator：布尔型或字符串，默认值为False。如果值为True，则添加一个列以输出名为_Merge的DataFrame对象，其中包含每一行的信息。如果是字符串，将向输出的DataFrame对象中添加包含每一行信息的列，并将列命名为字符型的值。　</p>
<p>validate：字符串，检查合并数据是否为指定类型。可选参数，其值说明如下。　one_to_one或“1:1”：检查合并键在左、右数据集中是否都是唯一的。　one_to_many或“1:m”：检查合并键在左数据集中是否唯一。　many_to_one或“m:1”：检查合并键在右数据集中是否唯一。　many_to_many或“m:m”：允许，但不检查。　</p>
<p>返回值：DataFrame对象，两个合并对象的数据集。</p>
<h4 id="1．常规合并"><a href="#1．常规合并" class="headerlink" title="1．常规合并"></a>1．常规合并</h4><p>【示例36】　合并学生成绩表。（示例位置：资源包\MR\Code\04\36）<br>假设一个DataFrame对象包含了学生的“语文”“数学”“英语”成绩，而另一个DataFrame对象则包含了学生的“体育”成绩，现在将它们合并，示意图如图4.39所示。</p>
<p><img src="/.com//image-20211020050304612.png" alt="image-20211020050304612"></p>
<p>​                 图4.39　数据合并效果对比示意图<br>程序代码如下：</p>
<p><img src="/.com//image-20211020050326358.png" alt="image-20211020050326358"></p>
<p>运行程序，控制台输出结果如图4.40所示。</p>
<p>【示例37】　通过索引合并数据。（示例位置：资源包\MR\Code\04\37）<br>如果通过索引列合并，则需要设置right_index参数和left_index参数值为True。例如，上述举例，通过列索引合并，主要代码如下：</p>
<p>01 df_merge=pd.merge(df1,df2,right_index=True,left_index=True)<br>02 print(df_merge)<br>运行程序，控制台输出结果如图4.41所示。</p>
<p><img src="/.com//image-20211020050352118.png" alt="image-20211020050352118"></p>
<p>​                           图4.40　合并结果</p>
<p><img src="/.com//image-20211020050412167.png" alt="image-20211020050412167"></p>
<p>​                            图4.41　通过索引列合并</p>
<p>【示例38】　对合并数据去重。（示例位置：资源包\MR\Code\04\38）<br>从图4.41中的运行结果得知：数据中存在重复列（如编号），如果不想要重复列，可以设置按指定列和列索引合并数据，主要代码如下：</p>
<p>df_merge=pd.merge(df1,df2,on=’编号’,left_index=True,right_index=True)</p>
<p>还可以通过how参数解决这一问题。例如，设置该参数值为left，就是让df1保留所有的行列数据，df2则根据df1的行列进行补全，主要代码如下：</p>
<p>df_merge=pd.merge(df1,df2,on=’编号’,how=’left’)<br>运行程序，控制台输出结果如图4.42所示。</p>
<p><img src="/.com//image-20211020050506047.png" alt="image-20211020050506047"></p>
<p>图4.42　合并结果</p>
<h4 id="2．多对一的数据合并"><a href="#2．多对一的数据合并" class="headerlink" title="2．多对一的数据合并"></a>2．多对一的数据合并</h4><p>多对一是指两个数据集（df1、df2）的共有列中的数据不是一对一的关系，例如，df1中的“编号”是唯一的，而df2中的“编号”有重复的编号，类似这种就是多对一的关系，示意图如图4.43所示。【示例39】　根据共有列进行合并数据。（示例位置：资源包\MR\Code\04\39）<br>根据共有列中的数据进行合并，df2根据df1的行列进行补全，程序代码如下：</p>
<p><img src="/.com//image-20211020050528714.png" alt="image-20211020050528714"></p>
<p>运行程序，控制台输出结果如图4.44所示。</p>
<p><img src="/.com//image-20211020050545631.png" alt="image-20211020050545631"></p>
<p>​                                     图4.43　多对一合并示意图</p>
<p><img src="/.com//image-20211020050604101.png" alt="image-20211020050604101"></p>
<p>​                                  图4.44　合并结果</p>
<h4 id="3．多对多的数据合并"><a href="#3．多对多的数据合并" class="headerlink" title="3．多对多的数据合并"></a>3．多对多的数据合并</h4><p>多对多是指两个数据集（df1、df2）的共有列中的数据不全是一对一的关系，都有重复数据，例如“编号”，示图如图4.45所示。</p>
<p><img src="/.com//image-20211020050702131.png" alt="image-20211020050702131"></p>
<p>​                                    图4.45　多对多示意图</p>
<p>【示例40】　合并数据并相互补全。（示例位置：资源包\MR\Code\04\40）<br>根据共有列中的数据进行合并，df2、df1相互补全，程序代码如下：</p>
<p><img src="/.com//image-20211020050733884.png" alt="image-20211020050733884"></p>
<p>运行程序，控制台输出结果如图4.46所示。</p>
<p><img src="/.com//image-20211020050749641.png" alt="image-20211020050749641"></p>
<p>​                                               图4.46　合并结果</p>
<h3 id="4-6-2-数据合并（concat-方法）"><a href="#4-6-2-数据合并（concat-方法）" class="headerlink" title="4.6.2　数据合并（concat()方法）"></a>4.6.2　数据合并（concat()方法）</h3><p>concat()方法可以根据不同的方式将数据合并，语法如下：</p>
<p>pandas.concat(objs,axis=0,join=’outer’,ignore_index: bool = False, keys=None, levels=None, names=None,<br>verify_integrity: bool = False, sort: bool = False, copy: bool = True)<br>参数说明：　</p>
<p>objs：Series、DataFrame或Panel对象的序列或映射。如果传递一个字典，则排序的键将用作键参数。　</p>
<p>axis：axis=1表示行，axis=0表示列。默认值为0。　</p>
<p>join：值为inner（内连接）或outer（外连连接），处理其他轴上的索引方式。默认值为outer。　</p>
<p>ignore_index：布尔值，默认值为False，保留索引，索引值为0，…，n-1。如果值为True，则忽略索引。　</p>
<p>keys：序列，默认值为None。使用传递的键作为最外层构建层次索引。如果为多索引，应该使用元组。　</p>
<p>levels：序列列表，默认值为None。用于构建MultiIndex的特定级别（唯一值）；否则，它们将从键推断。　</p>
<p>names：list列表，默认值为None。结果层次索引中的级别的名称。　</p>
<p>verify_integrity：布尔值，默认值为False。检查新连接的轴是否包含重复项。　</p>
<p>sort：布尔值，默认值为True（1.0.0以后版本默认值为False，即不排序）。如果连接为外连接（join=’outer’），则对未对齐的非连接轴进行排序；如果连接为内连接（join=’inner’），则该参数不起作用。</p>
<p>copy：是否复制数据，默认值为True，如果值为False，则不复制数据。</p>
<p>下面介绍concat()方法不同的合并方式，其中dfs代表合并后的DataFrame对象，df1、df2等代表单个DataFrame对象，result代表合并后的结果（DataFrame对象）。</p>
<h4 id="1．相同字段的表首尾相接"><a href="#1．相同字段的表首尾相接" class="headerlink" title="1．相同字段的表首尾相接"></a>1．相同字段的表首尾相接</h4><p>表结构相同的数据将直接合并，表首尾相接，主要代码如下：</p>
<p>01  dfs= [df1, df2, df3]<br>02  result = pd.concat(dfs)<br>例如，表df1、df2和df3结构相同，如图4.47所示。合并后的效果如图4.48所示。如果想要在合并数据时标记源数据来自哪张表，则需要在代码中加入参数keys，例如表名分别为“1月”“2月”“3月”，合并后的效果如图4.49所示。</p>
<p><img src="/.com//image-20211020051001176.png" alt="image-20211020051001176"></p>
<p>​                          图4.47　3张相同字段的表</p>
<p><img src="/.com//image-20211020051019220.png" alt="image-20211020051019220"></p>
<p>​                                     图4.48　首尾相接合并后的效果</p>
<p><img src="/.com//image-20211020051035379.png" alt="image-20211020051035379"></p>
<p>​                        图4.49　合并后带标记（月份）的效果<br>主要代码如下：</p>
<p>result = pd.concat(dfs, keys=[‘1月’, ‘2月’, ‘3月’])</p>
<h4 id="2．横向表合并（行对齐）"><a href="#2．横向表合并（行对齐）" class="headerlink" title="2．横向表合并（行对齐）"></a>2．横向表合并（行对齐）</h4><p>当合并的数据列名称不一致时，可以设置参数axis=1，concat()方法将按行对齐，然后将不同列名的两组数据进行合并，缺失的数据用NaN填充，df1和df4合并前后效果如图4.50和图4.51所示。</p>
<p><img src="/.com//image-20211020051057217.png" alt="image-20211020051057217"></p>
<p>​                        图4.50　横向表合并前</p>
<p><img src="/.com//image-20211020051113896.png" alt="image-20211020051113896"></p>
<p>​                            图4.51　横向表合并后<br>主要代码如下：</p>
<p>result = pd.concat([df1, df4], axis=1)</p>
<h4 id="3．交叉合并"><a href="#3．交叉合并" class="headerlink" title="3．交叉合并"></a>3．交叉合并</h4><p>交叉合并，需要在代码中加上join参数，如果值为inner，结果是两张表的交集；如果值为outer，结果是两张表的并集。例如两张表交集，表df1和df4合并前后的效果如图4.52和图4.53所示。</p>
<p><img src="/.com//image-20211020051227829.png" alt="image-20211020051227829"></p>
<p>​                                   图4.52　交叉合并前</p>
<p><img src="/.com//image-20211020051243654.png" alt="image-20211020051243654"></p>
<p>​                                       图4.53　交叉合并后<br>主要代码如下：</p>
<p>result = pd.concat([df1, df4], axis=1, join=’inner’)</p>
<h4 id="4．指定表对齐数据（行对齐）"><a href="#4．指定表对齐数据（行对齐）" class="headerlink" title="4．指定表对齐数据（行对齐）"></a>4．指定表对齐数据（行对齐）</h4><p>如果指定参数join_axes，就可以指定根据哪张表来对齐数据。例如，根据df4对齐数据，就会保留表df4的数据，然后将表df1的数据与之合并，行数不变，合并前后的效果与如图4.54和图4.55所示。</p>
<p><img src="/.com//image-20211020051305083.png" alt="image-20211020051305083"></p>
<p>​                          图4.54　指定表对齐数据合并前</p>
<p><img src="/.com//image-20211020051320918.png" alt="image-20211020051320918"></p>
<p>​                           图4.55　指定表对齐数据合并后<br>主要代码如下：</p>
<p>result = pd.concat([df1, df4], axis=1, join_axes=[df4.index])</p>
<h2 id="4-7-数据导出"><a href="#4-7-数据导出" class="headerlink" title="4.7　数据导出"></a>4.7　数据导出</h2><h3 id="4-7-1-导出为-xlsx文件"><a href="#4-7-1-导出为-xlsx文件" class="headerlink" title="4.7.1　导出为.xlsx文件"></a>4.7.1　导出为.xlsx文件</h3><p>导出数据为Excel，主要使用DataFrame对象的to_excel()方法，语法如下：</p>
<p>DataFrame.to_excel(excel_writer,sheet_name=’Sheet1’,na_rep=’’,float_format=None,columns=None,header=True,<br>index=True,index_label=None,startrow=0,startcol=0,engine=None,merge_cells=True, encoding=None, inf_rep=’inf’,<br>verbose=True, freeze_panes=None)<br>参数说明：　</p>
<p>excel_writer：字符串或ExcelWriter对象。　</p>
<p>sheet_name：字符串，默认值为Sheet1，包含DataFrame的表的名称。　</p>
<p>na_rep：字符串，默认值为’ ‘。缺失数据的表示方式。　</p>
<p>float_format：字符串，默认值为None，格式化浮点数的字符串。　</p>
<p>columns：序列，可选参数，要编辑的列。　</p>
<p>header：布尔型或字符串列表，默认值为True。列名称，如果给定字符串列表，则表示它是列名称的别名。　</p>
<p>index：布尔型，默认值为True，行名（索引）。　</p>
<p>index_label：字符串或序列，默认值为None。如果需要，可以使用索引列的列标签；如果没有给出，标题和索引为True，则使用索引名称；如果数据文件使用多索引，则需使用序列。</p>
<p>startrow：指定从哪一行开始写入数据。　</p>
<p>startcol：指定从哪一列开始写入数据。　</p>
<p>engine：字符串，默认值为None，指定要使用的写引擎，如openpyxl或xlsxwriter。也可以通过io.excel.xlsx.writer、io.excel.xls.writer和io.excel.xlsm.writer进行设置。　</p>
<p>merge_cells：布尔型，默认值为True。　</p>
<p>encoding：指定Excel文件的编码方式，默认值为None。　</p>
<p>inf_rep：字符串，默认值为“正”，表示无穷大。　</p>
<p>verbose：布尔型，默认值为True。在错误日志中显示更多信息。　freeze_panes：整数的元组，长度2，默认值为None。指定要冻结的行列。</p>
<p>【示例41】　将处理后的数据导出为Excel文件。（示例位置：资源包\MR\Code\04\41）<br>将数据合并后的结果导出为Excel文件，主要代码如下：</p>
<p>df_merge.to_excel(‘merge.xlsx’)<br>运行程序，数据将导出为Excel文件，如图4.56所示。</p>
<p><img src="/.com//image-20211020051510137.png" alt="image-20211020051510137"></p>
<p>​                         图4.56　导出为Excel文件</p>
<p>上述举例，如果需要指定Sheet页名称，可以通过sheet_name参数指定，主要代码如下：</p>
<p>df1.to_excel(‘df1.xlsx’,sheet_name=’df1’)</p>
<h3 id="4-7-2-导出为-csv文件"><a href="#4-7-2-导出为-csv文件" class="headerlink" title="4.7.2　导出为.csv文件"></a>4.7.2　导出为.csv文件</h3><p>导出数据为.csv文件，主要使用DataFrame对象的to_csv()方法，语法如下：</p>
<p>DataFrame.to_csv(path_or_buf=None,sep=’,’,na_rep=’’,float_format=None,columns=None,header=True,index=<br>True,index_label=None,mode=’w’,encoding=None,compression=’infer’,quoting=None,quotechar=’”‘,line_terminator=<br>None,chunksize=None,date_format=None,doublequote=True, escapechar=None, decimal=’.’,errors=’strict’)<br>参数说明：　</p>
<p>path_or_buf：要保存的路径及文件名。　</p>
<p>sep：分隔符，默认值为”,”。　</p>
<p>na_rep：指定空值的输出方式，默认值为空字符串。　</p>
<p>float_format：浮点数的输出格式，要用双引号括起来。　</p>
<p>columns：指定要导出的列，用列名列表表示，默认值为None。　header：是否输出列名，默认值为True。　</p>
<p>index：是否输出索引，默认值为True。　</p>
<p>index_label：索引列的列名，默认值为None。　</p>
<p>mode：Python写入模式，默认值为w。　</p>
<p>encoding：编码方式，默认值为utf-8。　</p>
<p>compression：压缩模式，默认值为infer。　</p>
<p>quoting：导出.csv文件是否用引号，默认值为0，表示不加双引号；如果值为1，则每个字段都会加上引号，数值也会被当作字符串看待。</p>
<p>quotechar：引用字符，当quoting=1时可以指定引号字符为双引号（” “）或单引号（’ ‘）。　</p>
<p>line_terminator：换行符，默认值为\n。</p>
<p>chunksize：一次写入.csv文件的行数，当DataFrame对象数据特别大时需要分批写入。　</p>
<p>date_format：日期输出格式。　</p>
<p>doublequote：是否添加双引用符，默认值为True。　</p>
<p>escapechar：设置转义字符。　</p>
<p>decimal：可识别十进制分隔符的字符。　</p>
<p>errors：指定如何处理编码和解码错误，默认值为strict（严格的）。</p>
<p>【示例42】　将处理后的数据导出为.csv文件。（示例位置：资源包\MR\Code\04\42）<br>下面介绍to_csv()方法常用功能，举例如下，df为DataFrame对象。<br>（1）相对位置，保存在程序所在路径下，代码如下：</p>
<p>df.to_csv(‘Result.csv’)<br>（2）绝对位置，代码如下：</p>
<p>df.to_csv(‘d:\Result.csv’)<br>（3）分隔符。使用问号（？）分隔符分隔需要保存的数据，代码如下：</p>
<p>df.to_csv(‘Result.csv’,sep=’?’)``<br>（4）替换空值，缺失值保存为NA，代码如下：</p>
<p>df.to_csv(‘Result1.csv’,na_rep=’NA’)<br>（5）格式化数据，保留两位小数，代码如下：</p>
<p>df.to_csv(‘Result1.csv’,float_format=’%.2f’)<br>（6）保留某列数据，保存索引列和name列，代码如下：</p>
<p>df.to_csv(‘Result.csv’,columns=[‘name’])<br>（7）是否保留列名，不保留列名，代码如下：</p>
<p>df.to_csv(‘Result.csv’,header=False)<br>（8）是否保留行索引，不保留行索引，代码如下：</p>
<p>df.to_csv(‘Result.csv’,index=False)</p>
<h3 id="4-7-3-导出多个Sheet"><a href="#4-7-3-导出多个Sheet" class="headerlink" title="4.7.3　导出多个Sheet"></a>4.7.3　导出多个Sheet</h3><p>导出多个Sheet，应首先使用pd.ExcelWriter()方法打开一个Excel文件，然后再使用to_excel()方法导出指定的Sheet。</p>
<p>【示例43】　导出Excel中多个Sheet页的数据。（示例位置：资源包\MR\Code\04\43）<br>导出指定Sheet页中的数据，主要代码如下：</p>
<p><img src="/.com//image-20211020051720411.png" alt="image-20211020051720411"></p>
<h2 id="4-8-日期数据处理"><a href="#4-8-日期数据处理" class="headerlink" title="4.8　日期数据处理"></a>4.8　日期数据处理</h2><h3 id="4-8-1-DataFrame的日期数据转换"><a href="#4-8-1-DataFrame的日期数据转换" class="headerlink" title="4.8.1　DataFrame的日期数据转换"></a>4.8.1　DataFrame的日期数据转换</h3><p>日常工作中，有一个非常麻烦的事情就是日期的格式可以有很多种表达，我们看到同样是2020年2月14日，可以有很多种格式，如图4.57所示。那么，我们需要先将这些格式统一后才能进行后续的工作。Pandas提供了to_datetime()方法可以帮助我们解决这一问题。<br>to_datetime()方法可以用来批量处理日期数据转换，对于处理大数据非常实用和方便，它可以将日期数据转换成你需要的各种格式。例如，将2/14/20和14-2-2020转换为日期格式2020-02-14。to_datetime()方法的语法如下：</p>
<p>pandas.to_datetime(arg,errors=’ignore’,dayfirst=False,yearfirst=False,utc=None,box=True,format=None,exact=<br>True,unit=None,infer_datetime_format=False,origin=’unix’,cache=False)<br>参数说明：　</p>
<p>arg：字符串、日期时间、字符串数组。　</p>
<p>errors：值为ignore、raise或coerce，具体说明如下，默认值为ignore，即忽略错误。　</p>
<p>ignore：无效的解析将返回原值。　</p>
<p>raise：无效的解析将引发异常。　</p>
<p>coerce：无效的解析将被设置为NaT，即无法转换为日期的数据将被转换为NaT。　</p>
<p>dayfirst：第一个为天，布尔型，默认值为False。例如02/09/2020，如果值为True，则解析日期的第一个为天，即2020-09-02；如果值为False，则解析日期与原日期一致，即2020-02-09。　</p>
<p>yearfirst：第一个为年，布尔型，默认值为False。例如14-Feb-20，如果值为True，则解析日期的第一个为年，即2014-02-20；如果值为False，则解析日期与原日期一致，即2020-02-14。　</p>
<p>utc：默认值为None。返回utc即协调世界时间。　</p>
<p>box：布尔值，默认值为True，如果值为True，则返回DatetimeIndex；如果值为False，则返回ndarray。　</p>
<p>format：格式化显示时间的格式。字符串，默认值为None。　</p>
<p>exact：布尔值，默认值为True。如果为True，则要求格式完全匹配；如果为False，则允许格式与目标字符串中的任何位置匹配。　</p>
<p>unit：默认值为None，参数的单位（D、s、、ms、μs、ns）表示时间的单位。　</p>
<p>infer_datetime_format：默认值为False。如果没有格式，则尝试根据第一个日期时间字符串推断格式。　</p>
<p>origin：默认值为unix。定义参考日期。数值将被解析为单位数。　</p>
<p>cache：默认值为False。如果值为True，则使用唯一、转换日期的缓存应用日期时间转换。在解析重复日期字符串，特别是带有时区偏移的字符串时，可能会产生明显的加速。只有在至少有50个值时才使用缓存。越界值的存在将使缓存不可用，并可能减慢解析速度。　</p>
<p>返回值：日期时间。</p>
<p>【示例44】　将各种日期字符串转换为指定的日期格式。（示例位置：资源包\MR\Code\04\44）<br>将2020年2月14日的各种格式转换为日期格式，程序代码如下：</p>
<p><img src="/.com//image-20211020051913944.png" alt="image-20211020051913944"></p>
<p>运行程序，控制台输出结果如图4.58所示。</p>
<p><img src="/.com//image-20211020051928130.png" alt="image-20211020051928130"></p>
<p>​                   图4.57　日期的多种格式转换</p>
<p><img src="/.com//image-20211020051944812.png" alt="image-20211020051944812"></p>
<p>​                 图4.58　2020年2月14日的各种格式转换为日期格式<br>还可以实现从DataFrame对象中的多列，如年、月、日各列组合成一列日期。键值是常用的日期缩略语。</p>
<p>组合要求：　</p>
<p>必选：year、month、day。　</p>
<p>可选：hour、minute、second、millisecond（毫秒）、microsecond（微秒）、nanosecond（纳秒）。</p>
<p>【示例45】　将一组数据组合为日期数据。（示例位置：资源包\MR\Code\04\45）<br>将一组数据组合为日期数据，主要代码如下：</p>
<p>运行程序，控制台输出结果如图4.59所示。</p>
<p><img src="/.com//image-20211020052022697.png" alt="image-20211020052022697"></p>
<p>​                                        图4.59　日期组合</p>
<h3 id="4-8-2-dt对象的使用"><a href="#4-8-2-dt对象的使用" class="headerlink" title="4.8.2　dt对象的使用"></a>4.8.2　dt对象的使用</h3><p>dt对象是Series对象中用于获取日期属性的一个访问器对象，通过它可以获取日期中的年、月、日、星期数、季节等，还可以判断日期是否处在年底。语法如下：</p>
<p>  Series.dt()<br>参数说明：　</p>
<p>返回值：返回与原始系列相同的索引系列。如果Series不包含类日期值，则引发错误。　</p>
<p>dt对象提供了year、month、day、dayofweek、dayofyear、is_leap_year、quarter、weekday_name等属性和方法。</p>
<p>例如，year可以获取“年”、month可以获取“月”、quarter可以直接得到每个日期分别是第几个季度，weekday_name可以直接得到每个日期对应的是周几。</p>
<p>【示例46】　获取日期中的年、月、日、星期数等。（示例位置：资源包\MR\Code\04\46）<br>使用dt对象获取日期中的年、月、日、星期数、季节等。<br>（1）获取年、月、日，代码如下：</p>
<p>df[‘年’],df[‘月’],df[‘日’]=df[‘日期’].dt.year,df[‘日期’].dt.month,df[‘日期’].dt.day<br>（2）从日期判断出所处星期数，代码如下：</p>
<p>df[‘星期几’]=df[‘日期’].dt.day_name()<br>（3）从日期判断所处季度，代码如下：</p>
<p>df[‘季度’]=df[‘日期’].dt.quarter<br>（4）从日期判断是否为年底最后一天，代码如下：</p>
<p>df[‘是否年底’]=df[‘日期’].dt.is_year_end<br>运行程序，控制台输出结果如图4.60所示。</p>
<p><img src="/.com//image-20211020052128703.png" alt="image-20211020052128703"></p>
<p>​                               图4.60　dt对象日期转换</p>
<h3 id="4-8-3-获取日期区间的数据"><a href="#4-8-3-获取日期区间的数据" class="headerlink" title="4.8.3　获取日期区间的数据"></a>4.8.3　获取日期区间的数据</h3><p>获取日期区间的数据的方法是直接在DataFrame对象中输入日期或日期区间，但前提必须设置日期为索引，举例如下。　</p>
<p>获取2018年的数据。</p>
<p>df1[‘2018’]　</p>
<p>获取2017—2018年的数据。</p>
<p>df1[‘2017’:’2018’]　</p>
<p>获取某月（2018年7月）的数据。</p>
<p>df1[‘2018-07’]　</p>
<p>获取具体某天（2018年5月6日）的数据。</p>
<p>df1[‘2018-05-06’:’2018-05-06’]</p>
<p>【示例47】　获取指定日期区间的订单数据。（示例位置：资源包\MR\Code\04\47）<br>获取2018年5月11日至6月10日的订单，结果如图4.61所示。<br>程序代码如下：</p>
<p><img src="/.com//image-20211020052236563.png" alt="image-20211020052236563"></p>
<p><img src="/.com//image-20211020052256160.png" alt="image-20211020052256160"></p>
<p>​            图4.61　2018年5月11日至6月10日的订单（省略部分数据）</p>
<h3 id="4-8-4-按不同时期统计并显示数据"><a href="#4-8-4-按不同时期统计并显示数据" class="headerlink" title="4.8.4　按不同时期统计并显示数据"></a>4.8.4　按不同时期统计并显示数据</h3><h4 id="1．按时期统计数据"><a href="#1．按时期统计数据" class="headerlink" title="1．按时期统计数据"></a>1．按时期统计数据</h4><p>按时期统计数据主要通过DataFrame对象的resample()方法结合数据计算函数实现。resample()方法主要应用于时间序列频率转换和重采样，它可以从日期中获取年、月、日、星期、季节等，结合数据计算函数就可以实现按年、月、日、星期或季度等不同时期统计数据。举例如下所示。<br>（1）按年统计数据，代码如下：</p>
<p>df1=df1.resample(‘AS’).sum()<br>（2）按季度统计数据，代码如下：</p>
<p>df2.resample(‘Q’).sum()<br>（3）按月度统计数据，代码如下：</p>
<p>df1.resample(‘M’).sum()<br>（4）按星期统计数据，代码如下：</p>
<p>df1.resample(‘W’).sum()<br>（5）按天统计数据，代码如下：</p>
<p>df1.resample(‘D’).sum()</p>
<p>实用技巧<br>按日期统计数据过程中，可能会出现如图4.62所示的错误提示。</p>
<p><img src="/.com//image-20211020052356675.png" alt="image-20211020052356675"></p>
<p>图4.62　错误提示</p>
<p>完整错误描述：<br>TypeError: Only valid with DatetimeIndex, TimedeltaIndex or PeriodIndex, but got an instance of’Index’<br>出现上述错误，是由于<strong>resample()函数要求索引必须为日期型</strong>。<br>解决方法：将数据的索引转换为datetime类型，主要代码如下：</p>
<p>df1.index = pd.to_datetime(df1.index)</p>
<h4 id="2．按时期显示数据"><a href="#2．按时期显示数据" class="headerlink" title="2．按时期显示数据"></a>2．按时期显示数据</h4><p>DataFrame对象的to_period()方法可以将时间戳转换为时期，从而实现按时期显示数据，前提是日期必须设置为索引。语法如下：</p>
<p>DataFrame.to_period(freq=None, axis=0, copy=True)<br>参数说明：　</p>
<p>freq：字符串，周期索引的频率，默认值为None。　</p>
<p>axis：行列索引，axis=0表示行索引，axis=1表示列索引。默认值为0，即表示行索引。　</p>
<p>copy：是否复制数据，默认值为True，如果值为False，则不复制数据。　返回值：带周期索引的时间序列。</p>
<p>【示例48】　从日期中获取不同的时期。（示例位置：资源包\MR\Code\04\48）<br>从日期中获取不同的时期，主要代码如下：</p>
<p><img src="/.com//image-20211020052452293.png" alt="image-20211020052452293"></p>
<h4 id="3．按时期统计并显示数据"><a href="#3．按时期统计并显示数据" class="headerlink" title="3．按时期统计并显示数据"></a>3．按时期统计并显示数据</h4><p>（1）按年统计并显示数据，代码如下：</p>
<p>df2.resample(‘AS’).sum().to_period(‘A’)<br>控制台输出结果如图4.63所示。<br>（2）按季度统计并显示数据，代码如下：</p>
<p>Q_df=df2.resample(‘Q’).sum().to_period(‘Q’)</p>
<p>控制台输出结果如图4.64所示。</p>
<p><img src="/.com//image-20211020052536700.png" alt="image-20211020052536700"></p>
<p>​                            图4.63　按年统计并显示数据</p>
<p><img src="/.com//image-20211020052550813.png" alt="image-20211020052550813"></p>
<p>​                      图4.64　按季度统计并显示数据<br>（3）按月统计并显示数据，代码如下：</p>
<p>df2.resample(‘M’).sum().to_period(‘M’)<br>控制台输出结果如图4.65所示。<br>（4）按星期统计并显示数据（前5条数据），代码如下：</p>
<p>df2.resample(‘W’).sum().to_period(‘W’).head()<br>控制台输出结果如图4.66所示。</p>
<p><img src="/.com//image-20211020052622774.png" alt="image-20211020052622774"></p>
<p>​                          图4.65　按月统计并显示数据</p>
<p><img src="/.com//image-20211020052640893.png" alt="image-20211020052640893"></p>
<p>​                      图4.66　按星期统计并显示数据</p>
<h2 id="4-9-时间序列"><a href="#4-9-时间序列" class="headerlink" title="4.9　时间序列"></a>4.9　时间序列</h2><h3 id="4-9-1-重采样（Resample-方法）"><a href="#4-9-1-重采样（Resample-方法）" class="headerlink" title="4.9.1　重采样（Resample()方法）"></a>4.9.1　重采样（Resample()方法）</h3><p>通过前面的学习，我们学会了如何生成不同频率的时间索引，按小时、按天、按周、按月等，如果想对数据做不同频率的转换，该怎么办？在Pandas中对时间序列的频率的调整称为重新采样，即将时间序列从一个频率转换到另一个频率的处理过程。例如，每天一个频率转换为每5天一个频率，如图4.67所示。</p>
<p><img src="/.com//image-20211020052720517.png" alt="image-20211020052720517"></p>
<p>​                                       图4.67　时间频率<br>重采样主要使用resample()方法，该方法用于对常规时间序列重新采样和频率转换，包括降采样和升采样两种。首先了解下resample()方法，语法如下：</p>
<p>DataFrame.resample(rule,how=None,axis=0,fill_method=None,closed=None,label=None,convention=’start’,kind=<br>None,loffset=None,limit=None,base=0,on=None,level=None)<br>参数说明：　</p>
<p>rule：字符串，偏移量表示目标字符串或对象转换。　</p>
<p>how：用于产生聚合值的函数名或数组函数。例如mean、ohlc和np.max等，默认值为mean，其他常用的值为first、last、median、max和min。　</p>
<p>axis：整型，表示行列，axis=0表示列，axis=1表示行。默认值为0，即表示列。　fill_method：升采样时所使用的填充方法，ffill()方法（用前值填充）或bfill()方法（用后值填充），默认值为None。　</p>
<p>closed：降采样时，时间区间的开和闭，与数学里区间的概念一样，其值为right或left，right表示左开右闭（即左边值不包括在内），left表示左闭右开（即右边值不包括在内），默认值为right左开右闭。　</p>
<p>label：降采样时，如何设置聚合值的标签。例如，10:30—10:35会被标记成10:30还是10:35，默认值为None。　</p>
<p>convention：当重采样时，将低频率转换到高频率所采用的约定，其值为start或end，默认值为start。　</p>
<p>kind：聚合到时期（period）或时间戳（timestamp），默认聚合到时间序列的索引类型，默认值为None。　</p>
<p>loffset：聚合标签的时间校正值，默认值为None。例如，-1s或Second(-1)用于将聚合标签调早1秒。　</p>
<p>limit：向前或向后填充时，允许填充的最大时期数，默认值为None。</p>
<p>　base：整型，默认值为0。对于均匀细分1天的频率，聚合间隔的“原点”。例如，对于5min频率，base的范围可以是0～4。　on：字符串，可选参数，默认值为None。对DataFrame对象使用列代替索引进行重新采样。列必须与日期时间类似。　</p>
<p>level：字符串或整型，可选参数，默认值为None。用于多索引，重新采样的级别名称或级别编号，级别必须与日期时间类似。　</p>
<p>返回值：重新采样对象。</p>
<p>【示例49】　一分钟的时间序列转换为3分钟的时间序列。（示例位置：资源包\MR\Code\04\49）<br>首先创建一个包含9个一分钟的时间序列，然后使用resample()方法转换为3分钟的时间序列，并对索引列进行求和计算，如图4.68所示。</p>
<p><img src="/.com//image-20211020052840027.png" alt="image-20211020052840027"></p>
<p>​                          图4.68　时间序列转换</p>
<p><img src="/.com//image-20211106103741281.png" alt="image-20211106103741281">程序代码如下：</p>
<p>01  import pandas as pd<br>02  index = pd.date_range(‘02/02/2020’, periods=9, freq=’T’)</p>
<p>03  series = pd.Series(range(9), index=index)<br>04  print(series)<br>05  print(series.resample(‘3T’).sum())</p>
<h3 id="4-9-2-降采样处理"><a href="#4-9-2-降采样处理" class="headerlink" title="4.9.2　降采样处理"></a>4.9.2　降采样处理</h3><p>降采样是周期由高频率转向低频率。例如，将5min股票交易数据转换为日交易，按天统计的销售数据转换为按周统计。<br>数据降采样会涉及数据的聚合。例如，天数据变成周数据，那么就要对1周7天的数据进行聚合，聚合的方式主要包括求和、求均值等。例如，淘宝店铺每天销售数据（部分数据），如图4.69所示。</p>
<p>【示例50】　按周统计销售数据。（示例位置：资源包\MR\Code\04\50）<br>使用resample()方法来做降采样处理，频率为“周”，也就是将上述销售数据处理为每周（每7天）求和一次数据，程序代码如下：</p>
<p>01 import pandas as pd<br>02 df=pd.read_excel(‘time.xls’)<br>03 df1 = df.set_index(‘订单付款时间’)  #设置“订单付款时间”为索引<br>04 print(df1.resample(‘W’).sum().head())<br>运行程序，控制台输出结果如图4.70所示。<br>在参数说明中，我们列出了closed参数的解释，如果把closed参数值设置为left，结果如图4.71所示。</p>
<p><img src="/.com//image-20211020052938423.png" alt="image-20211020052938423"></p>
<p>​              图4.69　淘宝店铺每天销售数据（部分数据）</p>
<p><img src="/.com//image-20211020053019859.png" alt="image-20211020053019859"></p>
<p>​                                       图4.70　周数据统计1</p>
<p><img src="/.com//image-20211020053036196.png" alt="image-20211020053036196"></p>
<p>​                              图4.71　周数据统计2</p>
<h3 id="4-9-3-升采样处理"><a href="#4-9-3-升采样处理" class="headerlink" title="4.9.3　升采样处理"></a>4.9.3　升采样处理</h3><p>​    升采样是周期由低频率转向高频率。将数据从低频率转换到高频率时，就不需要聚合了，将其重采样到日频率，默认会引入缺失值。<br>例如，原来是按周统计的数据，现在变成按天统计。升采样会涉及数据的填充，根据填充的方法不同，填充的数据也不同。下面介绍3种填充方法。　不填充。空值用NaN代替，使用asfreq()方法。　用前值填充。用前面的值填充空值，使用ffill()方法或者pad()方法。为了方便记忆，ffill()方法可以使用它的第一个字母“f”代替，代表forward，向前的意思。　用后值填充，使用bfill()方法，可以使用字母“b”代替，代表back，向后的意思。</p>
<p>【示例51】　每6小时统计一次数据。（示例位置：资源包\MR\Code\04\51）<br>下面创建一个时间序列，起始日期是2020-02-02，一共两天，每天对应的数值分别是1和2，通过升采样处理为每6小时统计一次数据，空值以不同的方式填充，程序代码如下：</p>
<p>01  import pandas as pd<br>02  import numpy as np<br>03  rng = pd.date_range(‘20200202’, periods=2)<br>05  s1_6h_asfreq = s1.resample(‘6H’).asfreq()</p>
<p>06  print(s1_6h_asfreq)<br>07  s1_6h_pad = s1.resample(‘6H’).pad()<br>08  print(s1_6h_pad)<br>09  s1_6h_ffill = s1.resample(‘6H’).ffill()<br>10  print(s1_6h_ffill)<br>11  s1_6h_bfill = s1.resample(‘6H’).bfill()<br>12  print(s1_6h_bfill)<br>运行程序，控制台输出结果如图4.72所示。</p>
<p><img src="/.com//image-20211020053124798.png" alt="image-20211020053124798"></p>
<p>​                          图4.72　6小时数据统计</p>
<h3 id="4-9-4-时间序列数据汇总（ohlc-函数）"><a href="#4-9-4-时间序列数据汇总（ohlc-函数）" class="headerlink" title="4.9.4　时间序列数据汇总（ohlc()函数）"></a>4.9.4　时间序列数据汇总（ohlc()函数）</h3><p>在金融领域，经常会看到开盘（open）、收盘（close）、最高价（high）和最低价（low）数据，而在Pandas中经过重新采样的数据也可以实现这样的结果，通过调用ohlc()函数得到数据汇总结果，即开始值（open）、结束值（close）、最高值（high）和最低值（low）。ohlc()函数的语法如下：</p>
<p>resample.ohlc()<br>ohlc()函数返回DataFrame对象，每组数据的open（开）、high（高）、low（低）和close（关）值。</p>
<p>【示例52】　统计数据的open、high、low和close值。（示例位置：资源包\MR\Code\04\52）<br>下面是一组5分钟的时间序列，通过ohlc()函数获取该时间序列中每组时间的开始值、最高值、最低值和结束值，程序代码如下：</p>
<p>01  import pandas as pd<br>02  import numpy as np<br>03  rng = pd.date_range(‘2/2/2020’,periods=12,freq=’T’)<br>04  s1 = pd.Series(np.arange(12),index=rng)<br>05  print(s1.resample(‘5min’).ohlc())<br>运行程序，控制台输出结果如图4.73所示。</p>
<p><img src="/.com//image-20211020053212045.png" alt="image-20211020053212045"></p>
<p>​                          图4.73　时间序列数据汇总</p>
<h3 id="4-9-5-移动窗口数据计算（rolling-函数）"><a href="#4-9-5-移动窗口数据计算（rolling-函数）" class="headerlink" title="4.9.5　移动窗口数据计算（rolling()函数）"></a>4.9.5　移动窗口数据计算（rolling()函数）</h3><p>通过重采样可以得到想要的任何频率的数据，但是这些数据也是一个时点的数据，那么就存在这样一个问题：时点的数据波动较大，某一点的数据就不能很好地表现它本身的特性，于是就有了“移动窗口”的概念，简单地说，为了提升数据的可靠性，将某个点的取值扩大到包含这个点的一段区间，用区间来进行判断，这个区间就是窗口。<br>下面举例说明，图4.74显示了移动窗口数据示意图，其中时间序列代表1号到15号每天的销量数据，接下来以3天为一个窗口，将该窗口从左至右依次移动，统计出3天的平均值作为这个点的值，如3号的销量是1号、2号和3号的平均值。</p>
<p><img src="/.com//image-20211020053234231.png" alt="image-20211020053234231"></p>
<p>​                      图4.74　移动窗口数据示意图<br>通过上述示意图相信您已经理解了移动窗口，在Pandas中可以通过rolling()函数实现移动窗口数据的计算，语法如下：</p>
<p>DataFrame.rolling(window, min_periods=None, center=False, win_type=None, on=None, axis=0, closed=None)</p>
<p>参数说明：　</p>
<p>window：时间窗口的大小，有两种形式，即int或offset。如果使用int，则数值表示计算统计量的观测值的数量，即向前几个数据；如果使用offset，则表示时间窗口的大小。　</p>
<p>min_periods：每个窗口最少包含的观测值数量，小于这个值的窗口结果为NA。值可以是int，默认值为None。offset情况下，默认值为1。</p>
<p>center：把窗口的标签设置为居中。布尔型，默认值为False，居右。</p>
<p>win_type：窗口的类型。截取窗的各种函数。字符串类型，默认值为None。　</p>
<p>on：可选参数。对于DataFrame对象，是指定要计算移动窗口的列，值为列名。　</p>
<p>axis：整型，axis=0表示列，axis=1表示行。默认值为0，即对列进行计算。　</p>
<p>closed：定义区间的开闭，支持int类型的窗口。对于offset类型默认是左开右闭（默认值为right）。可以根据情况指定left。　</p>
<p>返回值：为特定操作而生成的窗口或移动窗口子类。</p>
<p>【示例53】　创建淘宝每日销量数据。（示例位置：资源包\MR\Code\04\53）<br>首先创建一组淘宝每日销量数据，程序代码如下：</p>
<p>01  import pandas as pd<br>02  index=pd.date_range(‘20200201’,’20200215’)<br>03  data=[3,6,7,4,2,1,3,8,9,10,12,15,13,22,14]<br>04  s1_data=pd.Series(data,index=index)<br>05  print(s1_data)<br>运行程序，控制台输出结果如图4.75所示。</p>
<p>【示例54】　使用rolling()函数计算3天的均值。（示例位置：资源包\MR\Code\04\54）</p>
<p>下面使用rolling()函数计算2020-02-01至2020-02-15中每3天的均值，窗口个数为3，代码如下：</p>
<p>s1_data.rolling(3).mean()<br>运行程序，看下rolling()函数是如何计算的？在图4.76中，当窗口开始移动时，第一个时间点2020-02-01和第二个时间点2020-02-02的数值为空，这是因为窗口个数为3，它们前面有空数据，所以均值为空；而到第三个时间点2020-02-03时，它前面的数据是2020-02-01至2020-02-03，所以3天的均值是5.333333；以此类推。</p>
<p><img src="/.com//image-20211020053403924.png" alt="image-20211020053403924"></p>
<p>​                                     图4.75　原始数据</p>
<p><img src="/.com//image-20211020053419587.png" alt="image-20211020053419587"></p>
<p>​                       图4.76　2020-02-01至2020-02-15移动窗口均值1</p>
<p>【示例55】　用当天的数据代表窗口数据。（示例位置：资源包\MR\Code\04\55）<br>在计算第一个时间点2020-02-01的窗口数据时，虽然数据不够窗口长度3，但是至少有当天的数据，那么能否用当天的数据代表窗口数据呢？答案是肯定的，通过设置min_periods参数即可，它表示窗口最少包含的观测值，小于这个值的窗口长度显示为空，等于或大于时都有值，主要代码如下：</p>
<p>s1_data.rolling(3,min_periods=1).mean()</p>
<p>运行程序，对比效果如图4.77所示。<br>上述举例，我们再扩展下，通过图表观察原始数据与移动窗口数据的平稳性，如图4.78所示。其中实线代表移动窗口数据，其走向更平稳，这也是学习移动窗口rolling()函数的原因。</p>
<p><img src="/.com//image-20211020053518298.png" alt="image-20211020053518298"></p>
<p>​                 图4.77　2020-02-01至2020-02-15移动窗口均值2</p>
<p><img src="/.com//image-20211020053531782.png" alt="image-20211020053531782"></p>
<p>​                     图4.78　移动窗口数据的平稳性说明<br>虚线代表原始数据，实线代表移动窗口数据。</p>
<h2 id="4-10-综合应用"><a href="#4-10-综合应用" class="headerlink" title="4.10　综合应用"></a>4.10　综合应用</h2><h3 id="4-10-1-案例1：Excel多表合并"><a href="#4-10-1-案例1：Excel多表合并" class="headerlink" title="4.10.1　案例1：Excel多表合并"></a>4.10.1　案例1：Excel多表合并</h3><p>案例位置：资源包\MR\Code\04\example\01<br>在日常工作中，几乎我们每天都有大量的数据需要处理，桌面上总是布满密密麻麻的Excel表，这样看上去非常凌乱，其实我们完全可以将其中类别相同的Excel表合并到一起，这样不但不会丢失数据，而且还可以有效地分析数据。下面使用concat()方法将指定文件夹内的所有Excel表合并，程序代码如下：</p>
<p><img src="/.com//image-20211020053607260.png" alt="image-20211020053607260"></p>
<h3 id="4-10-2-案例2：股票行情数据分析"><a href="#4-10-2-案例2：股票行情数据分析" class="headerlink" title="4.10.2　案例2：股票行情数据分析"></a>4.10.2　案例2：股票行情数据分析</h3><p>案例位置：资源包\MR\Code\04\example\02<br>股票数据包括开盘价、收盘价、最高价、最低价、成交量等多个指标。其中，收盘价是当日行情的标准，也是下一个交易日开盘价的依据，可以预测未来证券市场行情，因此当投资者对行情分析时，一般采用收盘价作为计算依据。<br>下面使用rolling()函数计算某股票20天、50天和200天的收盘价均值并生成走势图（也称K线图），如图4.79所示。</p>
<p><img src="/.com//image-20211020053723586.png" alt="image-20211020053723586"></p>
<p>​                                       图4.79　股票行情分析</p>
<p>程序代码如下：</p>
<p><img src="/.com//image-20211020053800663.png" alt="image-20211020053800663"></p>
<p>实用技巧<br>默认情况下，图表嵌入控制台（IPython console）中并以静态方式显示，无法进行移动、放大、缩小等操作。此时需要在工具中的首选项窗口进行设置，方法为选择Tools→Preferences命令，打开Preferences（首选项）窗口，在左侧列表中选择IPython console（IPython控制台），在右侧窗口选择Graphics（图形）选项卡，然后在Backend（后端）下拉列表框中选择Automatic（自动）或者Qt5，单击Apply（应用）按钮。设置完成后重新启动Spyder才生效。</p>
<h2 id="4-11-小结"><a href="#4-11-小结" class="headerlink" title="4.11　小结"></a>4.11　小结</h2><p>本章是Pandas的进阶学习，有一定难度，但同时也更能够体现Pandas的强大之处，不仅可以完成数据处理工作，而且还能够实现数据的统计分析。Pandas提供的大量函数使统计分析工作变得简单高效。别具特色的“数据位移”是一个非常有用的方法，与其他方法结合，能够实现很多难以想象的功能，数据转换将DataFrame与Python数据类型之间进行灵活转换。不仅如此，对于日期数据的处理、时间序列也都提供了专门的函数和方法，使得量化数据得心应手。</p>
<pre><code class="python">import pymysql
from sqlalchemy import create_engine
import pandas as pd
engine = create_engine(&#39;mysql+pymysql://root:123456@127.0.0.1:3306/2013a&#39;)
sql2=&#39;select * from stu;&#39;
df2=pd.read_excel(&#39;费用.xlsx&#39;)
df2.to_sql(&#39;feiyong&#39;,engine) # 存入数据库
df_read1=pd.read_sql_query(sql2,engine) # 读出数据
</code></pre>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
  </entry>
  <entry>
    <title>pandas</title>
    <url>/2020/12/09/pandas/</url>
    <content><![CDATA[<p>一. 数据分析</p>
<p>熟悉工具-明确目的-获取数据-数据处理-数据分析-验证结果-结果呈现-数据应用</p>
<p>​                                                                                          表3.1　数据类型对应表　</p>
<h3 id="3-3-DataFrame重要属性和函数"><a href="#3-3-DataFrame重要属性和函数" class="headerlink" title="3.3 DataFrame重要属性和函数"></a>3.3 DataFrame重要属性和函数</h3><p>DataFrame是Pandas一个重要的对象，它的属性和函数很多，下面先简单了解DataFrame的几个重要属性和函数。重要属性介绍如表3.2所示，重要函数介绍如表3.3所示。</p>
<p>​                                                                                               表3.2　重要属性</p>
<p>​                                                                                                  表3.3　重要函数</p>
<h3 id="3-4-导入外部数据"><a href="#3-4-导入外部数据" class="headerlink" title="3.4 导入外部数据"></a>3.4 导入外部数据</h3><h4 id="3-4-1-导入-xls或-xlsx文件"><a href="#3-4-1-导入-xls或-xlsx文件" class="headerlink" title="3.4.1　导入.xls或.xlsx文件"></a>3.4.1　导入.xls或.xlsx文件</h4><p>导入.xls或.xlsx文件主要使用Pandas的read_excel()方法，语法如下：</p>
<p>pandas.read_excel(io,sheet_name=0,header=0,names=None,index_col=None,usecols=None,squeeze=False,<br>dtype=None,engine=None,converters=None,true_values=None,false_values=None,skiprows=None,nrow=None,<br>na_values=None,keep_default_na=True,verbose=False,parse_dates=False,date_parser=None,thousands=None,<br>comment=None,skipfooter=0,conver_float=True,mangle_dupe_cols=True,**kwds)<br>常用参数说明：　</p>
<p>io：字符串，.xls或.xlsx文件路径或类文件对象。　</p>
<p>sheet_name：None、字符串、整数、字符串列表或整数列表，默认值为0。字符串用于工作表名称，整数为索引表示工作表位置，字符串列表或整数列表用于请求多个工作表，为None时获取所有工作表。参数值如表3.4所示。</p>
<p>​                                                                                     表3.4　sheet_name参数值　</p>
<p>header：指定作为列名的行，默认值为0，即取第一行的值为列名。数据为除列名以外的数据；若数据不包含列名，则设置header=None。　</p>
<p>names：默认值为None，要使用的列名列表。　</p>
<p>index_col：指定列为行索引，默认值为None，索引0是DataFrame的行标签。</p>
<p>usecols：int、list列表或字符串，默认值为None。　如果为None，则解析所有列。　如果为int，则解析最后一列。　如果为list列表，则解析列号列表的列。　如果为字符串，则表示以逗号分隔的Excel列字母和列范围列表（例如“A:E”或“A,C,E:F”）。范围包括双方。　squeeze：布尔值，默认值为False，如果解析的数据只包含一列，则返回一个Series。　</p>
<p>dtype：列的数据类型名称或字典，默认值为None。例如{‘a’:np.float64,’b’:np.int32}。　</p>
<p>skiprows：省略指定行数的数据，从第一行开始。　</p>
<p>skipfooter：省略指定行数的数据，从尾部数的行开始。</p>
<p>下面通过示例，详细介绍如何导入.xlsx文件。</p>
<p>知识胶囊<br>导入外部数据，必然要涉及路径问题，下面来了解一下相对路径和绝对路径。　</p>
<p><strong>相对路径</strong>：相对路径就是以当前文件为基准进行一级级目录指向被引用的资源文件。以下是常用的表示当前目录和当前目录的父级目录的标识符。　../：表示当前文件所在目录的上一级目录。　./：表示当前文件所在的目录（可以省略）。　/：表示当前文件的根目录（域名映射或硬盘目录）。　如果使用系统默认文件路径\，那么，在Python中则需要在路径最前面加一个r，以避免路径里面的\被转义。　</p>
<p><strong>绝对路径</strong>：绝对路径是文件真正存在的路径，是指从硬盘的根目录（盘符）开始，进行一级级目录指向文件。</p>
<h5 id="2．导入指定的Sheet页"><a href="#2．导入指定的Sheet页" class="headerlink" title="2．导入指定的Sheet页"></a>2．导入指定的Sheet页</h5><p>一个Excel文件包含多个Sheet页，通过设置sheet_name参数就可以导入指定Sheet页的数据。</p>
<p>【示例13】　导入指定Sheet页的数据。 \03\13）一个Excel文件包含多家店铺的销售数据，导入其中一家店铺（莫寒）的销售数据，如图3.14所示。<br>图3.14　原始数据</p>
<p>程序代码如下：</p>
<p>01 import pandas as pd<br>02 df=pd.read_excel(‘1 月.xlsx’,sheet_name=’莫寒’)<br>03 df1=df.head()          #输出前5条数据<br>运行程序，输出前5条数据，结果如图3.15所示。<br>除了指定Sheet页的名字，还可以指定Sheet页的顺序，从0开始。例如，sheet_name=0表示导入第一个Sheet页的数据，sheet_name=1表示导入第二个Sheet页的数据，以此类推。<br>如果不指定sheet_name参数，则默认导入第一个Sheet页的数据。</p>
<h5 id="3．通过行、列索引导入指定行、列数据"><a href="#3．通过行、列索引导入指定行、列数据" class="headerlink" title="3．通过行、列索引导入指定行、列数据"></a>3．通过行、列索引导入指定行、列数据</h5><p>DataFrame是二维数据结构，因此它既有行索引又有列索引。当导入Excel数据时，行索引会自动生成，如0、1、2；而列索引则默认将第0行作为列索引（如A,B,…,J）。DataFrame行、列索引的示意图如图3.16所示。</p>
<p>​                                                  </p>
<p>​                                                                            图3.15　导入指定的Sheet页（前5条数据） </p>
<p>​                                                                                图3.16　DataFrame行、列索引示意图</p>
<p>【示例14】　指定行索引导入Excel数据。 \03\14）<br>如果通过指定行索引导入Excel数据，则需要设置index_col参数。下面将“买家会员名”作为行索引（位于第0列），导入Excel数据，程序代码如下：</p>
<p>01 import pandas as pd<br>02 df1=pd.read_excel(‘1 月.xlsx’,index_col=0)     #“买家会员名”为行索引<br>03 df1=df1.head()                                 #输出前5条数据<br>运行程序，输出结果如图3.17所示。</p>
<p>图3.17　通过指定行索引导入Excel数据<br>如果通过指定列索引导入Excel数据，则需要设置header参数，主要代码如下：</p>
<p>df2=pd.read_excel(‘1月.xlsx’,header=1)        #设置第1行为列索引</p>
<p>运行程序，输出结果如图3.18所示。<br>如果将数字作为列索引，可以设置header参数为None，主要代码如下：</p>
<p>df3=pd.read_excel(‘1月.xlsx’,header=None)    #列索引为数字</p>
<p>运行程序，输出结果如图3.19所示。</p>
<p>图3.19　指定列索引<br>那么，为什么要指定索引呢？因为通过索引可以快速地检索数据，例如df3[0]，就可以快速检索到“买家会员名”这一列数据。</p>
<h5 id="4-导入指定列数据"><a href="#4-导入指定列数据" class="headerlink" title="4.导入指定列数据"></a>4.导入指定列数据</h5><p>一个Excel往往包含多列数据，如果只需要其中的几列，可以通过usecols参数指定需要的列，从0开始（表示第1列，以此类推）。</p>
<p>【示例15】　导入第1列数据。 \03\15）下面导入第1列数据（索引为0），程序代码如下：</p>
<p>01 import pandas as pd<br>02 df1=pd.read_excel(‘1 月.xlsx’,usecols=[0])       #导入第1列<br>03 df1.head()<br>运行程序，输出结果如图3.20所示。<br>如果导入多列，可以在列表中指定多个值。例如，导入第1列和第4列，主要代码如下：</p>
<p>df2=pd.read_excel(‘1月.xlsx’,usecols=[0,3])<br>也可以指定列名称，主要代码如下：</p>
<p>df3=pd.read_excel(‘1月.xlsx’,usecols=[‘买家会员名’,’宝贝标题’])<br>运行程序，输出结果如图3.21所示。</p>
<p>​                                                                                     图3.21　导入第1列和第4列数据</p>
<h4 id="3-4-2-导入-csv文件"><a href="#3-4-2-导入-csv文件" class="headerlink" title="3.4.2　导入.csv文件"></a>3.4.2　导入.csv文件</h4><p>导入.csv文件主要使用Pandas的read_csv()方法，语法如下：</p>
<p>常用参数说明：　</p>
<p>filepath_or_buffer：字符串，文件路径，也可以是URL链接。　</p>
<p>sep、delimiter：字符串，分隔符。</p>
<p>header：指定作为列名的行，默认值为0，即取第1行的值为列名。数据为除列名以外的数据；若数据不包含列名，则设置header=None。　</p>
<p>names：默认值为None，要使用的列名列表。　</p>
<p>index_col：指定列为索引列，默认值为None，索引0是DataFrame的行标签。　</p>
<p>usecols：int、list列表或字符串，默认值为None。　如果为None，则解析所有列。　如果为int，则解析最后一列。　如果为list列表，则解析列号列表的列。　如果为字符串，则表示以逗号分隔的Excel列字母和列范围列表（例如“A:E”或“A,C,E:F”）。范围包括双方。　dtype：列的数据类型名称或字典，默认值为None。例如{‘a’:np.float64,’b’:np.int32}。　</p>
<p>parse_dates：布尔类型值、int类型值的列表、列表或字典，默认值为False。可以通过parse_dates参数直接将某列转换成datetime64日期类型。例如，df1=pd.read_csv(‘1月.csv’, parse_dates=[‘订单付款时间’])。　</p>
<p>​        parse_dates为True时，尝试解析索引。　</p>
<p>​        parse_dates为int类型值组成的列表时，如[1,2,3]，则解析1、2、3列的值作为独立的日期列。　</p>
<p>​        parse_date为列表组成的列表，如[[1,3]]，则将1、3列合并，作为一个日期列使用。　</p>
<p>​        parse_date为字典时，如{‘总计’：[1, 3]}，则将1、3列合并，合并后的列名为“总计”。　</p>
<p>encoding：字符串，默认值为None，文件的编码格式。Python常用的编码格式是UTF-8。　返回值：返回一个DataFrame。</p>
<p>【示例16】　导入.csv文件。 \03\16）导入.csv文件，程序代码如下：</p>
<p>01 import pandas as pd<br>02 df1=pd.read_csv(‘1月.csv’<strong>,encoding=</strong>‘gbk’)        #导入.csv文件，并指定编码格式<br>03 df1=df1.head()                                   #输出前5条数据<br>运行程序，输出结果如图3.22所示。                                                  </p>
<p>​                                                                                            图3.22　导入.csv文件</p>
<p>注意<br>上述代码中指定了编码格式，即encoding=’gbk’。Python常用的编码格式是UTF-8和gbk，默认编码格式为UTF-8。导入.csv文件时，需要通过encoding参数指定编码格式。当将Excel文件另存为.csv文件时，默认编码格式为gbk，此时当编写代码导入.csv文件时，就需要设置编码格式为gbk，与源文件编码格式保持一致；否则会提示错误。</p>
<h4 id="3-4-3-导入-txt文本文件"><a href="#3-4-3-导入-txt文本文件" class="headerlink" title="3.4.3　导入.txt文本文件"></a>3.4.3　导入.txt文本文件</h4><p>导入.txt文件同样使用Pandas的read_csv()方法，不同的是需要指定sep参数（如制表符\t）。read_csv()方法读取.txt文件返回一个DataFrame，像表格一样的二维数据结构，如图3.23所示。</p>
<p>【示例17】　导入.txt文件。 \03\17）<br>下面使用read_csv()方法导入1月.txt文件，主要代码如下：</p>
<p>01 import pandas as pd<br>02 df1=pd.read_csv(‘1月.txt’,sep=’\t’,encoding=’gbk’)<br>03 print(df1.head())<br>运行程序，输出结果如图3.24所示。</p>
<p>​                                                                                                         图3.24　导入.txt文本</p>
<h4 id="3-4-4-导入HTML网页"><a href="#3-4-4-导入HTML网页" class="headerlink" title="3.4.4　导入HTML网页"></a>3.4.4　导入HTML网页</h4><p>导入HTML网页数据主要使用Pandas的read_html()方法，该方法用于导入带有table标签的网页表格数据，语法如下：</p>
<p>pandas.read_html(io,match=’.+’,flavor=None,header=None,index_col=None,skiprows=None,attrs=None,parse_<br>dates=False,thousands=’,’,encoding=None,decimal=’.’,converters=None,na_values=None,keep_default_na=True,<br>displayed_only=True)<br>常用参数说明：　</p>
<p>io：字符串，文件路径，也可以是URL链接。网址不接受https，可以尝试去掉https中的s后爬取，如<a href="http://www.mingribook.com./">http://www.mingribook.com。</a></p>
<p>match：正则表达式，返回与正则表达式匹配的表格。　</p>
<p>flavor：解析器默认为lxml。　</p>
<p>header：指定列标题所在的行，列表list为多重索引。　</p>
<p>index_col：指定行标题对应的列，列表list为多重索引。　</p>
<p>encoding：字符串，默认为None，文件的编码格式。　</p>
<p>返回值：返回一个DataFrame。<br>使用read_html()方法前，首先要确定网页表格是否为table类型。例如，NBA球员薪资网页（<a href="http://www.espn.com/nba/salaries%EF%BC%89%EF%BC%8C%E5%8F%B3%E5%87%BB%E8%AF%A5%E7%BD%91%E9%A1%B5%E4%B8%AD%E7%9A%84%E8%A1%A8%E6%A0%BC%EF%BC%8C%E5%9C%A8%E5%BC%B9%E5%87%BA%E7%9A%84%E5%BF%AB%E6%8D%B7%E8%8F%9C%E5%8D%95%E4%B8%AD%E9%80%89%E6%8B%A9%E2%80%9C%E6%A3%80%E6%9F%A5%E5%85%83%E7%B4%A0%E2%80%9D%E5%91%BD%E4%BB%A4%EF%BC%8C%E6%9F%A5%E7%9C%8B%E4%BB%A3%E7%A0%81%E4%B8%AD%E6%98%AF%E5%90%A6%E5%90%AB%E6%9C%89%E8%A1%A8%E6%A0%BC%E6%A0%87%E7%AD%BE">http://www.espn.com/nba/salaries），右击该网页中的表格，在弹出的快捷菜单中选择“检查元素”命令，查看代码中是否含有表格标签</a><table>…</table>的字样，如图3.25所示。确定后才可以使用read_html()方法。</p>
<p>​                                                                            图3.25　<table>…</table>表格标签</p>
<p>【示例18】　导入NBA球员薪资数据。 \03\18）<br>下面使用read_html()方法导入NBA球员薪资数据，程序代码如下：</p>
<p>运行程序，输出结果如图3.26所示。</p>
<p>​                                                                                              图3.26　导入网页数据注意<br>运行程序，如果出现ImportError: lxml not found, please install it错误提示信息，则需要安装lxml模块。</p>
<h3 id="3-5-数据抽取"><a href="#3-5-数据抽取" class="headerlink" title="3.5　数据抽取"></a>3.5　数据抽取</h3><p>数据分析过程中，并不是所有的数据都是我们想要的，此时可以抽取部分数据，主要使用DataFrame对<strong>象的loc属性和iloc属性</strong>，示意图如图3.27所示。          </p>
<pre><code>                                                                                     图3.27　loc属性和iloc属性示意图
</code></pre>
<p>对象的loc属性和iloc属性都可以抽取数据，区别如下。　</p>
<p>loc属性：以列名（columns）和行名（index）作为参数，当只有一个参数时，默认是行名，即抽取整行数据，包括所有列，如df.loc[‘A’]。　</p>
<p>iloc属性：以行和列位置索引（即0，1，2，…)作为参数，0表示第1行，1表示第2行，以此类推。当只有一个参数时，默认是行索引，即抽取整行数据，包括所有列。如抽取第1行数据，df.iloc[0]。</p>
<h4 id="3-5-1-抽取一行数据"><a href="#3-5-1-抽取一行数据" class="headerlink" title="3.5.1　抽取一行数据"></a>3.5.1　抽取一行数据</h4><p>抽取一行数据主要使用loc属性。【</p>
<p>示例19】　抽取一行考试成绩数据。 \03\19）抽取一行名为“明日”的考试成绩数据（包括所有列），程序代码如下：运行程序，输出结果如图3.28所示。<br>使用iloc属性抽取第1行数据，指定行索引即可，如df.iloc[0]，输出结果同图3.28一样。</p>
<p>[1,2,2,3]</p>
<p>[[1,2,3,4]]</p>
<p>​                                                                                                                图3.28　抽取一行数据</p>
<h4 id="3-5-2-抽取多行数据"><a href="#3-5-2-抽取多行数据" class="headerlink" title="3.5.2　抽取多行数据"></a>3.5.2　抽取多行数据</h4><p>1．抽取任意多行数据<br><strong>通过loc属性和iloc属性指定行名和行索引即可实现抽取任意多行数据。</strong></p>
<p>【示例20】　抽取多行考试成绩数据。 \03\20）抽取行名为“明日”和“高袁圆”（即第1行和第3行数据）的考试成绩数据，可以使用loc属性，也可以使用iloc属性，其输出结果都是一样的，主要代码如下：</p>
<p>01 df1=df.loc[[‘明日’,’高袁圆’]]<br>02 df1=df.iloc[[0,2]]<br>运行程序，输出结果如图3.29所示。</p>
<p>​                                                                                                图3.29　抽取多行数据<br>2．抽取连续任意多行数据<br>在loc属性和iloc属性中合理地使用冒号（:），即可抽取连续任意多行数据。</p>
<p>【示例21】　抽取连续几个学生的考试成绩。 \03\21）抽取连续几个学生的考试成绩，主要代码如下：</p>
<p>运行程序，控制台输出结果如图3.30所示。</p>
<p>​                                                                                 图3.30　抽取连续任意多行数据</p>
<h4 id="3-5-3-抽取指定列数据"><a href="#3-5-3-抽取指定列数据" class="headerlink" title="3.5.3　抽取指定列数据"></a>3.5.3　抽取指定列数据</h4><p>抽取指定列数据，可以直接使用列名，也可以使用loc属性和iloc属性。<br>1．直接使用列名【示例22】　抽取“语文”和“数学”的考试成绩。 \03\22）<br>抽取列名为“语文”和“数学”的考试成绩数据，程序代码如下：</p>
<p>运行程序，输出结果如图3.31所示。</p>
<p>2．使用loc属性和iloc属性<br>前面介绍loc属性和iloc属性均有两个参数：第一个参数代表行；第二个参数代表列。那么这里抽取指定列数据时，行参数不能省略。</p>
<p>【示例23】　抽取指定学科的考试成绩。 \03\23）<br>下面使用loc属性和iloc属性抽取指定列数据，主要代码如下：</p>
<p>​                         </p>
<p>​                                                                                          图3.32　loc属性和iloc属性</p>
<h4 id="3-5-4-抽取指定行、列数据"><a href="#3-5-4-抽取指定行、列数据" class="headerlink" title="3.5.4　抽取指定行、列数据"></a>3.5.4　抽取指定行、列数据</h4><p>抽取指定行、列数据主要使用loc属性和iloc属性，这两个方法的两个参数都指定就可以实现指定行、列数据的抽取。</p>
<p>【示例24】　抽取指定学科和指定学生的考试成绩。 \03\24）使用loc属性和iloc属性抽取指定行、列数据，程序代码如下：</p>
<p>运行程序，控制台输出结果如图3.33所示。</p>
<pre><code>                                                                               图3.33　抽取指定行、列数据
</code></pre>
<p>在上述结果中，第一个输出结果是一个数，不是数据，是由于“df.loc[‘七月流火’,’英语’]”没有使用方括号[]，导致输出的数据不是DataFrame类型。</p>
<h4 id="3-5-5-按指定条件抽取数据"><a href="#3-5-5-按指定条件抽取数据" class="headerlink" title="3.5.5　按指定条件抽取数据"></a>3.5.5　按指定条件抽取数据</h4><p>DataFrame对象实现数据查询有以下3种方式。　取其中的一个元素.iat[x,x]。　基于位置的查询，如.iloc[]、iloc[2,1]。　基于行、列名称的查询，如.loc[x]。</p>
<p>【示例25】　抽取指定学科和指定分数的数据。 \03\25）抽取语文成绩大于105，数学成绩大于88的数据，程序代码如下：</p>
<p>​                                                                                             图3.34　按指定条件抽取数据</p>
<h3 id="3-6-数据的增加、修改和删除"><a href="#3-6-数据的增加、修改和删除" class="headerlink" title="3.6　数据的增加、修改和删除"></a>3.6　数据的增加、修改和删除</h3><h4 id="3-6-1-增加数据"><a href="#3-6-1-增加数据" class="headerlink" title="3.6.1　增加数据"></a>3.6.1　增加数据</h4><p>图3.35　原始数据</p>
<h5 id="1．按列增加数据"><a href="#1．按列增加数据" class="headerlink" title="1．按列增加数据"></a>1．按列增加数据</h5><p>按列增加数据，可以通过以下3种方式实现。<br>（1）直接为DataFrame对象赋值</p>
<p>【示例26】　增加一列“物理”成绩。 \03\26）<br>增加一列“物理”成绩，程序代码如下：</p>
<p>运行程序，输出结果如图3.36所示。</p>
<p>​                                                                                   图3.36　按列增加数据<br>（2）使用loc属性在DataFrame对象的最后增加一列</p>
<p>【示例27】　使用loc属性增加一列“物理”成绩。 \03\27）使用loc属性在DataFrame对象的最后增加一列。例如，增加“物理”一列，主要代码如下：</p>
<p>df.loc[:,’物理’] = [88,79,60,50]<br>在DataFrame对象最后增加一列“物理”，其值为等号右边数据。</p>
<p>（3）在指定位置插入一列<br>在指定位置插入一列，主要使用insert()方法。</p>
<p>【示例28】　在第1列后面插入“物理”成绩。 \03\28）<br>例如，在第1列后面插入“物理”，其值为wl的数值，主要代码如下：</p>
<p>01 wl =[88,79,60,50]<br>02 df.insert(1,’物理’,wl)<br>运行程序，输出结果如图3.37所示。</p>
<h5 id="2．按行增加数据"><a href="#2．按行增加数据" class="headerlink" title="2．按行增加数据"></a>2．按行增加数据</h5><p>按行增加数据，可以通过以下两种方式实现。<br>（1）增加一行数据<br>增加一行数据主要使用loc属性实现。</p>
<p>【示例29】　在成绩表中增加一行数据。 \03\29）在成绩表中增加一行数据，即“钱多多”同学的成绩，主要代码如下：</p>
<p>df.loc[‘钱多多’] = [100,120,99]<br>（2）增加多行数据</p>
<p>增加多行数据主要使用<strong>字典</strong>结合**append()**方法实现。</p>
<p>【示例30】　在原有数据中增加几名同学的考试成绩。 \03\30）在原有数据中增加“钱多多”“童年”“无名”同学的考试成绩，主要代码如下：</p>
<p>01 df_insert=pd.DataFrame({‘语文’:[100,123,138],’数学’:[99,142,60],’英语’:[98,139,99]},index = [‘钱多多’,’童年’,’无名’])<br>02 df1 = df.append(df_insert)</p>
<p>​                                              </p>
<p>​                                                    </p>
<h5 id="1．修改列标题"><a href="#1．修改列标题" class="headerlink" title="1．修改列标题"></a>1．修改列标题</h5><p>修改列标题主要使用DataFrame对象的cloumns属性，直接赋值即可。</p>
<p>【示例31】　修改“数学”的列名。 \03\31）将“数学”修改为“数学（上）”，主要代码如下：</p>
<p>df.columns=[‘语文’,’数学（上）’,’英语’]</p>
<p>上述代码中，即使只修改“数学”为“数学（上）”，但是也<strong>要将所有列的标题全部写上；</strong>否则将报错。<br>下面再介绍一种方法，使用DataFrame对象的rename()方法修改列标题。</p>
<p>【示例32】　修改多个学科的列名。 \03\32）将“语文”修改为“语文（上）”、“数学”修改为“数学（上）”、“英语”修改为“英语（上）”，主要代码如下：</p>
<p>df1=df.rename(columns = {‘语文’:’语文（上）’,’数学’:’数学（上）’,’英语’:’英语（上）’},inplace = True)</p>
<p>上述代码中，参数inplace为True，表示直接修改df；否则，不修改df，只返回修改后的数据。<br>运行程序，输出结果分别如图3.41和图3.42所示。</p>
<h5 id="2．修改行标题"><a href="#2．修改行标题" class="headerlink" title="2．修改行标题"></a>2．修改行标题</h5><p>修改行标题主要使用DataFrame对象的index属性，直接赋值即可。</p>
<p>【示例33】　将行标题统一修改为数字编号。 \03\33）<br>将行标题统一修改为数字编号，主要代码如下：</p>
<p>df.index=list(‘1234’)</p>
<p>使用DataFrame对象的rename()方法也可以修改行标题。例如，将行标题统一修改为数字编号，主要代码如下：</p>
<p>df.rename({‘明日’:1,’七月流火’:2,’高袁圆’:3,’二月二’:4},axis=0,inplace = True)</p>
<h5 id="3．修改数据"><a href="#3．修改数据" class="headerlink" title="3．修改数据"></a>3．修改数据</h5><p>修改数据主要使用DataFrame对象的loc属性和iloc属性。</p>
<p>【示例34】　修改学生成绩数据。 \03\34）<br>（1）修改整行数据<br>例如，修改“明日”同学的各科成绩，主要代码如下：</p>
<p>df.loc[‘明日’]=[120,115,109]<br>如果各科成绩均加10分，可以直接在原有值上加10，主要代码如下：</p>
<p>df.loc[‘明日’]=df.loc[‘明日’]+10<br>（2）修改整列数据<br>例如，修改所有同学的“语文”成绩，主要代码如下：</p>
<p>df.loc[:,’语文’]=[115,108,112,118]<br>（3）修改某一数据</p>
<p>例如，修改“明日”同学的“语文”成绩，主要代码如下：</p>
<p>df.loc[‘明日’,’语文’]=115<br>（4）使用iloc属性修改数据<br>通过iloc属性指定行、列位置实现修改数据，主要代码如下：</p>
<p>01 df.iloc[0,0]=115                        #修改某一数据<br>02 df.iloc[:,0]=[115,108,112,118]          #修改整列数据<br>03 df.iloc[0,:]=[120,115,109]              #修改整行数据</p>
<h4 id="3-6-3-删除数据"><a href="#3-6-3-删除数据" class="headerlink" title="3.6.3　删除数据"></a>3.6.3　删除数据</h4><p>删除数据主要使用DataFrame对象的drop()方法。语法如下：</p>
<p>DataFrame.drop(labels=None, axis=0, index=None, columns=None, level=None, inplace=False, errors=’raise’)<br>参数说明：　</p>
<p>labels：表示行标签或列标签。　</p>
<p>axis：axis = 0，表示按行删除；</p>
<p>​            axis = 1，表示按列删除。默认值为0，即按行删除。　</p>
<p>index：删除行，默认值为None。　</p>
<p>columns：删除列，默认值为None。</p>
<p>level：针对有两级索引的数据。level = 0，表示按第1级索引删除整行；level = 1表示按第2级索引删除整行，默认值为None。　inplace：可选参数，对原数组做出修改并返回一个新数组。默认值为False，如果值为True，那么原数组直接就被替换。　</p>
<p>errors：参数值为ignore或raise，默认值为raise，如果值为ignore（忽略），则取消错误。</p>
<h5 id="1．删除行、列数据"><a href="#1．删除行、列数据" class="headerlink" title="1．删除行、列数据"></a>1．删除行、列数据</h5><p>【示例35】　删除学生成绩数据。 \03\35）<br>删除指定的学生成绩数据，主要代码如下：</p>
<h5 id="2．删除特定条件的行"><a href="#2．删除特定条件的行" class="headerlink" title="2．删除特定条件的行"></a>2．删除特定条件的行</h5><p>删除满足特定条件的行，首先找到满足该条件的行索引，然后再使用drop()方法将其删除。</p>
<p>【示例36】　删除符合条件的学生成绩数据。 \03\36）<br>删除“数学”成绩中包含88的行、“语文”成绩中小于110的行，主要代码如下：</p>
<p>01 df.drop(index=df[df[‘数学’].<strong>isin</strong>([88])].index[0],inplace=True)      #删除“数学”成绩中包含88的行<br>02 df.drop(index=df[df[‘语文’]&lt;110].index[0],inplace=True)             #删除“语文”成绩中小于110的行说明<br>以上代码中的方法都可以实现删除指定的行、列数据，读者选择一种即可。</p>
<h3 id="3-7-数据清洗"><a href="#3-7-数据清洗" class="headerlink" title="3.7　数据清洗"></a>3.7　数据清洗</h3><h4 id="3-7-1-缺失值查看与处理"><a href="#3-7-1-缺失值查看与处理" class="headerlink" title="3.7.1　缺失值查看与处理"></a>3.7.1　缺失值查看与处理</h4><p>缺失值是指由于某种原因导致数据为空，这种情况一般有不处理、删除、填充／替换、插值（以均值／中位数／众数等填补）这4种处理方式。</p>
<h5 id="1．缺失值查看"><a href="#1．缺失值查看" class="headerlink" title="1．缺失值查看"></a>1．缺失值查看</h5><p>首先需要找到缺失值，主要使用DataFrame对象的info()方法。</p>
<p>【示例37】　查看数据概况。 \03\37）以淘宝销售数据为例，首先输出数据，然后使用info()方法查看数据，程序代码如下：</p>
<p>01 import pandas as pd<br>02 df=pd.read_excel(‘TB2018.xls’)<br>03 print(df)<br>04 print(df.info())</p>
<p>运行程序，控制台输出结果如图3.43所示。</p>
<p>图3.43　缺失值查看<br>在Python中，缺失值一般用NaN表示，如图3.43所示。通过info()方法可看到“买家会员名”“买家实际支付金额”“宝贝标题”“订单付款时间”的非空数量是10，而“宝贝总数量”和“类别”的非空数量是8，那么说明这两项存在空值。</p>
<p>【示例38】　判断数据是否存在缺失值。 \03\38）<br>接下来，判断数据是否存在缺失值还可以使用isnull()方法和notnull()方法，主要代码如下： </p>
<p>01  print(df.isnull())<br>02  print(df.notnull())</p>
<p>​                                                                                              图3.44　判断缺失值<br>使用isnull()方法缺失值返回True，非缺失值返回False；而notnull()方法与isnull()方法正好相反，缺失值返回False，非缺失值返回True。<br>如果使用df[df.isnull() == False]，</p>
<p>则会将所有非缺失值的数据找出来，只针对Series对象。</p>
<h5 id="2．缺失值删除处理"><a href="#2．缺失值删除处理" class="headerlink" title="2．缺失值删除处理"></a>2．缺失值删除处理</h5><p>通过前面的判断得知数据缺失情况，下面将缺失值删除，主要使用dropna()方法，该方法用于删除含有缺失值的行，主要代码如下：</p>
<p>df1=df.dropna()<br>运行程序，输出结果如图3.45所示。说明<br>有些时候数据可能存在整行为空的情况，此时可以在dropna()方法中指定参数how=’all’，删除所有空行。</p>
<p>​                                                                                   图3.45　缺失值删除处理1<br>从运行结果得知：dropna()方法将所有包含缺失值的数据全部删除了。那么，此时如果我们认为有些数据虽然存在缺失值，但是不影响数据分析，那么可以使用以下方法处理。例如，上述数据中只保留“宝贝总数量”不存在缺失值的数据，而类别是否缺失不关注，则可以使用notnull()方法判断，主要代码如下：</p>
<p>df2=df[df[‘宝贝总数量’].notnull()]<br>运行程序，输出结果如图3.46所示。</p>
<p>图3.46　缺失值删除处理2</p>
<h5 id="3．缺失值填充处理"><a href="#3．缺失值填充处理" class="headerlink" title="3．缺失值填充处理"></a>3．缺失值填充处理</h5><p>对于缺失数据，如果比例高于30%可以选择放弃这个指标，做删除处理；低于30%尽量不要删除，而是选择将这部分数据填充，一般以0、均值、众数（大多数）填充。DataFrame对象中的fillna()函数可以实现填充缺失数据，pad/ffill表示用前一个非缺失值去填充该缺失值；backfill/bfill表示用下一个非缺失值填充该缺失值；None用于指定一个值去替换缺失值。</p>
<p>【示例39】　将NaN填充为0。 \03\39）对于用于计算的数值型数据如果为空，可以选择用0填充。例如，将“宝贝总数量”为空的数据填充为0，主要代码如下：</p>
<p>运行程序，输出结果如图3.47所示。</p>
<p>​                                                                                                图3.47　缺失值填充处理</p>
<h4 id="3-7-2-重复值处理"><a href="#3-7-2-重复值处理" class="headerlink" title="3.7.2　重复值处理"></a>3.7.2　重复值处理</h4><p>对于数据中存在的重复数据，包括重复的行或者几行中某几列的值重复一般做删除处理，主要使用DataFrame对象的drop_duplicates()方法。</p>
<p>【示例40】　处理淘宝电商销售数据中的重复数据。 \03\40）下面以“1月.xlsx”淘宝销售数据为例，对其中的重复数据进行处理。<br>（1）判断每一行数据是否重复（完全相同），主要代码如下：</p>
<p>df1.duplicated()<br>如果返回值为False表示不重复，返回值为True表示重复。<br>（2）去除全部的重复数据，主要代码如下：</p>
<p>df1.drop_duplicates()#默认保留一行<br>（3）去除指定列的重复数据，主要代码如下：</p>
<p>df1.drop_duplicates([‘买家会员名’])<br>（4）保留重复行中的最后一行，主要代码如下：</p>
<p>df1.drop_duplicates([‘买家会员名’],keep=’last’)</p>
<p>说明<br>以上代码中参数keep的值有3个。当keep=’first’表示保留第一次出现的重复行，<strong>是默认值</strong>；当keep为另外两个取值，即last和False时，分别表示保留最后一次出现的重复行和去除所有重复行。<br>（5）直接删除，保留一个副本，主要代码如下：</p>
<p>df1.drop_duplicates([‘买家会员名’,’买家支付宝账号’],inplace=Fasle)<br>inplace=True表示直接在原来的DataFrame上删除重复项，而默认值False表示删除重复项后生成一个副本。</p>
<h4 id="3-7-3-异常值的检测与处理"><a href="#3-7-3-异常值的检测与处理" class="headerlink" title="3.7.3　异常值的检测与处理"></a>3.7.3　异常值的检测与处理</h4><p>首先了解一下什么是异常值。在数据分析中异常值是指超出或低于正常范围的值，如年龄大于200、身高大于3米、宝贝总数量为负数等类似数据。那么这些数据如何检测呢？主要有以下几种方法。<br>（1）根据给定的数据范围进行判断，不在范围内的数据视为异常值。<br>（2）均方差。<br>在统计学中，如果一个数据分布近似正态分布（数据分布的一种形式，正态分布的概率密度函数曲线呈钟形，两头低、中间高、左右对称，因此人们又经常称之为钟形曲线），那么大约68%的数据值会在均值的一个标准差范围内，大约95%会在两个标准差范围内，大约99.7%会在3个标准差范围内。<br>（3）箱形图。<br>箱形图是显示一组数据分散情况资料的统计图。它可以将数据通过四分位数的形式进行图形化描述。箱形图通过上限和下限作为数据分布的边界。任何高于上限或低于下限的数据都可以认为是异常值，如图3.48所示。</p>
<p>​                                                                                            图3.48　箱形图说明<br>有关箱形图的介绍以及如何通过箱形图识别异常值可参见第6章。<br>了解了异常值的检测，接下来介绍如何处理异常值，主要包括以下几种处理方式。<br>（1）最常用的方式是删除。<br>（2）将异常值当缺失值处理，以某个值填充。<br>（3）将异常值当特殊情况进行分析，研究异常值出现的原因。</p>
<p>缺失值替换</p>
<p>replace(to_repalce=None,value=None,inplace=False,limit=None,regex=False,method=’pad’)</p>
<p>to_repalce:指定需要替换的原值，可以是字符型，正则表达式，列表，series，整数，浮点数或None，例如{‘V1’:n1,’v2’:n2}表示使用n1,n2替换掉原来的v1,v2,这时的value必须为None</p>
<p>value：指定用于替换的新值</p>
<p>inplace：True修改原始数据，False仅修改视图</p>
<p>limit：限制向前，向后填充的最大个数</p>
<p>regex：默认False，若为True则to_palce必须为一个字符串。</p>
<p>pd.where(cond,value)</p>
<p>满足条件的保留，不满足条件的修改为value</p>
<h3 id="3-8-索引设置"><a href="#3-8-索引设置" class="headerlink" title="3.8 索引设置"></a>3.8 索引设置</h3><p>索引能够快速查询数据，本节主要介绍索引的作用以及索引的应用。</p>
<h4 id="3-8-1-索引的作用"><a href="#3-8-1-索引的作用" class="headerlink" title="3.8.1　索引的作用"></a>3.8.1　索引的作用</h4><p>索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。Pandas索引的作用如下。　</p>
<p>更方便查询数据。　</p>
<p>使用索引可以提升查询性能。　</p>
<p>如果索引是唯一的，Pandas会使用哈希表优化，查找数据的时间复杂度为O(1)。　</p>
<p>如果索引不是唯一的，但是有序，Pandas会使用二分查找算法，查找数据的时间复杂度为O(logN)。　</p>
<p>如果索引是完全随机的，那么每次查询都要扫描数据表，查找数据的时间复杂度为O(N)。　自动的数据对齐功能，示意图如图3.49所示。</p>
<p>​                                                                                    图3.49　自动数据对齐示意图<br>实现上述效果，程序代码如下：</p>
<p>01 import pandas as pd<br>02 s1 = pd.Series([10,20,30],index= list(“abc”))<br>03 s2 = pd.Series([2,3,4],index=list(“bcd”))<br>04 print(s1 + s2)　</p>
<p>强大的数据结构。　</p>
<p>基于分类数的索引，提升性能。　</p>
<p>多维索引，用于groupby多维聚合结果等。　</p>
<p>时间类型索引，强大的日期和时间的方法支持。</p>
<h4 id="3-8-2-重新设置索引"><a href="#3-8-2-重新设置索引" class="headerlink" title="3.8.2　重新设置索引"></a>3.8.2　重新设置索引</h4><p>Pandas有一个很重要的方法是reindex()，它的作用是创建一个适应新索引的新对象。语法如下：</p>
<p>DataFrame.reindex(labels = None,index = None,columns = None,axis = None,method = None,copy = True,level =<br>None,fill_value = nan,limit = None,tolerance = None)<br>常用参数说明：　</p>
<p>labels：标签，可以是数组，默认值为None（无）。　</p>
<p>index：行索引，默认值为None。　</p>
<p>columns：列索引，默认值为None。</p>
<p>axis：轴，axis=0表示行，axis=1表示列。默认值为None。　</p>
<p>method：默认值为None，重新设置索引时，选择插值（一种填充缺失数据的方法）方法，其值可以是None、bfill/backfill（向后填充）、ffill/pad（向前填充）等。　</p>
<p>fill_value：缺失值要填充的数据。如缺失值不用NaN填充，而用0填充，则设置fill_value=0即可。</p>
<h5 id="1．对Series对象重新设置索引"><a href="#1．对Series对象重新设置索引" class="headerlink" title="1．对Series对象重新设置索引"></a>1．对Series对象重新设置索引</h5><p>【示例41】　重新设置物理成绩的索引。 \03\41）<br>在3.2.3节已经建立了一组学生的物理成绩，下面重新设置索引，程序代码如下：</p>
<p>01 import pandas as pd<br>02 s1=pd.Series([88,60,75],index=[1,2,3])<br>03 print(s1)<br>04 print(s1.reindex([1,2,3,4,5]))</p>
<p>​                                                                                                 图3.51　重新设置索引<br>从运行结果得知：reindex()方法根据新索引进行了重新排序，并且对缺失值自动填充NaN。如果不想用NaN填充，则可以为fill_value参数指定值，如0，主要代码如下：</p>
<p>s1.reindex([1,2,3,4,5],fill_value=0)<br>而对于一些有一定顺序的数据，我们可能需要插值（插值是一种填充缺失数据的方法）来填充缺失的数据，可以使用method参数。</p>
<p>【示例42】　向前和向后填充数据。 \03\42）</p>
<p>向前填充（和前面数据一样）、向后填充（和后面数据一样），主要代码如下：</p>
<p>01 print(s1.reindex([1,2,3,4,5],method=’ffill’))   #向前填充<br>02 print(s1.reindex([1,2,3,4,5],method=’bfill’))   #向后填充</p>
<h5 id="2．对DataFrame对象重新设置索引"><a href="#2．对DataFrame对象重新设置索引" class="headerlink" title="2．对DataFrame对象重新设置索引"></a>2．对DataFrame对象重新设置索引</h5><p>对于DataFrame对象，reindex()方法用于修改行索引和列索引。</p>
<p>【示例43】　创建成绩表并重新设置索引。 \03\43）通过二维数组创建成绩表，程序代码如下：</p>
<p>df.reindex([‘mr001’,’mr002’,’mr003’,’mr004’,’mr005’])<br>通过reindex()方法重新设置列索引，主要代码如下：</p>
<p>df.reindex(columns=[‘语文’,’物理’,’数学’,’英语’])<br>通过reindex()方法重新设置行索引和列索引，主要代码如下：</p>
<p>df.reindex(index=[‘mr001’,’mr002’,’mr003’,’mr004’,’mr005’],columns=[‘语文’,’物理’,’数学’,’英语’])<br>运行程序，控制台输出结果分别为原始数据（见图3.52）、重新设置行索引（见图3.53）、重新设置列索引（见图3.54）、重新设置行、列索引（见图3.55）。</p>
<p>​                                                                                              </p>
<h4 id="3-8-3-设置某列为行索引"><a href="#3-8-3-设置某列为行索引" class="headerlink" title="3.8.3　设置某列为行索引"></a>3.8.3　设置某列为行索引</h4><p>设置某列为行索引主要使用set_index()方法。</p>
<p>【示例44】　设置“买家会员名”为行索引。 \03\44）<br>首先，导入“1月.xlsx”Excel文件，程序代码如下：</p>
<p>运行程序，输出结果如图3.56所示。<br>此时默认行索引为0、1、2、3、4，下面将“买家会员名”作为行索引，主要代码如下：</p>
<p>df2=df.set_index([‘买家会员名’])<br>运行程序，输出结果如图3.57所示。</p>
<p>​                                                                                                图3.56　1月淘宝销售数据（部分数据）</p>
<p>​                                                                                                       图3.57　设置“买家会员名”为索引<br>如果在set_index()方法中传入参数drop=True，则会删除“买家会员名”；如果传入drop=False，则会保留“买家会员名”。默认为False。</p>
<h4 id="3-8-4-数据清洗后重新设置连续的行索引"><a href="#3-8-4-数据清洗后重新设置连续的行索引" class="headerlink" title="3.8.4　数据清洗后重新设置连续的行索引"></a>3.8.4　数据清洗后重新设置连续的行索引</h4><p>在对Dataframe对象进行数据清洗后，例如去掉含NaN的行之后，发现行索引还是原来的行索引，对比效果如图3.58和图3.59所示。</p>
<p>​                                                                                            图3.58　原数据</p>
<p>​                                                                           图3.59　数据清洗后还是原来的索引</p>
<p>【示例45】　删除数据后重新设置索引。 \03\45）</p>
<p>如果要重新设置索引可以使用reset_index()方法，在删除缺失数据后重新设置索引，主要代码如下：</p>
<p>df2=df.dropna().reset_index(drop=True)<br>运行程序，输出结果如图3.60所示。</p>
<p>另外，对于分组统计后的数据，有时也需要重新设置连续的行索引，方法同上。</p>
<h3 id="3-9-数据排序与排名"><a href="#3-9-数据排序与排名" class="headerlink" title="3.9　数据排序与排名"></a>3.9　数据排序与排名</h3><p>本节主要介绍数据的各种排序和排名方法。</p>
<h4 id="3-9-1-数据排序"><a href="#3-9-1-数据排序" class="headerlink" title="3.9.1　数据排序"></a>3.9.1　数据排序</h4><p>DataFrame数据排序主要使用sort_values()方法，该方法类似于SQL中的ORDER BY。sort_values()方法可以根据指定行／列进行排序，语法如下：</p>
<p>DataFrame.sort_values(by,axis=0,ascending=True,inplace=False,kind=’quicksort’,na_position=’last’,ignore_<br>index=False)<br>参数说明：　</p>
<p>by：要排序的名称列表。</p>
<p>axis：轴，axis=0表示行，axis=1表示列。默认值为0，即按行排序。　</p>
<p>ascending：升序或降序排序，布尔值，指定多个排序可以使用布尔值列表。默认值为True。　</p>
<p>inplace：布尔值，默认值为False，如果值为True，则就地排序。　</p>
<p>kind：指定排序算法，值为quicksort（快速排序）、mergesort（混合排序）或heapsort（堆排），默认值为quicksort。　</p>
<p>na_position：空值（NaN）的位置，值为first空值在数据开头，值为last空值在数据最后，默认值为last。　</p>
<p>ignore_index：布尔值，是否忽略索引，值为True标记索引（从0开始按顺序的整数值），值为False则忽略索引。</p>
<h5 id="1．按一列数据排序"><a href="#1．按一列数据排序" class="headerlink" title="1．按一列数据排序"></a>1．按一列数据排序</h5><p>Spyder变量浏览窗口本身也支持数据排序，单击需要排序的列即可实现升序或降序排序。<br>程序代码如下：</p>
<h5 id="2．按多列数据排序"><a href="#2．按多列数据排序" class="headerlink" title="2．按多列数据排序"></a>2．按多列数据排序</h5><p>主要代码如下：</p>
<p>df1=df.sort_values(by=[‘图书名称’,’销量’])</p>
<h5 id="3．对统计结果排序"><a href="#3．对统计结果排序" class="headerlink" title="3．对统计结果排序"></a>3．对统计结果排序</h5><p>按“类别”分组统计销量并进行降序排序，统计排序后的效果如图3.64所示。</p>
<p>​                                                                                 图3.64　按“类别”分组统计销量并降序排序<br>主要代码如下：</p>
<p>01 df1=df.groupby([“类别”])[“销量”].sum().reset_index()</p>
<p>2 df2=df1.sort_values(by=’销量’,ascending=False)</p>
<h5 id="4．按行数据排序"><a href="#4．按行数据排序" class="headerlink" title="4．按行数据排序"></a>4．按行数据排序</h5><p>【示例49】　按行数据排序。 \03\49）<br>按行排序，主要代码如下：</p>
<p>df=dfrow.sort_values(by=0,ascending=True,axis=1)</p>
<p>注意<br><strong>按行排序的数据类型要一致</strong>，否则会出现错误提示。</p>
<h4 id="3-9-2-数据排名"><a href="#3-9-2-数据排名" class="headerlink" title="3.9.2　数据排名"></a>3.9.2　数据排名</h4><p>排名是根据Series对象或DataFrame的某几列的值进行排名的，主要使用rank()方法，语法如下：</p>
<p>DataFrame.rank(axis=0,method=’average’,numeric_only=None,na_option=’keep’,ascending=True,pct=False)<br>参数说明：　</p>
<p>axis：轴，axis=0表示行，axis=1表示列。默认值为0，即按行排序。　</p>
<p>method：表示在具有相同值的情况下所使用的排序方法。设置值如下。　</p>
<p>​    average：默认值，平均排名。</p>
<p>​    min：最小值排名。　</p>
<p>​    max：最大值排名。　</p>
<p>​    first：按值在原始数据中的出现顺序分配排名。　</p>
<p>​    dense：密集排名，类似最小值排名，但是排名每次只增加1，即排名相同的数据只占一个名次。　</p>
<p>numeric_only：对于DataFrame对象，如果设置值为True，则只对数字列进行排序。　</p>
<p>na_option：空值的排序方式，设置值如下。　</p>
<p>​    keep：保留，将空值等级赋值给NaN值。　</p>
<p>​    top：如果按升序排序，则将最小排名赋值给NaN值。　</p>
<p>​    bottom：如果按升序排序，则将最大排名赋值给NaN值。　</p>
<p>ascending：升序或降序排序，布尔值，指定多个排序可以使用布尔值列表。默认值为True。　</p>
<p>pct：布尔值，是否以百分比形式返回排名。默认值为False。</p>
<p>1．顺序排名</p>
<p>01 df[‘平均排名’]=df[‘销量’].rank(ascending=False)</p>
<p>02 df1=df[[‘图书名称’,’销量’,’平均排名’]]<br>程序运行结果如图3.66所示。<br>3．最小值排名<br>排名相同的，按顺序排名取最小值作为排名，主要代码如下：</p>
<p>df[‘最小值排名’]=df[‘销量’].rank(method=”min”,ascending=False)<br>4．最大值排名<br>排名相同的，按顺序排名取最大值作为排名，主要代码如下：</p>
<p>df[‘最大值排名’]=df[‘销量’]</p>
<p>rank(method=”max”,ascending=False)</p>
<h3 id="sum"><a href="#sum" class="headerlink" title="sum()"></a>sum()</h3><p>DataFrame.sum(axis=None, skipna=None, level=None, numeric_only=None, min_count=0, **kwargs)<br>参数说明：　</p>
<p>axis：axis=1表示行，axis=0表示列，默认值为None（无）。　skipna：布尔型，表示计算结果是否排除NaN/Null值，默认值为None。</p>
<p>level：表示索引层级，默认值为None。　</p>
<p>numeric_only：仅数字，布尔型，默认值为None。　</p>
<p>min_count：表示执行操作所需的数目，整型，默认值为0。　**kwargs：要传递给函数的附加关键字参数。　</p>
<p>返回值：返回Series对象或DataFrame对象。行或列求和数据。</p>
<p>【示例01】　计算语文、数学和英语三科的总成绩。 \04\01）<br>首先，创建一组DataFrame类型的数据，包括语文、数学和英语三科的成绩，如图4.1所示。<br>程序代码如下：</p>
<p>df[‘总成绩’]=df.sum(axis=1)</p>
<h3 id="mean"><a href="#mean" class="headerlink" title="mean()"></a>mean()</h3><p>DataFrame.mean(axis=None, skipna=None, level=None, numeric_only=None, kwargs)<br>参数说明：　</p>
<p>axis：axis=1表示行，axis=0表示列，默认值为None（无）。　</p>
<p>skipna：布尔型，表示计算结果是否排除NaN/Null值，默认值为None。　</p>
<p>level：表示索引层级，默认值为None。　</p>
<p>numeric_only：仅数字，布尔型，默认值为None。　</p>
<p>kwargs：要传递给函数的附加关键字参数。　</p>
<p>返回值：返回Series对象或DataFrame对象。行或列平均值数据。</p>
<h3 id="max"><a href="#max" class="headerlink" title="max()"></a>max()</h3><p>DataFrame.max(axis=None, skipna=None, level=None, numeric_only=None, **kwargs)<br>参数说明：　**</p>
<p>**axis：axis=1表示行，axis=0表示列，默认值为None（无）。　skipna：布尔型，表示计算结果是否排除NaN/Null值，默认值为None。　</p>
<p>**level：表示索引层级，默认值为None。　</p>
<p>**numeric_only：仅数字，布尔型，默认值为None。　</p>
<p>kwargs：要传递给函数的附加关键字参数。　</p>
<p>返回值：返回Series对象或DataFrame对象。行或列最大值数据。</p>
<h3 id="median"><a href="#median" class="headerlink" title="median()"></a>median()</h3><p>中位数又称中值，是统计学专有名词，是指按顺序排列的一组数据中位于中间位置的数，其不受异常值的影响。例如，年龄23、45、35、25、22、34、28这7个数，中位数就是排序后位于中间的数字，即28；而年龄23、45、35、25、22、34、28、27这8个数，中位数则是排序后位于中间两个数的平均值，即27.5。在Python中直接调用DataFrame对象的median()函数就可以轻松实现中位数的运算，语法如下：</p>
<p>DataFrame.median(axis=None,skipna=None,level=None,numeric_only=None,**kwargs)<br>参数说明：　**</p>
<p>**axis：axis=1表示行，axis=0表示列，默认值为None（无）。　skipna：布尔型，表示计算结果是否排除NaN/Null值，默认值为None。　</p>
<p>**level：表示索引层级，默认值为None。　</p>
<p>**numeric_only：仅数字，布尔型，默认值为None。　</p>
<p>kwargs：要传递给函数的附加关键字参数。　</p>
<p>返回值：返回Series对象或DataFrame对象。</p>
<h3 id="mode"><a href="#mode" class="headerlink" title="mode()"></a>mode()</h3><p>什么是众数？众数的众字有多的意思，顾名思义，众数就是一组数据中出现最多的数称为众数，它代表了数据的一般水平。<br>在Python中通过调用DataFrame对象的mode()函数可以实现众数运算，语法如下：</p>
<p>DataFrame.mode(axis=0,numeric_only=False,dropna=True)<br>参数说明：　</p>
<p>axis：axis=1表示行，axis=0表示列，默认值为0。　</p>
<p>numeric_only：仅数字，布尔型，默认值为False。如果值为True，则仅适用于数字列。　</p>
<p>dropna：是否删除缺失值，布尔型，默认值为True。　</p>
<p>返回值：返回Series对象或DataFrame对象。</p>
<h3 id="var"><a href="#var" class="headerlink" title="var()"></a>var()</h3><p>方差<br>接着来看一下总体波动（方差和），“小黑”的数据是73.2，“小白”的数据是949.2，很明显“小黑”的物理成绩波动较小，发挥更稳定，所以应该选“小黑”参加物理竞赛。<br>以上举例就是方差的意义。大数据时代，它能够帮助我们解决很多身边的问题、协助我们做出合理的决策。<br>在Python中通过调用DataFrame对象的var()函数可以实现方差运算，语法如下：</p>
<p><strong>DataFrame.var(axis=None,skipna=None,level=None,ddof=1,numeric_only=None,kwargs)</strong><br>参数说明：　</p>
<p>axis：axis=1表示行，axis=0表示列，默认值为None（无）。　skipna：布尔型，表示计算结果是否排除NaN/Null值，默认值为None。　</p>
<p>level：表示索引层级，默认值为None。　</p>
<p>ddof：整型，默认值为1。自由度，计算中使用的除数是N-ddof，其中N表示元素的数量。　</p>
<p>numeric_only：仅数字，布尔型，默认值为None。　</p>
<p>kwargs：要传递给函数的附加关键字参数。　</p>
<p>返回值：返回Series对象或DataFrame对象。</p>
<h3 id="std"><a href="#std" class="headerlink" title="std()"></a>std()</h3><p>标准差又称均方差，是方差的平方根，用来表示数据的离散程度。<br>在Python中通过调用DataFrame对象的std()函数求标准差，语法如下：</p>
<p>DataFrame.std(axis=None,skipna=None,level=None,ddof=1,numeric_only=None,**kwargs)<br>std()函数的参数与var()函数一样，这里不再赘述。</p>
<h3 id="4-1-9-求分位数（quantile-函数）"><a href="#4-1-9-求分位数（quantile-函数）" class="headerlink" title="4.1.9　求分位数（quantile()函数）"></a>4.1.9　求分位数（quantile()函数）</h3><p>分位数也称分位点，它以概率依据将数据分割为几个等份，常用的有中位数（即二分位数）、四分位数、百分位数等。分位数是数据分析中常用的一个统计量，经过抽样得到一个样本值。例如，经常会听老师说：“这次考试竟然有20%的同学不及格！”，那么这句话就体现了分位数的应用。在Python中通过调用DataFrame对象的quantile()函数求分位数，语法如下：</p>
<p><strong>DataFrame.quantile(q=0.5,axis=0,numeric_only=True, interpolation=’linear’)</strong><br>参数说明：　</p>
<p>q：浮点型或数组，默认为0.5（50%分位数），其值为0～1。　</p>
<p>axis：axis=1表示行，axis=0表示列。默认值为0。　</p>
<p>numeric_only：仅数字，布尔型，默认值为True。　</p>
<p>interpolation：内插值，可选参数[{‘linear’,‘lower’,‘higher’,‘midpoint’,‘nearest’}]用于指定要使用的插值方法，当期望的分位数为数据点i～j时。　</p>
<p>​    linear’：i+(j-i)×分数，其中分数是指数被i和j包围的小数部分。　</p>
<p>​    lower：i。　</p>
<p>​    higher：j。　 </p>
<p>​    nearest：i或j二者以最近者为准。　</p>
<p>​    midpoint：(i+j)/2。　</p>
<p>返回值：返回Series或DataFrame对象。</p>
<p>【示例10】　通过分位数确定被淘汰的35%的学生。 \04\10）<br>以学生成绩为例，数学成绩分别为120、89、98、78、65、102、112、56、79、45的10名同学，现根据分数淘汰35%的学生，该如何处理？首先使用quantile()函数计算35%的分位数，然后将学生成绩与分位数比较，筛选小于等于分位数的学生，程序代码如下：</p>
<h3 id="4-2-1-设置小数位数"><a href="#4-2-1-设置小数位数" class="headerlink" title="4.2.1　设置小数位数"></a>4.2.1　设置小数位数</h3><p>设置小数位数主要使用DataFrame对象的round()函数，该函数可以实现四舍五入，而它的decimals参数则用于设置保留小数的位数，设置后数据类型不会发生变化，依然是浮点型。语法如下：</p>
<p>DataFrame.round(decimals=0, *args, **kwargs)　**</p>
<p>decimals：每一列四舍五入的小数位数，整型、字典或Series对象。如果是整数，则将每一列四舍五入到相同的位置。否则，将字典和Series舍入到可变数目的位置；如果小数是类似于字典的，那么列名应该在键中；如果小数是级数，列名应该在索引中。没有包含在小数中的任何列都将保持原样。非输入列的小数元素将被忽略。　</p>
<p>args：附加的关键字参数。　</p>
<p>kwargs：附加的关键字参数。　</p>
<p>返回值：返回DataFrame对象。</p>
<p>当然，保留小数位数也可以用自定义函数，例如，为DataFrame对象中的各个浮点值保留两位小数，主要代码如下：</p>
<p>df.applymap(lambda x: ‘%.2f’%x)</p>
<h3 id="4-2-2-设置百分比"><a href="#4-2-2-设置百分比" class="headerlink" title="4.2.2　设置百分比"></a>4.2.2　设置百分比</h3><p>在数据分析过程中，有时需要百分比数据。那么，利用自定义函数将数据进行格式化处理，处理后的数据就可以从浮点型转换成带指定小数位数的百分比数据，主要使用apply()函数与format()函数。</p>
<p>【示例13】　将指定数据格式化为百分比数据。 \04\13）<br>将A1列的数据格式化为百分比数据，程序代码如下：</p>
<h3 id="4-2-3-设置千位分隔符"><a href="#4-2-3-设置千位分隔符" class="headerlink" title="4.2.3　设置千位分隔符"></a>4.2.3　设置千位分隔符</h3><p>由于业务需要，有时需要将数据格式化为带千位分隔符的数据。那么，处理后的数据将不再是浮点型而是对象型。</p>
<p>df[‘麻阳’]=df[‘妈呀’]。apply(lambda x:format(int(x),’,’))</p>
<h3 id="4-3-1-分组groupby"><a href="#4-3-1-分组groupby" class="headerlink" title="4.3.1　分组groupby()"></a>4.3.1　分组groupby()</h3><p><strong>DataFrame.groupby(by=None,axis=0,level=None,as_index=True,sort=True,group_keys=True,squeeze=False,observed=False)</strong></p>
<p>参数说明：　</p>
<p>by：映射、字典或Series对象、数组、标签或标签列表。如果by是一个函数，则对象索引的每个值都调用它；如果传递了一个字典或Series对象，则使用该字典或Series对象值来确定组；如果传递了数组ndarray，则按原样使用这些值来确定组。　</p>
<p>axis：axis=1表示行，axis=0表示列。默认值为0。　</p>
<p>level：表示索引层级，默认值为None（无）。　</p>
<p>as_index：布尔型，默认值为True，返回以组标签为索引的对象。　sort：对组进行排序，布尔型，默认值为True。　</p>
<p>group_keys：布尔型，默认值为True，调用apply()函数时，将分组的键添加到索引以标识片段。　</p>
<p>squeeze：布尔型，默认值为False。如果可能，减少返回类型的维度；否则返回一致类型。　</p>
<p>observed： <em>bool, default False</em> 布尔型, 观察者, 默认为False。当以石斑鱼为分类时，才会使用该参数。如果参数值为True，则仅显示分类石斑鱼的观测值；如果参数值为False，则显示分类石斑鱼的所有值。</p>
<p>返回值：返回DataFrameGroupBy，返回包含有关组的信息的groupby对象。</p>
<h4 id="1．按照一列分组统计"><a href="#1．按照一列分组统计" class="headerlink" title="1．按照一列分组统计"></a>1．按照一列分组统计</h4><p>【示例15】　根据“一级分类”统计订单数据。 \04\15）<br>按照图书“一级分类”对订单数据进行分组统计求和，程序代码如下：</p>
<p>​                                 图4.10　按照一列分组统计</p>
<h4 id="2．按照多列分组统计"><a href="#2．按照多列分组统计" class="headerlink" title="2．按照多列分组统计"></a>2．按照多列分组统计</h4><p>多列分组统计，以列表形式指定列。</p>
<p>【示例16】　根据两级分类统计订单数据。 \04\16）<br>按照图书“一级分类”和“二级分类”对订单数据进行分组统计求和，主要代码如下：</p>
<p>01 #抽取数据<br>02 df1=df[[‘一级分类’,’二级分类’,’7天点击量’,’订单预定’]]<br>03 df1=df1.groupby([‘一级分类’,’二级分类’]).sum()    #分组统计求和</p>
<h4 id="3．分组并按指定列进行数据计算"><a href="#3．分组并按指定列进行数据计算" class="headerlink" title="3．分组并按指定列进行数据计算"></a>3．分组并按指定列进行数据计算</h4><p>前面介绍的分组统计是按照所有列进行汇总计算的，那么如何按照指定列汇总计算呢？</p>
<p>【示例17】　统计各编程语言的7天点击量。 \04\17）<br>统计各编程语言的7天点击量，首先按“二级分类”分组，然后抽取“7天点击量”列并对该列进行求和运算，主要代码如下：</p>
<p>df1=df1.groupby(‘二级分类’)[‘7天点击量’].sum()</p>
<h3 id="4-3-3-对分组的某列或多列使用聚合函数（agg-函数）"><a href="#4-3-3-对分组的某列或多列使用聚合函数（agg-函数）" class="headerlink" title="4.3.3　对分组的某列或多列使用聚合函数（agg()函数）"></a>4.3.3　对分组的某列或多列使用聚合函数（agg()函数）</h3><p>Python也可以实现像SQL中的分组聚合运算操作，主要通过groupby()函数与agg()函数实现。【示例20】　对分组统计结果使用聚合函数。 \04\20）<br>按“一级分类”分组统计“7天点击量”“订单预定”的平均值和总和，主要代码如下：</p>
<p>print(df1.groupby(‘一级分类’).agg([‘mean’,’sum’]))<br>运行程序，控制台输出结果如图4.14所示。</p>
<p>【示例21】　针对不同的列使用不同的聚合函数。 \04\21）<br>在上述示例中，还可以针对不同的列使用不同的聚合函数。例如，按“一级分类”分组统计“7天点击量”的平均值和总和、“订单预定”的总和，主要代码如下：</p>
<p>print(df1.groupby(‘一级分类’).agg({‘7天点击量’:[‘mean’,’sum’], ‘订单预定’:[‘sum’]}))</p>
<p>​           图4.15　分组统计“7天点击量”的平均值和总和、“订单预定”的总和</p>
<p>【示例22】　通过自定义函数实现分组统计。 \04\22）<br>通过自定义函数也可以实现数据分组统计。例如，统计1月份销售数据中，购买次数最多的产品，主要代码如下：</p>
<h2 id="4-4-数据移位"><a href="#4-4-数据移位" class="headerlink" title="4.4　数据移位"></a>4.4　数据移位</h2><p>什么是数据移位？例如，分析数据时需要上一条数据怎么办？当然是移动至上一条，从而得到该条数据，这就是数据移位。在Pandas中，使用shift()方法可以获得上一条数据，该方法返回向下移位后的结果，从而得到上一条数据。例如，获取某学生上一次英语成绩，如图4.21所示。</p>
<p>DataFrame.shift(periods=1, freq=None, axis=0)<br>参数说明：　</p>
<p>periods：表示移动的幅度，可以是正数，也可以是负数，默认值是1，1表示移动一次。注意这里移动的都是数据，而索引是不移动的，移动之后是没有对应值的，赋值为NaN。　</p>
<p>freq：可选参数，默认值为None，只适用于时间序列，如果这个参数存在，那么会按照参数值移动时间索引，而数据值没有发生变化。　</p>
<p>axis：axis=1表示行，axis=0表示列。默认值为0。</p>
<h3 id="4-5-1-一列数据转换为多列数据"><a href="#4-5-1-一列数据转换为多列数据" class="headerlink" title="4.5.1　一列数据转换为多列数据"></a>4.5.1　一列数据转换为多列数据</h3><p>一列数据转换为多列数据的情况在日常工作中经常会用到，从各种系统中导出的订单号、名称、地址很多都是复合组成的（即由多项内容组成），那么，这些列在查找、统计、合并时就没办法使用，需要将它们拆分开。例如，地址信息由省市区街道门牌号等信息组成，如果按省、市或区统计数据，就需要将地址信息中的“省”“市”“区”拆分开，此时就应用到了一列数据转多列数据，通常使用以下方法。</p>
<h4 id="1．split-方法"><a href="#1．split-方法" class="headerlink" title="1．split()方法"></a>1．split()方法</h4><p>Pandas的DataFrame对象中的str.split()内置方法可以实现分割字符串，语法如下：</p>
<p>Series.str.split(pat=None, n=-1, expand=False)<br>参数说明：　</p>
<p>pat：字符串、符号或正则表达式，字符串分割的依据，默认以空格分割字符串。　</p>
<p>n：整型，分割次数，默认值是-1，0或-1都将返回所有拆分。　expand：布尔型，分割后的结果是否转换为DataFrame，默认值是False。　</p>
<p>返回值：系列、索引、DataFrame或多重索引。</p>
<h4 id="2．join-方法与split-方法结合"><a href="#2．join-方法与split-方法结合" class="headerlink" title="2．join()方法与split()方法结合"></a>2．join()方法与split()方法结合</h4><p>df = df.join(df[‘宝贝标题’].str.split(‘, ‘, expand=True))</p>
<p>【示例28】　对元组数据进行分隔。 \04\28）<br>首先，创建一组包含元组的数据，程序代码如下：</p>
<p>01  import pandas as pd<br>02  df = pd.DataFrame({‘a’:[1,2,3,4,5], ‘b’:[(1,2), (3,4),(5,6),(7,8),(9,10)]})<br>03  print(df)</p>
<p>然后，使用apply()函数对元组进行分隔，主要代码如下：</p>
<p>df[[‘b1’, ‘b2’]] = df[‘b’].apply(pd.Series)<br>或者使用join()方法结合apply()函数，主要代码如下：</p>
<p>df= df.join(df[‘b’].apply(pd.Series))</p>
<h4 id="3．pivot-方法"><a href="#3．pivot-方法" class="headerlink" title="3．pivot()方法"></a>3．pivot()方法</h4><p>pivot()方法针对列的值，即指定某列的值作为行索引，指定某列的值作为列索引，然后再指定哪些列作为索引对应的值。unstack()方法针对索引进行操作，pivot()方法针对值进行操作。但实际上，二者的功能往往可以互相实现。<br>pivot()方法的语法如下：</p>
<p>DataFrame.pivot(index=None, columns=None, values=None)<br>参数说明：　</p>
<p>index：字符串或对象，可选参数。列用于创建新DataFrame数据的索引。如果没有，则使用现有索引。　</p>
<p>columns：字符串或对象，列用于创建新DataFrame的列。　</p>
<p>values：列用于填充新DataFrame的值，如果未指定，则将使用所有剩余的列，结果将具有分层索引列。　</p>
<p>返回值：DataFrame对象或Series对象。</p>
<p>使用pivot()方法转换学生成绩表，主要代码如下：</p>
<p>01 df=pd.read_excel(‘grade.xls’,sheet_name=’英语3’)         #导入Excel文件<br>02 df1=df.pivot(index=’序号’,columns=’班级’,values=’得分’)</p>
<p>图4.33　使用pivot()方法转换学生成绩表</p>
<h3 id="4-5-3-DataFrame转换为字典"><a href="#4-5-3-DataFrame转换为字典" class="headerlink" title="4.5.3　DataFrame转换为字典"></a>4.5.3　DataFrame转换为字典</h3><p>DataFrame转换为字典主要使用DataFrame对象的to_dict()方法，以索引作为字典的键（key），以列作为字典的值（value）。例如，有一个DataFrame对象（索引为“类别”、列为“数量”），通过to_dict()方法就会生成一个字典，示意图如图4.34所示。如果DataFrame对象包含两列，那么to_dict()方法就会生成一个两层的字典（dict），第一层是列名作为字典的键（key），第二层以索引列的值作为字典的键（key），以列值作为字典的值（value）。</p>
<p>【示例32】　将Excel销售数据转换为字典。 \04\32）<br>使用to_dict()方法将按“宝贝标题”分组统计后的部分数据转换为字典，程序代码如下：</p>
<p>​                           图4.35　DataFrame转换为字典</p>
<h3 id="4-5-4-DataFrame转换为列表"><a href="#4-5-4-DataFrame转换为列表" class="headerlink" title="4.5.4　DataFrame转换为列表"></a>4.5.4　DataFrame转换为列表</h3><p>DataFrame转换为列表主要使用DataFrame对象的tolist()方法。</p>
<p>【示例33】　将电商数据转换为列表。 \04\33）</p>
<h3 id="4-5-5-DataFrame转换为元组"><a href="#4-5-5-DataFrame转换为元组" class="headerlink" title="4.5.5　DataFrame转换为元组"></a>4.5.5　DataFrame转换为元组</h3><p>DataFrame转换为元组，首先通过循环语句按行读取DataFrame数据，然后使用元组函数tuple()将其转换为元组。</p>
<p>【示例34】　将Excel数据转换为元组。 \04\34）<br>将Excel表中的人物关系部分数据转换成元组，程序代码如下：</p>
<p>​                            图4.37　DataFrame转换为元组</p>
<h3 id="4-5-6-Excel转换为HTML网页格式"><a href="#4-5-6-Excel转换为HTML网页格式" class="headerlink" title="4.5.6　Excel转换为HTML网页格式"></a>4.5.6　Excel转换为HTML网页格式</h3><p>日常工作中，有时会涉及财务数据的处理，而Excel应用最为广泛，但是对于展示数据来说，Excel并不友好，如果你想用其他格式的文件来向用户展示，那么，HTML网页格式是不错的选择。首先使用read_excel()方法导入Excel文件，然后使用to_html()方法将DataFrame数据导出为HTML格式，这样便实现了Excel转换为HTML格式。</p>
<p>程序代码如下：</p>
<p>01 import pandas as pd<br>02 df=pd.read_excel(‘mrbooks.xls’)<br>03 df.to_html(‘mrbook.html’,header = True,index = False)</p>
<h2 id="4-6-数据合并"><a href="#4-6-数据合并" class="headerlink" title="4.6　数据合并"></a>4.6　数据合并</h2><p>DataFrame数据合并主要使用merge()方法和concat()方法。</p>
<h3 id="4-6-1-数据合并（merge-方法）"><a href="#4-6-1-数据合并（merge-方法）" class="headerlink" title="4.6.1　数据合并（merge()方法）"></a>4.6.1　数据合并（merge()方法）</h3><p>Pandas模块的merge()方法是按照两个DataFrame对象列名相同的列进行连接合并，两个DataFrame对象必须具有同名的列。merge()方法的语法如下：</p>
<p>pandas.merge(right,how=’inner’,on=None,left_on=None,right_on=None,left_index=False,right_index=False,sort=<br>False,suffixes=(‘_x’,’_y’),copy=True,indicator=False,validate=None)<br>参数说明：　</p>
<p>right：合并对象，DataFrame对象或Series对象。　</p>
<p>how：合并类型，参数值可以是left（左合并）、right（右合并）、outer（外部合并）或inner（内部合并），默认值为inner。各个值的说明如下。　</p>
<p>​        left：只使用来自左数据集的键，类似于SQL左外部联接，保留键的顺序。　</p>
<p>​        right：只使用来自右数据集的键，类似于SQL右外部联接，保留键的顺序。　</p>
<p>​        outer：使用来自两个数据集的键，类似于SQL外部联接，按字典顺序对键进行排序。　</p>
<p>​        inner：使用来自两个数据集的键的交集，类似于SQL内部连接，保持左键的顺序。</p>
<p>on：标签、列表或数组，默认值为None。DataFrame对象连接的列或索引级别名称。也可以是DataFrame对象长度的数组或数组列表。</p>
<p>left_on：标签、列表或数组，默认值为None。要连接的左数据集的列或索引级名称，也可以是左数据集长度的数组或数组列表。　</p>
<p>right_on：标签、列表或数组，默认值为None。要连接的右数据集的列或索引级名称，也可以是右数据集长度的数组或数组列表。　left_index：布尔型，默认值为False。使用左数据集的索引作为连接键。如果是多重索引，则其他数据中的键数（索引或列数）必须匹配索引级别数。</p>
<p>right_index：布尔型，默认值为False，使用右数据集的索引作为连接键。　</p>
<p>sort：布尔型，默认值为False，在合并结果中按字典顺序对连接键进行排序。如果值为False，则连接键的顺序取决于连接类型how参数。　</p>
<p>suffixes：元组类型，默认值为(‘_x’,’_y’)。当左侧数据集和右侧数据集的列名相同时，数据合并后列名将带上“_x”和“_y”后缀。　</p>
<p>copy：是否复制数据，默认值为True。如果值为False，则不复制数据。　</p>
<p>indicator：布尔型或字符串，默认值为False。如果值为True，则添加一个列以输出名为_Merge的DataFrame对象，其中包含每一行的信息。如果是字符串，将向输出的DataFrame对象中添加包含每一行信息的列，并将列命名为字符型的值。　</p>
<p>validate：字符串，检查合并数据是否为指定类型。可选参数，其值说明如下。　one_to_one或“1:1”：检查合并键在左、右数据集中是否都是唯一的。　one_to_many或“1:m”：检查合并键在左数据集中是否唯一。　many_to_one或“m:1”：检查合并键在右数据集中是否唯一。　many_to_many或“m:m”：允许，但不检查。　</p>
<p>返回值：DataFrame对象，两个合并对象的数据集。</p>
<h4 id="1．常规合并"><a href="#1．常规合并" class="headerlink" title="1．常规合并"></a>1．常规合并</h4><p>运行程序，控制台输出结果如图4.40所示。</p>
<p>【示例37】　通过索引合并数据。 \04\37）<br>如果通过索引列合并，则需要设置right_index参数和left_index参数值为True。例如，上述举例，通过列索引合并，主要代码如下：</p>
<p>01 df_merge=pd.merge(df1,df2,right_index=True,left_index=True)<br>02 print(df_merge)<br>运行程序，控制台输出结果如图4.41所示。</p>
<p>【示例38】　对合并数据去重。 \04\38）<br>从图4.41中的运行结果得知：数据中存在重复列（如编号），如果不想要重复列，可以设置按指定列和列索引合并数据，主要代码如下：</p>
<p>df_merge=pd.merge(df1,df2,on=’编号’,left_index=True,right_index=True)</p>
<p>还可以通过how参数解决这一问题。例如，设置该参数值为left，就是让df1保留所有的行列数据，df2则根据df1的行列进行补全，主要代码如下：</p>
<p>df_merge=pd.merge(df1,df2,on=’编号’,how=’left’)<br>运行程序，控制台输出结果如图4.42所示。</p>
<h4 id="2．多对一的数据合并"><a href="#2．多对一的数据合并" class="headerlink" title="2．多对一的数据合并"></a>2．多对一的数据合并</h4><p>多对一是指两个数据集（df1、df2）的共有列中的数据不是一对一的关系，例如，df1中的“编号”是唯一的，而df2中的“编号”有重复的编号，类似这种就是多对一的关系，示意图如图4.43所示。【示例39】　根据共有列进行合并数据。 \04\39）<br>根据共有列中的数据进行合并，df2根据df1的行列进行补全，程序代码如下：</p>
<h3 id="4-6-2-数据合并（concat-方法）"><a href="#4-6-2-数据合并（concat-方法）" class="headerlink" title="4.6.2　数据合并（concat()方法）"></a>4.6.2　数据合并（concat()方法）</h3><p>concat()方法可以根据不同的方式将数据合并，语法如下：</p>
<p>pandas.concat(objs,axis=0,join=’outer’,ignore_index: bool = False, keys=None, levels=None, names=None,<br>verify_integrity: bool = False, sort: bool = False, copy: bool = True)<br>参数说明：　</p>
<p>objs：Series、DataFrame或Panel对象的序列或映射。如果传递一个字典，则排序的键将用作键参数。　</p>
<p>axis：axis=1表示行，axis=0表示列。默认值为0。　</p>
<p>join：值为inner（内连接）或outer（外连连接），处理其他轴上的索引方式。默认值为outer。　</p>
<p>ignore_index：布尔值，默认值为False，保留索引，索引值为0，…，n-1。如果值为True，则忽略索引。　</p>
<p>keys：序列，默认值为None。使用传递的键作为最外层构建层次索引。如果为多索引，应该使用元组。　</p>
<p>levels：序列列表，默认值为None。用于构建MultiIndex的特定级别（唯一值）；否则，它们将从键推断。　</p>
<p>names：list列表，默认值为None。结果层次索引中的级别的名称。　</p>
<p>verify_integrity：布尔值，默认值为False。检查新连接的轴是否包含重复项。　</p>
<p>sort：布尔值，默认值为True（1.0.0以后版本默认值为False，即不排序）。如果连接为外连接（join=’outer’），则对未对齐的非连接轴进行排序；如果连接为内连接（join=’inner’），则该参数不起作用。</p>
<p>copy：是否复制数据，默认值为True，如果值为False，则不复制数据。</p>
<p>下面介绍concat()方法不同的合并方式，其中dfs代表合并后的DataFrame对象，df1、df2等代表单个DataFrame对象，result代表合并后的结果（DataFrame对象）。</p>
<h4 id="1．相同字段的表首尾相接"><a href="#1．相同字段的表首尾相接" class="headerlink" title="1．相同字段的表首尾相接"></a>1．相同字段的表首尾相接</h4><p>表结构相同的数据将直接合并，表首尾相接，主要代码如下：</p>
<p>01  dfs= [df1, df2, df3]<br>02  result = pd.concat(dfs)<br>例如，表df1、df2和df3结构相同，如图4.47所示。合并后的效果如图4.48所示。如果想要在合并数据时标记源数据来自哪张表，则需要在代码中加入参数keys，例如表名分别为“1月”“2月”“3月”，合并后的效果如图4.49所示。</p>
<p>​                        图4.49　合并后带标记（月份）的效果<br>主要代码如下：</p>
<p>result = pd.concat(dfs, keys=[‘1月’, ‘2月’, ‘3月’])</p>
<h4 id="2．横向表合并（行对齐）"><a href="#2．横向表合并（行对齐）" class="headerlink" title="2．横向表合并（行对齐）"></a>2．横向表合并（行对齐）</h4><p>当合并的数据列名称不一致时，可以设置参数axis=1，concat()方法将按行对齐，然后将不同列名的两组数据进行合并，缺失的数据用NaN填充，df1和df4合并前后效果如图4.50和图4.51所示。</p>
<p>​                        图4.50　横向表合并前</p>
<p>​                            图4.51　横向表合并后<br>主要代码如下：</p>
<p>result = pd.concat([df1, df4], axis=1)</p>
<h4 id="3．交叉合并"><a href="#3．交叉合并" class="headerlink" title="3．交叉合并"></a>3．交叉合并</h4><p>交叉合并，需要在代码中加上join参数，如果值为inner，结果是两张表的交集；如果值为outer，结果是两张表的并集。例如两张表交集，表df1和df4合并前后的效果如图4.52和图4.53所示。</p>
<p>​                                       图4.53　交叉合并后<br>主要代码如下：</p>
<p>result = pd.concat([df1, df4], axis=1, join=’inner’)</p>
<h4 id="4．指定表对齐数据（行对齐）"><a href="#4．指定表对齐数据（行对齐）" class="headerlink" title="4．指定表对齐数据（行对齐）"></a>4．指定表对齐数据（行对齐）</h4><p>如果指定参数join_axes，就可以指定根据哪张表来对齐数据。例如，根据df4对齐数据，就会保留表df4的数据，然后将表df1的数据与之合并，行数不变，合并前后的效果与如图4.54和图4.55所示。</p>
<p>主要代码如下：</p>
<p>result = pd.concat([df1, df4], axis=1, join_axes=[df4.index])</p>
<h2 id="4-7-数据导出"><a href="#4-7-数据导出" class="headerlink" title="4.7　数据导出"></a>4.7　数据导出</h2><h3 id="4-7-1-导出为-xlsx文件"><a href="#4-7-1-导出为-xlsx文件" class="headerlink" title="4.7.1　导出为.xlsx文件"></a>4.7.1　导出为.xlsx文件</h3><p>导出数据为Excel，主要使用DataFrame对象的to_excel()方法，语法如下：</p>
<p>DataFrame.to_excel(excel_writer,sheet_name=’Sheet1’,na_rep=’’,float_format=None,columns=None,header=True,<br>index=True,index_label=None,startrow=0,startcol=0,engine=None,merge_cells=True, encoding=None, inf_rep=’inf’,<br>verbose=True, freeze_panes=None)<br>参数说明：　</p>
<p>excel_writer：字符串或ExcelWriter对象。　</p>
<p>sheet_name：字符串，默认值为Sheet1，包含DataFrame的表的名称。　</p>
<p>na_rep：字符串，默认值为’ ‘。缺失数据的表示方式。　</p>
<p>float_format：字符串，默认值为None，格式化浮点数的字符串。　</p>
<p>columns：序列，可选参数，要编辑的列。　</p>
<p>header：布尔型或字符串列表，默认值为True。列名称，如果给定字符串列表，则表示它是列名称的别名。　</p>
<p>index：布尔型，默认值为True，行名（索引）。　</p>
<p>index_label：字符串或序列，默认值为None。如果需要，可以使用索引列的列标签；如果没有给出，标题和索引为True，则使用索引名称；如果数据文件使用多索引，则需使用序列。</p>
<p>startrow：指定从哪一行开始写入数据。　</p>
<p>startcol：指定从哪一列开始写入数据。　</p>
<p>engine：字符串，默认值为None，指定要使用的写引擎，如openpyxl或xlsxwriter。也可以通过io.excel.xlsx.writer、io.excel.xls.writer和io.excel.xlsm.writer进行设置。　</p>
<p>merge_cells：布尔型，默认值为True。　</p>
<p>encoding：指定Excel文件的编码方式，默认值为None。　</p>
<p>inf_rep：字符串，默认值为“正”，表示无穷大。　</p>
<p>verbose：布尔型，默认值为True。在错误日志中显示更多信息。　freeze_panes：整数的元组，长度2，默认值为None。指定要冻结的行列。</p>
<p>【示例41】　将处理后的数据导出为Excel文件。 \04\41）<br>将数据合并后的结果导出为Excel文件，主要代码如下：</p>
<p>df_merge.to_excel(‘merge.xlsx’)<br>运行程序，数据将导出为Excel文件，如图4.56所示。</p>
<p>df1.to_excel(‘df1.xlsx’,sheet_name=’df1’)</p>
<h3 id="4-7-2-导出为-csv文件"><a href="#4-7-2-导出为-csv文件" class="headerlink" title="4.7.2　导出为.csv文件"></a>4.7.2　导出为.csv文件</h3><p>导出数据为.csv文件，主要使用DataFrame对象的to_csv()方法，语法如下：</p>
<p>path_or_buf：要保存的路径及文件名。　</p>
<p>sep：分隔符，默认值为”,”。　</p>
<p>na_rep：指定空值的输出方式，默认值为空字符串。　</p>
<p>float_format：浮点数的输出格式，要用双引号括起来。　</p>
<p>columns：指定要导出的列，用列名列表表示，默认值为None。　header：是否输出列名，默认值为True。　</p>
<p>index：是否输出索引，默认值为True。　</p>
<p>index_label：索引列的列名，默认值为None。　</p>
<p>mode：Python写入模式，默认值为w。　</p>
<p>encoding：编码方式，默认值为utf-8。　</p>
<p>compression：压缩模式，默认值为infer。　</p>
<p>quoting：导出.csv文件是否用引号，默认值为0，表示不加双引号；如果值为1，则每个字段都会加上引号，数值也会被当作字符串看待。</p>
<p>quotechar：引用字符，当quoting=1时可以指定引号字符为双引号（” “）或单引号（’ ‘）。　</p>
<p>line_terminator：换行符，默认值为\n。</p>
<p>chunksize：一次写入.csv文件的行数，当DataFrame对象数据特别大时需要分批写入。　</p>
<p>date_format：日期输出格式。　</p>
<p>doublequote：是否添加双引用符，默认值为True。　</p>
<p>escapechar：设置转义字符。　</p>
<p>decimal：可识别十进制分隔符的字符。　</p>
<p>errors：指定如何处理编码和解码错误，默认值为strict（严格的）。</p>
<p>【示例42】　将处理后的数据导出为.csv文件。 \04\42）<br>下面介绍to_csv()方法常用功能，举例如下，df为DataFrame对象。<br>（1）相对位置，保存在程序所在路径下，代码如下：</p>
<p>df.to_csv(‘Result.csv’)<br>（2）绝对位置，代码如下：</p>
<p>df.to_csv(‘d:\Result.csv’)<br>（3）分隔符。使用问号（？）分隔符分隔需要保存的数据，代码如下：</p>
<p>df.to_csv(‘Result.csv’,sep=’?’)``<br>（4）替换空值，缺失值保存为NA，代码如下：</p>
<p>df.to_csv(‘Result1.csv’,na_rep=’NA’)<br>（5）格式化数据，保留两位小数，代码如下：</p>
<p>df.to_csv(‘Result1.csv’,float_format=’%.2f’)<br>（6）保留某列数据，保存索引列和name列，代码如下：</p>
<p>df.to_csv(‘Result.csv’,columns=[‘name’])<br>（7）是否保留列名，不保留列名，代码如下：</p>
<p>df.to_csv(‘Result.csv’,header=False)<br>（8）是否保留行索引，不保留行索引，代码如下：</p>
<p>df.to_csv(‘Result.csv’,index=False)</p>
<h3 id="4-7-3-导出多个Sheet"><a href="#4-7-3-导出多个Sheet" class="headerlink" title="4.7.3　导出多个Sheet"></a>4.7.3　导出多个Sheet</h3><p>导出多个Sheet，应首先使用pd.ExcelWriter()方法打开一个Excel文件，然后再使用to_excel()方法导出指定的Sheet。</p>
<h2 id><a href="#" class="headerlink" title></a></h2><h3 id="4-8-1-DataFrame的日期数据转换"><a href="#4-8-1-DataFrame的日期数据转换" class="headerlink" title="4.8.1　DataFrame的日期数据转换"></a>4.8.1　DataFrame的日期数据转换</h3><p>日常工作中，有一个非常麻烦的事情就是日期的格式可以有很多种表达，我们看到同样是2020年2月14日，可以有很多种格式，如图4.57所示。那么，我们需要先将这些格式统一后才能进行后续的工作。Pandas提供了to_datetime()方法可以帮助我们解决这一问题。<br>to_datetime()方法可以用来批量处理日期数据转换，对于处理大数据非常实用和方便，它可以将日期数据转换成你需要的各种格式。例如，将2/14/20和14-2-2020转换为日期格式2020-02-14。to_datetime()方法的语法如下：</p>
<p>pandas.to_datetime(arg,errors=’ignore’,dayfirst=False,yearfirst=False,utc=None,box=True,format=None,exact=<br>True,unit=None,infer_datetime_format=False,origin=’unix’,cache=False)<br>参数说明：　</p>
<p>arg：字符串、日期时间、字符串数组。　</p>
<p>errors：值为ignore、raise或coerce，具体说明如下，默认值为ignore，即忽略错误。　</p>
<p>ignore：无效的解析将返回原值。　</p>
<p>raise：无效的解析将引发异常。　</p>
<p>coerce：无效的解析将被设置为NaT，即无法转换为日期的数据将被转换为NaT。　</p>
<p>dayfirst：第一个为天，布尔型，默认值为False。例如02/09/2020，如果值为True，则解析日期的第一个为天，即2020-09-02；如果值为False，则解析日期与原日期一致，即2020-02-09。　</p>
<p>yearfirst：第一个为年，布尔型，默认值为False。例如14-Feb-20，如果值为True，则解析日期的第一个为年，即2014-02-20；如果值为False，则解析日期与原日期一致，即2020-02-14。　</p>
<p>utc：默认值为None。返回utc即协调世界时间。　</p>
<p>box：布尔值，默认值为True，如果值为True，则返回DatetimeIndex；如果值为False，则返回ndarray。　</p>
<p>format：格式化显示时间的格式。字符串，默认值为None。　</p>
<p>exact：布尔值，默认值为True。如果为True，则要求格式完全匹配；如果为False，则允许格式与目标字符串中的任何位置匹配。　</p>
<p>unit：默认值为None，参数的单位（D、s、、ms、μs、ns）表示时间的单位。　</p>
<p>infer_datetime_format：默认值为False。如果没有格式，则尝试根据第一个日期时间字符串推断格式。　</p>
<p>origin：默认值为unix。定义参考日期。数值将被解析为单位数。　</p>
<p>cache：默认值为False。如果值为True，则使用唯一、转换日期的缓存应用日期时间转换。在解析重复日期字符串，特别是带有时区偏移的字符串时，可能会产生明显的加速。只有在至少有50个值时才使用缓存。越界值的存在将使缓存不可用，并可能减慢解析速度。　</p>
<p>返回值：日期时间。</p>
<p>​                                        图4.59　日期组合</p>
<h3 id="4-8-2-dt对象"><a href="#4-8-2-dt对象" class="headerlink" title="4.8.2　dt对象"></a>4.8.2　dt对象</h3><p>dt对象是Series对象中用于获取日期属性的一个访问器对象，通过它可以获取日期中的年、月、日、星期数、季节等，还可以判断日期是否处在年底。语法如下：</p>
<p>  Series.dt()<br>参数说明：　</p>
<p>返回值：返回与原始系列相同的索引系列。如果Series不包含类日期值，则引发错误。　</p>
<p>dt对象提供了year、month、day、dayofweek、dayofyear、is_leap_year、quarter、weekday_name等属性和方法。</p>
<p>例如，year可以获取“年”、month可以获取“月”、quarter可以直接得到每个日期分别是第几个季度，weekday_name可以直接得到每个日期对应的是周几。</p>
<p>【示例46】　获取日期中的年、月、日、星期数等。 \04\46）<br>使用dt对象获取日期中的年、月、日、星期数、季节等。<br>（1）获取年、月、日，代码如下：</p>
<p>df[‘年’],df[‘月’],df[‘日’]=df[‘日期’].dt.year,df[‘日期’].dt.month,df[‘日期’].dt.day<br>（2）从日期判断出所处星期数，代码如下：</p>
<p>df[‘星期几’]=df[‘日期’].dt.day_name()<br>（3）从日期判断所处季度，代码如下：</p>
<p>df[‘季度’]=df[‘日期’].dt.quarter<br>（4）从日期判断是否为年底最后一天，代码如下：</p>
<p>df[‘是否年底’]=df[‘日期’].dt.is_year_end<br>运行程序，控制台输出结果如图4.60所示。</p>
<p>​                               图4.60　dt对象日期转换</p>
<h3 id="4-8-3-获取日期区间的数据"><a href="#4-8-3-获取日期区间的数据" class="headerlink" title="4.8.3　获取日期区间的数据"></a>4.8.3　获取日期区间的数据</h3><p>获取日期区间的数据的方法是直接在DataFrame对象中输入日期或日期区间，但前提必须设置日期为索引，举例如下。　</p>
<p>获取2018年的数据。</p>
<p>df1[‘2018’]　</p>
<p>获取2017—2018年的数据。</p>
<p>df1[‘2017’:’2018’]　</p>
<p>获取某月（2018年7月）的数据。</p>
<p>df1[‘2018-07’]　</p>
<p>获取具体某天（2018年5月6日）的数据。</p>
<p>df1[‘2018-05-06’:’2018-05-06’]</p>
<h3 id="4-8-4-按不同时期统计并显示数据"><a href="#4-8-4-按不同时期统计并显示数据" class="headerlink" title="4.8.4　按不同时期统计并显示数据"></a>4.8.4　按不同时期统计并显示数据</h3><h4 id="1．按时期统计数据"><a href="#1．按时期统计数据" class="headerlink" title="1．按时期统计数据"></a>1．按时期统计数据</h4><p>按时期统计数据主要通过DataFrame对象的resample()方法结合数据计算函数实现。resample()方法主要应用于时间序列频率转换和重采样，它可以从日期中获取年、月、日、星期、季节等，结合数据计算函数就可以实现按年、月、日、星期或季度等不同时期统计数据。举例如下所示。<br>（1）按年统计数据，代码如下：</p>
<p>df1=df1.resample(‘AS’).sum()<br>（2）按季度统计数据，代码如下：</p>
<p>df2.resample(‘Q’).sum()<br>（3）按月度统计数据，代码如下：</p>
<p>df1.resample(‘M’).sum()<br>（4）按星期统计数据，代码如下：</p>
<p>df1.resample(‘W’).sum()<br>（5）按天统计数据，代码如下：</p>
<p>df1.resample(‘D’).sum()</p>
<p>完整错误描述：<br>TypeError: Only valid with DatetimeIndex, TimedeltaIndex or PeriodIndex, but got an instance of’Index’<br>出现上述错误，是由于<strong>resample()函数要求索引必须为日期型</strong>。<br>解决方法：将数据的索引转换为datetime类型，主要代码如下：</p>
<p>df1.index = pd.to_datetime(df1.index)</p>
<h4 id="2．按时期显示数据"><a href="#2．按时期显示数据" class="headerlink" title="2．按时期显示数据"></a>2．按时期显示数据</h4><p>DataFrame对象的to_period()方法可以将时间戳转换为时期，从而实现按时期显示数据，前提是日期必须设置为索引。语法如下：</p>
<p>DataFrame.to_period(freq=None, axis=0, copy=True)<br>参数说明：　</p>
<p>freq：字符串，周期索引的频率，默认值为None。　</p>
<p>axis：行列索引，axis=0表示行索引，axis=1表示列索引。默认值为0，即表示行索引。　</p>
<p>copy：是否复制数据，默认值为True，如果值为False，则不复制数据。　返回值：带周期索引的时间序列。</p>
<p>【示例48】　从日期中获取不同的时期。 \04\48）<br>从日期中获取不同的时期，主要代码如下：</p>
<p><img src="/.com//文档\第四章-Pandas统计分析.assets\image-20211020052452293.png" alt="image-20211020052452293"></p>
<h4 id="3．按时期统计并显示数据"><a href="#3．按时期统计并显示数据" class="headerlink" title="3．按时期统计并显示数据"></a>3．按时期统计并显示数据</h4><p>（1）按年统计并显示数据，代码如下：</p>
<p>df2.resample(‘AS’).sum().to_period(‘A’)<br>控制台输出结果如图4.63所示。<br>（2）按季度统计并显示数据，代码如下：</p>
<p>Q_df=df2.resample(‘Q’).sum().to_period(‘Q’)</p>
<p>（3）按月统计并显示数据，代码如下：</p>
<p>df2.resample(‘M’).sum().to_period(‘M’)<br>控制台输出结果如图4.65所示。<br>（4）按星期统计并显示数据（前5条数据），代码如下：</p>
<p>df2.resample(‘W’).sum().to_period(‘W’).head()</p>
<h2 id="4-9-时间序列"><a href="#4-9-时间序列" class="headerlink" title="4.9　时间序列"></a>4.9　时间序列</h2><h3 id="4-9-1-重采样（Resample-方法）"><a href="#4-9-1-重采样（Resample-方法）" class="headerlink" title="4.9.1　重采样（Resample()方法）"></a>4.9.1　重采样（Resample()方法）</h3><p>通过前面的学习，我们学会了如何生成不同频率的时间索引，按小时、按天、按周、按月等，如果想对数据做不同频率的转换，该怎么办？在Pandas中对时间序列的频率的调整称为重新采样，即将时间序列从一个频率转换到另一个频率的处理过程。例如，每天一个频率转换为每5天一个频率，如图4.67所示。</p>
<p>​                                       图4.67　时间频率<br>重采样主要使用resample()方法，该方法用于对常规时间序列重新采样和频率转换，包括降采样和升采样两种。首先了解下resample()方法，语法如下：</p>
<p>DataFrame.resample(rule,how=None,axis=0,fill_method=None,closed=None,label=None,convention=’start’,kind=<br>None,loffset=None,limit=None,base=0,on=None,level=None)<br>参数说明：　</p>
<p>rule：字符串，偏移量表示目标字符串或对象转换。　</p>
<p>how：用于产生聚合值的函数名或数组函数。例如mean、ohlc和np.max等，默认值为mean，其他常用的值为first、last、median、max和min。　</p>
<p>axis：整型，表示行列，axis=0表示列，axis=1表示行。默认值为0，即表示列。　fill_method：升采样时所使用的填充方法，ffill()方法（用前值填充）或bfill()方法（用后值填充），默认值为None。　</p>
<p>closed：降采样时，时间区间的开和闭，与数学里区间的概念一样，其值为right或left，right表示左开右闭（即左边值不包括在内），left表示左闭右开（即右边值不包括在内），默认值为right左开右闭。　</p>
<p>label：降采样时，如何设置聚合值的标签。例如，10:30—10:35会被标记成10:30还是10:35，默认值为None。　</p>
<p>convention：当重采样时，将低频率转换到高频率所采用的约定，其值为start或end，默认值为start。　</p>
<p>kind：聚合到时期（period）或时间戳（timestamp），默认聚合到时间序列的索引类型，默认值为None。　</p>
<p>loffset：聚合标签的时间校正值，默认值为None。例如，-1s或Second(-1)用于将聚合标签调早1秒。　</p>
<p>limit：向前或向后填充时，允许填充的最大时期数，默认值为None。</p>
<p>　base：整型，默认值为0。对于均匀细分1天的频率，聚合间隔的“原点”。例如，对于5min频率，base的范围可以是0～4。　on：字符串，可选参数，默认值为None。对DataFrame对象使用列代替索引进行重新采样。列必须与日期时间类似。　</p>
<p>level：字符串或整型，可选参数，默认值为None。用于多索引，重新采样的级别名称或级别编号，级别必须与日期时间类似。　</p>
<p>返回值：重新采样对象。</p>
<p>​                          图4.68　时间序列转换程序代码如下：</p>
<p>01  import pandas as pd<br>02  index = pd.date_range(‘02/02/2020’, periods=9, freq=’T’)</p>
<p>03  series = pd.Series(range(9), index=index)<br>04  print(series)<br>05  print(series.resample(‘3T’).sum())</p>
<h3 id="4-9-2-降采样处理"><a href="#4-9-2-降采样处理" class="headerlink" title="4.9.2　降采样处理"></a>4.9.2　降采样处理</h3><p>降采样是周期由高频率转向低频率。例如，将5min股票交易数据转换为日交易，按天统计的销售数据转换为按周统计。<br>数据降采样会涉及数据的聚合。例如，天数据变成周数据，那么就要对1周7天的数据进行聚合，聚合的方式主要包括求和、求均值等。例如，淘宝店铺每天销售数据（部分数据），如图4.69所示。</p>
<p>【示例50】　按周统计销售数据。 \04\50）<br>使用resample()方法来做降采样处理，频率为“周”，也就是将上述销售数据处理为每周（每7天）求和一次数据，程序代码如下：</p>
<p>01 import pandas as pd<br>02 df=pd.read_excel(‘time.xls’)<br>03 df1 = df.set_index(‘订单付款时间’)  #设置“订单付款时间”为索引<br>04 print(df1.resample(‘W’).sum().head())<br>运行程序，控制台输出结果如图4.70所示。<br>在参数说明中，我们列出了closed参数的解释，如果把closed参数值设置为left，结果如图4.71所示。</p>
<p>​              图4.69　淘宝店铺每天销售数据（部分数据）</p>
<p>​                                       图4.70　周数据统计1</p>
<p>​                              图4.71　周数据统计2</p>
<h3 id="4-9-3-升采样处理"><a href="#4-9-3-升采样处理" class="headerlink" title="4.9.3　升采样处理"></a>4.9.3　升采样处理</h3><p>​    升采样是周期由低频率转向高频率。将数据从低频率转换到高频率时，就不需要聚合了，将其重采样到日频率，默认会引入缺失值。<br>例如，原来是按周统计的数据，现在变成按天统计。升采样会涉及数据的填充，根据填充的方法不同，填充的数据也不同。下面介绍3种填充方法。　不填充。空值用NaN代替，使用asfreq()方法。　用前值填充。用前面的值填充空值，使用ffill()方法或者pad()方法。为了方便记忆，ffill()方法可以使用它的第一个字母“f”代替，代表forward，向前的意思。　用后值填充，使用bfill()方法，可以使用字母“b”代替，代表back，向后的意思。</p>
<p>【示例51】　每6小时统计一次数据。 \04\51）<br>下面创建一个时间序列，起始日期是2020-02-02，一共两天，每天对应的数值分别是1和2，通过升采样处理为每6小时统计一次数据，空值以不同的方式填充，程序代码如下：</p>
<p>01  import pandas as pd<br>02  import numpy as np<br>03  rng = pd.date_range(‘20200202’, periods=2)<br>05  s1_6h_asfreq = s1.resample(‘6H’).asfreq()</p>
<p>06  print(s1_6h_asfreq)<br>07  s1_6h_pad = s1.resample(‘6H’).pad()<br>08  print(s1_6h_pad)<br>09  s1_6h_ffill = s1.resample(‘6H’).ffill()<br>10  print(s1_6h_ffill)<br>11  s1_6h_bfill = s1.resample(‘6H’).bfill()<br>12  print(s1_6h_bfill)<br>运行程序，控制台输出结果如图4.72所示。</p>
<p>​                          图4.72　6小时数据统计</p>
<h3 id="4-9-4-时间序列数据汇总（ohlc-函数）"><a href="#4-9-4-时间序列数据汇总（ohlc-函数）" class="headerlink" title="4.9.4　时间序列数据汇总（ohlc()函数）"></a>4.9.4　时间序列数据汇总（ohlc()函数）</h3><p>在金融领域，经常会看到开盘（open）、收盘（close）、最高价（high）和最低价（low）数据，而在Pandas中经过重新采样的数据也可以实现这样的结果，通过调用ohlc()函数得到数据汇总结果，即开始值（open）、结束值（close）、最高值（high）和最低值（low）。ohlc()函数的语法如下：</p>
<p>resample.ohlc()<br>ohlc()函数返回DataFrame对象，每组数据的open（开）、high（高）、low（低）和close（关）值。</p>
<p>【示例52】　统计数据的open、high、low和close值。 \04\52）<br>下面是一组5分钟的时间序列，通过ohlc()函数获取该时间序列中每组时间的开始值、最高值、最低值和结束值，程序代码如下：</p>
<p>01  import pandas as pd<br>02  import numpy as np<br>03  rng = pd.date_range(‘2/2/2020’,periods=12,freq=’T’)<br>04  s1 = pd.Series(np.arange(12),index=rng)<br>05  print(s1.resample(‘5min’).ohlc())<br>运行程序，控制台输出结果如图4.73所示。</p>
<p>​                          图4.73　时间序列数据汇总</p>
<h3 id="4-9-5-移动窗口数据计算（rolling-函数）"><a href="#4-9-5-移动窗口数据计算（rolling-函数）" class="headerlink" title="4.9.5　移动窗口数据计算（rolling()函数）"></a>4.9.5　移动窗口数据计算（rolling()函数）</h3><p>通过重采样可以得到想要的任何频率的数据，但是这些数据也是一个时点的数据，那么就存在这样一个问题：时点的数据波动较大，某一点的数据就不能很好地表现它本身的特性，于是就有了“移动窗口”的概念，简单地说，为了提升数据的可靠性，将某个点的取值扩大到包含这个点的一段区间，用区间来进行判断，这个区间就是窗口。<br>下面举例说明，图4.74显示了移动窗口数据示意图，其中时间序列代表1号到15号每天的销量数据，接下来以3天为一个窗口，将该窗口从左至右依次移动，统计出3天的平均值作为这个点的值，如3号的销量是1号、2号和3号的平均值。</p>
<p>通过上述示意图相信您已经理解了移动窗口，在Pandas中可以通过rolling()函数实现移动窗口数据的计算，语法如下：</p>
<p>DataFrame.rolling(window, min_periods=None, center=False, win_type=None, on=None, axis=0, closed=None)</p>
<p>参数说明：　</p>
<p>window：时间窗口的大小，有两种形式，即int或offset。如果使用int，则数值表示计算统计量的观测值的数量，即向前几个数据；如果使用offset，则表示时间窗口的大小。　</p>
<p>min_periods：每个窗口最少包含的观测值数量，小于这个值的窗口结果为NA。值可以是int，默认值为None。offset情况下，默认值为1。</p>
<p>center：把窗口的标签设置为居中。布尔型，默认值为False，居右。</p>
<p>win_type：窗口的类型。截取窗的各种函数。字符串类型，默认值为None。　</p>
<p>on：可选参数。对于DataFrame对象，是指定要计算移动窗口的列，值为列名。　</p>
<p>axis：整型，axis=0表示列，axis=1表示行。默认值为0，即对列进行计算。　</p>
<p>closed：定义区间的开闭，支持int类型的窗口。对于offset类型默认是左开右闭（默认值为right）。可以根据情况指定left。　</p>
<p>返回值：为特定操作而生成的窗口或移动窗口子类。</p>
<p>【示例53】　创建淘宝每日销量数据。 \04\53）<br>首先创建一组淘宝每日销量数据，程序代码如下：</p>
<p>01  import pandas as pd<br>02  index=pd.date_range(‘20200201’,’20200215’)<br>03  data=[3,6,7,4,2,1,3,8,9,10,12,15,13,22,14]<br>04  s1_data=pd.Series(data,index=index)<br>05  print(s1_data)<br>运行程序，控制台输出结果如图4.75所示。</p>
<p>【示例54】　使用rolling()函数计算3天的均值。 \04\54）</p>
<p>下面使用rolling()函数计算2020-02-01至2020-02-15中每3天的均值，窗口个数为3，代码如下：</p>
<p>s1_data.rolling(3).mean()<br>运行程序，看下rolling()函数是如何计算的？在图4.76中，当窗口开始移动时，第一个时间点2020-02-01和第二个时间点2020-02-02的数值为空，这是因为窗口个数为3，它们前面有空数据，所以均值为空；而到第三个时间点2020-02-03时，它前面的数据是2020-02-01至</p>
<p>​                       图4.76　2020-02-01至2020-02-15移动窗口均值1</p>
<p>【示例55】　用当天的数据代表窗口数据。 \04\55）<br>在计算第一个时间点2020-02-01的窗口数据时，虽然数据不够窗口长度3，但是至少有当天的数据，那么能否用当天的数据代表窗口数据呢？答案是肯定的，通过设置min_periods参数即可，它表示窗口最少包含的观测值，小于这个值的窗口长度显示为空，等于或大于时都有值，主要代码如下：</p>
<p>s1_data.rolling(3,min_periods=1).mean()</p>
<p>运行程序，对比效果如图4.77所示。<br>上述举例，我们再扩展下，通过图表观察原始数据与移动窗口数据的平稳性，如图4.78所示。其中实线代表移动窗口数据，其走向更平稳，这也是学习移动窗口rolling()函数的原因。</p>
<h2 id="4-10-综合应用"><a href="#4-10-综合应用" class="headerlink" title="4.10　综合应用"></a>4.10　综合应用</h2><h3 id="4-10-1-案例1：Excel多表合并"><a href="#4-10-1-案例1：Excel多表合并" class="headerlink" title="4.10.1　案例1：Excel多表合并"></a>4.10.1　案例1：Excel多表合并</h3><p>案例位置：资源包\MR\Code\04\example\01<br>在日常工作中，几乎我们每天都有大量的数据需要处理，桌面上总是布满密密麻麻的Excel表，这样看上去非常凌乱，其实我们完全可以将其中类别相同的Excel表合并到一起，这样不但不会丢失数据，而且还可以有效地分析数据。下面使用concat()方法将指定文件夹内的所有Excel表合并，程序代码如下：</p>
<h3 id="4-10-2-案例2：股票行情数据分析"><a href="#4-10-2-案例2：股票行情数据分析" class="headerlink" title="4.10.2　案例2：股票行情数据分析"></a>4.10.2　案例2：股票行情数据分析</h3><p>案例位置：资源包\MR\Code\04\example\02<br>股票数据包括开盘价、收盘价、最高价、最低价、成交量等多个指标。其中，收盘价是当日行情的标准，也是下一个交易日开盘价的依据，可以预测未来证券市场行情，因此当投资者对行情分析时，一般采用收盘价作为计算依据。<br>下面使用rolling()函数计算某股票20天、50天和200天的收盘价均值并生成走势图（也称K线图），如图4.79所示。</p>
]]></content>
      <categories>
        <category>数据分析文档</category>
      </categories>
  </entry>
  <entry>
    <title>seajs</title>
    <url>/2015/03/10/seajs/</url>
    <content><![CDATA[<p><strong>1.Seajs简介</strong></p>
<p>Seajs，一个Web模块加载框架，追求简单、自然的代码书写和组织方式，：Sea.js 遵循 CMD 规范，模块化JS代码。依赖的自动加载、配置的简洁清晰，可以让程序员更多地专注编码。</p>
<p><strong>2.Seajs优缺点</strong></p>
<p>优点：<br>1).提高可维护性。<br>2).模块化编程。<br>3).动态加载，前端性能优化</p>
<p><strong>缺点：</strong><br>1).学习文档偏少且混乱，会更改团队使用JS的编写习惯，必须使用模块化编程。<br>2).不太适合团队目前的情况，多JS文件但少改动，动态加载优势和模块化优势不明显。<br>3). 需要配套使用SPM工具，JS的打包和管理工具。</p>
<p>2.什么是CMD 和AMD ？</p>
<p>异步模块定义（AMD）是Asynchronous Module Definition的缩写，是 RequireJS 在推广过程中对模块定义的规范化产出。<br>通用模块定义（CMD）是Common Module Definition的缩写，是SeaJS 在推广过程中对模块定义的规范化产出。<br>RequireJS 和 SeaJS 都是模块化框架的代表，AMD和CMD，是他们各自定义模块化的方式，大同小异，主要是代码风格和API不同。</p>
<p>3.Seajs如何使用？</p>
<p>一段代码教新手一目了然，快速上手！</p>
<p> 代码如下:</p>
<pre><code>&lt;script src=&quot;../js/examples-master/sea-modules/seajs/seajs/2.1.1/sea.js&quot;&gt;&lt;/script&gt;
</code></pre>
<pre><code class="js">&lt;script&gt;
  //配置js路径
 seajs.config(&#123;
  alias:&#123;
   &quot;jquery&quot;:&quot;../examples-master/sea-modules/jquery/jquery/1.10.1/jquery.js&quot;
  &#125;
 &#125;);
  //加载模块
 seajs.use(&#39;../js/seajs/init&#39;,function($)&#123;
  $(&quot;#test_div&quot;).click(function()&#123;alert(1);&#125;);
 &#125;);
&lt;/script&gt;
</code></pre>
<p>代码如下:</p>
<pre><code class="js">//init.js
define(function(require,exports,module)&#123;
var $ = require(&#39;jquery&#39;);
return $;
&#125;);
</code></pre>
<p>Seajs就是如此简单，快来深入学习吧！</p>
<p><strong>由来：</strong></p>
<p>在软件开发过程中，模块化编程思想已经习以为常了，模块化编程不仅仅给开发团队带来效率方面上的好处，还能够让开发的项目或者产品维护成本大大降低。<br>那么，在WEB开发过程中JS脚本语言已经不可或缺了，通过JS脚本语言能够带来更加舒适的人机交互和用户体验。但是，JS脚本的使用过程中也会有出现引用依赖的混乱，那么JS脚本语言的模块化思想势必会得到大家广泛的认可，在这样的一个背景下，淘宝前端工程师玉伯带来了SeaJS脚本语言，让模块化编程思想进入到JS脚本的世界里。</p>
<p><strong>特点：</strong></p>
<p>SeaJS是一个遵循CommonJS规范的JavaScript模块加载框架，可以实现JavaScript的模块化开发及加载机制。与jQuery等JavaScript框架不同，SeaJS不会扩展封装语言特性，而只是实现JavaScript的模块化及按模块加载。SeaJS的主要目的是令JavaScript开发模块化并可以轻松愉悦进行加载，将前端工程师从繁重的JavaScript文件及对象依赖处理中解放出来，可以专注于代码本身的逻辑。SeaJS可以与jQuery这类框架完美集成。使用SeaJS可以提高JavaScript代码的可读性和清晰度，解决目前JavaScript编程中普遍存在的依赖关系混乱和代码纠缠等问题，方便代码的编写和维护。<br>SeaJS本身遵循KISS（Keep It Simple, Stupid）理念进行开发，其本身仅有个位数的API，因此学习起来毫无压力。在学习SeaJS的过程中，处处能感受到KISS原则的精髓——仅做一件事，做好一件事。</p>
<pre><code>11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>第一篇博客</title>
    <url>/2021/11/10/one/</url>
    <content><![CDATA[<h1 id="这是第一篇博客内容"><a href="#这是第一篇博客内容" class="headerlink" title="这是第一篇博客内容"></a>这是第一篇博客内容</h1><p>为什么会突然搭建一个自己博客呢？  好问题！<br>在  **B站 ** 上看到一个资深程序员的一篇博客内容: 说一个代码代码习惯良好的程序员都会有自己的博客<br>后来我信誓旦旦的开始了我的搭建之旅！<br>现在也是搭建完成了  因为一个项目，没有及时的发布一篇博客内容。<br>好了认识一个吧   我叫大路宽宽！</p>
]]></content>
  </entry>
  <entry>
    <title>vue-v-if与v-for为什么不建议一起用</title>
    <url>/2021/05/16/vue-v-if%E4%B8%8Ev-for%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AE%E4%B8%80%E8%B5%B7%E7%94%A8/</url>
    <content><![CDATA[<h2 id="一、作用"><a href="#一、作用" class="headerlink" title="一、作用"></a>一、作用</h2><p><code>v-if</code> 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 <code>true</code>值的时候被渲染</p>
<p><code>v-for</code> 指令基于一个数组来渲染一个列表。<code>v-for</code> 指令需要使用 <code>item in items</code> 形式的特殊语法，其中 <code>items</code> 是源数据数组或者对象，而 <code>item</code> 则是被迭代的数组元素的别名</p>
<p>在 <code>v-for</code> 的时候，建议设置<code>key</code>值，并且保证每个<code>key</code>值是独一无二的，这便于<code>diff</code>算法进行优化</p>
<p>两者在用法上</p>
<pre><code class="js">&lt;Modal v-if=&quot;isShow&quot; /&gt;

&lt;li v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;
    &#123;&#123; item.label &#125;&#125;
&lt;/li&gt;
</code></pre>
<h2 id="二、优先级"><a href="#二、优先级" class="headerlink" title="#二、优先级"></a><a href="https://vue3js.cn/interview/vue/if_for.html#%E4%BA%8C%E3%80%81%E4%BC%98%E5%85%88%E7%BA%A7">#</a>二、优先级</h2><p><code>v-if</code>与<code>v-for</code>都是<code>vue</code>模板系统中的指令</p>
<p>在<code>vue</code>模板编译的时候，会将指令系统转化成可执行的<code>render</code>函数</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="#示例"></a><a href="https://vue3js.cn/interview/vue/if_for.html#%E7%A4%BA%E4%BE%8B">#</a>示例</h3><p>编写一个<code>p</code>标签，同时使用<code>v-if</code>与 <code>v-for</code></p>
<pre><code class="html">&lt;div id=&quot;app&quot;&gt;
    &lt;p v-if=&quot;isShow&quot; v-for=&quot;item in items&quot;&gt;
        &#123;&#123; item.title &#125;&#125;
    &lt;/p&gt;
&lt;/div&gt;
</code></pre>
<p>创建<code>vue</code>实例，存放<code>isShow</code>与<code>items</code>数据</p>
<pre><code class="js">const app = new Vue(&#123;
  el: &quot;#app&quot;,
  data() &#123;
    return &#123;
      items: [
        &#123; title: &quot;foo&quot; &#125;,
        &#123; title: &quot;baz&quot; &#125;]
    &#125;
  &#125;,
  computed: &#123;
    isShow() &#123;
      return this.items &amp;&amp; this.items.length &gt; 0
    &#125;
  &#125;
&#125;)
</code></pre>
<p>模板指令的代码都会生成在<code>render</code>函数中，通过<code>app.$options.render</code>就能得到渲染函数</p>
<pre><code class="js">ƒ anonymous() &#123;
  with (this) &#123; return 
    _c(&#39;div&#39;, &#123; attrs: &#123; &quot;id&quot;: &quot;app&quot; &#125; &#125;, 
    _l((items), function (item) 
    &#123; return (isShow) ? _c(&#39;p&#39;, [_v(&quot;\n&quot; + _s(item.title) + &quot;\n&quot;)]) : _e() &#125;), 0) &#125;
&#125;
</code></pre>
<p><code>_l</code>是<code>vue</code>的列表渲染函数，函数内部都会进行一次<code>if</code>判断</p>
<p>初步得到结论：<code>v-for</code>优先级是比<code>v-if</code>高</p>
<p>再将<code>v-for</code>与<code>v-if</code>置于不同标签</p>
<pre><code class="html">&lt;div id=&quot;app&quot;&gt;
    &lt;template v-if=&quot;isShow&quot;&gt;
        &lt;p v-for=&quot;item in items&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;/p&gt;
    &lt;/template&gt;
&lt;/div&gt;
</code></pre>
<p>再输出下<code>render</code>函数</p>
<pre><code class="js">ƒ anonymous() &#123;
  with(this)&#123;return 
    _c(&#39;div&#39;,&#123;attrs:&#123;&quot;id&quot;:&quot;app&quot;&#125;&#125;,
    [(isShow)?[_v(&quot;\n&quot;),
    _l((items),function(item)&#123;return _c(&#39;p&#39;,[_v(_s(item.title))])&#125;)]:_e()],2)&#125;
&#125;
</code></pre>
<p>这时候我们可以看到，<code>v-for</code>与<code>v-if</code>作用在不同标签时候，是先进行判断，再进行列表的渲染</p>
<p>我们再在查看下<code>vue</code>源码</p>
<p>源码位置：<code>\vue-dev\src\compiler\codegen\index.js</code></p>
<pre><code class="js">export function genElement (el: ASTElement, state: CodegenState): string &#123;
  if (el.parent) &#123;
    el.pre = el.pre || el.parent.pre
  &#125;
  if (el.staticRoot &amp;&amp; !el.staticProcessed) &#123;
    return genStatic(el, state)
  &#125; else if (el.once &amp;&amp; !el.onceProcessed) &#123;
    return genOnce(el, state)
  &#125; else if (el.for &amp;&amp; !el.forProcessed) &#123;
    return genFor(el, state)
  &#125; else if (el.if &amp;&amp; !el.ifProcessed) &#123;
    return genIf(el, state)
  &#125; else if (el.tag === &#39;template&#39; &amp;&amp; !el.slotTarget &amp;&amp; !state.pre) &#123;
    return genChildren(el, state) || &#39;void 0&#39;
  &#125; else if (el.tag === &#39;slot&#39;) &#123;
    return genSlot(el, state)
  &#125; else &#123;
    // component or element
    ...
&#125;
</code></pre>
<p>在进行<code>if</code>判断的时候，<code>v-for</code>是比<code>v-if</code>先进行判断</p>
<p>最终结论：<code>v-for</code>优先级比<code>v-if</code>高</p>
<h2 id="三、注意事项"><a href="#三、注意事项" class="headerlink" title="#三、注意事项"></a><a href="https://vue3js.cn/interview/vue/if_for.html#%E4%B8%89%E3%80%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">#</a>三、注意事项</h2><ol>
<li>永远不要把 <code>v-if</code> 和 <code>v-for</code> 同时用在同一个元素上，带来性能方面的浪费（每次渲染都会先循环再进行条件判断）</li>
<li>如果避免出现这种情况，则在外层嵌套<code>template</code>（页面渲染不生成<code>dom</code>节点），在这一层进行v-if判断，然后在内部进行v-for循环</li>
</ol>
<pre><code class="js">&lt;template v-if=&quot;isShow&quot;&gt;
    &lt;p v-for=&quot;item in items&quot;&gt;
&lt;/template&gt;
</code></pre>
<ol>
<li>如果条件出现在循环内部，可通过计算属性<code>computed</code>提前过滤掉那些不需要显示的项</li>
</ol>
<pre><code class="js">computed: &#123;
    items: function() &#123;
      return this.list.filter(function (item) &#123;
        return item.isShow
      &#125;)
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-组件化</title>
    <url>/2020/06/10/vue-%E7%BB%84%E4%BB%B6%E5%8C%96/</url>
    <content><![CDATA[<h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><blockquote>
<p>vue组件系统提供了一种抽象，让我们可以使用独立可复用的组件来构建大型应用，任意类型的应用界 面都可以抽象为一个组件树。组件化能提高开发效率，方便重复使用，简化调试步骤，提升项目可维护 性，便于多人协同开发。</p>
</blockquote>
<p><img src="https://blog.poetries.top/img/static/images/20210313133919.png" alt="img"></p>
<h2 id="组件通信常用方式"><a href="#组件通信常用方式" class="headerlink" title="组件通信常用方式"></a>组件通信常用方式</h2><h3 id="1-props"><a href="#1-props" class="headerlink" title="1. props"></a><strong>1. props</strong></h3><blockquote>
<p>父给子传值</p>
</blockquote>
<pre><code>// child
props: &#123; msg: String &#125;
// parent
&lt;HelloWorld msg=&quot;Welcome to Your Vue.js App&quot;/&gt;
</code></pre>
<h3 id="2-自定义事件"><a href="#2-自定义事件" class="headerlink" title="2. 自定义事件"></a>2. 自定义事件</h3><blockquote>
<p>子给父传值</p>
</blockquote>
<pre><code>// child this.$emit(&#39;add&#39;, good)
// parent
&lt;Cart @add=&quot;cartAdd($event)&quot;&gt;&lt;/Cart&gt;
</code></pre>
<h3 id="3-事件总线"><a href="#3-事件总线" class="headerlink" title="3. 事件总线"></a>3. 事件总线</h3><blockquote>
<p>任意两个组件之间传值常用事件总线 或 vuex的方式。</p>
</blockquote>
<pre><code>  // Bus:事件派发、监听和回调管理 class Bus &#123;
constructor()&#123; this.callbacks = &#123;&#125;
  &#125;
  $on(name, fn)&#123;
this.callbacks[name] = this.callbacks[name] || []
this.callbacks[name].push(fn) &#125;
$emit(name, args)&#123; if(this.callbacks[name])&#123;
this.callbacks[name].forEach(cb =&gt; cb(args)) &#125;
&#125; &#125;
// main.js
Vue.prototype.$bus = new Bus()
// child1
this.$bus.$on(&#39;foo&#39;, handle) // child2 this.$bus.$emit(&#39;foo&#39;)
</code></pre>
<blockquote>
<p>实践中通常用Vue代替Bus，因为Vue已经实现了相应接口</p>
</blockquote>
<h3 id="4-vuex"><a href="#4-vuex" class="headerlink" title="4. vuex"></a><strong>4. vuex</strong></h3><blockquote>
<p>创建唯一的全局数据管理者store，通过它管理数据并通知组件状态变更。</p>
</blockquote>
<h3 id="5-parent-root"><a href="#5-parent-root" class="headerlink" title="5. $parent/$root"></a>5. <strong>$parent/$root</strong></h3><blockquote>
<p>兄弟组件之间通信可通过共同祖辈搭桥，<code>$parent</code>或<code>$root</code>。</p>
</blockquote>
<pre><code>// brother1
this.$parent.$on(&#39;foo&#39;, handle)
// brother2 
this.$parent.$emit(&#39;foo&#39;)
</code></pre>
<h3 id="6-children"><a href="#6-children" class="headerlink" title="6. $children"></a>6. <strong>$children</strong></h3><blockquote>
<p>父组件可以通过<code>$children</code>访问子组件实现父子通信。</p>
</blockquote>
<pre><code>// parent 
this.$children[0].xx = &#39;xxx&#39;
</code></pre>
<h3 id="7-attrs-listeners"><a href="#7-attrs-listeners" class="headerlink" title="7. $attrs/$listeners"></a>7. <strong>$attrs/$listeners</strong></h3><blockquote>
<p>包含了父作用域中不作为 <strong>prop</strong> 被识别 (且获取) 的特性绑定 ( class 和 style 除外)。当一个组件没有 声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外)，并且可以通过 <code>v- bind=&quot;$attrs&quot;</code> 传入内部组件——在创建高级别的组件时非常有用。</p>
</blockquote>
<pre><code>// child:并未在props中声明foo 
&lt;p&gt;&#123;&#123;$attrs.foo&#125;&#125;&lt;/p&gt;
// parent
&lt;HelloWorld foo=&quot;foo&quot;/&gt;
</code></pre>
<h3 id="8-refs"><a href="#8-refs" class="headerlink" title="8. refs"></a>8. <strong>refs</strong></h3><blockquote>
<p>获取子节点引用</p>
</blockquote>
<pre><code>// parent
&lt;HelloWorld ref=&quot;hw&quot;/&gt;
mounted() &#123; 
  this.$refs.hw.xx = &#39;xxx&#39;
&#125;
</code></pre>
<h3 id="9-provide-inject"><a href="#9-provide-inject" class="headerlink" title="9. provide/inject"></a>9. <strong>provide/inject</strong></h3><blockquote>
<p>能够实现祖先和后代之间传值</p>
</blockquote>
<pre><code>// ancestor
provide() &#123;
  return &#123;foo: &#39;foo&#39;&#125;
&#125;
// descendant
inject: [&#39;foo&#39;]
</code></pre>
<p>实例</p>
<pre><code>// index.vue
&lt;template&gt;
  &lt;div&gt;
    &lt;h2&gt;组件通信&lt;/h2&gt;
    &lt;!-- props, 自定义事件 --&gt;
    &lt;Child1 msg=&quot;some msg from parent&quot; @some-event=&quot;onSomeEvent&quot;&gt;&lt;/Child1&gt;
    &lt;!-- 事件总线 --&gt;
    &lt;Child2 msg=&quot;other msg&quot;&gt;&lt;/Child2&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  import Child1 from &#39;@/components/communication/Child1.vue&#39;
  import Child2 from &#39;@/components/communication/Child2.vue&#39;
  
  export default &#123;
    components: &#123;
      Child1, Child2,
      // Child3: () =&gt; import(&#39;./Child3.vue&#39;)
    &#125;,
    methods: &#123;
      onSomeEvent(msg) &#123;
        console.log(&#39;Communition:&#39;, msg);
      &#125;
    &#125;,
    mounted () &#123;
      // $children持有所有自定义组件
      // 它不保证顺序
      console.log(this.$children);
    &#125;,
  &#125;
&lt;/script&gt;

&lt;style scoped&gt;

&lt;/style&gt;
// child1.vue
&lt;template&gt;
  &lt;div @click=&quot;$emit(&#39;some-event&#39;, &#39;msg from child1&#39;)&quot;&gt;
    &lt;h3&gt;child1&lt;/h3&gt;
    &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  export default &#123;
    props: &#123;
      msg: &#123;
        type: String,
        default: &#39;&#39;
      &#125;,
    &#125;,
    mounted () &#123;
      // this.$bus.$on(&#39;event-from-child2&#39;, msg =&gt; &#123;
      //   console.log(&#39;Child1:&#39;, msg);
      // &#125;);
      this.$parent.$on(&#39;event-from-child2&#39;, msg =&gt; &#123;
        console.log(&#39;Child1:&#39;, msg);
      &#125;);
    &#125;,
  &#125;
&lt;/script&gt;

&lt;style scoped&gt;

&lt;/style&gt;
// child2.vue
&lt;template&gt;
  &lt;div&gt;
    &lt;!-- 展开$attrs对象 --&gt;
    &lt;h3 v-bind=&quot;$attrs&quot;&gt;child2&lt;/h3&gt;
    &lt;button @click=&quot;sendToChild1&quot;&gt;给child1发送消息&lt;/button&gt;
    &lt;!-- $attrs --&gt;
    &lt;p&gt;&#123;&#123;$attrs.msg&#125;&#125;&lt;/p&gt;
    &lt;!-- inject --&gt;
    &lt;p&gt;&#123;&#123;foo&#125;&#125;&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  export default &#123;
    inheritAttrs: false,
    inject: [&#39;foo&#39;],
    methods: &#123;
      sendToChild1() &#123;
        // 利用事件总线发送事件
        // this.$bus.$emit(&#39;event-from-child2&#39;, &#39;some msg from child2&#39;)
        this.$parent.$emit(&#39;event-from-child2&#39;, &#39;some msg from child2&#39;)
      &#125;
    &#125;,
  &#125;
&lt;/script&gt;

&lt;style scoped&gt;

&lt;/style&gt;
</code></pre>
<h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><blockquote>
<p>插槽语法是Vue 实现的内容分发 API，用于复合组件开发。该技术在通用组件库开发中有大量应用</p>
</blockquote>
<h3 id="1-匿名插槽"><a href="#1-匿名插槽" class="headerlink" title="1. 匿名插槽"></a>1. 匿名插槽</h3><pre><code>// comp1
&lt;div&gt;
  &lt;slot&gt;&lt;/slot&gt;
&lt;/div&gt;
// parent
&lt;comp&gt;hello&lt;/comp&gt;
</code></pre>
<h3 id="2-具名插槽"><a href="#2-具名插槽" class="headerlink" title="2. 具名插槽"></a>2. 具名插槽</h3><blockquote>
<p>将内容分发到子组件指定位置</p>
</blockquote>
<pre><code>// comp2
&lt;div&gt;
&lt;slot&gt;&lt;/slot&gt;
&lt;slot name=&quot;content&quot;&gt;&lt;/slot&gt;
&lt;/div&gt;
// parent
&lt;Comp2&gt;
&lt;!-- 默认插槽用default做参数 --&gt;
&lt;template v-slot:default&gt;具名插槽&lt;/template&gt; &lt;!-- 具名插槽用插槽名做参数 --&gt;
&lt;template v-slot:content&gt;内容...&lt;/template&gt;
&lt;/Comp2&gt;
</code></pre>
<h3 id="3-作用域插槽"><a href="#3-作用域插槽" class="headerlink" title="3. 作用域插槽"></a>3. 作用域插槽</h3><blockquote>
<p>分发内容要用到子组件中的数据</p>
</blockquote>
<pre><code>// comp3
&lt;div&gt;
&lt;slot :foo=&quot;foo&quot;&gt;&lt;/slot&gt;
&lt;/div&gt;
// parent
&lt;Comp3&gt;
&lt;!-- 把v-slot的值指定为作用域上下文对象 --&gt; &lt;template v-slot:default=&quot;slotProps&quot;&gt; 来自子组件数据:&#123;&#123;slotProps.foo&#125;&#125; &lt;/template&gt;
&lt;/Comp3&gt;
</code></pre>
<p>范例</p>
<pre><code>// 子组件 Layout.vue
&lt;template&gt;
  &lt;div&gt;
    &lt;div class=&quot;header&quot;&gt;
      &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;
    &lt;/div&gt;
    &lt;div class=&quot;body&quot;&gt;
      &lt;slot&gt;&lt;/slot&gt;
    &lt;/div&gt;
    &lt;div class=&quot;footer&quot;&gt;
      &lt;slot name=&quot;footer&quot; :fc=&quot;footerContent&quot;&gt;&lt;/slot&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  export default &#123;
    data() &#123;
      return &#123;
        remark: [
          &#39;好好学习，天天向上&#39;,
          &#39;学习永远不晚&#39;,
          &#39;学习知识要善于思考,思考,再思考&#39;,
          &#39;学习的敌人是自己的满足,要认真学习一点东西,必须从不自满开始&#39;,
          &#39;构成我们学习最大障碍的是已知的东西,而不是未知的东西&#39;,
          &#39;在今天和明天之间,有一段很长的时间;趁你还有精神的时候,学习迅速办事&#39;,
          &#39;三人行必有我师焉；择其善者而从之，其不善者而改之&#39;
        ]
      &#125;
    &#125;,
    computed: &#123;
      footerContent() &#123;
        return this.remark[new Date().getDay() - 1] 
      &#125;
    &#125;,
  &#125;
&lt;/script&gt;

&lt;style scoped&gt;
.header &#123;
  background-color: rgb(252, 175, 175);
&#125;
.body &#123;
  display: flex;
  background-color: rgb(144, 250, 134);
  min-height: 100px;
  align-items: center;
  justify-content: center;
&#125;
.footer &#123;
  background-color: rgb(114, 116, 255);
&#125;
&lt;/style&gt;
//父组件 index.vue
&lt;template&gt;
  &lt;div&gt;
    &lt;h2&gt;插槽&lt;/h2&gt;
    &lt;!-- 插槽 --&gt;
    &lt;Layout&gt;
      &lt;!-- 具名插槽 --&gt;
      &lt;template v-slot:header&gt;全栈工程师&lt;/template&gt;
      &lt;!-- 匿名插槽 --&gt;
      &lt;template&gt;content...&lt;/template&gt;
      &lt;!-- 作用域插槽 --&gt;
      &lt;template v-slot:footer=&quot;&#123;fc&#125;&quot;&gt;&#123;&#123;fc&#125;&#125;&lt;/template&gt;
    &lt;/Layout&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  import Layout from &#39;@/components/slots/Layout.vue&#39;
  
  export default &#123;
    components: &#123;
      Layout
    &#125;,
  &#125;
&lt;/script&gt;

&lt;style scoped&gt;

&lt;/style&gt;
</code></pre>
<h2 id="组件化实战"><a href="#组件化实战" class="headerlink" title="组件化实战"></a>组件化实战</h2><h3 id="通用表单组件"><a href="#通用表单组件" class="headerlink" title="通用表单组件"></a>通用表单组件</h3><blockquote>
<p>收集数据、校验数据并提交。</p>
</blockquote>
<ul>
<li>实现KForm 指定数据、校验规则</li>
<li>KformItem<ul>
<li>label标签添加</li>
<li>执行校验</li>
<li>显示错误信息</li>
</ul>
</li>
<li>KInput<ul>
<li>维护数据</li>
</ul>
</li>
</ul>
<pre><code>&lt;template&gt;
  &lt;el-form :model=&quot;userInfo&quot; :rules=&quot;rules&quot; ref=&quot;loginForm&quot;&gt;
    &lt;el-form-item label=&quot;用户名&quot; prop=&quot;name&quot;&gt;
      &lt;el-input v-model=&quot;userInfo.name&quot;&gt;&lt;/el-input&gt;
    &lt;/el-form-item&gt;
    &lt;el-form-item label=&quot;密码&quot; prop=&quot;password&quot;&gt;
      &lt;el-input v-model=&quot;userInfo.password&quot; type=&quot;password&quot;&gt;&lt;/el-input&gt;
    &lt;/el-form-item&gt;
    &lt;el-form-item&gt;
      &lt;el-button @click=&quot;login&quot;&gt;登录&lt;/el-button&gt;
    &lt;/el-form-item&gt;
  &lt;/el-form&gt;
&lt;/template&gt;

&lt;script&gt;
export default &#123;
  data() &#123;
    return &#123;
      userInfo: &#123;
        username: &quot;&quot;,
        password: &quot;&quot;
      &#125;,
      rules: &#123;
        username: [&#123; required: true, message: &quot;请输入用户名称&quot; &#125;],
        password: [&#123; required: true, message: &quot;请输入密码&quot; &#125;]
      &#125;
    &#125;;
  &#125;,
  methods: &#123;
    login() &#123;
      this.$refs[&quot;loginForm&quot;].validate(valid =&gt; &#123;
        if (valid) &#123;
          alert(&quot;submit&quot;);
        &#125; else &#123;
          console.log(&quot;error submit!&quot;);
          return false;
        &#125;
      &#125;);
    &#125;
  &#125;
&#125;;
&lt;/script&gt;

&lt;style scoped&gt;
&lt;/style&gt;
</code></pre>
<p><strong>1.</strong> KInput</p>
<pre><code>// 创建components/form/KInput.vue
&lt;template&gt;
  &lt;div&gt;
    &lt;!-- 管理数据：实现双绑 --&gt;
    &lt;!-- :value, @input --&gt;
    &lt;input :type=&quot;type&quot; :value=&quot;value&quot; @input=&quot;onInput&quot;
      v-bind=&quot;$attrs&quot;&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  export default &#123;
    inheritAttrs: false , // 关闭特性继承
    props: &#123;
      value: &#123;
        type: String,
        default: &#39;&#39;
      &#125;,
      type: &#123;
        type: String,
        default: &#39;text&#39;
      &#125;
    &#125;,
    methods: &#123;
      onInput(e) &#123;
        this.$emit(&#39;input&#39;, e.target.value)

        // 值发生变化的时候就是需要校验的时候
        this.$parent.$emit(&#39;validate&#39;)
      &#125;
    &#125;,
  &#125;
&lt;/script&gt;

&lt;style scoped&gt;

&lt;/style&gt;
</code></pre>
<ol>
<li>使用<strong>KInput</strong></li>
</ol>
<p>创建components/form/index.vue，添加如下代码:</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
&lt;h3&gt;KForm表单&lt;/h3&gt;
&lt;hr&gt;
&lt;k-input v-model=&quot;model.username&quot;&gt;&lt;/k-input&gt;
&lt;k-input type=&quot;password&quot; v-model=&quot;model.password&quot;&gt;&lt;/k-input&gt;
  &lt;/div&gt;
&lt;/template&gt;
export default &#123;
  components: &#123;
  KInput
&#125;, 
  data() &#123;
   return &#123;
      model: &#123; username: &quot;tom&quot;, password: &quot;&quot; &#125;,
    &#125;; 
  &#125;
&#125;;
&lt;/script&gt;
</code></pre>
<ol>
<li>实现<strong>KFormItem</strong></li>
</ol>
<p>创建components/form/KFormItem.vue</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;!-- label标签 --&gt;
    &lt;label v-if=&quot;label&quot;&gt;&#123;&#123;label&#125;&#125;&lt;/label&gt;
    &lt;!-- 容器，放插槽 --&gt;
    &lt;slot&gt;&lt;/slot&gt;
    &lt;!-- 错误信息展示 --&gt;
    &lt;p v-if=&quot;error&quot; class=&quot;error&quot;&gt;&#123;&#123;error&#125;&#125;&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  import Schema from &#39;async-validator&#39;

  export default &#123;
    inject: [&#39;form&#39;],
    data() &#123;
      return &#123;
        error: &#39;&#39;
      &#125;
    &#125;,
    props: &#123;
      label: &#123;
        type: String,
        default: &#39;&#39;
      &#125;,
      prop: &#123;
        type: String,
        default: &#39;&#39;
      &#125;
    &#125;,
    mounted () &#123;
      // 监听校验事件
      this.$on(&#39;validate&#39;, () =&gt; &#123;
        this.validate()
      &#125;)
    &#125;,
    methods: &#123;
      validate() &#123;
        // 执行校验
        // 1.获取值和校验规则
        const rules = this.form.rules[this.prop]
        const value = this.form.model[this.prop]

        // 2.执行校验：使用官方也使用的async-validator
        // 创建描述对象
        const descriptor = &#123;[this.prop]:rules&#125;
        // 创建校验器
        const validator = new Schema(descriptor)
        // 执行校验
        return validator.validate(&#123;[this.prop]:value&#125;, errors =&gt; &#123;
          // 如果errors存在，则说明校验失败
          if (errors) &#123;
            this.error = errors[0].message
          &#125; else &#123;
            this.error = &#39;&#39;
          &#125;
        &#125;)
      &#125;
    &#125;,
  &#125;
&lt;/script&gt;

&lt;style scoped&gt;
.error&#123;
  color: red
&#125;
&lt;/style&gt;
</code></pre>
<ol>
<li>使用<strong>KFormItem</strong></li>
</ol>
<p>components/form/index.vue，添加基础代码:</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
&lt;h3&gt;KForm表单&lt;/h3&gt;
&lt;hr&gt;
&lt;k-form-item label=&quot;用户名&quot; prop=&quot;username&quot;&gt;
&lt;k-input v-model=&quot;model.username&quot;&gt;&lt;/k-input&gt; &lt;/k-form-item&gt;
&lt;k-form-item label=&quot;确认密码&quot; prop=&quot;password&quot;&gt;
&lt;k-input type=&quot;password&quot; v-model=&quot;model.password&quot;&gt;&lt;/k-input&gt;
&lt;/k-form-item&gt; &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<ol>
<li>实现<strong>KForm</strong></li>
</ol>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;!-- 容器：存放所有表单项 --&gt;
    &lt;!-- 存储值载体：保存大家数据和校验规则 --&gt;
    &lt;slot&gt;&lt;/slot&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
// 我们平时写的组件是一个组件配置对象
export default &#123;
  provide() &#123;
    return &#123;
      // 直接把当前组件实例传递下去
      // 传递下去的对象是响应式的则还可以响应式
      form: this
    &#125;;
  &#125;,
  props: &#123;
    // 数据模型
    model: &#123;
      type: Object,
      required: true
    &#125;,
    rules: Object
  &#125;,
  methods: &#123;
    validate(cb) &#123;
      // 遍历肚子里面的所有FormItem，执行他们的validate方法
      // 全部通过才算通过
      // tasks是校验结果的Promise组成的数组
      const tasks = this.$children
        .filter(item =&gt; item.prop)
        .map(item =&gt; item.validate());
      // 统一判断
      Promise.all(tasks)
        .then(() =&gt; cb(true))
        .catch(() =&gt; cb(false));
    &#125;
  &#125;
&#125;;
&lt;/script&gt;

&lt;style scoped&gt;
&lt;/style&gt;
</code></pre>
<ol>
<li>使用<strong>KForm</strong></li>
</ol>
<p>components/form/index.vue，添加基础代码:</p>
<pre><code>&lt; template &gt; &lt;div &gt; &lt;h3 &gt; KForm表单 &lt; /h3&gt;
&lt;hr&gt;
&lt;k-form :model=&quot;model&quot; :rules=&quot;rules&quot; ref=&quot;loginForm&quot;&gt;
...
&lt;/k - form &gt; &lt;/div&gt;
&lt;/template &gt; &lt;script &gt; import KForm from &quot;./KForm&quot;;
export default &#123;
        components:
        &#123;
            KForm,
        &#125;,
        data() &#123;
            return &#123;
                rules: &#123;
                    username: [&#123;
                        required: true,
                        message: &quot;请输入用户名&quot;
                    &#125;],
                    password: [&#123;
                        required: true,
                        message: &quot;请输入密码&quot;
                    &#125;]
                &#125;
            &#125;;
        &#125;,
        methods: &#123;
            submitForm() &#123;
                this.$refs[&#39;loginForm&#39;].validate(valid = &gt;&#123;
                    if (valid) &#123;
                        alert(&quot;请求登录!&quot;);
                    &#125; else &#123;
                        alert(&quot;校验失败!&quot;);
                    &#125;
                &#125;);
            &#125;
        &#125;
    &#125;; &lt; /script&gt;/
</code></pre>
<ol>
<li>数据校验</li>
</ol>
<p>Input通知校验</p>
<pre><code>onInput(e) &#123; // ...
    // $parent指FormItem
    this.$parent.$emit(&#39;validate&#39;);
&#125;
</code></pre>
<p>FormItem监听校验通知，获取规则并执行校验</p>
<pre><code>inject: [&#39;form&#39;],
// 注入 mounted()&#123;// 监听校验事件
this.$on(&#39;validate&#39;, () = &gt;&#123;
    this.validate()
&#125;)
&#125;,
methods: &#123;
    validate() &#123;
        // 获取对应FormItem校验规则 console.log(this.form.rules[this.prop]);
    &#125;
&#125;,
import Schema from &quot;async-validator&quot;;

validate() &#123;
    // 获取对应FormItem校验规则
    const rules = this.form.rules[this.prop];
    // 获取校验值
    const value = this.form.model[this.prop];
    // 校验
    const schema = new Schema(descriptor);
    // 返回Promise，没有触发catch就说明验证通过
    return schema.validate(&#123; [this.prop] : value
    &#125;,
    errors = &gt;&#123;
        if (errors) &#123;
            // 将错误信息显示
            this.error = errors[0].message;
        &#125; else &#123;
            // 校验通过 this.error = &quot;&quot;;
        &#125;
    &#125;);
&#125;
</code></pre>
<p>表单全局验证，为<code>Form</code>提供<code>validate</code>方法</p>
<pre><code>validate(cb) &#123;
    // 调用所有含有prop属性的子组件的validate方法并得到Promise数组 const tasks = this.$children
    .filter(item = &gt;item.prop).map(item = &gt;item.validate());
    // 所有任务必须全部成功才算校验通过，任一失败则校验失败
    Promise.all(tasks).then(() = &gt;cb(true)).catch(() = &gt;cb(false))
&#125;
</code></pre>
<h3 id="实现弹窗组件"><a href="#实现弹窗组件" class="headerlink" title="实现弹窗组件"></a>实现弹窗组件</h3><blockquote>
<p>弹窗这类组件的特点是它们在当前<strong>vue</strong>实例之外独立存在，通常挂载于body;它们是通过JS动态创建的，不需要在任何组件中声明。常⻅使用姿势</p>
</blockquote>
<pre><code>this.$create(Notice, &#123;
    title: &#39;喊你来搬砖&#39;,
    message: &#39;提示信息&#39;,
    duration: 1000
&#125;).show();
</code></pre>
<p>create函数</p>
<pre><code>import Vue from &quot;vue&quot;;
// 创建函数接收要创建组件定义
function create(Component, props) &#123;
    // 创建一个Vue新实例 const vm = new Vue(&#123;
    render(h) &#123;
        // render函数将传入组件配置对象转换为虚拟dom console.log(h(Component, &#123; props &#125;)); return h(Component, &#123; props &#125;);
    &#125;
&#125;).$mount(); //执行挂载函数，但未指定挂载目标，表示只执行初始化工作

  // 将生成dom元素追加至
  body document.body.appendChild(vm.$el);

  // 给组件实例添加销毁方法
  const comp = vm.$children[0];
  comp.remove = () = &gt;&#123;
      document.body.removeChild(vm.$el);
      vm.$destroy();
  &#125;;
  return comp;
&#125;
// 暴露调用接口
export default create
</code></pre>
<blockquote>
<p>另一种创建组件实例的方式: <code>Vue.extend(Component)</code></p>
</blockquote>
<pre><code>const Ctor = Vue.extend(Component) 
const comp = new Ctor(&#123;
    propsData: props
&#125;) 
comp.$mount();

document.body.appendChild(comp.$el) 

comp.remove = () = &gt;&#123;
    // 移除dom document.body.removeChild(comp.$el) // 销毁组件
    comp.$destroy();
&#125;
</code></pre>
<h3 id="通知组件"><a href="#通知组件" class="headerlink" title="通知组件"></a>通知组件</h3><p>建通知组件，Notice.vue</p>
<pre><code>&lt;template&gt;
  &lt;div class=&quot;box&quot; v-if=&quot;isShow&quot;&gt;
    &lt;h3&gt;&#123;&#123;title&#125;&#125;&lt;/h3&gt;
    &lt;p class=&quot;box-content&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default &#123;
  props: &#123;
    title: &#123;
      type: String,
      default: &quot;&quot;
    &#125;,
    message: &#123;
      type: String,
      default: &quot;&quot;
    &#125;,
    duration: &#123;
      type: Number,
      default: 2000
    &#125;
  &#125;,
  data() &#123;
    return &#123;
      isShow: false
    &#125;;
  &#125;,
  methods: &#123;
    show() &#123;
      this.isShow = true;
      setTimeout(this.hide, this.duration);
    &#125;,
    hide() &#123;
      this.isShow = false;
      this.remove();
    &#125;
  &#125;
&#125;;
&lt;/script&gt;

&lt;style&gt;
.box &#123;
  position: fixed;
  width: 100%;
  top: 16px;
  left: 0;
  text-align: center;
  pointer-events: none;
  background-color: #fff;
  border: grey 3px solid;
  box-sizing: border-box;
&#125;
.box-content &#123;
  width: 200px;
  margin: 10px auto;
  font-size: 14px;  
  padding: 8px 16px;
  background: #fff;
  border-radius: 3px;
  margin-bottom: 8px;
&#125;
&lt;/style&gt;
</code></pre>
<blockquote>
<p>使用插件进一步封装便于使用，<code>create.js</code></p>
</blockquote>
<pre><code>import Notice from &#39;@/components/Notice.vue&#39; //...
export default &#123;
  install(Vue) &#123;
      Vue.prototype.$notice = function(options) &#123;
          return create(Notice, options)
      &#125;
  &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>原理</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-v-if与v-show的区别</title>
    <url>/2021/05/12/vue-v-if%E4%B8%8Ev-show%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="一、v-show与v-if的共同点"><a href="#一、v-show与v-if的共同点" class="headerlink" title="一、v-show与v-if的共同点"></a>一、v-show与v-if的共同点</h2><p>我们都知道在 <code>vue</code> 中 <code>v-show</code> 与 <code>v-if</code> 的作用效果是相同的(不含v-else)，都能控制元素在页面是否显示</p>
<p>在用法上也是相同的</p>
<pre><code class="js">&lt;Model v-show=&quot;isShow&quot; /&gt;
&lt;Model v-if=&quot;isShow&quot; /&gt;
</code></pre>
<ul>
<li>当表达式为<code>true</code>的时候，都会占据页面的位置</li>
<li>当表达式都为<code>false</code>时，都不会占据页面位置</li>
</ul>
<h2 id="二、v-show与v-if的区别"><a href="#二、v-show与v-if的区别" class="headerlink" title="#二、v-show与v-if的区别"></a><a href="https://vue3js.cn/interview/vue/show_if.html#%E4%BA%8C%E3%80%81v-show%E4%B8%8Ev-if%E7%9A%84%E5%8C%BA%E5%88%AB">#</a>二、v-show与v-if的区别</h2><ul>
<li>控制手段不同</li>
<li>编译过程不同</li>
<li>编译条件不同</li>
</ul>
<p>控制手段：<code>v-show</code>隐藏则是为该元素添加<code>css--display:none</code>，<code>dom</code>元素依旧还在。<code>v-if</code>显示隐藏是将<code>dom</code>元素整个添加或删除</p>
<p>编译过程：<code>v-if</code>切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；<code>v-show</code>只是简单的基于css切换</p>
<p>编译条件：<code>v-if</code>是真正的条件渲染，它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。只有渲染条件为假时，并不做操作，直到为真才渲染</p>
<ul>
<li><code>v-show</code> 由<code>false</code>变为<code>true</code>的时候不会触发组件的生命周期</li>
<li><code>v-if</code>由<code>false</code>变为<code>true</code>的时候，触发组件的<code>beforeCreate</code>、<code>create</code>、<code>beforeMount</code>、<code>mounted</code>钩子，由<code>true</code>变为<code>false</code>的时候触发组件的<code>beforeDestory</code>、<code>destoryed</code>方法</li>
</ul>
<p>性能消耗：<code>v-if</code>有更高的切换消耗；<code>v-show</code>有更高的初始渲染消耗；</p>
<h2 id="三、v-show与v-if原理分析"><a href="#三、v-show与v-if原理分析" class="headerlink" title="#三、v-show与v-if原理分析"></a><a href="https://vue3js.cn/interview/vue/show_if.html#%E4%B8%89%E3%80%81v-show%E4%B8%8Ev-if%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90">#</a>三、v-show与v-if原理分析</h2><p>具体解析流程这里不展开讲，大致流程如下</p>
<ul>
<li>将模板<code>template</code>转为<code>ast</code>结构的<code>JS</code>对象</li>
<li>用<code>ast</code>得到的<code>JS</code>对象拼装<code>render</code>和<code>staticRenderFns</code>函数</li>
<li><code>render</code>和<code>staticRenderFns</code>函数被调用后生成虚拟<code>VNODE</code>节点，该节点包含创建<code>DOM</code>节点所需信息</li>
<li><code>vm.patch</code>函数通过虚拟<code>DOM</code>算法利用<code>VNODE</code>节点创建真实<code>DOM</code>节点</li>
</ul>
<h3 id="v-show原理"><a href="#v-show原理" class="headerlink" title="#v-show原理"></a><a href="https://vue3js.cn/interview/vue/show_if.html#v-show%E5%8E%9F%E7%90%86">#</a>v-show原理</h3><p>不管初始条件是什么，元素总是会被渲染</p>
<p>我们看一下在<code>vue</code>中是如何实现的</p>
<p>代码很好理解，有<code>transition</code>就执行<code>transition</code>，没有就直接设置<code>display</code>属性</p>
<pre><code class="js">// https://github.com/vuejs/vue-next/blob/3cd30c5245da0733f9eb6f29d220f39c46518162/packages/runtime-dom/src/directives/vShow.ts
export const vShow: ObjectDirective&lt;VShowElement&gt; = &#123;
  beforeMount(el, &#123; value &#125;, &#123; transition &#125;) &#123;
    el._vod = el.style.display === &#39;none&#39; ? &#39;&#39; : el.style.display
    if (transition &amp;&amp; value) &#123;
      transition.beforeEnter(el)
    &#125; else &#123;
      setDisplay(el, value)
    &#125;
  &#125;,
  mounted(el, &#123; value &#125;, &#123; transition &#125;) &#123;
    if (transition &amp;&amp; value) &#123;
      transition.enter(el)
    &#125;
  &#125;,
  updated(el, &#123; value, oldValue &#125;, &#123; transition &#125;) &#123;
    // ...
  &#125;,
  beforeUnmount(el, &#123; value &#125;) &#123;
    setDisplay(el, value)
  &#125;
&#125;
</code></pre>
<h3 id="v-if原理"><a href="#v-if原理" class="headerlink" title="#v-if原理"></a><a href="https://vue3js.cn/interview/vue/show_if.html#v-if%E5%8E%9F%E7%90%86">#</a>v-if原理</h3><p><code>v-if</code>在实现上比<code>v-show</code>要复杂的多，因为还有<code>else</code> <code>else-if</code> 等条件需要处理，这里我们也只摘抄源码中处理 <code>v-if</code> 的一小部分</p>
<p>返回一个<code>node</code>节点，<code>render</code>函数通过表达式的值来决定是否生成<code>DOM</code></p>
<pre><code class="js">// https://github.com/vuejs/vue-next/blob/cdc9f336fd/packages/compiler-core/src/transforms/vIf.ts
export const transformIf = createStructuralDirectiveTransform(
  /^(if|else|else-if)$/,
  (node, dir, context) =&gt; &#123;
    return processIf(node, dir, context, (ifNode, branch, isRoot) =&gt; &#123;
      // ...
      return () =&gt; &#123;
        if (isRoot) &#123;
          ifNode.codegenNode = createCodegenNodeForBranch(
            branch,
            key,
            context
          ) as IfConditionalExpression
        &#125; else &#123;
          // attach this branch&#39;s codegen node to the v-if root.
          const parentCondition = getParentCondition(ifNode.codegenNode!)
          parentCondition.alternate = createCodegenNodeForBranch(
            branch,
            key + ifNode.branches.length - 1,
            context
          )
        &#125;
      &#125;
    &#125;)
  &#125;
)
</code></pre>
<h2 id="四、v-show与v-if的使用场景"><a href="#四、v-show与v-if的使用场景" class="headerlink" title="#四、v-show与v-if的使用场景"></a><a href="https://vue3js.cn/interview/vue/show_if.html#%E5%9B%9B%E3%80%81v-show%E4%B8%8Ev-if%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">#</a>四、v-show与v-if的使用场景</h2><p><code>v-if</code> 与 <code>v-show</code> 都能控制<code>dom</code>元素在页面的显示</p>
<p><code>v-if</code> 相比 <code>v-show</code> 开销更大的（直接操作<code>dom</code>节点增加与删除）</p>
<p>如果需要非常频繁地切换，则使用 v-show 较好</p>
<p>如果在运行时条件很少改变，则使用 v-if 较好</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-事件</title>
    <url>/2021/03/06/vue-%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="一、方法传参"><a href="#一、方法传参" class="headerlink" title="一、方法传参"></a>一、方法传参</h2><pre><code>&lt;div id=&quot;test&quot;&gt;
    &lt;button @click=&quot;sayHi(&#39;你好&#39;)&quot;&gt;说你好&lt;/button&gt; &lt;!--这里使用@--&gt;
    &lt;button @click=&quot;sayHi(&#39;我被点击了&#39;)&quot;&gt;说我被点击了&lt;/button&gt; &lt;!--这里使用@--&gt;
&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    var myVue = new Vue(&#123;
        el: &#39;#test&#39;,
        methods: &#123;      //这里使用methods
            sayHi: function (message) &#123;
                alert(message)
            &#125;
        &#125;
    &#125;)
&lt;/script&gt;
</code></pre>
<h2 id="二、vue访问原生-DOM-事件"><a href="#二、vue访问原生-DOM-事件" class="headerlink" title="二、vue访问原生 DOM 事件"></a>二、vue访问原生 DOM 事件</h2><blockquote>
<p>用<code>$event</code>获取</p>
</blockquote>
<pre><code>&lt;button @click=&quot;changeColor(&#39;你好&#39;,$event)&quot;&gt;点击我&lt;/button&gt; &lt;!--这里使用@--&gt;
&lt;div style=&quot;height: 100px;width: 100px;background-color: red;&quot; @mouseover=&quot;over(&#39;鼠标从我上面滑过&#39;,$event)&quot;&gt;
    鼠标从我上面滑过试试
&lt;/div&gt;
           
            
&lt;script type=&quot;text/javascript&quot;&gt;
    var myVue = new Vue(&#123;
        el: &#39;#test&#39;,
        methods: &#123;      //这里使用methods
            changeColor: function (message, event) &#123;
                alert(message+event);    //弹出我被点击了,事件是[object MouseEvent]
            &#125;,
            over :function (message, event) &#123;
                alert(message+event);   //弹出鼠标从我上面滑过,事件是[object MouseEvent]
            &#125;
        &#125;
    &#125;)
&lt;/script&gt;
</code></pre>
<h2 id="三、事件修饰符"><a href="#三、事件修饰符" class="headerlink" title="三、事件修饰符"></a>三、事件修饰符</h2><blockquote>
<p>事件修饰符有基本的6种</p>
</blockquote>
<p><strong>.stop阻止事件冒泡</strong></p>
<pre><code>&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;
</code></pre>
<p><strong>.prevent阻止默认事件</strong></p>
<pre><code>&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;
</code></pre>
<p><strong>.capture时间捕获（从上到下）</strong></p>
<pre><code>&lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;
</code></pre>
<p><strong>.self只在元素自身回调</strong></p>
<pre><code>&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;
</code></pre>
<p><strong>.once只触发一次</strong></p>
<pre><code>&lt;a v-on:click.once=&quot;doThis&quot;&gt;&lt;/a&gt;
</code></pre>
<blockquote>
<p>使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 [<code>@click.prevent.self](mailto:</code>@click.prevent.self)<code>会阻止所有的点击，而</code>@click.self.prevent` 只会阻止元素上的点击</p>
</blockquote>
<h2 id="四、键值修饰符"><a href="#四、键值修饰符" class="headerlink" title="四、键值修饰符"></a>四、键值修饰符</h2><blockquote>
<p>在监听键盘事件时，我们经常需要监测常见的键值。 Vue 允许为 v-on 在监听键盘事件时添加关键修饰符</p>
</blockquote>
<pre><code>&lt;div id=&quot;app&quot;&gt;
    &#123;&#123;msg&#125;&#125;
    &lt;input type=&quot;text&quot; v-on:keydown=&quot;ke&quot;/&gt;
&lt;/div&gt;
&lt;script&gt;
var app = new Vue(&#123;
        el:&quot;#app&quot;,
        data:&#123;
            msg:&quot;事件处理&quot;,
            counter:0
        &#125;,
        methods:&#123;
            ke:function(e)&#123;
                if(e.keyCode == 13)&#123;
                    this.msg = e.target.value;
                    e.target.value = &quot;&quot;;
                &#125;
            &#125;
        &#125;
&#125;);
&lt;/script&gt;
</code></pre>
<ul>
<li><code>enter</code>(回车)</li>
<li><code>tab</code>（tab切换）</li>
<li><code>delete</code> (捕获 “删除” 和 “退格” 键)</li>
<li><code>esc</code>（esc键）</li>
<li><code>space</code>（退档键）</li>
<li><code>up</code>（上键）</li>
<li><code>down</code>（下键）</li>
<li><code>left</code>（左键）</li>
<li><code>right</code>（右键）</li>
</ul>
<blockquote>
<p>我们也可以通过全局<code>config.keyCodes</code> 对象自定义键值修饰符别名</p>
</blockquote>
<pre><code>Vue.config.keyCodes.f1 = 112
</code></pre>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>scikit-learn</title>
    <url>/2022/01/15/scikit-learn/</url>
    <content><![CDATA[<h1 id="第一章-scikit-learn初级"><a href="#第一章-scikit-learn初级" class="headerlink" title="第一章 scikit-learn初级"></a>第一章 scikit-learn初级</h1><p>课程介绍：本阶段课程学习人工智能机器学习入门算法以及opencv人脸识别基础。机器学习方向主要通过Scikit-learn模块来学习。人脸识别基础主要通过opencv来实现与了解。</p>
<h1 id="scikit-learn"><a href="#scikit-learn" class="headerlink" title="scikit-learn"></a>scikit-learn</h1><p>英文官网：<a href="https://scikit-learn.org/stable/index.html">https://scikit-learn.org/stable/index.html</a></p>
<p>中文官网：<a href="https://sklearn.apachecn.org/#/">https://sklearn.apachecn.org/#/</a></p>
<p>官网：<a href="https://scikit-learn.org/stable/index.html">https://scikit-learn.org/stable/index.html</a></p>
<h2 id="1-1-Scikit-Learn简介"><a href="#1-1-Scikit-Learn简介" class="headerlink" title="1.1 Scikit-Learn简介"></a>1.1 Scikit-Learn简介</h2><p>Scikit-Learn（简称Sklearn）是Python的第三方模块，它是机器学习领域中知名的Python模块之一，它对常用的机器学习算法进行了封装，包括回归（Regression）、降维（Dimensionality Reduction）、分类（Classification）和聚类（Clustering）四大机器学习算法。Scikit-Learn具有以下特点。　</p>
<p>简单高效的数据挖掘和数据分析工具。　</p>
<p>让每个人能够在复杂环境中重复使用。　</p>
<p>Scikit-Learn是Scipy模块的扩展，是建立在NumPy和Matplotlib模块的基础上的。利用这几大模块的优势，可以大大提高机器学习的效率。　</p>
<p>开源，采用BSD协议，可用于商业。</p>
<h2 id="1-2安装Scikit-Learn"><a href="#1-2安装Scikit-Learn" class="headerlink" title="1.2安装Scikit-Learn"></a>1.2安装Scikit-Learn</h2><p>Scikit-Learn安装要求如下。　</p>
<p>Python版本：高于2.7。　</p>
<p>NumPy版本：高于1.10.2。　</p>
<p>SciPy版本：高于0.13.3。</p>
<p>如果已经安装NumPy和Scipy，那么安装Scikit-Learn最简单的方法是使用pip工具安装。命令如下：</p>
<p>pip install -U scikit-learn<br>或者使用conda，命令如下：</p>
<p>conda install scikit-learn<br>还可以在PyCharm开发环境中安装。运行PyCharm，选择File→Settings命令，打开Settings对话框，选择Project Interpreter选项，然后单击+（添加）按钮，打开Available Packages对话框，在搜索文本框中输入需要添加的模块名称，例如scikit-learn，然后在列表中选择需要安装的模块，如图10.1所示。单击Install Package按钮即可实现Scikit-Learn模块的安装。</p>
<p><img src="/.com//image-20211101095419172.png" alt="image-20211101095419172"></p>
<p>​                                                                                  图1.1　安装Scikit-Learn<br>这里需要注意：尽量选择安装0.21.2版本，否则运行程序可能会出现因为模块版本不适合而导致程序出现错误提示——“找不到指定的模块”。</p>
<p>查看是否安装成功 pip list</p>
<p>或者</p>
<p>import sklearn</p>
<p>sklearn.<strong><strong>version</strong></strong></p>
<h2 id="1-3-概念"><a href="#1-3-概念" class="headerlink" title="1.3  概念"></a>1.3  概念</h2><p>scikit-learn库主要功能分六大部分：分类，回归，聚类，降维，模型选择，数据预处理。</p>
<h3 id="1-3-1-监督学习"><a href="#1-3-1-监督学习" class="headerlink" title="1.3.1 监督学习"></a>1.3.1 监督学习</h3><p><strong>监督学习（supervised learning）</strong>的任务是学习一个模型，使模型能够对任意给定的输入，对其相应的输出做出一个好的预测。</p>
<p>即：利用训练数据集学习一个模型，再用模型对测试样本集进行预测。</p>
<p>通俗理解：每个数据点都被标记或关联一个类别或者分值。</p>
<p>例（类别）：输入一张图片，判断该图片中的动物是猫还是狗；</p>
<p>例（分值）：通过大量数据预测一辆二手车的出售价格；</p>
<p>监督学习的目的就是学习大量的样本（称作训练数据），从而对未来的数据点做出预测（称作测试数据）。</p>
<p>分类和回归</p>
<p>从根本上来说，分类是预测一个标签，回归是预测一个数量。</p>
<ul>
<li><p>分类是给一个样本预测离散型类别标签的问题。</p>
</li>
<li><p>回归是给一个样本预测连续输出量的问题。</p>
</li>
</ul>
<h3 id="1-3-2-非监督学习"><a href="#1-3-2-非监督学习" class="headerlink" title="1.3.2 非监督学习"></a>1.3.2 非监督学习</h3><p><strong>非监督学习（unsupervised learning）</strong>为直接对数据进行建模。没有给定事先标记过的训练范例，所用的数据没有属性或标签这一概念。事先不知道输入数据对应的输出结果是什么。</p>
<p>自动对输入的资料进行分类或分群，以寻找数据的模型和规律。</p>
<p>例：聚类</p>
<h3 id="1-3-3-强化学习"><a href="#1-3-3-强化学习" class="headerlink" title="1.3.3 强化学习"></a>1.3.3 强化学习</h3><p><strong>强化学习（Reinforcement Learning）</strong>是机器学习中的一个领域，强调如何基于环境而行动，以取得最大化的预期利益。其灵感来源于心理学中的行为主义理论，即有机体如何在环境给予的奖励或惩罚的刺激下，逐步形成对刺激的预期，产生能获得最大利益的习惯性行为。</p>
<p>有监督学习、无监督学习、强化学习具有不同的特点：</p>
<ul>
<li>有监督学习是有一个label（标记）的，这个label告诉算法什么样的输入对应着什么样的输出，常见的算法是分类、回归等；</li>
<li>无监督学习则是没有label（标记），常见的算法是聚类；</li>
<li>强化学习强调如何基于环境而行动，以取得最大化的预期利益。</li>
</ul>
<h2 id="1-4-数据预处理"><a href="#1-4-数据预处理" class="headerlink" title="1.4  数据预处理"></a>1.4  数据预处理</h2><p>在真实的世界中，经常需要处理大量的原始数据，这些原始数据是机器学习算法无法理解的，为了让机器学习算法理解原始数据，需要对数据进行预处理。</p>
<h3 id="1-4-1-准备工作"><a href="#1-4-1-准备工作" class="headerlink" title="1.4.1 准备工作"></a>1.4.1 准备工作</h3><p>python进行数据预处理，需要加载两个必要的程序包。</p>
<p>import numpy as np<br>from sklearn import preprocessing</p>
<p>data = np.array([[ 3, -1.5,  2, -5.4],<br>                 [ 0,  4,  -0.3, 2.1],<br>                 [ 1,  3.3, -1.9, -4.3]])</p>
<h3 id="1-4-2-详细步骤"><a href="#1-4-2-详细步骤" class="headerlink" title="1.4.2 详细步骤"></a>1.4.2 详细步骤</h3><h4 id="1-均值移除（Mean-removal）"><a href="#1-均值移除（Mean-removal）" class="headerlink" title="1.均值移除（Mean removal）"></a>1.均值移除（Mean removal）</h4><p>**通常我们会把每个特征的平均值移除，以保证特征均值为0(即标准化处理)**。这样做可以消除特征彼此之间的偏差（bias)。</p>
<p>sklearn.preprocessing.scale()函数<br>官方文档</p>
<p>sklearn.preprocessing.scale(X, axis=0, with_mean=True, with_std=True, copy=True)<br>沿着某个轴标准化数据集，以均值为中心，以分量为单位方差。</p>
<p>参数    数据类型    意义<br>X    {array-like, sparse matrix}    以此数据为中心缩放<br>axis    int (0 by default)    沿着计算均值和标准差的轴。如果是0，独立的标准化每个特征，如果是1则标准化每个样本（即行）<br>with_mean    boolean, True by default    如果是True，缩放之前先中心化数据<br>with_std    boolean, True by default    如果是True，以单位方差法缩放数据（或者等价地，单位标准差）<br>copy    boolean, optional, default True    False：原地执行行标准化并避免复制（如果输入已经是一个numpy数组或者scipy.sparse CSC矩阵以及axis是1）</p>
<p>[x1,x2,x3,x4]</p>
<p>var=((x1-mean)^2+(x2-mean)^2+(x3-mean)^2+(x4-mean)^2)/4</p>
<p>std=sqrt(var)</p>
<p>#mean removal</p>
<p>data_standardized = preprocessing.scale(data)<br>print “\nMean =”, data_standardized.mean(axis=0)<br>print “Std deviation =”, data_standardized.std(axis=0)</p>
<p>范数：</p>
<h4 id="2-范围缩放（Scaling"><a href="#2-范围缩放（Scaling" class="headerlink" title="2.范围缩放（Scaling)"></a>2.范围缩放（Scaling)</h4><p>数据点中每个特征的数值范围可能变化很大，以此，有时将特征的数值范围缩放到合理的大小是非常重要的。</p>
<p>官网：<a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.MinMaxScaler.html#sklearn.preprocessing.MinMaxScaler">https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.MinMaxScaler.html#sklearn.preprocessing.MinMaxScaler</a></p>
<p>方法介绍：</p>
<p>fit(): Method calculates the parameters μ and σ and saves them as internal objects.<br>解释：简单来说，就是求得训练集X的均值，方差，最大值，最小值,这些训练集X固有的属性。</p>
<p>transform(): Method using these calculated parameters apply the transformation to a particular dataset.<br>解释：在fit的基础上，进行标准化，降维，归一化等操作（看具体用的是哪个工具，如PCA，StandardScaler等）。</p>
<p>fit_transform(): joins the fit() and transform() method for transformation of dataset.<br>解释：fit_transform是fit和transform的组合，既包括了训练又包含了转换。<br>transform()和fit_transform()二者的功能都是对数据进行某种统一处理（比如标准化~N(0,1)，将数据缩放(映射)到某个固定区间，归一化，正则化等）</p>
<p>#min max scaling</p>
<p>data_scaler = preprocessing.MinMaxScaler(feature_range=(0, 1))<br>data_scaled = data_scaler.fit_transform(data)<br>print(“\nMin max scaled data:\n”, data_scaled)</p>
<h4 id="3-归一化（normalization"><a href="#3-归一化（normalization" class="headerlink" title="3.归一化（normalization)"></a>3.归一化（normalization)</h4><p>数据归一化用于需要对特征向量的值进行调整时，以保证每个特征向量的值都缩放到相同的数值范围。机器学习中最常用的归一化形式就是将特征向量调整为L1范数。</p>
<p>L1归一化：将每个数据除以L1范数(所有数据的绝对值之和)</p>
<p>##normalization</p>
<p>data_normalized = preprocessing.normalize(data, norm=’l1’)<br>print (“\nL1 normalized data:\n”, data_normalized)</p>
<p>这个方法经常用于确保数据点没有因为特征的基本性质而产生较大的差异，即确保数据处于同一数量级，提高不同特征数据的可比性。</p>
<h5 id="L0，L1范数和L2范数"><a href="#L0，L1范数和L2范数" class="headerlink" title="L0，L1范数和L2范数"></a>L0，L1范数和L2范数</h5><p><img src="/.com//image-20211207164714720.png" alt="image-20211207164714720"></p>
<h5 id="L1和L2范数在机器学习中的用途"><a href="#L1和L2范数在机器学习中的用途" class="headerlink" title="L1和L2范数在机器学习中的用途"></a>L1和L2范数在机器学习中的用途</h5><p><a href="https://zhuanlan.zhihu.com/p/28023308">https://zhuanlan.zhihu.com/p/28023308</a></p>
<p>注意：虽然在数学概念上存在Lp范数，但是在机器学习函数中只支持L1和L2范数。</p>
<p>例1:使用numpy生成一组随机数，并使用归一化进行预处理</p>
<h4 id="4-二值化（Binarization）"><a href="#4-二值化（Binarization）" class="headerlink" title="4.二值化（Binarization）"></a>4.二值化（Binarization）</h4><p>二值化用于将数值特征向量转换为布尔类型的向量。</p>
<p>#binarization</p>
<p>data_binarized = preprocessing.Binarizer(threshold=1.4).transform(data)<br>print(“\nBinarized data:\n”, data_binarized) </p>
<h4 id="5-独热编码（one-hot-encoding"><a href="#5-独热编码（one-hot-encoding" class="headerlink" title="5.独热编码（one-hot encoding)"></a>5.独热编码（one-hot encoding)</h4><p>通常，需要处理的数值都是稀疏的，散乱的分布在空间中，然而我们并不需要存储这些大数值，这时就需要使用独热编码。可以把独热编码看做一种收紧特征向量的工具。它把特征向量的每个特征与特征的非重复总数相对应，通过one-of-k的形式对每个特征进行编码。</p>
<p>#one hot encoding</p>
<p>encoder = preprocessing.OneHotEncoder()<br>encoder.fit([</p>
<p>[0, 2, 1, 12], </p>
<p>[1, 3, 5, 3], </p>
<p>[2, 3, 2, 12],</p>
<p> [1, 2, 4, 3]])<br>encoded_vector = encoder.transform([[2, 3, 5, 3]]).toarray()<br>print (“\nEncoded vector:\n”, encoded_vector)</p>
<p>#第一个特征（即为第一列）为[0,1,2,1],其中三类特征值[0,1,2],因此One-Hot Code可将[0,1,2]表示为:[100,010,001]<br>#第一个特征有三种值：采用三个编码：[100,010,001]</p>
<p>#同理第二个特征列可将两类特征值[2,3]表示为[10,01]</p>
<p>#第三个特征将4类特征值[1,2,4,5]表示为[1000,0100,0010,0001]</p>
<p>#第四个特征将2类特征值[3,12]表示为[10,01]</p>
<h3 id="1-4-3-标记编码"><a href="#1-4-3-标记编码" class="headerlink" title="1.4.3 标记编码"></a>1.4.3 标记编码</h3><p>在监督学习中，经常需要处理各种各样的标记。这些标记可能是数字，也可能是单词。如果标记是数字，那么算法可以直接使用它们，但是许多情况下，标记都需要以人们可理解的形式存在。因此，人们通常会用单词标记训练数据集。标记编码就是把单词标记转换成数值形式，让算法懂得如何操作标记。</p>
<p>import numpy as np<br>from sklearn import preprocessing</p>
<p>label_encoder = preprocessing.LabelEncoder()<br>input_classes = [‘audi’, ‘ford’, ‘audi’, ‘toyota’, ‘ford’, ‘bmw’]<br>label_encoder.fit(input_classes)</p>
<p>#print classes</p>
<p>print “\nClass mapping:”<br>for i, item in enumerate(label_encoder.classes_):<br>    print item, ‘–&gt;’, i</p>
<p>#transform a set of classes</p>
<p>labels = [‘toyota’, ‘ford’, ‘audi’]<br>encoded_labels = label_encoder.transform(labels)<br>print “\nLabels =”, labels<br>print “Encoded labels =”, list(encoded_labels)</p>
<p>#inverse transform</p>
<p>encoded_labels = [2, 1, 0, 3, 1]<br>decoded_labels = label_encoder.inverse_transform(encoded_labels)<br>print “\nEncoded labels =”, encoded_labels<br>print “Decoded labels =”, list(decoded_labels)</p>
<h2 id="1-5-线性回归模型"><a href="#1-5-线性回归模型" class="headerlink" title="1.5 线性回归模型"></a>1.5 线性回归模型</h2><p>Scikit-Learn已经为我们设计好了线性模型（sklearn.linear_model），在程序中直接调用即可，无须编写过多代码就可以轻松实现线性回归分析。首先了解一下线性回归析。<br>线性回归是利用数理统计中的回归分析来确定两种或两种以上变量间相互依赖的定量关系的一种统计分析与预测方法，运用十分广泛。</p>
<p>在线性回归分析中，只包括一个自变量和一个因变量，且二者的关系可用一条直线近似表示，这种回归分析称为<strong>一元线性回归分析</strong>；如果线性回归分析中包括两个或两个以上的自变量，且因变量和自变量之间是线性关系，则称为<strong>多元线性回归分析</strong>。</p>
<p>在Python中，无须理会烦琐的线性回归求解数学过程，直接使用Scikit-Learn的linear_model模块就可以实现线性回归分析。</p>
<p>linear_model模块提供了很多线性模型，包括最小二乘法回归、岭回归、<strong>Lasso、贝叶斯回归</strong>等。本节主要介绍最小二乘法回归和岭回归。</p>
<p>5x1+6x2=10</p>
<p>x1-x2=5</p>
<p>首先导入linear_model模块，程序代码如下：</p>
<p>from sklearn import linear_model<br>导入linear_model模块后，在程序中就可以使用相关函数实现线性回归分析。</p>
<h3 id="1-5-1-最小二乘法回归"><a href="#1-5-1-最小二乘法回归" class="headerlink" title="1.5.1　最小二乘法回归"></a>1.5.1　最小二乘法回归</h3><p>线性回归是数据挖掘中的基础算法之一，线性回归的思想其实就是解一组方程，得到回归系数，不过在出现误差项之后，方程的解法就存在了改变，一般使用最小二乘法进行计算，所谓“二乘”就是平方的意思，最小二乘法也称最小平方和，其目的是通过最小化误差的平方和，使得预测值与真值无限接近。</p>
<p>最小二乘原理补充：</p>
<p><img src="/.com//image-20211116054806678.png" alt="image-20211116054806678"></p>
<p><img src="/.com//image-20211116054851514.png" alt="image-20211116054851514"></p>
<p>linear_model模块的LinearRegression()函数用于实现最小二乘法回归。LinearRegression()函数拟合一个带有回归系数的线性模型，使得真实数据和预测数据（估计值）之间的残差平方和最小，与真实数据无限接近。LinearRegression()函数语法如下：</p>
<p>linear_model.LinearRegression(fit_intercept=True,normalize=False,copy_X=True,n_jobs=NoNone)<br>参数说明：　</p>
<p>fit_intercept：布尔型值，是否需要计算截距，默认值为True。　</p>
<p>normalize：布尔型值，是否需要标准化，默认值为False，与参数fit_intercept有关。当fit_intercept参数值为False时，将忽略该参数；当fit_intercept参数值为True时，则回归前对回归量X进行归一化处理，取均值相减，再除以L2范数（L2范数是指向量各元素的平方和然后开方）。　</p>
<p>copy_X：布尔型值，选择是否复制X数据，默认值为True，如果值为False，则覆盖X数据。　</p>
<p>n_jobs：整型，代表CPU工作效率的核数，默认值为1，-1表示跟CPU核数一致。</p>
<p>主要属性：　</p>
<p>coef_：数组或形状，表示线性回归分析的回归系数。　</p>
<p>intercept_：数组，表示截距。<br>主要方法：　</p>
<p>fit(X,y,sample_weight=None)：拟合线性模型。　</p>
<p>predict(X)：使用线性模型返回预测数据。　</p>
<p>score(X,y,sample_weight=None)：返回预测的确定系数R^2。<br>LinearRegression()函数调用fit()方法来拟合数组X、y，并且将线性模型的回归系数存储在其成员变量coef_属性中。</p>
<p>【示例01】　智能预测房价。（示例位置：资源包\MR\Code\10\01）<br>智能预测房价，假设某地房屋面积和价格关系如图10.2所示。下面使用LinearRegression()函数预测面积为170平方米的房屋的单价。</p>
<p><img src="/.com//image-20211101095833224.png" alt="image-20211101095833224"></p>
<p>​                                                                                            图10.2　房屋价格表<br>程序代码如下：</p>
<p><img src="/.com//image-20211101095853611.png" alt="image-20211101095853611"></p>
<p>运行程序，输出结果如下：</p>
<p>回归系数：[1853.37423313  -21.7791411 ]</p>
<p>截距：7215.950920245397</p>
<p>预测值：[16487.11656442]</p>
<h3 id="1-5-2-岭回归"><a href="#1-5-2-岭回归" class="headerlink" title="1.5.2　岭回归"></a>1.5.2　岭回归</h3><p>线性回归的主要问题的对异常值敏感。在真实的世界的数据收集过程中，经常会遇到错误的度量结果。而线性回归使用的普通最小二乘法，其目标是使平方误差最小化。这时，由于异常误差的绝对值很大，因此会引起问题，从而破坏整个模型。为了避免整个问题，我们引入了<strong>正则化项的系数</strong>作为阈值来消除异常值的影响。这个方法称为岭回归。</p>
<p>岭回归是在最小二乘法回归基础上，加入了对表示回归系数的L2范数约束。岭回归是缩减法的一种，相当于对回归系数的大小施加了限制。</p>
<p>岭回归详解：</p>
<p><img src="/.com//image-20211116055823554.png" alt="image-20211116055823554"></p>
<p><img src="/.com//image-20211116055857220.png" alt="image-20211116055857220"></p>
<p>岭回归的特点：<br>岭回归是一种改良的最小二乘估计法，通过放弃最小二乘法的无偏性，以损失部分信息、降低精度为代价获得回归系数，它是更为符合实际、更可靠的回归方法，对存在离群点的数据的拟合要强于最小二乘法。</p>
<p>不同与线性回归的无偏估计，岭回归的优势在于它的无偏估计，更趋向于将部分系数向0收缩。因此，它可以缓解多重共线问题，以及过拟合问题。但是由于岭回归中并没有将系数收缩到0，而是使得系数整体变小，因此，某些时候模型的解释性会大大降低，也无法从根本上解决多重共线问题。</p>
<p>岭回归主要使用linear_model模块的Ridge()函数实现。语法如下：</p>
<p>linear_model.Ridge(alpha=1.0,fit_intercept=True,normalize=False,copy_X=True,max_iter=None,tol=0.001,solver=<br>‘auto’,random_state=None)<br>参数说明：　</p>
<p>alpha：权重。　</p>
<p>fit_intercept：布尔型值，是否需要计算截距，默认值为True。　</p>
<p>normalize：输入的样本特征归一化，默认值为False。　</p>
<p>copy_X：复制或者重写。　</p>
<p>max_iter：最大迭代次数。</p>
<p>tol：浮点型，控制求解的精度。　</p>
<p>solver：求解器，其值包括auto、svd、cholesky、sparse_cg和lsqr，默认值为auto。</p>
<p>主要属性：</p>
<p>coef_：数组或形状，表示线性回归分析的回归系数。</p>
<p>主要方法：　</p>
<p>_fit(X,y)：拟合线性模型。　</p>
<p>_predict(X)：使用线性模型返回预测数据。<br>Ridg()函数使用fit()方法将线性模型的回归系数存储在其成员变量coef_属性中。</p>
<p>【示例02】　使用岭回归函数实现智能预测房价。（示例位置：资源包\MR\Code\10\02）<br>使用岭回归函数Ridg()实现智能预测房价，程序代码如下：</p>
<p><img src="/.com//image-20211101100017254.png" alt="image-20211101100017254"></p>
<p>运行程序，输出结果如下：</p>
<p>回归系数：[10.00932795 16.11613094]截距：6935.001421210872预测值：[9744.80897725]</p>
<h2 id="1-6-支持向量机"><a href="#1-6-支持向量机" class="headerlink" title="1.6 支持向量机"></a>1.6 支持向量机</h2><p>支持向量机（SVM）可用于监督学习算法，主要包括分类、回归和异常检测。支持向量分类的方法可以被扩展用作解决回归问题，这个方法被称作支持向量回归。</p>
<p>本节介绍支持向量回归函数——LinearSVR()函数。LinearSVR()类是一个支持向量回归的函数，支持向量回归不仅适用于线性模型，还可以用于对数据和特征之间的非线性关系的研究。避免多重共线性问题，从而提高泛化性能，解决高维问题，语法如下：</p>
<p>sklearn.svm.LinearSVR(epsilon = 0.0, tol = 0.0001, C = 1.0, loss =’epsilon_insensitive’, fit_intercept = True,<br>intercept_scaling = 1.0, dual = True, verbose = 0, random_state = None, max_iter = 1000)<br>参数说明：　</p>
<p>epsilon：float类型值，默认值为0.0。　</p>
<p>tol：float类型值，终止迭代的标准值，默认值为0.0001。　</p>
<p>C：float类型值，罚项参数，该参数越大，使用的正则化越少，默认值为1.0。　</p>
<p>loss：string类型值，损失函数，该参数有以下两种选项。　</p>
<p>epsilon_insensitive：默认值，不敏感损失（标准SVR）是L1损失。　</p>
<p>squared_epsilon_insensitive：平方不敏感损失是L2损失。　</p>
<p>fit_intercept：boolean类型值，是否计算此模型的截距。如果设置值为False，则不会在计算中使用截距（即数据预计已经居中）。默认值为True。　</p>
<p>intercept_scaling：float类型值，当fit_intercept为True时，实例向量x变为[x,self.intercept_scaling]。此时相当于添加了一个特征，该特征将对所有实例都是常数值。　</p>
<p>dual：boolean类型值，选择算法以解决对偶或原始优化问题。当设置值为True时，可解决对偶问题；当设置值为False时，可解决原始问题。默认值为True。　</p>
<p>verbose：int类型值，是否开启verbose输出，默认值为0。</p>
<p>random_state：int类型值，随机数生成器的种子，用于在清洗数据时使用。默认值为None。　</p>
<p>max_iter：int类型值，要运行的最大迭代次数。默认值为1000。</p>
<p>两个主要的属性：　</p>
<p>coef_：赋予特征的权重，返回array数据类型。</p>
<p>intercept_：决策函数中的常量，返回array数据类型。</p>
<p>【示例03】　波士顿房价预测。（示例位置：资源包\MR\Code\10\03）</p>
<p>变量名    说明<br>CRIM    城镇人口犯罪率<br>ZN    超过25000平方英尺的住宅用地所占比例<br>INDUS    城镇非零售业务地区的比例<br>CHAS    查尔斯河虚拟变量(如果土地在河边=1；否则是0)<br>NOX    一氧化氮浓度(每1000万份)<br>RM    平均每居民房数<br>AGE    在1940年之前建成的所有者占用单位的比例<br>DIS    与五个波士顿就业中心的加权距离<br>RAD    辐射状公路的可达性指数<br>TAX    每10,000美元的全额物业税率<br>RTRATIO    城镇师生比例<br>B    1000(Bk-0.63)^2其中Bk是城镇黑人的比例<br>LSTAT    人口中地位较低人群的百分数<br>MEDV    (目标变量/类别属性)以1000美元计算的自有住房的中位数</p>
<p>通过Scikit-Learn自带的数据集“波士顿房价”，实现房价预测，程序代码如下：</p>
<p><img src="/.com//image-20211101100311355.png" alt="image-20211101100311355"></p>
<p>运行程序，输出结果如下：</p>
<p><img src="/.com//image-20211101100341186.png" alt="image-20211101100341186"></p>
<h2 id="1-7-决策树回归器"><a href="#1-7-决策树回归器" class="headerlink" title="1.7 决策树回归器"></a>1.7 决策树回归器</h2><p>决策树是一个树状模型，每个节点都做出一个决策，从而影响最终结果。叶子节点表示输出数值，分支表示根据输入特征做出的中间决策。AdaBoost算法是指自适应增强算法，这是一种利用其它系统增强模型准确性的技术。这种技术是将不同版本的算法结果进行组合，用加权汇总的方法获得最终结果，被称为弱学习器。Adaboost算法在每个阶段获取的信息都会反馈到模型中，这样学习器就可以在后一阶段重点训练难以分类的样本。这种学习方式可以增强系统的准确性。</p>
<p><a href="https://www.cnblogs.com/liuwu265/p/4692347.html">https://www.cnblogs.com/liuwu265/p/4692347.html</a></p>
<p>例1:波士顿房价预估</p>
<p>import numpy as np<br>from sklearn.ensemble import RandomForestRegressor, AdaBoostRegressor<br>from sklearn.tree import DecisionTreeRegressor<br>from sklearn import datasets<br>from sklearn.metrics import mean_squared_error, explained_variance_score<br>from sklearn.utils import shuffle<br>import matplotlib.pyplot as plt</p>
<p>housing_data = datasets.load_boston() </p>
<p>#Shuffle the data</p>
<p>X, y = shuffle(housing_data.data, housing_data.target, random_state=7)</p>
<p>#Split the data 80/20 (80% for training, 20% for testing)</p>
<p>num_training = int(0.8 * len(X))<br>X_train, y_train = X[:num_training], y[:num_training]<br>X_test, y_test = X[num_training:], y[num_training:]</p>
<p>#决策树模型</p>
<p>dt_regressor = DecisionTreeRegressor(max_depth=4)<br>dt_regressor.fit(X_train, y_train)</p>
<p>#AdaBoost决策树</p>
<p>ab_regressor = AdaBoostRegressor(DecisionTreeRegressor(max_depth=4), n_estimators=400, random_state=7)<br>ab_regressor.fit(X_train, y_train)</p>
<p>#Evaluate performance of Decision Tree regressor</p>
<p>y_pred_dt = dt_regressor.predict(X_test)<br>mse = mean_squared_error(y_test, y_pred_dt)<br>evs = explained_variance_score(y_test, y_pred_dt)<br>print(“\n#### Decision Tree performance ####”)<br>print(“Mean squared error =”, round(mse, 2))<br>print(“Explained variance score =”, round(evs, 2)) </p>
<p>#Evaluate performance of AdaBoost</p>
<p>y_pred_ab = ab_regressor.predict(X_test)<br>mse = mean_squared_error(y_test, y_pred_ab)<br>evs = explained_variance_score(y_test, y_pred_ab)<br>print(“\n#### AdaBoost performance ####”)<br>print(“Mean squared error =”, round(mse, 2))<br>print(“Explained variance score =”, round(evs, 2)) </p>
<h2 id="1-7-聚类"><a href="#1-7-聚类" class="headerlink" title="1.7　聚类"></a>1.7　聚类</h2><h3 id="1-7-1-什么是聚类"><a href="#1-7-1-什么是聚类" class="headerlink" title="1.7.1　什么是聚类"></a>1.7.1　什么是聚类</h3><p>聚类类似于分类，不同的是聚类所要求划分的类是未知的，也就是说不知道应该属于哪类，而是通过一定的算法自动分类。在实际应用中，聚类是一个将在某些方面相似的据进行分类组织的过程（简单地说就是将相似数据聚在一起），其示意图如图10.3和图10.4所示。</p>
<p><img src="/.com//image-20211101100624704.png" alt="image-20211101100624704"></p>
<p>​                                                                                                         图10.3　聚类前</p>
<p><img src="/.com//image-20211101100611630.png" alt="image-20211101100611630"></p>
<p>​                                                                                                   图10.4　聚类后<br>聚类主要应用领域如下。　</p>
<p>商业：聚类分析被用来发现不同的客户群，并且通过购买模式刻画不同客户群的特征。　</p>
<p>生物：聚类分析被用来对动植物分类和对基因进行分类，获取对种群固有结构的认识。　</p>
<p>保险行业：聚类分析通过一个高的平均消费来鉴定汽车保险单持有者的分组，同时根据住宅类型、价值和地理位置来判断一个城市的房产分组。　</p>
<p>互联网：聚类分析被用来在网上进行文档归类。　</p>
<p>电子商务：聚类分析在电子商务网站数据挖掘中也是很重要的一个方面，通过分组聚类出具有相似浏览行为的客户，并分析客户的共同特征，可以更好地帮助电商了解自己的客户，向客户提供更合适的服务。</p>
<h3 id="1-7-2-聚类算法"><a href="#1-7-2-聚类算法" class="headerlink" title="1.7.2　聚类算法"></a>1.7.2　聚类算法</h3><p>k-means算法是一种聚类算法，它是一种无监督学习算法，目的是将相似的对象归到同一个簇中。簇内的对象越相似，聚类的效果就越好。<br>传统的聚类算法包括划分方法、层次方法、基于密度方法、基于网格方法和基于模型方法。</p>
<p>本节主要介绍k-means聚类算法，它是划分方法中较典型的一种，也可以称为k均聚类算法。下面介绍什么是k均值聚类以及相关算法。</p>
<p>1．k-means聚类</p>
<p>k-means聚类也称为k均值聚类，是著名的划分聚类的算法，由于简洁和高效使得它成为所有聚类算法中应用最为广泛的一种。k均值聚类是给定一个数据点集合和需要的聚类数目k，k由用户指定，k均值算法根据某个距离函数反复把数据分入k个聚类中。</p>
<p>2．算法</p>
<p>随机选取k个点作为初始质心（质心即簇中所有点的中心），然后将数据集中的每个点分配到一个簇中，具体来讲，为每个点找距其最近的质心，并将其分配给该质心所对应的簇。这一步完成之后，将每个簇的质心更新为该簇所有点的平均值。这个过程将不断重复直到满足某个终止条件。终止条件可以是以下任何一个。　</p>
<p>没有（或最小数目）对象被重新分配给不同的聚类。　</p>
<p>没有（或最小数目）聚类中心再发生变化。　</p>
<p>误差平方和局部最小。</p>
<p>伪代码：</p>
<p><img src="/.com//image-20211101100743922.png" alt="image-20211101100743922"></p>
<p>通过以上介绍相信读者对k-means聚类算法已经有了初步的认识，而在Python中应用该算法无须手动编写代码，因为Python第三方模块Scikit-Learn已经帮我们写好了，在性能和稳定性上比自己写的好得多，只需在程序中调用即可，没必要自己造轮子。</p>
<h3 id="1-7-3-聚类模块"><a href="#1-7-3-聚类模块" class="headerlink" title="1.7.3　聚类模块"></a>1.7.3　聚类模块</h3><p>Scikit-Learn的cluster模块用于聚类分析，该模块提供了很多聚类算法，下面主要介绍KMeans方法，该方法通过k-means聚类算法实现聚类分析。<br>首先导入sklearn.cluster模块的KMeans方法，程序代码如下：</p>
<p>from sklearn.cluster import KMeans<br>接下来，在程序中就可以使用KMeans()方法了。KMeans()方法的语法如下：</p>
<p>KMeans(n_clusters=8,init=’k-means++’,n_init=10,max_iter=300,tol=1e-4,precompute_distances=’auto’,verbose=<br>0,random_state=None,copy_x=True,n_jobs=None,algorithm=’auto’)<br>参数说明：　</p>
<p>n_clusters：整型，默认值为8，是生成的聚类数，即产生的质心（centroid）数。　</p>
<p>init：参数值为k-means++、random或者传递一个数组向量。默认值为k-means++。　</p>
<p>k-means++：用一种特殊的方法选定初始质心从而加速迭代过程的收敛。　</p>
<p>random：随机从训练数据中选取初始质心。如果传递数组类型，则应该是shape(n_clusters,n_features)的形式，并给出初始质心。　</p>
<p>n_init：整型，默认值为10，用不同的质心初始化值运行算法的次数。　</p>
<p>max_iter：整型，默认值为300，每执行一次k-means算法的最大迭代次数。　</p>
<p>tol：浮点型，默认值1e-4（科学技术法，即1乘以10的-4次方），控制求解的精度。　</p>
<p>precompute_distances：参数值为auto、True或者False。用于预先计算距离，计算速度更快但占用更多内存。　</p>
<p>​            auto：如果样本数乘以聚类数大于12e6（科学技术法，即12乘以10的6次方），则不预先计算距离。</p>
<p>​            True：总是预先计算距离。　</p>
<p>​            False：永远不预先计算距离。　</p>
<p>verbose：整型，默认值为0，冗长的模式。　</p>
<p>random_state：整型或随机数组类型。用于初始化质心的生成器（generator）。如果值为一个整数，则确定一个种子（seed）。默认值为NumPy的随机数生成器。　</p>
<p>copy_x：布尔型，默认值为True。如果值为True，则原始数据不会被改变；如果值为False，则会直接在原始数据上做修改，并在函数返回值时将其还原。但是在计算过程中由于有对数据均值的加减运算，所以数据返回后，原始数据同计算前数据可能会有细小差别。　</p>
<p>n_jobs：整型，指定计算所用的进程数。如果值为-1，则用所有的CPU进行运算；如果值为1，则不进行并行运算，这样方便调试；如果值小于-1，则用到的CPU数为（n_cpus+1+n_jobs），例如n_jobs值为-2，则用到的CPU数为总CPU数减1。　</p>
<p>algorithm：表示k-means算法法则，参数值为auto、full或elkan，默认值为auto。</p>
<p>主要属性：　</p>
<p>cluster_centers_：返回数组，表示分类簇的均值向量。　</p>
<p>_labels_：返回数组，表示每个样本数据所属的类别标记。　</p>
<p>inertia_：返回数组，表示每个样本数据距离它们各自最近簇的中心之和。<br>主要方法：</p>
<p>fit(X[,y])：计算k-means聚类。　</p>
<p>fit_predictt(X[,y])：计算簇质心并给每个样本数据预测类别。　</p>
<p>predict(X)：给每个样本估计最接近的簇。　</p>
<p>score(X[,y])：计算聚类误差。</p>
<p>【示例04】　对一组数据聚类。（示例位置：资源包MR\Code\10\04）<br>对一组数据聚类，程序代码如下：</p>
<p><img src="/.com//image-20211101101115664.png" alt="image-20211101101115664"></p>
<p>运行程序，输出结果如下：</p>
<p><img src="/.com//image-20211101101127730.png" alt="image-20211101101127730"></p>
<h3 id="1-7-4-聚类数据生成器"><a href="#1-7-4-聚类数据生成器" class="headerlink" title="1.7.4　聚类数据生成器"></a>1.7.4　聚类数据生成器</h3><p>1.7.3节列举了一个简单的聚类示例，但是聚类效果并不明显。本节生成了专门的聚类算法的测试数据，可以更好地诠释聚类算法，展示聚类效果。</p>
<p>Scikit-Learn的make_blobs()方法用于生成聚类算法的测试数据，直观地说，make_blobs()方法可以根据用户指定的特征数量、中心点数量、范围等生成几类数据，这些数据可用于测试聚类算法的效果。</p>
<p>make_blobs()方法的语法如下：</p>
<p><img src="/.com//image-20211101101212613.png" alt="image-20211101101212613"></p>
<p>常用参数说明：　</p>
<p>n_samples：待生成的样本的总数。　</p>
<p>n_features：每个样本的特征数。　</p>
<p>centers：类别数。　</p>
<p>cluster_std：每个类别的方差，例如，生成两类数据，其中一类比另一类具有更大的方差，可以将cluster_std设置为[1.0,3.0]。</p>
<p>【示例05】　生成用于聚类的测试数据。（示例位置：资源包\MR\Code\10\05）<br>生成用于聚类的数据（500个样本，每个样本有两个特征），程序代码如下：</p>
<p>01  from sklearn.datasets import make_blobs</p>
<p>02  from matplotlib import pyplot<br>03  x,y = make_blobs(n_samples=500, n_features=2, centers=3)</p>
<p>接下来，通过KMeans()方法对测试数据进行聚类，程序代码如下：</p>
<p>01  from sklearn.cluster import KMeans<br>02  y_pred = KMeans(n_clusters=4, random_state=9).fit_predict(x)<br>03  plt.scatter(x[:, 0], x[:, 1], c=y_pred)<br>04  plt.show()<br>运行程序，效果如图10.5所示。</p>
<p><img src="/.com//image-20211101101258102.png" alt="image-20211101101258102"></p>
<p>​                                                                                         图10.5　聚类散点图<br>从分析结果得知：相似的数据聚在一起，分成了4堆，也就是4类，并以不同的颜色显示，看上去清晰直观。</p>
<h2 id="项目一：线性回归器"><a href="#项目一：线性回归器" class="headerlink" title="项目一：线性回归器"></a>项目一：线性回归器</h2><p>假设有一个数据文件data_singlevar.txt，文件里用逗号分隔符分割字段，第一个字段是输入值，第二个字段是与逗号前面的输入值相对应的输出值。建立一个线性回归模型，并检验模型的准确度。</p>
<p>（1）读取数据，其中x是数据，y是标记</p>
<p>import sys</p>
<p>import numpy as np</p>
<p>filename = ‘data_singlevar.txt’</p>
<p>#filename = sys.argv[1]</p>
<p>X = []<br>y = []<br>with open(filename, ‘r’) as f:<br>    for line in f.readlines():<br>        xt, yt = [float(i) for i in line.split(‘,’)]<br>        X.append(xt)<br>        y.append(yt)</p>
<p>（2）建立机器学习模型，需要用一种方法来验证模型，检查模型是否达到一定的满意度。为了实现这个方法，通常将数据分成两组：训练数据集（training dataset）和测试数据集（testing dataset）。训练数据集用来建立模型，测试数据集用来验证模型对未知数据的学习效果。因此先把数据分成训练数据与测试数据集：</p>
<p>#Train/test split</p>
<p>num_training = int(0.8 * len(X))<br>num_test = len(X) - num_training</p>
<p>#训练数据</p>
<p>X_train = np.array(X[:num_training]).reshape((num_training,1))<br>y_train = np.array(y[:num_training])</p>
<p>#测试数据</p>
<p>X_test = np.array(X[num_training:]).reshape((num_test,1))<br>y_test = np.array(y[num_training:])</p>
<p>（3）创建一个回归器对象</p>
<p>#Create linear regression object</p>
<p>from sklearn import linear_model</p>
<p>linear_regressor = linear_model.LinearRegression()</p>
<p>（4）利用训练数据集训练线性回归器，向fit方法提供输入数据即可训练模型。画图看是否拟合；</p>
<p>#Train the model using the training sets</p>
<p>linear_regressor.fit(X_train, y_train)</p>
<p>#Predict the output</p>
<p>y_test_pred = linear_regressor.predict(X_test)</p>
<p>#Plot outputs</p>
<p>import matplotlib.pyplot as plt</p>
<p>plt.scatter(X_test, y_test, color=’green’)<br>plt.plot(X_test, y_test_pred, color=’black’, linewidth=4)<br>plt.xticks(())<br>plt.yticks(())<br>plt.show()</p>
<p>（5）查看模型的准确性</p>
<p>#Measure performance</p>
<p>import sklearn.metrics as sm</p>
<p>print (“Mean absolute error =”, round(sm.mean_absolute_error(y_test, y_test_pred), 2) )<br>print (“Mean squared error =”, round(sm.mean_squared_error(y_test, y_test_pred), 2) )<br>print (“Median absolute error =”, round(sm.median_absolute_error(y_test, y_test_pred), 2) )<br>print (“Explain variance score =”, round(sm.explained_variance_score(y_test, y_test_pred), 2) )<br>print (“R2 score =”, round(sm.r2_score(y_test, y_test_pred), 2))</p>
<p>评价指标：</p>
<p>平均绝对误差（mean absolute error）：绝对误差的平均值</p>
<p>均方误差（mean squared error):所有数据点的误差的平方的均值。</p>
<p>中位数绝对误差（median absolute error）：给定数据集的所有数据点的误差的中位数。这个指标的主要优点是可以消除异常值（outlier）的干扰。测试数据集中的单个坏点不会影响这个误差指标，均值误差会受到异常点的影响。</p>
<p>解释方差（explained variance score)：这个分数用于衡量我们的模型对数据集波动的解释能力。如果得分1.0分，那么表明我们的模型是完美的。</p>
<p>R方得分（R2 score)：这个指标读作“R方”，是指确定性相关系数。用于衡量模型对未知样本预测的效果。最好的得分是1.0。值也可以是复数。</p>
<p>（6）保存模型，下次使用时直接加载</p>
<p>#Model persistence</p>
<p>import pickle</p>
<p>output_model_file = ‘3_model_linear_regr.pkl’</p>
<p>with open(output_model_file, ‘wb’) as f:<br>    pickle.dump(linear_regressor, f)</p>
<p>with open(output_model_file, ‘rb’) as f:<br>    model_linregr = pickle.load(f)</p>
<p>y_test_pred_new = model_linregr.predict(X_test)<br>print(“\nNew mean absolute error =”, round(sm.mean_absolute_error(y_test, y_test_pred_new), 2) ) </p>
<h2 id="项目二-二手房房价分析与预测"><a href="#项目二-二手房房价分析与预测" class="headerlink" title="项目二　二手房房价分析与预测"></a>项目二　二手房房价分析与预测</h2><p>衣食住行，住房一直以来都是热门话题，而房价更是大家时刻关心的问题。虽然新商品房听着上档次，但是二手房是现房交易，并且具有地段较好、配套设施完善、产权权属清晰、选择面更广等优势，使得二手房越来越受到广大消费者的青睐。由此，越来越多的人关注二手房，对房价、面积、地理位置、装修程度等进行多维度对比与分析，从而找到既适合自己又具备一定升值空间的房子。</p>
<h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1　概述"></a>2.1　概述</h2><p>随着现代科技化的不断进步，信息化将是科技发展中的重要元素之一，而人们每天都要面对海量的数据，如医疗数据、人口数据、人均收入等，因此数据分析将会得到广泛应用。数据分析在实际应用时可以帮助人们在海量数据中找到具有决策意义的重要信息。<br>本章将通过数据分析方法实现“二手房数据分析预测系统”，用于对二手房数据进行分析、统计，并根据数据中的重要特征实现房屋价格的预测，最后通过可视化图表方式进行数据的显示功能。</p>
<h2 id="2-2-项目效果预览"><a href="#2-2-项目效果预览" class="headerlink" title="2.2　项目效果预览"></a>2.2　项目效果预览</h2><p>在二手房数据分析预测系统中，查看二手房各种数据分析图表时，需要在主窗体工具栏中单击对应的工具栏按钮。主窗体运行效果如图13.1所示。</p>
<p><img src="/.com//image-20211101105726717.png" alt="image-20211101105726717"></p>
<p>​                                                                                                图13.1　主窗体<br>在主窗体工具栏中单击“各区二手房均价分析”按钮，显示各区域二手房均价，如图13.2所示。</p>
<p><img src="/.com//image-20211101105815676.png" alt="image-20211101105815676"></p>
<p>​                                                                                                    图13.2　各区二手房均价分析<br>在主窗体工具栏中单击“各区二手房数量所占比例”按钮，了解城市所属区域二手房的销售数量和占比情况，如图13.3所示。<br>经过分析得知：二手房数据中房子的装修程度也是购买者关心的一个重要元素。在主窗体工具栏中单击“全市二手房装修程度分析”按钮，分析全市二手房装修程度，如图13.4所示。</p>
<p><img src="/.com//image-20211101105848608.png" alt="image-20211101105848608"></p>
<p>​                                                                              图13.3　各区二手房数量所占比例</p>
<p><img src="/.com//image-20211101105916747.png" alt="image-20211101105916747"></p>
<p>​                                                                                           图13.4　全市二手房装修程度分析<br>二手房的户型类别很多，如果需要查看所有二手房户型中比较热门的户型均价时，则在主窗体工具栏中单击“热门户型均价分析”按钮，分析热门户型均价，如图13.5所示。<br>分析二手房数据时，首先分析特征数据，然后通过回归算法的函数预测二手房的售价。在主窗体工具栏中单击“二手房售价预测”按钮，显示二手房售价预测的折线图，如图13.6所示。</p>
<p><img src="/.com//image-20211101110020403.png" alt="image-20211101110020403"></p>
<p>​                                                                                          图13.5　热门户型均价分析</p>
<p><img src="/.com//image-20211101110046986.png" alt="image-20211101110046986"></p>
<p>​                                                                                                            图13.6　二手房售价预测</p>
<h2 id="2-3-项目准备"><a href="#2-3-项目准备" class="headerlink" title="2.3　项目准备"></a>2.3　项目准备</h2><p>本项目的开发及运行环境如下。　</p>
<p>操作系统：Windows 7、Windows 10。　</p>
<p>语言：Python 3.7。　</p>
<p>开发环境：PyCharm。　</p>
<p>内置模块：sys。　</p>
<p>第三方模块：PyQt5（5.11.3）、PyQt5-tools（5.11.3.1.4）、Pandas（1.0.3）、xlrd（1.2.0）、xlwt（1.3.0）、Scipy（1.2.1）、NumPy（1.16.1）、Matplotlib（3.0.2）、Scikit-Learn（0.21.2）。</p>
<h2 id="2-4-图表工具模块"><a href="#2-4-图表工具模块" class="headerlink" title="2.4　图表工具模块"></a>2.4　图表工具模块</h2><p>图表工具模块为自定义工具模块，该模块中主要定义用于显示可视化数据图表的函数，用于实现饼形图、折线图以及条形图的绘制与显示工作。图表工具模块创建完成后根据数据分析的类型调用对应的图表函数，就可以实现数据的可视化操作。</p>
<h3 id="2-4-1-绘制饼形图"><a href="#2-4-1-绘制饼形图" class="headerlink" title="2.4.1　绘制饼形图"></a>2.4.1　绘制饼形图</h3><p>在实现绘制饼形图时，首先需要创建chart.py文件，该文件为图表工具的自定义模块。然后在该文件中导入matplotlib模块与pyplot子模块。接下来为了避免中文乱码，需要使用rcParams变量。<br>绘制饼形图的函数名称为pie_chart()，用于显示各区二手房数量所占比例。pie_chart()函数需要以下3个参数：size为饼形图中每个区二手房数量；label为每个区对应的名称；title为图表的标题。<br>程序代码如下：（源码位置：资源包\MR\Code\13\house_data_analysis\chart.py）</p>
<p><img src="/.com//image-20211101110146661.png" alt="image-20211101110146661"></p>
<h3 id="2-4-2-绘制折线图"><a href="#2-4-2-绘制折线图" class="headerlink" title="2.4.2　绘制折线图"></a>2.4.2　绘制折线图</h3><p>绘制折线图的函数名称为broken_line()，用于显示真实房价与预测房价的折线图。该函数需要以下3个参数：y为二手房的真实价格；y_pred为二手房的预测价格；title为图表的标题。<br>程序代码如下：（源码位置：资源包\MR\Code\13\house_data_analysis\chart.py）</p>
<p><img src="/.com//image-20211101110214640.png" alt="image-20211101110214640"></p>
<h3 id="2-4-3-绘制条形图"><a href="#2-4-3-绘制条形图" class="headerlink" title="2.4.3　绘制条形图"></a>2.4.3　绘制条形图</h3><p>绘制条形图的函数一共分为3个，分别用于显示各区二手房均价、全市二手房装修程度以及热门户型均价。下面介绍定义函数的具体方式。<br>1．绘制各区二手房均价的条形图<br>绘制各区二手房均价的条形图为纵向条形图，函数名称为average_price_bar()，该函数需要以下3个参数：x为全市中各区域的数据；y为各区域的均价数据；title为图表的标题。<br>程序代码如下：（源码位置：资源包\MR\Code\13\house_data_analysis\chart.py）</p>
<p><img src="/.com//image-20211101110253761.png" alt="image-20211101110253761"></p>
<p>2．绘制全市二手房装修程度的条形图<br>绘制全市二手房装修程度的条形图为纵向条形图，函数名称为renovation_bar()，该函数需要以下3个参数：x为装修类型的数据；y为每种装修类型所对应的数量；title为图表的标题。<br>程序代码如下：（源码位置：资源包\MR\Code\13\house_data_analysis\chart.py）</p>
<p><img src="/.com//image-20211101110314134.png" alt="image-20211101110314134"></p>
<p>3．绘制热门户型均价的条形图<br>绘制热门户型均价的条形图为水平条形图，函数名称为bar()，该函数需要以下3个参数：price为热门户型的均价；type为热门户型的名称；title为图表的标题。<br>程序代码如下：（源码位置：资源包\MR\Code\13\house_data_analysis\chart.py）</p>
<p><img src="/.com//image-20211101110356475.png" alt="image-20211101110356475"></p>
<h2 id="2-5-项目实现过程"><a href="#2-5-项目实现过程" class="headerlink" title="2.5　项目实现过程"></a>2.5　项目实现过程</h2><h3 id="2-5-1-数据清洗"><a href="#2-5-1-数据清洗" class="headerlink" title="2.5.1　数据清洗"></a>2.5.1　数据清洗</h3><p>在实现数据分析前需要先对数据进行清洗工作，清洗数据的主要目的是为了减小数据分析的误差。清洗数据时首先需要读取数据，然后观察数据中是否存在无用值、空值以及数据类型是否需要进行转换等。清洗二手房数据的具体步骤如下所示。<br>（1）读取二手房数据文件，显示部分数据。<br>程序代码如下：（源码位置：资源包\MR\Code\13\house_data_analysis\house_analysis.py）</p>
<p>01  import pandas as as pd                 #导入数据统计模块<br>02  data = pd.read_csv(‘data.csv’)          #读取csv数据文件<br>03  print(data.head())                      #打印文件内容的头部信息<br>运行程序，输出结果如图13.7所示。</p>
<p><img src="/.com//image-20211101110416616.png" alt="image-20211101110416616"></p>
<p>​                                                                                  图13.7　二手房数据（部分数据）<br>观察上述数据，首先“Unnamed: 0”索引列对于数据分析没有任何帮助，然后“总价”“建筑面积”“单价”列所对应的数据不是数值类型，所以无法进行计算。接下来对这些数据进行处理。<br>（2）将索引列“Unnamed: 0”删除；然后将数据中的所有空值删除；最后分别将“总价”“建筑面积”“单价”列所对应数据中的字符删除仅保留数字部分，再将数字转换为float类型，再次输出数据。<br>程序代码如下：（源码位置：资源包\MR\Code\13\house_data_analysis\house_analysis.py）</p>
<p><img src="/.com//image-20211101110741933.png" alt="image-20211101110741933">运行程序，输出结果如图13.8所示。</p>
<p><img src="/.com//image-20211101110803692.png" alt="image-20211101110803692"></p>
<p>​                                                                           图13.8　处理后的二手房数据（部分数据）</p>
<h3 id="2-5-2-区域二手房均价分析"><a href="#2-5-2-区域二手房均价分析" class="headerlink" title="2.5.2　区域二手房均价分析"></a>2.5.2　区域二手房均价分析</h3><p>实现区域二手房均价分析前，首先需要将数据按所属区域进行划分，然后计算每个区域的二手房均价，最后将区域及对应的房屋均价信息通过纵向条形图显示，具体步骤如下所示。<br>（1）通过groupby()方法实现二手房区域的划分，然后通过mean()方法计算出每个区域的二手房均价，最后分别通过index属性与values属性获取所有区域信息与对应的均价。<br>程序代码如下：（源码位置：资源包\MR\Code\13\house_data_analysis\house_analysis.py）</p>
<p><img src="/.com//image-20211101110827332.png" alt="image-20211101110827332"></p>
<p>（2）在主窗体初始化类中创建show_average_price()方法，用于绘制并显示各区二手房均价分析图。程序代码如下：（源码位置：资源包\MR\Code\13\house_data_analysis\show_window.py）</p>
<p><img src="/.com//image-20211101110953838.png" alt="image-20211101110953838"></p>
<p>（3）指定显示各区二手房均价分析图，按钮事件所对应的方法。<br>程序代码如下：（源码位置：资源包\MR\Code\13\house_data_analysis\show_window.py）</p>
<p>01 #显示各区二手房均价分析图，按钮事件<br>02 main.btn_1.triggered.connect(main.show_average_price)</p>
<p>（4）在主窗体工具栏中单击“各区二手房均价分析”按钮，显示各区二手房均价分析图，如图13.9所示。</p>
<p><img src="/.com//image-20211101111015267.png" alt="image-20211101111015267"></p>
<p>​                                                                             图13.9　各区二手房均价分析图</p>
<h3 id="2-5-3-区域二手房数据及占比分析"><a href="#2-5-3-区域二手房数据及占比分析" class="headerlink" title="2.5.3　区域二手房数据及占比分析"></a>2.5.3　区域二手房数据及占比分析</h3><p>在实现各区房子数量比例时，首先需要将数据中每个区域进行分组并获取每个区域的房子数量，然后获取每个区域与对应的二手房数量，最后计算每个区域二手房数量的百分比。具体步骤如下所示。<br>（1）通过groupby()方法对房子区域进行分组，并使用size()方法获取每个区域的分组数量（区域对应的房子数量），然后使用index属性与values属性分别获取每个区域与对应的二手房数量，最后计算每个区域房子数量的百分比。<br>程序代码如下：（源码位置：资源包\MR\Code\13\house_data_analysis\house_analysis.py）</p>
<p><img src="/.com//image-20211101111114194.png" alt="image-20211101111114194"></p>
<p>（2）在主窗体初始化类中创建show_house_number()方法，用于绘制并显示各区二手房数量所占比例的分析图。<br>程序代码如下：（源码位置：资源包\MR\Code\13\house_data_analysis\show_window.py）</p>
<p><img src="/.com//image-20211101111129394.png" alt="image-20211101111129394"></p>
<p>（3）指定显示各区二手房数量所占比例图，按钮事件所对应的方法。<br>程序代码如下：（源码位置：资源包\MR\Code\13\house_data_analysis\show_window.py）</p>
<p>01 #显示各区二手房数量所占比例图，按钮事件<br>02 main.btn_2.triggered.connect(main.show_house_number)<br>（4）在主窗体工具栏中单击“各区二手房数量所占比例”按钮，显示各区二手房数量及占比分析图，如图13.10所示。</p>
<p><img src="/.com//image-20211101111150978.png" alt="image-20211101111150978"></p>
<p>​                                                                          图13.10　各区二手房数量所占比例分析图</p>
<h3 id="2-5-4-全市二手房装修程度分析"><a href="#2-5-4-全市二手房装修程度分析" class="headerlink" title="2.5.4　全市二手房装修程度分析"></a>2.5.4　全市二手房装修程度分析</h3><p>在实现全市二手房装修程度分析时，首先需要将二手房的装修程度进行分组并将每个分组对应的数量统计出来，再将装修程度分类信息与对应的数量进行数据的分离工作，具体步骤如下所示。<br>（1）通过groupby()方法对房子的装修程度进行分组，并使用size()方法获取每个装修程度分组的数量，然后使用index属性与values属性分别获取每个装修程度分组与对应的数量。<br>程序代码如下：（源码位置：资源包\MR\Code\13\house_data_analysis\house_analysis.py）</p>
<p><img src="/.com//image-20211101111235322.png" alt="image-20211101111235322"></p>
<p>（2）在主窗体初始化类中创建show_renovation()方法，用于绘制并显示全市房子装修程度的分析图。<br>程序代码如下：（源码位置：资源包\MR\Code\13\house_data_analysis\show_window.py）</p>
<p><img src="/.com//image-20211101111257695.png" alt="image-20211101111257695"></p>
<p>（3）指定显示全市二手房装修程度分析图，按钮事件所对应的方法。<br>程序代码如下：（源码位置：资源包\MR\Code\13\house_data_analysis\show_window.py）</p>
<p>01 #显示全市二手房装修程度分析图，按钮事件<br>02 main.btn_3.triggered.connect(main.show_renovation)<br>（4）在主窗体工具栏中单击“全市二手房装修程度分析”按钮，显示全市二手房装修程度分析图，如图13.11所示。</p>
<p><img src="/.com//image-20211101111320801.png" alt="image-20211101111320801"></p>
<p>​                                                                      图13.11　全市二手房装修程度分析图</p>
<h3 id="2-5-5-热门户型均价分析"><a href="#2-5-5-热门户型均价分析" class="headerlink" title="2.5.5　热门户型均价分析"></a>2.5.5　热门户型均价分析</h3><p>在实现热门户型均价分析时，首先需要将户型进行分组并获取每个分组所对应的数量，然后对户型分组数量进行降序处理，提取前5组户型数据，作为热门户型的数据，最后计算每个户型的均价。具体步骤如下所示。<br>（1）通过groupby()方法对房子的户型进行分组，并使用size()方法获取每个户型分组的数量，使用sort_values()方法对户型分组数量进行降序处理。然后通过head(5)方法，提取前5组户型数据。再通过mean()方法计算每个户型的均价，最后使用index属性与values属性分别获取户型与对应的均价。<br>程序代码如下：（源码位置：资源包\MR\Code\13\house_data_analysis\house_analysis.py）</p>
<p><img src="/.com//image-20211101111410258.png" alt="image-20211101111410258"></p>
<p>（2）在主窗体初始化类中创建show_type()方法，绘制并显示热门户型均价的分析图。<br>程序代码如下：（源码位置：资源包\MR\Code\13\house_data_analysis\show_window.py）</p>
<p><img src="/.com//image-20211101111432393.png" alt="image-20211101111432393"></p>
<p>（3）指定显示热门户型均价分析图，按钮事件所对应的方法。<br>程序代码如下：（源码位置：资源包\MR\Code\13\house_data_analysis\show_window.py）</p>
<p>01 #显示热门户型均价分析图，按钮事件<br>02 main.btn_4.triggered.connect(main.show_type)<br>（4）在主窗体工具栏中单击“热门户型均价分析”按钮，显示热门户型均价分析图，效果如图13.12所示。</p>
<p><img src="/.com//image-20211101111504958.png" alt="image-20211101111504958"></p>
<p>​                                                                                    图13.12　热门户型均价分析图</p>
<h3 id="2-5-6-二手房房价预测"><a href="#2-5-6-二手房房价预测" class="headerlink" title="2.5.6　二手房房价预测"></a>2.5.6　二手房房价预测</h3><p>在实现二手房房价预测时，需要提供二手房源数据中的参考数据（特征值），这里将“户型”和“建筑面积”作为参考数据来进行房价的预测，所以需要观察“户型”数据是否符合分析条件。如果参考数据不符合分析条件，则需要再次对数据进行清洗处理。再通过源数据中已知的参考数据“户型”和“建筑面积”进行未知房价的预测。实现的具体步骤如下所示。<br>（1）查看源数据中“户型”和“建筑面积”数据，确认数据是否符合数据分析条件。<br>程序代码如下：（源码位置：资源包\MR\Code\13\house_data_analysis\house_analysis.py）</p>
<p><img src="/.com//image-20211101111609998.png" alt="image-20211101111609998"></p>
<p>运行程序，输出结果如图13.13所示。</p>
<p><img src="/.com//image-20211101111628674.png" alt="image-20211101111628674"></p>
<p>​                                                             图13.13　户型和建筑面积（部分数据）<br>（2）从输出结果得知：“户型”数据中包含文字信息，而文字信息并不能实现数据分析时的拟合工作，所以需要将“室”“厅”“卫”进行独立字段的处理。<br>程序代码如下：（源码位置：资源包\MR\Code\13\house_data_analysis\house_analysis.py）</p>
<p><img src="/.com//image-20211101111649911.png" alt="image-20211101111649911"></p>
<p>运行程序，输出结果如图13.14所示。</p>
<p><img src="/.com//image-20211101111733193.png" alt="image-20211101111733193"></p>
<p>​                                                                           图13.14　处理后的户型数据（部分数据）<br>（3）将数据中没有参考意义的数据删除，其中包含“小区名字”“户型”“朝向”“楼层”“装修”“区域”“单价”“空值”，然后将“建筑面积”小于300平方米的房子信息筛选出来。<br>程序代码如下：（源码位置：资源包\MR\Code\13\house_data_analysis\house_analysis.py）</p>
<p><img src="/.com//image-20211101111800005.png" alt="image-20211101111800005"></p>
<p>运行程序，输出结果如图13.15所示。</p>
<p><img src="/.com//image-20211101111814905.png" alt="image-20211101111814905"></p>
<p>​                                                            图13.15　“建筑面积”小于300平米的数据（部分数据）<br>（4）添加自定义预测数据，其中包含“总价”“建筑面积”“室”“厅”“卫”，总价数据为None，其他数据为模拟数据。然后进行数据的标准化，定义特征数据与目标数据，最后训练回归模型进行未知房价的预测。<br>程序代码如下：（源码位置：资源包\MR\Code\13\house_data_analysis\house_analysis.py）</p>
<p><img src="/.com//image-20211101111836971.png" alt="image-20211101111836971"></p>
<p>查看打印的“真实值”和“预测值”，其中索引编号</p>
<p>2505和2506均为添加自定义的预测数据，输出结果如图13.16所示。（由于数据过多，省略部分数据）</p>
<p><img src="/.com//image-20211101111933722.png" alt="image-20211101111933722"></p>
<p>​                                                                 图13.16　真实值和预测值（省略部分数据）<br>从输出结果得知：“总价”一列为房价的真实数据，而“y_pred”一列为房价的预测数据，其中索引为2505和2506为模拟的未知数据，所以“总价”列中的数据为空，而右侧的数据是根据已知的参考数据预测而来的。<br>（5）在主窗体初始化类中创建show_total_price()方法，用于绘制并显示二手房售价预测折线图。<br>程序代码如下：（源码位置：资源包\MR\Code\13\house_data_analysis\show_window.py）</p>
<p>01  def show_total_price(self):<br>02             true_price,forecast_price = house_analysis.get_price_forecast()   #获取预测房价<br>03             chart.broken_line(true_price,forecast_price,’二手房售价预测’)     #绘制及显示图表<br>（6）指定显示全市二手房户售价预测图，按钮事件所对应的方法。<br>程序代码如下：（源码位置：资源包\MR\Code\13\house_data_analysis\show_window.py）</p>
<p>01 #显示全市二手房户售价预测图，按钮事件<br>02 main.btn_5.triggered.connect(main.show_total_price)<br>（7）在主窗体工具栏中单击“二手房售价预测”按钮，显示全市二手房房价预测分析图，效果如图13.17所示。</p>
<p><img src="/.com//image-20211101112023856.png" alt="image-20211101112023856"></p>
<p>​                                                                     图13.17　全市二手房房价预测折线图</p>
<p>说明<br>为了清晰地体现二手房房价预测数据，以上选择了展示部分数据，即索引为2490以后的预测房价，其中预测房价多出的部分为索引2505和2506的预测房价。</p>
<h2 id="2-6-小结"><a href="#2-6-小结" class="headerlink" title="2.6　小结"></a>2.6　小结</h2><p>本章主要使用Python开发了二手房房价分析与预测系统，该项目主要应用了Pandas和Scikit-Learn模块。其中Pandas模块主要用于实现数据的预处理以及数据的分类等，而Scikit-Learn模块主要用于实现数据的回归模型以及预测功能，最后通过绘图模块Matplotlib，将分析后的数据绘制成图表，从而形成更直观的可视化数据。在开发中，数据分析是该项目的重点与难点，需要读者认真领会其中的算法，方便读者开发其他项目。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>数据统计</title>
    <url>/2020/12/09/plt%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="第9章-数据统计分析案例"><a href="#第9章-数据统计分析案例" class="headerlink" title="第9章　数据统计分析案例"></a>第9章　数据统计分析案例</h1><p>本章以案例为主，通过简单的知识讲解使读者了解数据统计分析中常用的分析方法，如对比分析，同比、定比和环比分析，贡献度分析，差异化分析，相关性分析和时间序列分析的概念。通过典型案例，将数据统计分析方法与前面学习的内容相结合，力求将所学内容应用到实践中。</p>
<h1 id="9-1-对比分析"><a href="#9-1-对比分析" class="headerlink" title="9.1　对比分析"></a>9.1　对比分析</h1><h2 id="9-1-1-什么是对比分析"><a href="#9-1-1-什么是对比分析" class="headerlink" title="9.1.1　什么是对比分析"></a>9.1.1　什么是对比分析</h2><p>对比分析法是将两个或两个以上的数据进行比较，分析其中的差异，从而揭示这些事物代表的发展变化情况和规律性。 特点：非常直观地看出事物某方面的变化或差距，而且可以准确、量化地表示出变化的差距是多少。 对比分析法通常是把两个相互联系的指标数据进行比较，从数量上展示和说明研究对象规模的大小、水平的高低、速度的快慢，以及各种关系是否协调。对比分析一般来说有以下几种对比方法：纵向对比、横向对比、标准对比、实际与计划对比。</p>
<h2 id="9-1-2-案例：对比分析各品牌销量表现TOP10"><a href="#9-1-2-案例：对比分析各品牌销量表现TOP10" class="headerlink" title="9.1.2　案例：对比分析各品牌销量表现TOP10"></a>9.1.2　案例：对比分析各品牌销量表现TOP10</h2><p>案例位置：资源包\MR\Code\09\example\01 对比国产各品牌汽车2020年1月销量，效果如图9.1所示。 程序代码如下：</p>
<p><img src="/.com//%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%5Cimage-20211101091340914.png" alt="image-20211101091340914"></p>
<p><img src="/.com//%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%5Cimage-20211101091429952.png" alt="image-20211101091429952"></p>
<p>​                                                                                     图9.1　对比分析各品牌销量表现TOP10</p>
<h1 id="9-2-同比、定比和环比分析"><a href="#9-2-同比、定比和环比分析" class="headerlink" title="9.2　同比、定比和环比分析"></a>9.2　同比、定比和环比分析</h1><p>在数据分析中，有一个重要的分析方法，叫趋势分析法，即将两期或连续数期报告中某一指标进行对比，确定其增减变动的方向、数额和幅度，以确定该指标的变动趋势。趋势分析法中的指标，有同比分析、定比（定基比）分析和环比分析，以及同比增长率分析、定比（定基比）增长率分析和环比增长率分析。</p>
<h2 id="9-2-1-同比、定比和环比概述"><a href="#9-2-1-同比、定比和环比概述" class="headerlink" title="9.2.1　同比、定比和环比概述"></a>9.2.1　同比、定比和环比概述</h2><p>首先了解一下同比、定比和环比的概念。　</p>
<p>同比：本期数据与历史同期数据比较。例如，2021年11月份与2020年11月份相比较。　</p>
<p>定比：本期数据与特定时期的数据比较。例如，2021年11月与2019年12月份相比较。　</p>
<p>环比：本期数据与上期数据比较。例如，2021年11月份与2020年11月份相比较。</p>
<p>同比的好处是可以排除一部分季节因素；环比的好处是可以更直观地表明阶段性的变换，但是会受季节性因素影响；定比常用于财务数据分析。下面来看一个生活中经常出现的场景。　同比：去年这个这时候这条裙子我还能穿，现在穿不进去啦！　定比：年龄，50岁是25岁的两倍。　环比：这个月好像比上个月胖了。 下面简单介绍一下同比、定比和环比计算的公式。</p>
<h3 id="1．同比"><a href="#1．同比" class="headerlink" title="1．同比"></a>1．同比</h3><p>同比的计算公式如下：</p>
<p><img src="/.com//%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%5Cimage-20211101091544403.png" alt="image-20211101091544403"></p>
<h3 id="2．定比"><a href="#2．定比" class="headerlink" title="2．定比"></a>2．定比</h3><p>定比的计算公式如下：</p>
<p><img src="/.com//%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%5Cimage-20211101091601809.png" alt="image-20211101091601809"></p>
<h3 id="3．环比"><a href="#3．环比" class="headerlink" title="3．环比"></a>3．环比</h3><p>环比增长率反映本期比上期增长了多少，公式如下：</p>
<p><img src="/.com//%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%5Cimage-20211101091624602.png" alt="image-20211101091624602"></p>
<p>环比发展速度是本期水平与前一期水平之比，反映前后两期的发展变化情况，公式如下：</p>
<p><img src="/.com//%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%5Cimage-20211101091640229.png" alt="image-20211101091640229"></p>
<h2 id="9-2-2-案例1：京东电商单品销量同比增长情况分析"><a href="#9-2-2-案例1：京东电商单品销量同比增长情况分析" class="headerlink" title="9.2.2　案例1：京东电商单品销量同比增长情况分析"></a>9.2.2　案例1：京东电商单品销量同比增长情况分析</h2><p>案例位置：资源包\MR\Code\09\example\02\01 下面分析2020年2月与2019年2月相比，京东电商《零基础学Python（全彩版）》一书销量同比增长情况，效果如图9.2所示。 从分析结果得知：上海、武汉同比增长较小。</p>
<p><img src="/.com//%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%5Cimage-20211101091708101.png" alt="image-20211101091708101"></p>
<p>​                                                                                                              图9.2　同比分析 程序代码如下：</p>
<p><img src="/.com//%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%5Cimage-20211101091740885.png" alt="image-20211101091740885"></p>
<h2 id="9-2-3-案例2：单品销量定比分析"><a href="#9-2-3-案例2：单品销量定比分析" class="headerlink" title="9.2.3　案例2：单品销量定比分析"></a>9.2.3　案例2：单品销量定比分析</h2><p>案例位置：资源包\MR\Code\09\example\02\02 下面实现京东电商《零基础学Python（全彩版）》一书2019年销量定比分析，以2019年1月为基期，基点为1，效果如图9.3所示。</p>
<p><img src="/.com//%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%5Cimage-20211101091933203.png" alt="image-20211101091933203"></p>
<p>​                                                                                                      图9.3　定比分析 从图9.3中可以看到，6月开始呈现连续小幅度增长，到11月开始大幅度增长，定比指数较10月提高了3.028个点。 程序代码如下：</p>
<p><img src="/.com//%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%5Cimage-20211101092002261.png" alt="image-20211101092002261"></p>
<h2 id="9-2-4-案例3：单品销量环比增长情况分析"><a href="#9-2-4-案例3：单品销量环比增长情况分析" class="headerlink" title="9.2.4　案例3：单品销量环比增长情况分析"></a>9.2.4　案例3：单品销量环比增长情况分析</h2><p>案例位置：资源包\MR\Code\09\example\02\03 下面分析京东电商《零基础学Python（全彩版）》一书2019年销量环比增长情况，效果如图9.4所示。</p>
<p><img src="/.com//%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%5Cimage-20211101092041392.png" alt="image-20211101092041392"></p>
<p>​                                                                                                    图9.4　环比分析 程序代码如下：</p>
<p><img src="/.com//%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%5Cimage-20211101092113806.png" alt="image-20211101092113806"></p>
<p>实用技巧 在使用Matplotlib绘制图表时，发现了一个警告Warining，如图9.5所示。</p>
<p><img src="/.com//%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%5Cimage-20211101092157969.png" alt="image-20211101092157969"></p>
<p>​                                                                                                                  图9.5　警告信息 完整警告信息如下： MatplotlibDeprecationWarning: Adding an axes using the same arguments as a previous axes currently reuses the earlier instance. In a future version, a new instance will always be created and returned. Meanwhile, this warning can be suppressed, and the future behavior ensured, by passing a unique label to each axes instance. “Adding an axes using the same arguments as a previous axes “ 解决方法： 出现上述警告，原因是在创建画布fig=plt.figure()后就设置了图表标题或坐标轴标签，将图表标题或坐标轴标签相关代码放置在定义子图ax=fig.add_subplot(111)代码后就不会出现警告信息了。</p>
<h1 id="9-3-贡献度分析（帕累托法则）"><a href="#9-3-贡献度分析（帕累托法则）" class="headerlink" title="9.3　贡献度分析（帕累托法则）"></a>9.3　贡献度分析（帕累托法则）</h1><h2 id="9-3-1-什么是贡献度分析"><a href="#9-3-1-什么是贡献度分析" class="headerlink" title="9.3.1　什么是贡献度分析"></a>9.3.1　什么是贡献度分析</h2><p>贡献度分析又称80/20法则、二八法则、帕累托法则、帕累托定律、最省力法则或不平衡原则。 该法则是由意大利经济学家“帕累托”提出的。80/20法则认为：原因和结果、投入和产出、努力和报酬之间本来存在着无法解释的不平衡。例如，一个公司80%的利润常常来自20%的产品，那么使用贡献度分析就可以分析获利最高的20%的产品。 下面简单介绍一下贡献率相关算法。</p>
<p><img src="/.com//%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%5Cimage-20211101092249403.png" alt="image-20211101092249403"></p>
<p>通过上述公式得出累计贡献率，当累计贡献率接近80%时（不一定正好是80%)，然后找到该产品在图表中相应的位置并进行标注。说明 真正的比例不一定正好是80%:20%。80/20法则表明在多数情况下该关系很可能是不平衡的，并且接近于80/20。</p>
<h2 id="9-3-2-案例：产品贡献度分析"><a href="#9-3-2-案例：产品贡献度分析" class="headerlink" title="9.3.2　案例：产品贡献度分析"></a>9.3.2　案例：产品贡献度分析</h2><p>案例位置：资源包\MR\Code\09\example\03 下面分析淘宝电商全彩系列图书2018年上半年销售收入占比80%的产品。首先，使用9.3.1节中的公式计算产品累计贡献率，结果如图9.6所示。从图9.6中可以看出，到图书编号B13时，累计贡献率就已达到了0.817665（接近总销售收入的80%），其中共有10种产品，接下来在图表中进行标注，如图9.7所示。</p>
<p><img src="/.com//%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%5Cimage-20211101092358482.png" alt="image-20211101092358482"></p>
<p>​                                                                                         图9.6　输出累计贡献率</p>
<p><img src="/.com//%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%5Cimage-20211101092428830.png" alt="image-20211101092428830"></p>
<p>​                                                                                                   图9.7　产品贡献度分析 程序代码如下：</p>
<p><img src="/.com//%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%5Cimage-20211101092455112.png" alt="image-20211101092455112"></p>
<h1 id="9-4-差异化分析"><a href="#9-4-差异化分析" class="headerlink" title="9.4　差异化分析"></a>9.4　差异化分析</h1><h2 id="9-4-1-差异化概述"><a href="#9-4-1-差异化概述" class="headerlink" title="9.4.1　差异化概述"></a>9.4.1　差异化概述</h2><p>任何事物都存在差异，如同上课听讲，有人津津有味，有人昏昏欲睡。 那么，通过差异化分析，比较不同事物之间在某个指标上存在的差异，根据差异定制不同的策略。对于产品而言，差异化分析是指企业在其提供给顾客的产品上，通过各种方法满足顾客的偏好，使顾客能够把它同其他竞争企业提供的同类产品有效地区别开来，从而使企业在市场竞争中占据有利的地位。 比较常见的有性别差异、年龄差异。通过差异化分析比较不同性别之间在某个指标上存在的差异，通过分析结果对不同性别定制不同的方案。例如，分析不同性别的同学在学习成绩上的差异，了解男生和女生之间的这些差异，因材施教，定制不同的弥补弱项的方案。对于女生，可以有意识地培养她的思维能力；而对于男生，可以买些书籍，来增强他薄弱的方面。 年龄差异化分析，了解不同年龄的需求，投其所好，使企业的利润最大化。例如，网购、自媒体、汽车、旅游等行业，通过年龄差异化分析，找出不同年龄段用户群体的喜好，从而增加产品销量。</p>
<h2 id="9-4-2-案例：学生成绩性别差异分析"><a href="#9-4-2-案例：学生成绩性别差异分析" class="headerlink" title="9.4.2　案例：学生成绩性别差异分析"></a>9.4.2　案例：学生成绩性别差异分析</h2><p>案例位置：资源包\MR\Code\09\example\04 “女孩喜欢毛绒玩具，男孩喜欢车”这大概是天生的。 科学研究表明，男孩和女孩的差别在相当程度上是由生理基础决定的。通过高科技扫描就可以发现，男孩和女孩的大脑都会有某些部位比对方相应的部位更发达、更忙碌。 随着孩子的成长，这种天生的性别差异就会对孩子的学习有所影响，并且不断强化。而反过来，学习的本身也在改变着大脑的机能发育。因为当孩子玩耍和学习时，相对应的脑细胞就会更加活跃且随时更新，而那些不经常使用的部分将会逐渐退化萎缩。 下面我们用数据说话，通过雷达图分析男生、女生各科成绩差异，效果如图9.8所示。</p>
<p><img src="/.com//%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%5Cimage-20211101093258671.png" alt="image-20211101093258671"></p>
<p>​                                                                                 图9.8　男生、女生各科成绩差异分析 从分析结果得知：男生数学和物理高于女生，而女生在英语和语文上略占优势。针对性别差异造成学习成绩的差距，应该采取因材施教，从而提高女生的数学和物理成绩</p>
<p>男生的语文和英语成绩。 程序代码如下：</p>
<p><img src="/.com//%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%5Cimage-20211101093347266.png" alt="image-20211101093347266"></p>
<h1 id="9-5-相关性分析"><a href="#9-5-相关性分析" class="headerlink" title="9.5　相关性分析"></a>9.5　相关性分析</h1><h2 id="9-5-1-相关性概述"><a href="#9-5-1-相关性概述" class="headerlink" title="9.5.1　相关性概述"></a>9.5.1　相关性概述</h2><p>任何事物之间都存在一定的联系。例如，夏天温度的高低与空调的销量就存在相关性。当温度升高时，空调的销量也会相应提高。 相关性分析是指对多个具备相关关系的数据进行分析，从而衡量数据之间的相关程度或密切程度。相关性可以应用到所有数据的分析过程中。如果一组数据的改变引发另一组数据朝相同方向变化，那么这两组数据存在正相关性，例如，身高与体重，一般个子高的人体重会重一些，个子矮的人体重会轻一些；如果一组数据的改变引发另一组数据朝相反方向变化，那么这两组数据存在负相关性，例如，运动与体重。</p>
<h2 id="9-5-2-案例：广告展现量与费用成本相关性分析"><a href="#9-5-2-案例：广告展现量与费用成本相关性分析" class="headerlink" title="9.5.2　案例：广告展现量与费用成本相关性分析"></a>9.5.2　案例：广告展现量与费用成本相关性分析</h2><p>案例位置：资源包\MR\Code\09\example\05 为了促进销售，电商营销必然要投入广告，这样就会产生广告展现量和费用成本相关的数据。通常情况下，我们认为费用高，广告效果就好，它们之间必然存在联系，但仅通过主观判断没有说服力，无法证明数据之间关系的真实存在，也无法度量它们之间关系的强弱。因此，我们要通过相关性分析来找出数据之间的关系。 下面来看一下费用成本与广告展现量相关数据情况（由于数据太多，只显示部分数据），如图9.9和图9.10所示。</p>
<p><img src="/.com//%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%5Cimage-20211101093655985.png" alt="image-20211101093655985"></p>
<p>​                                                                                                图9.9　费用成本</p>
<p><img src="/.com//%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%5Cimage-20211101093722813.png" alt="image-20211101093722813"></p>
<p>​                                                                                                图9.10　广告展现量 相关性分析方法很多，简单的相关性分析方法是将数据进行可视化处理，单纯从数据的角度很难发现数据之间的趋势和联系，而将数据绘制成图表后就可以直观地看出数据之间的趋势和联系。 下面通过散点图看一看广告展现量与费用成本的相关性，效果如图9.11所示。</p>
<p><img src="/.com//%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%5Cimage-20211101093751243.png" alt="image-20211101093751243"></p>
<p>​                                                                                                            图9.11　散点图 首先对数据进行简单处理，由于“费用.xlsx”表中同一天会产生多个类型的费用，所以需要按天统计费用，然后将“展现量.xlsx”和“费用.xlsx”两张表的数据合并，最后绘制散点图，程序代码如下：</p>
<p><img src="/.com//%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%5Cimage-20211101093837899.png" alt="image-20211101093837899"></p>
<p>虽然图表清晰地展示了广告展现量与费用成本的相关性，但无法判断数据之间有什么关系，相关关系也没有准确地度量，并且数据超过两组时也无法完成各组数据的相关性分析。 下面再介绍一种方法——相关系数方法。相关系数是反映数据之间关系密切程度的统计指标，相关系数的取值区间为1～-1。1表示数据之间完全正相关（线性相关）；-1表示数据之间完全负相关；0表示数据之间不相关。数据越接近0表示相关关系越弱，越接近1表示相关关系越强。 计算相关系数需要一定的计算公式，而在Python中无须使用烦琐的公式，通过DataFrame对象提供的corr()函数就可以轻松实现，关键代码如下：</p>
<p>data.corr() 运行程序，输出结果如图9.12所示。</p>
<p><img src="/.com//%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%5Cimage-20211101093902187.png" alt="image-20211101093902187"></p>
<pre><code>                                                                                             图9.12　各组数据的相关系数
</code></pre>
<p>从分析结果得知：“费用”与“费用”自身的相关性是1，与“展现量”“点击量”的相关系数分别是0.856013、0.858597；“展现量”与“展现量”自身的相关性是1，与“点击量”“订单金额”的相关系数分别是0.938554、0.728037。那么，除了“商品关注数”相关系数比较低，其他都很高，可以看出“费用”与“展现量”“点击量”等有一定的正相关性，而且相关性很强。 相关系数的优点是可以通过数字对变量的关系进行度量，并且带有方向性，1表示正相关，-1表示负相关，越靠近0相关性越弱。缺点是无法利用这种关系对数据进行预测。</p>
<h1 id="9-6-时间序列分析"><a href="#9-6-时间序列分析" class="headerlink" title="9.6　时间序列分析"></a>9.6　时间序列分析</h1><h2 id="9-6-1-时间序列概述"><a href="#9-6-1-时间序列概述" class="headerlink" title="9.6.1　时间序列概述"></a>9.6.1　时间序列概述</h2><p>顾名思义，时间序列就是按照时间顺序排列的一组数据序列。时间序列分析就是找出数据变化发展的规律，从而预测未来的走势。 时间序列分析有以下几种表现形式。　长期趋势变化：受某种因素的影响，数据依据时间变化，按某种规则稳步增长或下降。使用的分析方法有移动平均法、指数平滑法等。　季节性周期变化：受季节更替等因素影响，数据依据固定周期规则性的变化。季节性周期变化，不局限于自然季节，还包括月、周等短期周期。例如，空调、羽绒服、冷饮的销售，双十一、双十二流量在一周之内的波动等。采用的方法为季节指数。　循环变化：指一种较长时间的上、下起伏周期性波动，一般循环时间为2～15年。　随机性变化：由许多不确定因素引起的数据变化，在时间序列中无法预计。</p>
<h2 id="9-6-2-案例：年增长趋势和季节性波动分析"><a href="#9-6-2-案例：年增长趋势和季节性波动分析" class="headerlink" title="9.6.2　案例：年增长趋势和季节性波动分析"></a>9.6.2　案例：年增长趋势和季节性波动分析</h2><p>案例位置：资源包\MR\Code\09\example\06 下面分析淘宝店铺近3年增长趋势和季节性波动，如图9.13所示。从分析结果得出，近3年淘宝店铺收入呈现持续稳定增长趋势，但2019年有所下降，季节性波动比较明显，每年的第4季度是销售“旺季”。 程序代码如下：</p>
<p><img src="/.com//%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%5Cimage-20211101094004956.png" alt="image-20211101094004956"></p>
<p><img src="/.com//%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%5Cimage-20211101094315925.png" alt="image-20211101094315925"></p>
<p>​                                                                                                             图9.13　年增长趋势和季节性波动</p>
<h1 id="9-7-小结"><a href="#9-7-小结" class="headerlink" title="9.7　小结"></a>9.7　小结</h1><p>本章通过常用的数据分析方法并结合图表，以案例的形式呈现，每一种分析方法都对应一个恰当的分析案例，一张贴切的图表，力求使读者能够真正理解数据分析，并将其应用到实际数据分析工作中。每一个案例都经过作者反复揣摩，希望能够对读者有所帮助。</p>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
  </entry>
  <entry>
    <title>vue-过滤器</title>
    <url>/2021/04/03/vue-%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    <content><![CDATA[<h2 id="一、全局过滤器"><a href="#一、全局过滤器" class="headerlink" title="一、全局过滤器"></a>一、全局过滤器</h2><pre><code>// 第一个参数表示：过滤器的名称
// 第二个参数表示：函数，使用过滤器的时候，这个函数中的代码会被执行
Vue.filter(&#39;filterName&#39;, function (value) &#123;
  // value 表示要过滤的内容
&#125;)
</code></pre>
<p><strong>例子</strong></p>
<pre><code>Vue.filter(&#39;date&#39;, function (input, format = &#39;yyyy-MM-dd hh:mm:ss&#39;）&#123;
      var o = &#123;
        &quot;M+&quot;: input.getMonth() + 1, //月份 
        &quot;d+&quot;: input.getDate(), //日 
        &quot;h+&quot;: input.getHours(), //小时 
        &quot;m+&quot;: input.getMinutes(), //分 
        &quot;s+&quot;: input.getSeconds(), //秒 
        &quot;q+&quot;: Math.floor((input.getMonth() + 3) / 3), //季度 
        &quot;S&quot;: input.getMilliseconds() //毫秒 
      &#125;;

      if (/(y+)/.test(format)) format = format.replace(RegExp.$1, (input.getFullYear() + &quot;&quot;).substr(4 - RegExp.$1.length));
      // 不够2位的前面补0
      for (var k in o)
        if (new RegExp(&quot;(&quot; + k + &quot;)&quot;).test(format)) 
        format = format.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : ((&quot;00&quot; + o[k]).substr((&quot;&quot; + o[k]).length)));
      return format;
    &#125;)
</code></pre>
<p>使用</p>
<pre><code>&lt;h1&gt;&#123;&#123;item.time | date('yyyy-MM-dd hh:mm:ss')&#125;&#125;&lt;/h1&gt;
</code></pre>
<blockquote>
<p>一个项目中，可能要用到很多过滤器来处理数据，多个组件公用的，可以注册全局过滤器。单个组件使用的，就挂载到实例<code>filters</code>中。项目做的多了以后，可以整理一套常用的<code>filters</code>，不用反复的写。比如：时间等各种操作，数据格式转化，单位换算，部分数据的<code>md5</code>加密等…</p>
</blockquote>
<p><strong>创建一个filters专门放各种过滤器</strong></p>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/622.png" alt="img"></p>
<blockquote>
<p>filter.js</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/623.png" alt="img"></p>
<blockquote>
<p>main.js</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/624.png" alt="img"></p>
<blockquote>
<p>页面上直接用 ’｜过滤器名‘ 即可</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/625.png" alt="img"></p>
<blockquote>
<p>或者直接在<code>main.js</code>中直接自定义全局过滤器</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/626.png" alt="img"></p>
<h2 id="二、局部过滤器"><a href="#二、局部过滤器" class="headerlink" title="二、局部过滤器"></a>二、局部过滤器</h2><blockquote>
<p>在某一个vue实例的内创建的，只在当前实例中起作用</p>
</blockquote>
<pre><code>new Vue(&#123;
  data:&#123;
      
  &#125;,
   // 通过 filters 属性创建局部过滤器
   // 注意：此处为 filters
  filters: &#123;
    filterName: function(value, format) &#123;&#125;
  &#125;
&#125;)
</code></pre>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue双向绑定（一）</title>
    <url>/2019/09/02/vue%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<h2 id="数据劫持"><a href="#数据劫持" class="headerlink" title="数据劫持"></a>数据劫持</h2><p>vue.js 则是采用数据劫持结合发布者-订阅者的方式，通过<strong>object.defineproperty()<strong>来劫持各个属性的</strong>setter</strong>，<strong>getter</strong>，在数据变动时发布消息给订阅者，触发相应的监听回调。</p>
<h2 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h2><p>已经了解到vue是通过数据劫持的方式来做数据绑定的，其中最核心的方法便是通过**object.defineproperty()**来实现对属性的劫持，达到监听数据变动的目的，无疑这个方法是本文中最重要、最基础的内容之一。<br>整理了一下，要实现mvvm的双向数据绑定，就必须要实现以下几点：</p>
<ol>
<li>实现一个数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者</li>
<li>实现一个指令解析器Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数</li>
<li>实现一个watcher，作为连接Observer和Compile的桥梁，能够订阅并受到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图</li>
<li>mvvm入口函数，整合以上三者</li>
</ol>
<p><img src="/.com//1.png"></p>
<p>下一篇实现Observer</p>
]]></content>
  </entry>
  <entry>
    <title>Vue  单文件</title>
    <url>/2021/11/24/vue%E5%8D%95%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="初识Vue："><a href="#初识Vue：" class="headerlink" title="初识Vue："></a>初识Vue：</h1><p>​        1.想让Vue工作，就必须创建一个Vue实例，且要传入一个配置对象；</p>
<p>​        2.root容器里的代码依然符合html规范，只不过混入了一些特殊的Vue语法；</p>
<p>​        3.root容器里的代码被称为【Vue模板】；</p>
<p>​        4.Vue实例和容器是一一对应的；</p>
<p>​        5.真实开发中只有一个Vue实例，并且会配合着组件一起使用；</p>
<p>​        6.中的xxx要写js表达式，且xxx可以自动读取到data中的所有属性；</p>
<p>​        7.一旦data中的数据发生改变，那么页面中用到该数据的地方也会自动更新；</p>
<p>​        注意区分：js表达式 和 js代码(语句)</p>
<pre><code class="javascript">            1.表达式：一个表达式会产生一个值，可以放在任何一个需要值的地方：

​                  (1). a

​                  (2). a+b

​                  (3). demo(1)

​                  (4). x === y ? &#39;a&#39; : &#39;b&#39;
</code></pre>
<pre><code>            2.js代码(语句)

​                  (1). if()&#123;&#125;

​                  (2). for()&#123;&#125;
</code></pre>
<h1 id="Vue模板语法有2大类："><a href="#Vue模板语法有2大类：" class="headerlink" title="Vue模板语法有2大类："></a>Vue模板语法有2大类：</h1><h2 id="1-插值语法："><a href="#1-插值语法：" class="headerlink" title="1.插值语法："></a>1.插值语法：</h2><p>​              功能：用于解析标签体内容。</p>
<p>​              写法：，xxx是js表达式，且可以直接读取到data中的所有属性。</p>
<h2 id="2-指令语法："><a href="#2-指令语法：" class="headerlink" title="2.指令语法："></a>2.指令语法：</h2><p>​              功能：用于解析标签（包括：标签属性、标签体内容、绑定事件…..）。</p>
<p>​              举例：v-bind:href=”xxx” 或 简写为 :href=”xxx”，xxx同样要写js表达式，</p>
<p>​                   且可以直接读取到data中的所有属性。</p>
<p>​              备注：Vue中有很多的指令，且形式都是：v-????，此处我们只是拿v-bind举个例子。</p>
<h1 id="Vue中有2种数据绑定的方式："><a href="#Vue中有2种数据绑定的方式：" class="headerlink" title="Vue中有2种数据绑定的方式："></a>Vue中有2种数据绑定的方式：</h1><p>​          1.单向绑定(v-bind)：数据只能从data流向页面。</p>
<p>​          2.双向绑定(v-model)：数据不仅能从data流向页面，还可以从页面流向data。</p>
<p>​            备注：</p>
<p>​                1.双向绑定一般都应用在表单类元素上（如：input、select等）</p>
<p>​                2.v-model:value 可以简写为 v-model，因为v-model默认收集的就是value值。</p>
<h1 id="data与el的2种写法"><a href="#data与el的2种写法" class="headerlink" title="data与el的2种写法"></a>data与el的2种写法</h1><h2 id="1-el有2种写法"><a href="#1-el有2种写法" class="headerlink" title="1.el有2种写法"></a>1.el有2种写法</h2><p>​                  (1).new Vue时候配置el属性。</p>
<p>​                  (2).先创建Vue实例，随后再通过vm.$mount(‘#root’)指定el的值。</p>
<h2 id="2-data有2种写法"><a href="#2-data有2种写法" class="headerlink" title="2.data有2种写法"></a>2.data有2种写法</h2><p>​                  (1).对象式</p>
<p>​                  (2).函数式</p>
<p>​                  如何选择：目前哪种写法都可以，以后学习到组件时，data必须使用函数式，否则会报错。</p>
<h2 id="3-一个重要的原则："><a href="#3-一个重要的原则：" class="headerlink" title="3.一个重要的原则："></a>3.一个重要的原则：</h2><p>​                  由Vue管理的函数，一定不要写箭头函数，一旦写了箭头函数，this就不再是Vue实例了。</p>
<h1 id="MVVM模型"><a href="#MVVM模型" class="headerlink" title="MVVM模型"></a>MVVM模型</h1><pre><code>            \1. M：模型(Model) ：data中的数据

​            \2. V：视图(View) ：模板代码

​            \3. VM：视图模型(ViewModel)：Vue实例
</code></pre>
<p>​      观察发现：</p>
<p>​            1.data中所有的属性，最后都出现在了vm身上。</p>
<p>​            2.vm身上所有的属性 及 Vue原型上所有属性，在Vue模板中都可以直接使用。</p>
<h1 id="回顾Object-defineproperty方法"><a href="#回顾Object-defineproperty方法" class="headerlink" title="回顾Object.defineproperty方法"></a>回顾Object.defineproperty方法</h1><pre><code class="javascript">&lt;script type=&quot;text/javascript&quot; &gt;
let number = 18
let person = &#123;
name:&#39;张三&#39;,
sex:&#39;男&#39;,
&#125;

Object.defineProperty(person,&#39;age&#39;,&#123;
// value:18,
// enumerable:true, //控制属性是否可以枚举，默认值是false
// writable:true, //控制属性是否可以被修改，默认值是false
// configurable:true //控制属性是否可以被删除，默认值是false

//当有人读取person的age属性时，get函数(getter)就会被调用，且返回值就是age的值
get()&#123;
console.log(&#39;有人读取age属性了&#39;)
return number
&#125;,

//当有人修改person的age属性时，set函数(setter)就会被调用，且会收到修改的具体值
set(value)&#123;
console.log(&#39;有人修改了age属性，且值是&#39;,value)
number = value
&#125;

&#125;)

// console.log(Object.keys(person))

console.log(person)
&lt;/script&gt;
</code></pre>
<h1 id="何为数据代理"><a href="#何为数据代理" class="headerlink" title="何为数据代理"></a>何为数据代理</h1><pre><code class="javascript">&lt;!-- 数据代理：通过一个对象代理对另一个对象中属性的操作（读/写）--&gt;
        &lt;script type=&quot;text/javascript&quot; &gt;
            let obj = &#123;x:100&#125;
            let obj2 = &#123;y:200&#125;

            Object.defineProperty(obj2,&#39;x&#39;,&#123;
                get()&#123;
                    return obj.x
                &#125;,
                set(value)&#123;
                    obj.x = value
                &#125;
            &#125;)
        &lt;/script&gt;
</code></pre>
<h1 id="Vue中的数据代理"><a href="#Vue中的数据代理" class="headerlink" title="Vue中的数据代理"></a>Vue中的数据代理</h1><pre><code class="javascript">1.Vue中的数据代理：
    通过vm对象来代理data对象中属性的操作（读/写）
2.Vue中数据代理的好处：
    更加方便的操作data中的数据
3.基本原理：
    通过Object.defineProperty()把data对象中所有属性添加到vm上。
    为每一个添加到vm上的属性，都指定一个getter/setter。
    在getter/setter内部去操作（读/写）data中对应的属性。
</code></pre>
<h1 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h1><p>事件的基本使用：</p>
<pre><code class="javascript">              1.使用v-on:xxx 或 @xxx 绑定事件，其中xxx是事件名；

​              2.事件的回调需要配置在methods对象中，最终会在vm上；

​              3.methods中配置的函数，不要用箭头函数！否则this就不是vm了；

​              4.methods中配置的函数，都是被Vue所管理的函数，this的指向是vm 或 组件实例对象；

​              5.@click=&quot;demo&quot; 和 @click=&quot;demo($event)&quot; 效果一致，但后者可以传参；
</code></pre>
<pre><code class="javascript">Vue中的事件修饰符：

​            1.prevent：阻止默认事件（常用）；

​            2.stop：阻止事件冒泡（常用）；

​            3.once：事件只触发一次（常用）；

​            4.capture：使用事件的捕获模式；

​            5.self：只有event.target是当前操作的元素时才触发事件；

​            6.passive：事件的默认行为立即执行，无需等待事件回调执行完毕；
</code></pre>
<pre><code class="javascript">1.Vue中常用的按键别名：
                            回车 =&gt; enter
                            删除 =&gt; delete (捕获“删除”和“退格”键)
                            退出 =&gt; esc
                            空格 =&gt; space
                            换行 =&gt; tab (特殊，必须配合keydown去使用)
                            上 =&gt; up
                            下 =&gt; down
                            左 =&gt; left
                            右 =&gt; right

                2.Vue未提供别名的按键，可以使用按键原始的key值去绑定，但注意要转为kebab-case（短横线命名）

                3.系统修饰键（用法特殊）：ctrl、alt、shift、meta
                            (1).配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发。
                            (2).配合keydown使用：正常触发事件。

                4.也可以使用keyCode去指定具体的按键（不推荐）

                5.Vue.config.keyCodes.自定义键名 = 键码，可以去定制按键别名
</code></pre>
<h1 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h1><h3 id="插值语法实现"><a href="#插值语法实现" class="headerlink" title="插值语法实现"></a>插值语法实现</h3><pre><code>html
    &lt;!-- 准备好一个容器--&gt;
        &lt;div id=&quot;root&quot;&gt;
            姓：&lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; &lt;br/&gt;&lt;br/&gt;
            名：&lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt; &lt;br/&gt;&lt;br/&gt;
            全名：&lt;span&gt;&#123;&#123;firstName&#125;&#125;-&#123;&#123;lastName&#125;&#125;&lt;/span&gt;
        &lt;/div&gt;
js
    new Vue(&#123;
            el:&#39;#root&#39;,
            data:&#123;
                firstName:&#39;张&#39;,
                lastName:&#39;三&#39;
            &#125;
        &#125;)
</code></pre>
<h3 id="methods实现"><a href="#methods实现" class="headerlink" title="methods实现"></a>methods实现</h3><pre><code>html 
    &lt;!-- 准备好一个容器--&gt;
        &lt;div id=&quot;root&quot;&gt;
            姓：&lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; &lt;br/&gt;&lt;br/&gt;
            名：&lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt; &lt;br/&gt;&lt;br/&gt;
            全名：&lt;span&gt;&#123;&#123;fullName()&#125;&#125;&lt;/span&gt;
        &lt;/div&gt;
js 
    new Vue(&#123;
            el:&#39;#root&#39;,
            data:&#123;
                firstName:&#39;张&#39;,
                lastName:&#39;三&#39;
            &#125;,
            methods: &#123;
                fullName()&#123;
                    console.log(&#39;@---fullName&#39;)
                    return this.firstName + &#39;-&#39; + this.lastName
                &#125;
            &#125;,
        &#125;)
</code></pre>
<h3 id="计算属性实现"><a href="#计算属性实现" class="headerlink" title="计算属性实现"></a>计算属性实现</h3><pre><code>计算属性：
    1.定义：要用的属性不存在，要通过已有属性计算得来。
    2.原理：底层借助了Objcet.defineproperty方法提供的getter和setter。
    3.get函数什么时候执行？
        (1).初次读取时会执行一次。
        (2).当依赖的数据发生改变时会被再次调用。
    4.优势：与methods实现相比，内部有缓存机制（复用），效率更高，调试方便。
    5.备注：
        1.计算属性最终会出现在vm上，直接读取使用即可。
        2.如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变。
html
        &lt;div id=&quot;root&quot;&gt;
            姓：&lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; &lt;br/&gt;&lt;br/&gt;
            名：&lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt; &lt;br/&gt;&lt;br/&gt;
            测试：&lt;input type=&quot;text&quot; v-model=&quot;x&quot;&gt; &lt;br/&gt;&lt;br/&gt;
            全名：&lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;br/&gt;&lt;br/&gt;
            &lt;!-- 全名：&lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;br/&gt;&lt;br/&gt;
            全名：&lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;br/&gt;&lt;br/&gt;
            全名：&lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; --&gt;
        &lt;/div&gt;
js 
    const vm = new Vue(&#123;
            el:&#39;#root&#39;,
            data:&#123;
                firstName:&#39;张&#39;,
                lastName:&#39;三&#39;,
                x:&#39;你好&#39;
            &#125;,
            methods: &#123;
                demo()&#123;
                    
                &#125;
            &#125;,
            computed:&#123;
                fullName:&#123;
                    //get有什么作用？当有人读取fullName时，get就会被调用，且返回值就作为fullName的值
                    //get什么时候调用？1.初次读取fullName时。2.所依赖的数据发生变化时。
                    get()&#123;
                        console.log(&#39;get被调用了&#39;)
                        // console.log(this) //此处的this是vm
                        return this.firstName + &#39;-&#39; + this.lastName
                    &#125;,
                    //set什么时候调用? 当fullName被修改时。
                    set(value)&#123;
                        console.log(&#39;set&#39;,value)
                        const arr = value.split(&#39;-&#39;)
                        this.firstName = arr[0]
                        this.lastName = arr[1]
                    &#125;
                &#125;
            &#125;
        &#125;)
</code></pre>
<h4 id="简写"><a href="#简写" class="headerlink" title="简写"></a>简写</h4><pre><code>html
    &lt;div id=&quot;root&quot;&gt;
        姓：&lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; &lt;br/&gt;&lt;br/&gt;
        名：&lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt; &lt;br/&gt;&lt;br/&gt;
        全名：&lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;br/&gt;&lt;br/&gt;
    &lt;/div&gt;
js
    const vm = new Vue(&#123;
            el:&#39;#root&#39;,
            data:&#123;
                firstName:&#39;张&#39;,
                lastName:&#39;三&#39;,
            &#125;,
            computed:&#123;
                //简写
                fullName()&#123;
                    console.log(&#39;get被调用了&#39;)
                    return this.firstName + &#39;-&#39; + this.lastName
                &#125;
            &#125;
        &#125;)
</code></pre>
<h1 id="监视属性"><a href="#监视属性" class="headerlink" title="监视属性"></a>监视属性</h1><pre><code>html
    &lt;div id=&quot;root&quot;&gt;
            &lt;h2&gt;今天天气很&#123;&#123;info&#125;&#125;&lt;/h2&gt;
            &lt;!-- 绑定事件的时候：@xxx=&quot;yyy&quot; yyy可以写一些简单的语句 --&gt;
            &lt;!-- &lt;button @click=&quot;isHot = !isHot&quot;&gt;切换天气&lt;/button&gt; --&gt;
            &lt;button @click=&quot;changeWeather&quot;&gt;切换天气&lt;/button&gt;
    &lt;/div&gt;
    
js
    const vm = new Vue(&#123;
            el:&#39;#root&#39;,
            data:&#123;
                isHot:true,
            &#125;,
            computed:&#123;
                info()&#123;
                    return this.isHot ? &#39;炎热&#39; : &#39;凉爽&#39;
                &#125;
            &#125;,
            methods: &#123;
                changeWeather()&#123;
                    this.isHot = !this.isHot
                &#125;
            &#125;,
        &#125;)
</code></pre>
<h4 id="监视属性watch："><a href="#监视属性watch：" class="headerlink" title="监视属性watch："></a>监视属性watch：</h4><pre><code>          1.当被监视的属性变化时, 回调函数自动调用, 进行相关操作

​          2.监视的属性必须存在，才能进行监视！！

​          3.监视的两种写法：

​              (1).new Vue时传入watch配置

​              (2).通过vm.$watch监视
</code></pre>
<pre><code>            /* watch:&#123;
                isHot:&#123;
                    immediate:true, //初始化时让handler调用一下
                    //handler什么时候调用？当isHot发生改变时。
                    handler(newValue,oldValue)&#123;
                        console.log(&#39;isHot被修改了&#39;,newValue,oldValue)
                    &#125;
                &#125;
            &#125; */
            
            
            
            
            vm.$watch(&#39;isHot&#39;,&#123;
                immediate:true, //初始化时让handler调用一下
                //handler什么时候调用？当isHot发生改变时。
                handler(newValue,oldValue)&#123;
                console.log(&#39;isHot被修改了&#39;,newValue,oldValue)
                &#125;
            &#125;)
</code></pre>
<h2 id="深度监视："><a href="#深度监视：" class="headerlink" title="深度监视："></a>深度监视：</h2><pre><code>            (1).Vue中的watch默认不监测对象内部值的改变（一层）。

​            (2).配置deep:true可以监测对象内部值改变（多层）。

​        备注：

​            (1).Vue自身可以监测对象内部值的改变，但Vue提供的watch默认不可以！

​            (2).使用watch时根据数据的具体结构，决定是否采用深度监视。
</code></pre>
<h2 id="简写-1"><a href="#简写-1" class="headerlink" title="简写"></a>简写</h2><pre><code>watch: &#123;
            //正常写法
            /* isHot:&#123;
                // immediate:true, //初始化时让handler调用一下
                // deep:true,//深度监视
                handler(newValue,oldValue)&#123;
                    console.log(&#39;isHot被修改了&#39;,newValue,oldValue)
                &#125;
            &#125;, */
            //简写
            /* isHot(newValue,oldValue)&#123;
                console.log(&#39;isHot被修改了&#39;,newValue,oldValue,this)
            &#125; */
        &#125;
</code></pre>
<h1 id="computed和watch之间的区别："><a href="#computed和watch之间的区别：" class="headerlink" title="computed和watch之间的区别："></a>computed和watch之间的区别：</h1><pre><code>            1.computed能完成的功能，watch都可以完成。

​            2.watch能完成的功能，computed不一定能完成，例如：watch可以进行异步操作。

​        两个重要的小原则：

​              1.所被Vue管理的函数，最好写成普通函数，这样this的指向才是vm 或 组件实例对象。

​              2.所有不被Vue所管理的函数（定时器的回调函数、ajax的回调函数等、Promise的回调函数），最好写成箭头函数，

​                这样this的指向才是vm 或 组件实例对象。
</code></pre>
<h1 id="收集表单数据"><a href="#收集表单数据" class="headerlink" title="收集表单数据"></a>收集表单数据</h1><pre><code>收集表单数据：
    若：&lt;input type=&quot;text&quot;/&gt;，则v-model收集的是value值，用户输入的就是value值。
    若：&lt;input type=&quot;radio&quot;/&gt;，则v-model收集的是value值，且要给标签配置value值。
    若：&lt;input type=&quot;checkbox&quot;/&gt;
    1.没有配置input的value属性，那么收集的就是checked（勾选 or 未勾选，是布尔值）
    2.配置input的value属性:
    (1)v-model的初始值是非数组，那么收集的就是checked（勾选 or 未勾选，是布尔值）
    (2)v-model的初始值是数组，那么收集的的就是value组成的数组
    备注：v-model的三个修饰符：
    lazy：失去焦点再收集数据
    number：输入字符串转为有效的数字
    trim：输入首尾空格过滤
</code></pre>
<pre><code>&lt;form @submit.prevent=&quot;demo&quot;&gt;
                账号：&lt;input type=&quot;text&quot; v-model.trim=&quot;userInfo.account&quot;&gt; &lt;br/&gt;&lt;br/&gt;
                密码：&lt;input type=&quot;password&quot; v-model=&quot;userInfo.password&quot;&gt; &lt;br/&gt;&lt;br/&gt;
                年龄：&lt;input type=&quot;number&quot; v-model.number=&quot;userInfo.age&quot;&gt; &lt;br/&gt;&lt;br/&gt;
                性别：
                男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; v-model=&quot;userInfo.sex&quot; value=&quot;male&quot;&gt;
                女&lt;input type=&quot;radio&quot; name=&quot;sex&quot; v-model=&quot;userInfo.sex&quot; value=&quot;female&quot;&gt; &lt;br/&gt;&lt;br/&gt;
                爱好：
                学习&lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.hobby&quot; value=&quot;study&quot;&gt;
                打游戏&lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.hobby&quot; value=&quot;game&quot;&gt;
                吃饭&lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.hobby&quot; value=&quot;eat&quot;&gt;
                &lt;br/&gt;&lt;br/&gt;
                所属校区
                &lt;select v-model=&quot;userInfo.city&quot;&gt;
                    &lt;option value=&quot;&quot;&gt;请选择校区&lt;/option&gt;
                    &lt;option value=&quot;beijing&quot;&gt;北京&lt;/option&gt;
                    &lt;option value=&quot;shanghai&quot;&gt;上海&lt;/option&gt;
                    &lt;option value=&quot;shenzhen&quot;&gt;深圳&lt;/option&gt;
                    &lt;option value=&quot;wuhan&quot;&gt;武汉&lt;/option&gt;
                &lt;/select&gt;
                &lt;br/&gt;&lt;br/&gt;
                其他信息：
                &lt;textarea v-model.lazy=&quot;userInfo.other&quot;&gt;&lt;/textarea&gt; &lt;br/&gt;&lt;br/&gt;
                &lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.agree&quot;&gt;阅读并接受&lt;a href=&quot;http://www.atguigu.com&quot;&gt;《用户协议》&lt;/a&gt;
                &lt;button&gt;提交&lt;/button&gt;
&lt;/form&gt;
            
            
            
            
data:&#123;
    userInfo:&#123;
    account:&#39;&#39;,
    password:&#39;&#39;,
    age:18,
    sex:&#39;female&#39;,
    hobby:[],
    city:&#39;beijing&#39;,
    other:&#39;&#39;,
    agree:&#39;&#39;
&#125;
</code></pre>
<h1 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h1><pre><code>过滤器：
    定义：对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑的处理）。
    语法：
    1.注册过滤器：Vue.filter(name,callback) 或 new Vue&#123;filters:&#123;&#125;&#125;
    2.使用过滤器：&#123;&#123; xxx | 过滤器名&#125;&#125;  或  v-bind:属性 = &quot;xxx | 过滤器名&quot;
    备注：
    1.过滤器也可以接收额外参数、多个过滤器也可以串联
    2.并没有改变原本的数据, 是产生新的对应的数据
</code></pre>
<pre><code>    //全局过滤器
    Vue.filter(&#39;mySlice&#39;,function(value)&#123;
        return value.slice(0,4)
    &#125;)

    //局部过滤器
    filters:&#123;
        timeFormater(value,str=&#39;YYYY年MM月DD日 HH:mm:ss&#39;)&#123;
        // console.log(&#39;@&#39;,value)
        return dayjs(value).format(str)
        &#125;
    &#125;
</code></pre>
<h1 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h1><pre><code>我们学过的指令：
    v-bind    : 单向绑定解析表达式, 可简写为 :xxx
    v-model    : 双向数据绑定
    v-for      : 遍历数组/对象/字符串
    v-on       : 绑定事件监听, 可简写为@
    v-if          : 条件渲染（动态控制节点是否存存在）
    v-else     : 条件渲染（动态控制节点是否存存在）
    v-show     : 条件渲染 (动态控制节点是否展示)
    v-text指令：
    1.作用：向其所在的节点中渲染文本内容。
    2.与插值语法的区别：v-text会替换掉节点中的内容，&#123;&#123;xx&#125;&#125;则不会。
</code></pre>
<pre><code>v-html指令：
    1.作用：向指定节点中渲染包含html结构的内容。
    2.与插值语法的区别：
    (1).v-html会替换掉节点中所有的内容，&#123;&#123;xx&#125;&#125;则不会。
    (2).v-html可以识别html结构。
    3.严重注意：v-html有安全性问题！！！！
    (1).在网站上动态渲染任意HTML是非常危险的，容易导致XSS攻击。
    (2).一定要在可信的内容上使用v-html，永不要用在用户提交的内容上！
</code></pre>
<pre><code>v-cloak指令（没有值）：

            1.本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v-cloak属性。
            2.使用css配合v-cloak可以解决网速慢时页面展示出&#123;&#123;xxx&#125;&#125;的问题。
v-once指令：
            1.v-once所在节点在初次动态渲染后，就视为静态内容了。
            2.以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能。
v-pre指令：
            1.跳过其所在节点的编译过程。
            2.可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译。
</code></pre>
<h1 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h1><img src="/.com//Users\kuankuan\AppData\Roaming\Typora\typora-user-images\image-20210910095050679.png" alt="image-20210910095050679" style="zoom:150%;">

<pre><code>directives:&#123;
            //big函数何时会被调用？1.指令与元素成功绑定时（一上来）。2.指令所在的模板被重新解析时。
            /* &#39;big-number&#39;(element,binding)&#123;
            // console.log(&#39;big&#39;)
                element.innerText = binding.value * 10
            &#125;, */
            big(element,binding)&#123;
            console.log(&#39;big&#39;,this) //注意此处的this是window
            // console.log(&#39;big&#39;)
                element.innerText = binding.value * 10
            &#125;,
            fbind:&#123;
            //指令与元素成功绑定时（一上来）
            bind(element,binding)&#123;
                element.value = binding.value
            &#125;,
            //指令所在元素被插入页面时
            inserted(element,binding)&#123;
                element.focus()
            &#125;,
            //指令所在的模板被重新解析时
            update(element,binding)&#123;
                element.value = binding.value
            &#125;
           &#125;
        &#125;
</code></pre>
<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p>生命周期：</p>
<p>​            1.又名：生命周期回调函数、生命周期函数、生命周期钩子。</p>
<p>​            2.是什么：Vue在关键时刻帮我们调用的一些特殊名称的函数。</p>
<p>​            3.生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的。</p>
<p>​            4.生命周期函数中的this指向是vm 或 组件实例对象。</p>
<pre><code>常用的生命周期钩子：
                        1.mounted: 发送ajax请求、启动定时器、绑定自定义事件、订阅消息等【初始化操作】。
                        2.beforeDestroy: 清除定时器、解绑自定义事件、取消订阅消息等【收尾工作】。

                关于销毁Vue实例
                        1.销毁后借助Vue开发者工具看不到任何信息。
                        2.销毁后自定义事件会失效，但原生DOM事件依然有效。
                        3.一般不会在beforeDestroy操作数据，因为即便操作数据，也不会再触发更新流程了。
</code></pre>
<h1 id="1-一个重要的内置关系：VueComponent-prototype-proto-Vue-prototype"><a href="#1-一个重要的内置关系：VueComponent-prototype-proto-Vue-prototype" class="headerlink" title="1.一个重要的内置关系：VueComponent.prototype.proto === Vue.prototype"></a>1.一个重要的内置关系：VueComponent.prototype.<strong>proto</strong> === Vue.prototype</h1><h1 id="2-为什么要有这个关系：让组件实例对象（vc）可以访问到-Vue原型上的属性、方法。"><a href="#2-为什么要有这个关系：让组件实例对象（vc）可以访问到-Vue原型上的属性、方法。" class="headerlink" title="2.为什么要有这个关系：让组件实例对象（vc）可以访问到 Vue原型上的属性、方法。"></a>2.为什么要有这个关系：让组件实例对象（vc）可以访问到 Vue原型上的属性、方法。</h1>]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue双向绑定（四）Watcher</title>
    <url>/2019/09/03/vue%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9AWatcher/</url>
    <content><![CDATA[<h2 id="实现Watcher"><a href="#实现Watcher" class="headerlink" title="实现Watcher"></a>实现Watcher</h2><p>Watcher订阅者作为Observer和Compile之间通信的桥梁，主要做的事情是:</p>
<ol>
<li>在自身实例化时往属性订阅器(dep)里面添加自己</li>
<li>自身必须有一个update()方法</li>
<li>待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。</li>
</ol>
<pre><code class="js">function Watcher(vm, exp, cb) &#123;
    this.cb = cb;
    this.vm = vm;
    this.exp = exp;
    // 此处为了触发属性的getter，从而在dep添加自己，结合Observer更易理解
    this.value = this.get(); 
&#125;
Watcher.prototype = &#123;
    update: function() &#123;
        this.run();    // 属性值变化收到通知
    &#125;,
    run: function() &#123;
        var value = this.get(); // 取到最新值
        var oldVal = this.value;
        if (value !== oldVal) &#123;
            this.value = value;
            this.cb.call(this.vm, value, oldVal); // 执行Compile中绑定的回调，更新视图
        &#125;
    &#125;,
    get: function() &#123;
        Dep.target = this;    // 将当前订阅者指向自己
        var value = this.vm[exp];    // 触发getter，添加自己到属性订阅器中
        Dep.target = null;    // 添加完毕，重置
        return value;
    &#125;
&#125;;
// 这里再次列出Observer和Dep，方便理解
Object.defineProperty(data, key, &#123;
    get: function() &#123;
        // 由于需要在闭包内添加watcher，所以可以在Dep定义一个全局target属性，暂存watcher, 添加完移除
        Dep.target &amp;&amp; dep.addDep(Dep.target);
        return val;
    &#125;
    // ... 省略
&#125;);
Dep.prototype = &#123;
    notify: function() &#123;
        this.subs.forEach(function(sub) &#123;
            sub.update(); // 调用订阅者的update方法，通知变化
        &#125;);
    &#125;
&#125;;
</code></pre>
<p>实例化Watcher的时候，调用get()方法，通过Dep.target = watcherInstance标记订阅者是当前watcher实例，强行触发属性定义的getter方法，getter方法执行的时候，就会在属性的订阅器dep添加当前watcher实例，从而在属性值有变化的时候，watcherInstance就能收到更新通知。</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
  </entry>
  <entry>
    <title>vue双向绑定（二）Observer</title>
    <url>/2019/09/02/vue%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9AObserver/</url>
    <content><![CDATA[<h2 id="实现observer"><a href="#实现observer" class="headerlink" title="实现observer"></a>实现observer</h2><p>我们知道可以利用object.defineproperty()来监听属性变动那么将需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter</p>
<p>这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化。</p>
<pre><code class="js">var data = &#123;name: &#39;kuankuan&#39;&#125;;
observe(data);
data.name = &#39;dmq&#39;; // 哈哈哈，监听到值变化了 kindeng --&gt; dmq

function observe(data) &#123;
    if (!data || typeof data !== &#39;object&#39;) &#123;
        return;
    &#125;
    // 取出所有属性遍历
    Object.keys(data).forEach(function(key) &#123;
        defineReactive(data, key, data[key]);
    &#125;);
&#125;;

function defineReactive(data, key, val) &#123;
    observe(val); // 监听子属性
    Object.defineProperty(data, key, &#123;
        enumerable: true, // 可枚举
        configurable: false, // 不能再define
        get: function() &#123;
            return val;
        &#125;,
        set: function(newVal) &#123;
            console.log(&#39;哈哈哈，监听到值变化了 &#39;, val, &#39; --&gt; &#39;, newVal);
            val = newVal;
        &#125;
    &#125;);
&#125;
</code></pre>
<p>这样我们已经可以监听到每个数据的变化了，那么监听到变化之后就是怎么通知订阅者了，所以接下来我们需要实现一个消息订阅器，很简单，维护一个数组，用来收集订阅者，数据变动触发notify，在调用订阅者的update方法，代码改善之后是这样。</p>
<pre><code class="js">// ... 省略
function defineReactive(data, key, val) &#123;
    var dep = new Dep();
    observe(val); // 监听子属性

    Object.defineProperty(data, key, &#123;
        // ... 省略
        set: function(newVal) &#123;
            if (val === newVal) return;
            console.log(&#39;哈哈哈，监听到值变化了 &#39;, val, &#39; --&gt; &#39;, newVal);
            val = newVal;
            dep.notify(); // 通知所有订阅者
        &#125;
    &#125;);
&#125;

function Dep() &#123;
    this.subs = [];
&#125;
Dep.prototype = &#123;
    addSub: function(sub) &#123;
        this.subs.push(sub);
    &#125;,
    notify: function() &#123;
        this.subs.forEach(function(sub) &#123;
            sub.update();
        &#125;);
    &#125;
&#125;;
</code></pre>
<p>那么问题来了，谁是订阅者？怎么往订阅器添加订阅者？<br>没错，上面的思路整理中我们已经明确订阅者应该是watcher，而且var dep = new Dep();是在 defineReactive方法内部定义的，所以想通过dep添加订阅者，就必须要在闭包内操作，所以我们可以在 getter里面动手脚：</p>
<pre><code class="js">// Observer.js
// ...省略
Object.defineProperty(data, key, &#123;
    get: function() &#123;
        // 由于需要在闭包内添加watcher，所以通过Dep定义一个全局target属性，暂存watcher, 添加完移除
        Dep.target &amp;&amp; dep.addDep(Dep.target);
        return val;
    &#125;
    // ... 省略
&#125;);

// Watcher.js
Watcher.prototype = &#123;
    get: function(key) &#123;
        Dep.target = this;
        this.value = data[key];    // 这里会触发属性的getter，从而添加订阅者
        Dep.target = null;
    &#125;
&#125;
</code></pre>
<p>这里已经实现了一个Observer了，已经具备了监听数据和数据变化通知订阅者的功能。那么接下来就是实现Compile了</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
  </entry>
  <entry>
    <title>vue双向绑定（三）Compile</title>
    <url>/2019/09/03/vue%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9Acompile/</url>
    <content><![CDATA[<h2 id="实现Compile"><a href="#实现Compile" class="headerlink" title="实现Compile"></a>实现Compile</h2><p>因为遍历解析的过程有多次操作dom节点，为提高性能和效率，会先将跟节点el转换成文档碎片fragment进行解析编译操作，解析完成，再将fragment添加回原来的真实dom节点中</p>
<pre><code class="js">function Compile(el) &#123;
    this.$el = this.isElementNode(el) ? el : document.querySelector(el);
    if (this.$el) &#123;
        this.$fragment = this.node2Fragment(this.$el);
        this.init();
        this.$el.appendChild(this.$fragment);
    &#125;
&#125;
Compile.prototype = &#123;
    init: function() &#123; this.compileElement(this.$fragment); &#125;,
    node2Fragment: function(el) &#123;
        var fragment = document.createDocumentFragment(), child;
        // 将原生节点拷贝到fragment
        while (child = el.firstChild) &#123;
            fragment.appendChild(child);
        &#125;
        return fragment;
    &#125;
&#125;;
compileElement方法将遍历所有节点及其子节点，进行扫描解析编译，调用对应的指令渲染函数进行数据渲染，并调用对应的指令更新函数进行绑定，详看代码及注释说明：

Compile.prototype = &#123;
    // ... 省略
    compileElement: function(el) &#123;
        var childNodes = el.childNodes, me = this;
        [].slice.call(childNodes).forEach(function(node) &#123;
            var text = node.textContent;
            var reg = /\&#123;\&#123;(.*)\&#125;\&#125;/;    // 表达式文本
            // 按元素节点方式编译
            if (me.isElementNode(node)) &#123;
                me.compile(node);
            &#125; else if (me.isTextNode(node) &amp;&amp; reg.test(text)) &#123;
                me.compileText(node, RegExp.$1);
            &#125;
            // 遍历编译子节点
            if (node.childNodes &amp;&amp; node.childNodes.length) &#123;
                me.compileElement(node);
            &#125;
        &#125;);
    &#125;,

    compile: function(node) &#123;
        var nodeAttrs = node.attributes, me = this;
        [].slice.call(nodeAttrs).forEach(function(attr) &#123;
            // 规定：指令以 v-xxx 命名
            // 如 &lt;span v-text=&quot;content&quot;&gt;&lt;/span&gt; 中指令为 v-text
            var attrName = attr.name;    // v-text
            if (me.isDirective(attrName)) &#123;
                var exp = attr.value; // content
                var dir = attrName.substring(2);    // text
                if (me.isEventDirective(dir)) &#123;
                    // 事件指令, 如 v-on:click
                    compileUtil.eventHandler(node, me.$vm, exp, dir);
                &#125; else &#123;
                    // 普通指令
                    compileUtil[dir] &amp;&amp; compileUtil[dir](node, me.$vm, exp);
                &#125;
            &#125;
        &#125;);
    &#125;
&#125;;

// 指令处理集合
var compileUtil = &#123;
    text: function(node, vm, exp) &#123;
        this.bind(node, vm, exp, &#39;text&#39;);
    &#125;,
    // ...省略
    bind: function(node, vm, exp, dir) &#123;
        var updaterFn = updater[dir + &#39;Updater&#39;];
        // 第一次初始化视图
        updaterFn &amp;&amp; updaterFn(node, vm[exp]);
        // 实例化订阅者，此操作会在对应的属性消息订阅器中添加了该订阅者watcher
        new Watcher(vm, exp, function(value, oldValue) &#123;
            // 一旦属性值有变化，会收到通知执行此更新函数，更新视图
            updaterFn &amp;&amp; updaterFn(node, value, oldValue);
        &#125;);
    &#125;
&#125;;

// 更新函数
var updater = &#123;
    textUpdater: function(node, value) &#123;
        node.textContent = typeof value == &#39;undefined&#39; ? &#39;&#39; : value;
    &#125;
    // ...省略
&#125;;
</code></pre>
<pre><code class="js">/*
这里通过递归遍历保证了每个节点及子节点都会解析编译到，包括了&#123;&#123;&#125;&#125;表达式声明的文本节点。指令的声明规定是通过特定前缀的节点属性来标记，如&lt;span v-text=&quot;content&quot; other-attr中v-text便是指令，而other-attr不是指令，只是普通的属性。
监听数据、绑定更新函数的处理是在compileUtil.bind()这个方法中，通过new Watcher()添加回调来接收数据变化的通知
*/
</code></pre>
<p>至此，一个简单的Compile就完成了。接下来要看看Watcher这个订阅者的具体实现了</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue  脚手架</title>
    <url>/2021/11/24/vue%E8%84%9A%E6%89%8B%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><h2 id="脚手架文件结构"><a href="#脚手架文件结构" class="headerlink" title="脚手架文件结构"></a>脚手架文件结构</h2><pre><code>├── node_modules 
├── public
│   ├── favicon.ico: 页签图标
│   └── index.html: 主页面
├── src
│   ├── assets: 存放静态资源
│   │   └── logo.png
│   │── component: 存放组件
│   │   └── HelloWorld.vue
│   │── App.vue: 汇总所有组件
│   │── main.js: 入口文件
├── .gitignore: git版本管制忽略的配置
├── babel.config.js: babel的配置文件
├── package.json: 应用包配置文件 
├── README.md: 应用描述文件
├── package-lock.json：包版本控制文件
</code></pre>
<h2 id="关于不同版本的Vue"><a href="#关于不同版本的Vue" class="headerlink" title="关于不同版本的Vue"></a>关于不同版本的Vue</h2><ol>
<li>vue.js与vue.runtime.xxx.js的区别：<ol>
<li>vue.js是完整版的Vue，包含：核心功能 + 模板解析器。</li>
<li>vue.runtime.xxx.js是运行版的Vue，只包含：核心功能；没有模板解析器。</li>
</ol>
</li>
<li>因为vue.runtime.xxx.js没有模板解析器，所以不能使用template这个配置项，需要使用render函数接收到的createElement函数去指定具体内容。</li>
</ol>
<h2 id="vue-config-js配置文件"><a href="#vue-config-js配置文件" class="headerlink" title="vue.config.js配置文件"></a>vue.config.js配置文件</h2><ol>
<li>使用vue inspect &gt; output.js可以查看到Vue脚手架的默认配置。</li>
<li>使用vue.config.js可以对脚手架进行个性化定制，详情见：<a href="https://cli.vuejs.org/zh">https://cli.vuejs.org/zh</a></li>
</ol>
<h2 id="ref属性"><a href="#ref属性" class="headerlink" title="ref属性"></a>ref属性</h2><ol>
<li>被用来给元素或子组件注册引用信息（id的替代者）</li>
<li>应用在html标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象（vc）</li>
<li>使用方式：<ol>
<li>打标识：<code>&lt;h1 ref=&quot;xxx&quot;&gt;.....&lt;/h1&gt;</code> 或 <code>&lt;School ref=&quot;xxx&quot;&gt;&lt;/School&gt;</code></li>
<li>获取：<code>this.$refs.xxx</code></li>
</ol>
</li>
</ol>
<h2 id="props配置项"><a href="#props配置项" class="headerlink" title="props配置项"></a>props配置项</h2><ol>
<li><p>功能：让组件接收外部传过来的数据</p>
</li>
<li><p>传递数据：<code>&lt;Demo name=&quot;xxx&quot;/&gt;</code></p>
</li>
<li><p>接收数据：</p>
<ol>
<li><p>第一种方式（只接收）：<code>props:[&#39;name&#39;] </code></p>
</li>
<li><p>第二种方式（限制类型）：<code>props:&#123;name:String&#125;</code></p>
</li>
<li><p>第三种方式（限制类型、限制必要性、指定默认值）：</p>
<pre><code class="js">props:&#123;
    name:&#123;
    type:String, //类型
    required:true, //必要性
    default:&#39;老王&#39; //默认值
    &#125;
&#125;
</code></pre>
</li>
</ol>
<blockquote>
<p>备注：props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中一份，然后去修改data中的数据。</p>
</blockquote>
</li>
</ol>
<h2 id="mixin-混入"><a href="#mixin-混入" class="headerlink" title="mixin(混入)"></a>mixin(混入)</h2><ol>
<li><p>功能：可以把多个组件共用的配置提取成一个混入对象</p>
</li>
<li><p>使用方式：</p>
<p> 第一步定义混合：</p>
<pre><code class="vue">&#123;
    data()&#123;....&#125;,
    methods:&#123;....&#125;
    ....
&#125;
</code></pre>
<p> 第二步使用混入：</p>
<p> ​    全局混入：<code>Vue.mixin(xxx)</code><br> ​    局部混入：<code>mixins:[&#39;xxx&#39;]    </code></p>
</li>
</ol>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><ol>
<li><p>功能：用于增强Vue</p>
</li>
<li><p>本质：包含install方法的一个对象，install的第一个参数是Vue，第二个以后的参数是插件使用者传递的数据。</p>
</li>
<li><p>定义插件：</p>
<pre><code class="js">对象.install = function (Vue, options) &#123;
    // 1. 添加全局过滤器
    Vue.filter(....)

    // 2. 添加全局指令
    Vue.directive(....)

    // 3. 配置全局混入(合)
    Vue.mixin(....)

    // 4. 添加实例方法
    Vue.prototype.$myMethod = function () &#123;...&#125;
    Vue.prototype.$myProperty = xxxx
&#125;
</code></pre>
</li>
<li><p>使用插件：<code>Vue.use()</code></p>
</li>
</ol>
<h2 id="scoped样式"><a href="#scoped样式" class="headerlink" title="scoped样式"></a>scoped样式</h2><ol>
<li>作用：让样式在局部生效，防止冲突。</li>
<li>写法：<code>&lt;style scoped&gt;</code></li>
</ol>
<h2 id="总结TodoList案例"><a href="#总结TodoList案例" class="headerlink" title="总结TodoList案例"></a>总结TodoList案例</h2><ol>
<li><p>组件化编码流程：</p>
<p> ​    (1).拆分静态组件：组件要按照功能点拆分，命名不要与html元素冲突。</p>
<p> ​    (2).实现动态组件：考虑好数据的存放位置，数据是一个组件在用，还是一些组件在用：</p>
<p> ​            1).一个组件在用：放在组件自身即可。</p>
<p> ​            2). 一些组件在用：放在他们共同的父组件上（<span style="color:red">状态提升</span>）。</p>
<p> ​    (3).实现交互：从绑定事件开始。</p>
</li>
<li><p>props适用于：</p>
<p> ​    (1).父组件 ==&gt; 子组件 通信</p>
<p> ​    (2).子组件 ==&gt; 父组件 通信（要求父先给子一个函数）</p>
</li>
<li><p>使用v-model时要切记：v-model绑定的值不能是props传过来的值，因为props是不可以修改的！</p>
</li>
<li><p>props传过来的若是对象类型的值，修改对象中的属性时Vue不会报错，但不推荐这样做。</p>
</li>
</ol>
<h2 id="webStorage"><a href="#webStorage" class="headerlink" title="webStorage"></a>webStorage</h2><ol>
<li><p>存储内容大小一般支持5MB左右（不同浏览器可能还不一样）</p>
</li>
<li><p>浏览器端通过 Window.sessionStorage 和 Window.localStorage 属性来实现本地存储机制。</p>
</li>
<li><p>相关API：</p>
<ol>
<li><p><code>xxxxxStorage.setItem(&#39;key&#39;, &#39;value&#39;);</code></p>
<pre><code>             该方法接受一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新其对应的值。
</code></pre>
</li>
<li><p><code>xxxxxStorage.getItem(&#39;person&#39;);</code></p>
<p> ​        该方法接受一个键名作为参数，返回键名对应的值。</p>
</li>
<li><p><code>xxxxxStorage.removeItem(&#39;key&#39;);</code></p>
<p> ​        该方法接受一个键名作为参数，并把该键名从存储中删除。</p>
</li>
<li><p><code> xxxxxStorage.clear()</code></p>
<p> ​        该方法会清空存储中的所有数据。</p>
</li>
</ol>
</li>
<li><p>备注：</p>
<ol>
<li>SessionStorage存储的内容会随着浏览器窗口关闭而消失。</li>
<li>LocalStorage存储的内容，需要手动清除才会消失。</li>
<li><code>xxxxxStorage.getItem(xxx)</code>如果xxx对应的value获取不到，那么getItem的返回值是null。</li>
<li><code>JSON.parse(null)</code>的结果依然是null。</li>
</ol>
</li>
</ol>
<h2 id="组件的自定义事件"><a href="#组件的自定义事件" class="headerlink" title="组件的自定义事件"></a>组件的自定义事件</h2><ol>
<li><p>一种组件间通信的方式，适用于：<strong style="color:red">子组件 ===&gt; 父组件</strong></p>
</li>
<li><p>使用场景：A是父组件，B是子组件，B想给A传数据，那么就要在A中给B绑定自定义事件（<span style="color:red">事件的回调在A中</span>）。</p>
</li>
<li><p>绑定自定义事件：</p>
<ol>
<li><p>第一种方式，在父组件中：<code>&lt;Demo @atguigu=&quot;test&quot;/&gt;</code>  或 <code>&lt;Demo v-on:atguigu=&quot;test&quot;/&gt;</code></p>
</li>
<li><p>第二种方式，在父组件中：</p>
<pre><code class="js">&lt;Demo ref=&quot;demo&quot;/&gt;
......
mounted()&#123;
   this.$refs.xxx.$on(&#39;atguigu&#39;,this.test)
&#125;
</code></pre>
</li>
<li><p>若想让自定义事件只能触发一次，可以使用<code>once</code>修饰符，或<code>$once</code>方法。</p>
</li>
</ol>
</li>
<li><p>触发自定义事件：<code>this.$emit(&#39;atguigu&#39;,数据)</code>        </p>
</li>
<li><p>解绑自定义事件<code>this.$off(&#39;atguigu&#39;)</code></p>
</li>
<li><p>组件上也可以绑定原生DOM事件，需要使用<code>native</code>修饰符。</p>
</li>
<li><p>注意：通过<code>this.$refs.xxx.$on(&#39;atguigu&#39;,回调)</code>绑定自定义事件时，回调<span style="color:red">要么配置在methods中</span>，<span style="color:red">要么用箭头函数</span>，否则this指向会出问题！</p>
</li>
</ol>
<h2 id="全局事件总线（GlobalEventBus）"><a href="#全局事件总线（GlobalEventBus）" class="headerlink" title="全局事件总线（GlobalEventBus）"></a>全局事件总线（GlobalEventBus）</h2><ol>
<li><p>一种组件间通信的方式，适用于<span style="color:red">任意组件间通信</span>。</p>
</li>
<li><p>安装全局事件总线：</p>
<pre><code class="js">new Vue(&#123;
    ......
    beforeCreate() &#123;
        Vue.prototype.$bus = this //安装全局事件总线，$bus就是当前应用的vm
    &#125;,
    ......
&#125;) 
</code></pre>
</li>
<li><p>使用事件总线：</p>
<ol>
<li><p>接收数据：A组件想接收数据，则在A组件中给$bus绑定自定义事件，事件的<span style="color:red">回调留在A组件自身。</span></p>
<pre><code class="js">methods()&#123;
  demo(data)&#123;......&#125;
&#125;
......
mounted() &#123;
  this.$bus.$on(&#39;xxxx&#39;,this.demo)
&#125;
</code></pre>
</li>
<li><p>提供数据：<code>this.$bus.$emit(&#39;xxxx&#39;,数据)</code></p>
</li>
</ol>
</li>
<li><p>最好在beforeDestroy钩子中，用$off去解绑<span style="color:red">当前组件所用到的</span>事件。</p>
</li>
</ol>
<h2 id="消息订阅与发布（pubsub）"><a href="#消息订阅与发布（pubsub）" class="headerlink" title="消息订阅与发布（pubsub）"></a>消息订阅与发布（pubsub）</h2><ol>
<li><p>  一种组件间通信的方式，适用于<span style="color:red">任意组件间通信</span>。</p>
</li>
<li><p>使用步骤：</p>
<ol>
<li><p>安装pubsub：<code>npm i pubsub-js</code></p>
</li>
<li><p>引入: <code>import pubsub from &#39;pubsub-js&#39;</code></p>
</li>
<li><p>接收数据：A组件想接收数据，则在A组件中订阅消息，订阅的<span style="color:red">回调留在A组件自身。</span></p>
<pre><code class="js">methods()&#123;
  demo(data)&#123;......&#125;
&#125;
......
mounted() &#123;
  this.pid = pubsub.subscribe(&#39;xxx&#39;,this.demo) //订阅消息
&#125;
</code></pre>
</li>
<li><p>提供数据：<code>pubsub.publish(&#39;xxx&#39;,数据)</code></p>
</li>
<li><p>最好在beforeDestroy钩子中，用<code>PubSub.unsubscribe(pid)</code>去<span style="color:red">取消订阅。</span></p>
<h2 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h2></li>
</ol>
</li>
<li><p>语法：<code>this.$nextTick(回调函数)</code></p>
</li>
<li><p>作用：在下一次 DOM 更新结束后执行其指定的回调。</p>
</li>
<li><p>什么时候用：当改变数据后，要基于更新后的新DOM进行某些操作时，要在nextTick所指定的回调函数中执行。</p>
</li>
</ol>
<h2 id="Vue封装的过度与动画"><a href="#Vue封装的过度与动画" class="headerlink" title="Vue封装的过度与动画"></a>Vue封装的过度与动画</h2><ol>
<li><p>作用：在插入、更新或移除 DOM元素时，在合适的时候给元素添加样式类名。</p>
</li>
<li><p>图示：<img src="https://img04.sogoucdn.com/app/a/100520146/5990c1dff7dc7a8fb3b34b4462bd0105" style="width:60%"></p>
</li>
<li><p>写法：</p>
<ol>
<li><p>准备好样式：</p>
<ul>
<li>元素进入的样式：<ol>
<li>v-enter：进入的起点</li>
<li>v-enter-active：进入过程中</li>
<li>v-enter-to：进入的终点</li>
</ol>
</li>
<li>元素离开的样式：<ol>
<li>v-leave：离开的起点</li>
<li>v-leave-active：离开过程中</li>
<li>v-leave-to：离开的终点</li>
</ol>
</li>
</ul>
</li>
<li><p>使用<code>&lt;transition&gt;</code>包裹要过度的元素，并配置name属性：</p>
<pre><code class="vue">&lt;transition name=&quot;hello&quot;&gt;
    &lt;h1 v-show=&quot;isShow&quot;&gt;你好啊！&lt;/h1&gt;
&lt;/transition&gt;
</code></pre>
</li>
<li><p>备注：若有多个元素需要过度，则需要使用：<code>&lt;transition-group&gt;</code>，且每个元素都要指定<code>key</code>值。</p>
</li>
</ol>
</li>
</ol>
<h2 id="vue脚手架配置代理"><a href="#vue脚手架配置代理" class="headerlink" title="vue脚手架配置代理"></a>vue脚手架配置代理</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>​    在vue.config.js中添加如下配置：</p>
<pre><code class="js">devServer:&#123;
  proxy:&quot;http://localhost:5000&quot;
&#125;
</code></pre>
<p>说明：</p>
<ol>
<li>优点：配置简单，请求资源时直接发给前端（8080）即可。</li>
<li>缺点：不能配置多个代理，不能灵活的控制请求是否走代理。</li>
<li>工作方式：若按照上述配置代理，当请求了前端不存在的资源时，那么该请求会转发给服务器 （优先匹配前端资源）</li>
</ol>
<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>​    编写vue.config.js配置具体代理规则：</p>
<pre><code class="js">module.exports = &#123;
    devServer: &#123;
      proxy: &#123;
      &#39;/api1&#39;: &#123;// 匹配所有以 &#39;/api1&#39;开头的请求路径
        target: &#39;http://localhost:5000&#39;,// 代理目标的基础路径
        changeOrigin: true,
        pathRewrite: &#123;&#39;^/api1&#39;: &#39;&#39;&#125;
      &#125;,
      &#39;/api2&#39;: &#123;// 匹配所有以 &#39;/api2&#39;开头的请求路径
        target: &#39;http://localhost:5001&#39;,// 代理目标的基础路径
        changeOrigin: true,
        pathRewrite: &#123;&#39;^/api2&#39;: &#39;&#39;&#125;
      &#125;
    &#125;
  &#125;
&#125;
/*
   changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000
   changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:8080
   changeOrigin默认值为true
*/
</code></pre>
<p>说明：</p>
<ol>
<li>优点：可以配置多个代理，且可以灵活的控制请求是否走代理。</li>
<li>缺点：配置略微繁琐，请求资源时必须加前缀。</li>
</ol>
<h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><ol>
<li><p>作用：让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式，适用于 <strong style="color:red">父组件 ===&gt; 子组件</strong> 。</p>
</li>
<li><p>分类：默认插槽、具名插槽、作用域插槽</p>
</li>
<li><p>使用方式：</p>
<ol>
<li><p>默认插槽：</p>
<pre><code class="vue">父组件中：
        &lt;Category&gt;
           &lt;div&gt;html结构1&lt;/div&gt;
        &lt;/Category&gt;
子组件中：
        &lt;template&gt;
            &lt;div&gt;
               &lt;!-- 定义插槽 --&gt;
               &lt;slot&gt;插槽默认内容...&lt;/slot&gt;
            &lt;/div&gt;
        &lt;/template&gt;
</code></pre>
</li>
<li><p>具名插槽：</p>
<pre><code class="vue">父组件中：
        &lt;Category&gt;
            &lt;template slot=&quot;center&quot;&gt;
              &lt;div&gt;html结构1&lt;/div&gt;
            &lt;/template&gt;

            &lt;template v-slot:footer&gt;
               &lt;div&gt;html结构2&lt;/div&gt;
            &lt;/template&gt;
        &lt;/Category&gt;
子组件中：
        &lt;template&gt;
            &lt;div&gt;
               &lt;!-- 定义插槽 --&gt;
               &lt;slot name=&quot;center&quot;&gt;插槽默认内容...&lt;/slot&gt;
               &lt;slot name=&quot;footer&quot;&gt;插槽默认内容...&lt;/slot&gt;
            &lt;/div&gt;
        &lt;/template&gt;
</code></pre>
</li>
<li><p>作用域插槽：</p>
<ol>
<li><p>理解：<span style="color:red">数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。</span>（games数据在Category组件中，但使用数据所遍历出来的结构由App组件决定）</p>
</li>
<li><p>具体编码：</p>
<pre><code class="vue">父组件中：
        &lt;Category&gt;
            &lt;template scope=&quot;scopeData&quot;&gt;
                &lt;!-- 生成的是ul列表 --&gt;
                &lt;ul&gt;
                    &lt;li v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/li&gt;
                &lt;/ul&gt;
            &lt;/template&gt;
        &lt;/Category&gt;

        &lt;Category&gt;
            &lt;template slot-scope=&quot;scopeData&quot;&gt;
                &lt;!-- 生成的是h4标题 --&gt;
                &lt;h4 v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/h4&gt;
            &lt;/template&gt;
        &lt;/Category&gt;
子组件中：
        &lt;template&gt;
            &lt;div&gt;
                &lt;slot :games=&quot;games&quot;&gt;&lt;/slot&gt;
            &lt;/div&gt;
        &lt;/template&gt;
        
        &lt;script&gt;
            export default &#123;
                name:&#39;Category&#39;,
                props:[&#39;title&#39;],
                //数据在子组件自身
                data() &#123;
                    return &#123;
                        games:[&#39;红色警戒&#39;,&#39;穿越火线&#39;,&#39;劲舞团&#39;,&#39;超级玛丽&#39;]
                    &#125;
                &#125;,
            &#125;
        &lt;/script&gt;
</code></pre>
<p>```</p>
</li>
</ol>
</li>
</ol>
<p>```</p>
</li>
</ol>
<h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><p>​        在Vue中实现集中式状态（数据）管理的一个Vue插件，对vue应用中多个组件的共享状态进行集中式的管理（读/写），也是一种组件间通信的方式，且适用于任意组件间通信。</p>
<h3 id="2-何时使用？"><a href="#2-何时使用？" class="headerlink" title="2.何时使用？"></a>2.何时使用？</h3><p>​        多个组件需要共享数据时</p>
<h3 id="3-搭建vuex环境"><a href="#3-搭建vuex环境" class="headerlink" title="3.搭建vuex环境"></a>3.搭建vuex环境</h3><ol>
<li><p>创建文件：<code>src/store/index.js</code></p>
<pre><code class="js">//引入Vue核心库
import Vue from &#39;vue&#39;
//引入Vuex
import Vuex from &#39;vuex&#39;
//应用Vuex插件
Vue.use(Vuex)

//准备actions对象——响应组件中用户的动作
const actions = &#123;&#125;
//准备mutations对象——修改state中的数据
const mutations = &#123;&#125;
//准备state对象——保存具体的数据
const state = &#123;&#125;

//创建并暴露store
export default new Vuex.Store(&#123;
    actions,
    mutations,
    state
&#125;)
</code></pre>
</li>
<li><p>在<code>main.js</code>中创建vm时传入<code>store</code>配置项</p>
<pre><code class="js">......
//引入store
import store from &#39;./store&#39;
......

//创建vm
new Vue(&#123;
    el:&#39;#app&#39;,
    render: h =&gt; h(App),
    store
&#125;)
</code></pre>
</li>
</ol>
<h3 id="4-基本使用"><a href="#4-基本使用" class="headerlink" title="4.基本使用"></a>4.基本使用</h3><ol>
<li><p>初始化数据、配置<code>actions</code>、配置<code>mutations</code>，操作文件<code>store.js</code></p>
<pre><code class="js">//引入Vue核心库
import Vue from &#39;vue&#39;
//引入Vuex
import Vuex from &#39;vuex&#39;
//引用Vuex
Vue.use(Vuex)

const actions = &#123;
    //响应组件中加的动作
    jia(context,value)&#123;
        // console.log(&#39;actions中的jia被调用了&#39;,miniStore,value)
        context.commit(&#39;JIA&#39;,value)
    &#125;,
&#125;

const mutations = &#123;
    //执行加
    JIA(state,value)&#123;
        // console.log(&#39;mutations中的JIA被调用了&#39;,state,value)
        state.sum += value
    &#125;
&#125;

//初始化数据
const state = &#123;
   sum:0
&#125;

//创建并暴露store
export default new Vuex.Store(&#123;
    actions,
    mutations,
    state,
&#125;)
</code></pre>
</li>
<li><p>组件中读取vuex中的数据：<code>$store.state.sum</code></p>
</li>
<li><p>组件中修改vuex中的数据：<code>$store.dispatch(&#39;action中的方法名&#39;,数据)</code> 或 <code>$store.commit(&#39;mutations中的方法名&#39;,数据)</code></p>
<blockquote>
<p> 备注：若没有网络请求或其他业务逻辑，组件中也可以越过actions，即不写<code>dispatch</code>，直接编写<code>commit</code></p>
</blockquote>
</li>
</ol>
<h3 id="5-getters的使用"><a href="#5-getters的使用" class="headerlink" title="5.getters的使用"></a>5.getters的使用</h3><ol>
<li><p>概念：当state中的数据需要经过加工后再使用时，可以使用getters加工。</p>
</li>
<li><p>在<code>store.js</code>中追加<code>getters</code>配置</p>
<pre><code class="js">......

const getters = &#123;
    bigSum(state)&#123;
        return state.sum * 10
    &#125;
&#125;

//创建并暴露store
export default new Vuex.Store(&#123;
    ......
    getters
&#125;)
</code></pre>
</li>
<li><p>组件中读取数据：<code>$store.getters.bigSum</code></p>
</li>
</ol>
<h3 id="6-四个map方法的使用"><a href="#6-四个map方法的使用" class="headerlink" title="6.四个map方法的使用"></a>6.四个map方法的使用</h3><ol>
<li><p><strong>mapState方法：</strong>用于帮助我们映射<code>state</code>中的数据为计算属性</p>
<pre><code class="js">computed: &#123;
    //借助mapState生成计算属性：sum、school、subject（对象写法）
     ...mapState(&#123;sum:&#39;sum&#39;,school:&#39;school&#39;,subject:&#39;subject&#39;&#125;),
         
    //借助mapState生成计算属性：sum、school、subject（数组写法）
    ...mapState([&#39;sum&#39;,&#39;school&#39;,&#39;subject&#39;]),
&#125;,
</code></pre>
</li>
<li><p><strong>mapGetters方法：</strong>用于帮助我们映射<code>getters</code>中的数据为计算属性</p>
<pre><code class="js">computed: &#123;
    //借助mapGetters生成计算属性：bigSum（对象写法）
    ...mapGetters(&#123;bigSum:&#39;bigSum&#39;&#125;),

    //借助mapGetters生成计算属性：bigSum（数组写法）
    ...mapGetters([&#39;bigSum&#39;])
&#125;,
</code></pre>
</li>
<li><p><strong>mapActions方法：</strong>用于帮助我们生成与<code>actions</code>对话的方法，即：包含<code>$store.dispatch(xxx)</code>的函数</p>
<pre><code class="js">methods:&#123;
    //靠mapActions生成：incrementOdd、incrementWait（对象形式）
    ...mapActions(&#123;incrementOdd:&#39;jiaOdd&#39;,incrementWait:&#39;jiaWait&#39;&#125;)

    //靠mapActions生成：incrementOdd、incrementWait（数组形式）
    ...mapActions([&#39;jiaOdd&#39;,&#39;jiaWait&#39;])
&#125;
</code></pre>
</li>
<li><p><strong>mapMutations方法：</strong>用于帮助我们生成与<code>mutations</code>对话的方法，即：包含<code>$store.commit(xxx)</code>的函数</p>
<pre><code class="js">methods:&#123;
    //靠mapActions生成：increment、decrement（对象形式）
    ...mapMutations(&#123;increment:&#39;JIA&#39;,decrement:&#39;JIAN&#39;&#125;),
    
    //靠mapMutations生成：JIA、JIAN（对象形式）
    ...mapMutations([&#39;JIA&#39;,&#39;JIAN&#39;]),
&#125;
</code></pre>
</li>
</ol>
<blockquote>
<p>备注：mapActions与mapMutations使用时，若需要传递参数需要：在模板中绑定事件时传递好参数，否则参数是事件对象。</p>
</blockquote>
<h3 id="7-模块化-命名空间"><a href="#7-模块化-命名空间" class="headerlink" title="7.模块化+命名空间"></a>7.模块化+命名空间</h3><ol>
<li><p>目的：让代码更好维护，让多种数据分类更加明确。</p>
</li>
<li><p>修改<code>store.js</code></p>
<pre><code class="javascript">const countAbout = &#123;
  namespaced:true,//开启命名空间
  state:&#123;x:1&#125;,
  mutations: &#123; ... &#125;,
  actions: &#123; ... &#125;,
  getters: &#123;
    bigSum(state)&#123;
       return state.sum * 10
    &#125;
  &#125;
&#125;

const personAbout = &#123;
  namespaced:true,//开启命名空间
  state:&#123; ... &#125;,
  mutations: &#123; ... &#125;,
  actions: &#123; ... &#125;
&#125;

const store = new Vuex.Store(&#123;
  modules: &#123;
    countAbout,
    personAbout
  &#125;
&#125;)
</code></pre>
</li>
<li><p>开启命名空间后，组件中读取state数据：</p>
<pre><code class="js">//方式一：自己直接读取
this.$store.state.personAbout.list
//方式二：借助mapState读取：
...mapState(&#39;countAbout&#39;,[&#39;sum&#39;,&#39;school&#39;,&#39;subject&#39;]),
</code></pre>
</li>
<li><p>开启命名空间后，组件中读取getters数据：</p>
<pre><code class="js">//方式一：自己直接读取
this.$store.getters[&#39;personAbout/firstPersonName&#39;]
//方式二：借助mapGetters读取：
...mapGetters(&#39;countAbout&#39;,[&#39;bigSum&#39;])
</code></pre>
</li>
<li><p>开启命名空间后，组件中调用dispatch</p>
<pre><code class="js">//方式一：自己直接dispatch
this.$store.dispatch(&#39;personAbout/addPersonWang&#39;,person)
//方式二：借助mapActions：
...mapActions(&#39;countAbout&#39;,&#123;incrementOdd:&#39;jiaOdd&#39;,incrementWait:&#39;jiaWait&#39;&#125;)
</code></pre>
</li>
<li><p>开启命名空间后，组件中调用commit</p>
<pre><code class="js">//方式一：自己直接commit
this.$store.commit(&#39;personAbout/ADD_PERSON&#39;,person)
//方式二：借助mapMutations：
...mapMutations(&#39;countAbout&#39;,&#123;increment:&#39;JIA&#39;,decrement:&#39;JIAN&#39;&#125;),
</code></pre>
</li>
</ol>
<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><ol>
<li>理解： 一个路由（route）就是一组映射关系（key - value），多个路由需要路由器（router）进行管理。</li>
<li>前端路由：key是路径，value是组件。</li>
</ol>
<h3 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1.基本使用"></a>1.基本使用</h3><ol>
<li><p>安装vue-router，命令：<code>npm i vue-router</code></p>
</li>
<li><p>应用插件：<code>Vue.use(VueRouter)</code></p>
</li>
<li><p>编写router配置项:</p>
<pre><code class="js">//引入VueRouter
import VueRouter from &#39;vue-router&#39;
//引入Luyou 组件
import About from &#39;../components/About&#39;
import Home from &#39;../components/Home&#39;

//创建router实例对象，去管理一组一组的路由规则
const router = new VueRouter(&#123;
    routes:[
        &#123;
            path:&#39;/about&#39;,
            component:About
        &#125;,
        &#123;
            path:&#39;/home&#39;,
            component:Home
        &#125;
    ]
&#125;)

//暴露router
export default router
</code></pre>
</li>
<li><p>实现切换（active-class可配置高亮样式）</p>
<pre><code class="vue">&lt;router-link active-class=&quot;active&quot; to=&quot;/about&quot;&gt;About&lt;/router-link&gt;
</code></pre>
</li>
<li><p>指定展示位置</p>
<pre><code class="vue">&lt;router-view&gt;&lt;/router-view&gt;
</code></pre>
</li>
</ol>
<h3 id="2-几个注意点"><a href="#2-几个注意点" class="headerlink" title="2.几个注意点"></a>2.几个注意点</h3><ol>
<li>路由组件通常存放在<code>pages</code>文件夹，一般组件通常存放在<code>components</code>文件夹。</li>
<li>通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载。</li>
<li>每个组件都有自己的<code>$route</code>属性，里面存储着自己的路由信息。</li>
<li>整个应用只有一个router，可以通过组件的<code>$router</code>属性获取到。</li>
</ol>
<h3 id="3-多级路由（多级路由）"><a href="#3-多级路由（多级路由）" class="headerlink" title="3.多级路由（多级路由）"></a>3.多级路由（多级路由）</h3><ol>
<li><p>配置路由规则，使用children配置项：</p>
<pre><code class="js">routes:[
    &#123;
        path:&#39;/about&#39;,
        component:About,
    &#125;,
    &#123;
        path:&#39;/home&#39;,
        component:Home,
        children:[ //通过children配置子级路由
            &#123;
                path:&#39;news&#39;, //此处一定不要写：/news
                component:News
            &#125;,
            &#123;
                path:&#39;message&#39;,//此处一定不要写：/message
                component:Message
            &#125;
        ]
    &#125;
]
</code></pre>
</li>
<li><p>跳转（要写完整路径）：</p>
<pre><code class="vue">&lt;router-link to=&quot;/home/news&quot;&gt;News&lt;/router-link&gt;
</code></pre>
</li>
</ol>
<h3 id="4-路由的query参数"><a href="#4-路由的query参数" class="headerlink" title="4.路由的query参数"></a>4.路由的query参数</h3><ol>
<li><p>传递参数</p>
<pre><code class="vue">&lt;!-- 跳转并携带query参数，to的字符串写法 --&gt;
&lt;router-link :to=&quot;/home/message/detail?id=666&amp;title=你好&quot;&gt;跳转&lt;/router-link&gt;
                
&lt;!-- 跳转并携带query参数，to的对象写法 --&gt;
&lt;router-link 
    :to=&quot;&#123;
        path:&#39;/home/message/detail&#39;,
        query:&#123;
           id:666,
            title:&#39;你好&#39;
        &#125;
    &#125;&quot;
&gt;跳转&lt;/router-link&gt;
</code></pre>
</li>
<li><p>接收参数：</p>
<pre><code class="js">$route.query.id
$route.query.title
</code></pre>
</li>
</ol>
<h3 id="5-命名路由"><a href="#5-命名路由" class="headerlink" title="5.命名路由"></a>5.命名路由</h3><ol>
<li><p>作用：可以简化路由的跳转。</p>
</li>
<li><p>如何使用</p>
<ol>
<li><p>给路由命名：</p>
<pre><code class="js">&#123;
    path:&#39;/demo&#39;,
    component:Demo,
    children:[
        &#123;
            path:&#39;test&#39;,
            component:Test,
            children:[
                &#123;
                      name:&#39;hello&#39; //给路由命名
                    path:&#39;welcome&#39;,
                    component:Hello,
                &#125;
            ]
        &#125;
    ]
&#125;
</code></pre>
</li>
<li><p>简化跳转：</p>
<pre><code class="vue">&lt;!--简化前，需要写完整的路径 --&gt;
&lt;router-link to=&quot;/demo/test/welcome&quot;&gt;跳转&lt;/router-link&gt;

&lt;!--简化后，直接通过名字跳转 --&gt;
&lt;router-link :to=&quot;&#123;name:&#39;hello&#39;&#125;&quot;&gt;跳转&lt;/router-link&gt;

&lt;!--简化写法配合传递参数 --&gt;
&lt;router-link 
    :to=&quot;&#123;
        name:&#39;hello&#39;,
        query:&#123;
           id:666,
            title:&#39;你好&#39;
        &#125;
    &#125;&quot;
&gt;跳转&lt;/router-link&gt;
</code></pre>
</li>
</ol>
</li>
</ol>
<h3 id="6-路由的params参数"><a href="#6-路由的params参数" class="headerlink" title="6.路由的params参数"></a>6.路由的params参数</h3><ol>
<li><p>配置路由，声明接收params参数</p>
<pre><code class="js">&#123;
    path:&#39;/home&#39;,
    component:Home,
    children:[
        &#123;
            path:&#39;news&#39;,
            component:News
        &#125;,
        &#123;
            component:Message,
            children:[
                &#123;
                    name:&#39;xiangqing&#39;,
                    path:&#39;detail/:id/:title&#39;, //使用占位符声明接收params参数
                    component:Detail
                &#125;
            ]
        &#125;
    ]
&#125;
</code></pre>
</li>
<li><p>传递参数</p>
<pre><code class="vue">&lt;!-- 跳转并携带params参数，to的字符串写法 --&gt;
&lt;router-link :to=&quot;/home/message/detail/666/你好&quot;&gt;跳转&lt;/router-link&gt;
                
&lt;!-- 跳转并携带params参数，to的对象写法 --&gt;
&lt;router-link 
    :to=&quot;&#123;
        name:&#39;xiangqing&#39;,
        params:&#123;
           id:666,
            title:&#39;你好&#39;
        &#125;
    &#125;&quot;
&gt;跳转&lt;/router-link&gt;
</code></pre>
<blockquote>
<p>特别注意：路由携带params参数时，若使用to的对象写法，则不能使用path配置项，必须使用name配置！</p>
</blockquote>
</li>
<li><p>接收参数：</p>
<pre><code class="js">$route.params.id
$route.params.title
</code></pre>
</li>
</ol>
<h3 id="7-路由的props配置"><a href="#7-路由的props配置" class="headerlink" title="7.路由的props配置"></a>7.路由的props配置</h3><p>​    作用：让路由组件更方便的收到参数</p>
<pre><code class="js">&#123;
    name:&#39;xiangqing&#39;,
    path:&#39;detail/:id&#39;,
    component:Detail,

    //第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件
    // props:&#123;a:900&#125;

    //第二种写法：props值为布尔值，布尔值为true，则把路由收到的所有params参数通过props传给Detail组件
    // props:true
    
    //第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件
    props(route)&#123;
        return &#123;
            id:route.query.id,
            title:route.query.title
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="8-lt-router-link-gt-的replace属性"><a href="#8-lt-router-link-gt-的replace属性" class="headerlink" title="8.&lt;router-link&gt;的replace属性"></a>8.<code>&lt;router-link&gt;</code>的replace属性</h3><ol>
<li>作用：控制路由跳转时操作浏览器历史记录的模式</li>
<li>浏览器的历史记录有两种写入方式：分别为<code>push</code>和<code>replace</code>，<code>push</code>是追加历史记录，<code>replace</code>是替换当前记录。路由跳转时候默认为<code>push</code></li>
<li>如何开启<code>replace</code>模式：<code>&lt;router-link replace .......&gt;News&lt;/router-link&gt;</code></li>
</ol>
<h3 id="9-编程式路由导航"><a href="#9-编程式路由导航" class="headerlink" title="9.编程式路由导航"></a>9.编程式路由导航</h3><ol>
<li><p>作用：不借助<code>&lt;router-link&gt; </code>实现路由跳转，让路由跳转更加灵活</p>
</li>
<li><p>具体编码：</p>
<pre><code class="js">//$router的两个API
this.$router.push(&#123;
    name:&#39;xiangqing&#39;,
        params:&#123;
            id:xxx,
            title:xxx
        &#125;
&#125;)

this.$router.replace(&#123;
    name:&#39;xiangqing&#39;,
        params:&#123;
            id:xxx,
            title:xxx
        &#125;
&#125;)
this.$router.forward() //前进
this.$router.back() //后退
this.$router.go() //可前进也可后退
</code></pre>
</li>
</ol>
<h3 id="10-缓存路由组件"><a href="#10-缓存路由组件" class="headerlink" title="10.缓存路由组件"></a>10.缓存路由组件</h3><ol>
<li><p>作用：让不展示的路由组件保持挂载，不被销毁。</p>
</li>
<li><p>具体编码：</p>
<pre><code class="vue">&lt;keep-alive include=&quot;News&quot;&gt; 
    &lt;router-view&gt;&lt;/router-view&gt;
&lt;/keep-alive&gt;
</code></pre>
</li>
</ol>
<h3 id="11-两个新的生命周期钩子"><a href="#11-两个新的生命周期钩子" class="headerlink" title="11.两个新的生命周期钩子"></a>11.两个新的生命周期钩子</h3><ol>
<li>作用：路由组件所独有的两个钩子，用于捕获路由组件的激活状态。</li>
<li>具体名字：<ol>
<li><code>activated</code>路由组件被激活时触发。</li>
<li><code>deactivated</code>路由组件失活时触发。</li>
</ol>
</li>
</ol>
<h3 id="12-路由守卫"><a href="#12-路由守卫" class="headerlink" title="12.路由守卫"></a>12.路由守卫</h3><ol>
<li><p>作用：对路由进行权限控制</p>
</li>
<li><p>分类：全局守卫、独享守卫、组件内守卫</p>
</li>
<li><p>全局守卫:</p>
<pre><code class="js">//全局前置守卫：初始化时执行、每次路由切换前执行
router.beforeEach((to,from,next)=&gt;&#123;
    console.log(&#39;beforeEach&#39;,to,from)
    if(to.meta.isAuth)&#123; //判断当前路由是否需要进行权限控制
        if(localStorage.getItem(&#39;school&#39;) === &#39;atguigu&#39;)&#123; //权限控制的具体规则
            next() //放行
        &#125;else&#123;
            alert(&#39;暂无权限查看&#39;)
            // next(&#123;name:&#39;guanyu&#39;&#125;)
        &#125;
    &#125;else&#123;
        next() //放行
    &#125;
&#125;)

//全局后置守卫：初始化时执行、每次路由切换后执行
router.afterEach((to,from)=&gt;&#123;
    console.log(&#39;afterEach&#39;,to,from)
    if(to.meta.title)&#123; 
        document.title = to.meta.title //修改网页的title
    &#125;else&#123;
        document.title = &#39;vue_test&#39;
    &#125;
&#125;)
</code></pre>
</li>
<li><p>独享守卫:</p>
<pre><code class="js">beforeEnter(to,from,next)&#123;
    console.log(&#39;beforeEnter&#39;,to,from)
    if(to.meta.isAuth)&#123; //判断当前路由是否需要进行权限控制
        if(localStorage.getItem(&#39;school&#39;) === &#39;atguigu&#39;)&#123;
            next()
        &#125;else&#123;
            alert(&#39;暂无权限查看&#39;)
            // next(&#123;name:&#39;guanyu&#39;&#125;)
        &#125;
    &#125;else&#123;
        next()
    &#125;
&#125;
</code></pre>
</li>
<li><p>组件内守卫：</p>
<pre><code class="js">//进入守卫：通过路由规则，进入该组件时被调用
beforeRouteEnter (to, from, next) &#123;
&#125;,
//离开守卫：通过路由规则，离开该组件时被调用
beforeRouteLeave (to, from, next) &#123;
&#125;
</code></pre>
</li>
</ol>
<h3 id="13-路由器的两种工作模式"><a href="#13-路由器的两种工作模式" class="headerlink" title="13.路由器的两种工作模式"></a>13.路由器的两种工作模式</h3><ol>
<li>对于一个url来说，什么是hash值？—— #及其后面的内容就是hash值。</li>
<li>hash值不会包含在 HTTP 请求中，即：hash值不会带给服务器。</li>
<li>hash模式：<ol>
<li>地址中永远带着#号，不美观 。</li>
<li>若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法。</li>
<li>兼容性较好。</li>
</ol>
</li>
<li>history模式：<ol>
<li>地址干净，美观 。</li>
<li>兼容性和hash模式相比略差。</li>
<li>应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题。</li>
</ol>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>webpack优化</title>
    <url>/2022/04/27/webpack%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="webpack开发环境优化："><a href="#webpack开发环境优化：" class="headerlink" title="webpack开发环境优化："></a>webpack开发环境优化：</h2><h2 id="首先要知道为什么要优化webpack？"><a href="#首先要知道为什么要优化webpack？" class="headerlink" title="首先要知道为什么要优化webpack？"></a>首先要知道为什么要优化webpack？</h2><p>​    不就是因为在开发阶段可以及时的编译和浏览器实时刷新页面知道最新的内容嘛，   但是如果说模块很多的话  刷新页    面这个方案很是不好，加载很慢。</p>
<h3 id="优化打包构建速度-HMR"><a href="#优化打包构建速度-HMR" class="headerlink" title="优化打包构建速度 HMR"></a>优化打包构建速度 HMR</h3><p>​    HMR 全称 Hot Module Replacement，中文语境通常翻译为模块热更新，它能够在保持页面状态的情况下动态替换资源    模块，提供丝滑顺畅的 Web 页面开发体验。</p>
<p>​    所以说有一个HMR（热更新，热模块）这个可以让你实时的监听你的文件变化从而达    到替换小一部分dom</p>
<pre><code class="js">if (module.hot) &#123;
  // 一旦 module.hot 为true，说明开启了HMR功能。 --&gt; 让HMR功能代码生效
  module.hot.accept(&#39;./print.js&#39;, function() &#123;
    // 方法会监听 print.js 文件的变化，一旦发生变化，其他模块不会重新打包构建。
    // 会执行后面的回调函数
    print();
  &#125;);
&#125;
</code></pre>
<h3 id="优化代码调试-source-map"><a href="#优化代码调试-source-map" class="headerlink" title="优化代码调试    source-map"></a>优化代码调试    source-map</h3><p>​    再思考一个问题 webpack最后打包生成的bundle聚集了所有的代码，如果说其中有一行代码出错了 你是想精准的定位    到哪一行还是说不让其有报错</p>
<p>​    设置sourcemap中的属性可以有很多种模式</p>
<pre><code class="js">/*
  source-map: 一种 提供源代码到构建后代码映射 技术 （如果构建后代码出错了，通过映射可以追踪源代码错误）

    [inline-|hidden-|eval-][nosources-][cheap-[module-]]source-map

    source-map：外部
      错误代码准确信息 和 源代码的错误位置
    inline-source-map：内联
      只生成一个内联source-map
      错误代码准确信息 和 源代码的错误位置
    hidden-source-map：外部
      错误代码错误原因，但是没有错误位置
      不能追踪源代码错误，只能提示到构建后代码的错误位置
    eval-source-map：内联
      每一个文件都生成对应的source-map，都在eval
      错误代码准确信息 和 源代码的错误位置
    nosources-source-map：外部
      错误代码准确信息, 但是没有任何源代码信息
    cheap-source-map：外部
      错误代码准确信息 和 源代码的错误位置 
      只能精确的行
    cheap-module-source-map：外部
      错误代码准确信息 和 源代码的错误位置 
      module会将loader的source map加入

    内联 和 外部的区别：1. 外部生成了文件，内联没有 2. 内联构建速度更快

    开发环境：速度快，调试更友好
      速度快(eval&gt;inline&gt;cheap&gt;...)
        eval-cheap-souce-map
        eval-source-map
      调试更友好  
        souce-map
        cheap-module-souce-map
        cheap-souce-map

      --&gt; eval-source-map  / eval-cheap-module-souce-map

    生产环境：源代码要不要隐藏? 调试要不要更友好
      内联会让代码体积变大，所以在生产环境不用内联
      nosources-source-map 全部隐藏
      hidden-source-map 只隐藏源代码，会提示构建后代码错误信息

      --&gt; source-map / cheap-module-souce-map
*/
</code></pre>
<h1 id="生产环境中："><a href="#生产环境中：" class="headerlink" title="生产环境中："></a>生产环境中：</h1><h2 id="优化打包构建速度"><a href="#优化打包构建速度" class="headerlink" title="优化打包构建速度"></a>优化打包构建速度</h2><h3 id="oneOf："><a href="#oneOf：" class="headerlink" title="oneOf："></a>oneOf：</h3><p>提升构建速度，避免每个文件都被所有<code>loader</code>过一遍，因为任何一个文件，构建过程中，在遇到第一个与之对应的<code>loader</code>后，不会再往下进行。</p>
<pre><code class="js">module: &#123;
  rules: [
    &#123;
      oneOf:[
        &#123;
          test: /\.css$/,
          use: [&quot;style-loader&quot;, &quot;css-loader&quot;],
        &#125;,
        &#123;
          test: /\.html$/,
          loader: &quot;html-loader&quot;,
        &#125;,
        &#123;
          test: /\.js$/,
          loader: &quot;eslint-loader&quot;,
        &#125;
      ]
    &#125;
  ],
&#125;,
</code></pre>
<p>但是，实际开发过程中，同样会有一个文件需要匹配多个<code>loader</code>的场景，比如<code>js</code>文件同时需要<code>eslint-loader</code>和<code>babel-loader</code>，这样的话就不能将两个<code>loader</code>都放到<code>oneOf</code>里面，因为一旦匹配了第一个<code>loader</code>就不会再继续执行第二个<code>loader</code>，解决办法也很简单，只需要放到<code>oneOf</code>外面即可。</p>
<pre><code class="js">module: &#123;
  rules: [
    &#123;
      test: /\.js$/,
      enforce: &quot;pre&quot;,
      loader: &quot;eslint-loader&quot;,
    &#125;,
    &#123;
      oneOf:[
        &#123;
          test: /\.css$/,
          use: [&quot;style-loader&quot;, &quot;css-loader&quot;],
        &#125;,
        &#123;
          test: /\.html$/,
          loader: &quot;html-loader&quot;,
        &#125;,
        &#123;
          test: /\.js$/,
          loader: &quot;babel-loader&quot;,
        &#125;
      ]
    &#125;
  ],
&#125;,
</code></pre>
<h3 id="babel缓存："><a href="#babel缓存：" class="headerlink" title="babel缓存："></a>babel缓存：</h3><pre><code class="js">/*
  缓存：
    babel缓存
      cacheDirectory: true
      --&gt; 让第二次打包构建速度更快
    文件资源缓存
      hash: 每次wepack构建时会生成一个唯一的hash值。
        问题: 因为js和css同时使用一个hash值。
          如果重新打包，会导致所有缓存失效。（可能我却只改动一个文件）
      chunkhash：根据chunk生成的hash值。如果打包来源于同一个chunk，那么hash值就一样
        问题: js和css的hash值还是一样的
          因为css是在js中被引入的，所以同属于一个chunk
      contenthash: 根据文件的内容生成hash值。不同文件hash值一定不一样    
      --&gt; 让代码上线运行缓存更好使用
*/
module: &#123;
    rules: [
        &#123;
            test: /\.js$/,
            exclude: /node_modules/,
            loader: &#39;babel-loader&#39;,
            options: &#123;
                presets: [
                    [
                        &#39;@babel/preset-env&#39;,
                        &#123;
                            useBuiltIns: &#39;usage&#39;,
                            corejs: &#123; version: 3 &#125;,
                            targets: &#123;
                                chrome: &#39;60&#39;,
                                firefox: &#39;50&#39;
                            &#125;
                        &#125;
                    ]
                ],
                // 开启babel缓存
                // 第二次构建时，会读取之前的缓存
                cacheDirectory: true
            &#125;
        &#125;,
    ]
&#125;
</code></pre>
<h3 id="多进程打包"><a href="#多进程打包" class="headerlink" title="多进程打包"></a>多进程打包</h3><pre><code class="js">module: &#123;
    rules: [
        &#123;
            test: /\.js$/,
            exclude: /node_modules/,
            use: [
                /* 
                开启多进程打包。 
                进程启动大概为600ms，进程通信也有开销。
                只有工作消耗时间比较长，才需要多进程打包
              */
                &#123;
                    loader: &#39;thread-loader&#39;,
                    options: &#123;
                        workers: 2 // 进程2个
                    &#125;
                &#125;,
                &#123;
                    loader: &#39;babel-loader&#39;,
                    options: &#123;
                        presets: [
                            [
                                &#39;@babel/preset-env&#39;,
                                &#123;
                                    useBuiltIns: &#39;usage&#39;,
                                    corejs: &#123; version: 3 &#125;,
                                    targets: &#123;
                                        chrome: &#39;60&#39;,
                                        firefox: &#39;50&#39;
                                    &#125;
                                &#125;
                            ]
                        ],
                        // 开启babel缓存
                        // 第二次构建时，会读取之前的缓存
                        cacheDirectory: true
                    &#125;
                &#125;
            ]
        &#125;,
    ]
&#125;
</code></pre>
<h3 id="externals"><a href="#externals" class="headerlink" title="externals"></a>externals</h3><pre><code class="js">  externals: &#123;
    // 拒绝jQuery被打包进来
    jquery: &#39;jQuery&#39;
  &#125;
</code></pre>
<p>如果需要引用一个库，但是又不想让webpack打包（减少打包的时间），并且又不影响我们在程序中以<a href="https://so.csdn.net/so/search?q=CMD&spm=1001.2101.3001.7020">CMD</a>、AMD或者window/global全局等方式进行使用（一般都以import方式引用使用），那就可以通过配置externals。</p>
<p>这样做的目的就是<strong>将不怎么需要更新的第三方库脱离webpack打包，不被打入bundle中，从而减少打包时间，但又不影响运用第三方库的方式，例如import方式等。</strong></p>
<h3 id="dll"><a href="#dll" class="headerlink" title="dll"></a>dll</h3><ul>
<li><p>什么是DLL</p>
<ul>
<li><p>DLL全称是动态链接库(Dynamic Link Library)，是为软件在Windows中实现共享函数库的一种实现方式;</p>
</li>
<li><p>那么webpack中也有内置DLL的功能，它指的是可以将可以共享，并且不经常改变的代码，抽取成一个共享的库;</p>
</li>
<li><p>这个库在之后编译的过程中，会被引入到其他项目的代码中，减少的打包的时间;</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>DDL库的使用分为两步:</p>
<ul>
<li><p>第一步:打包一个DLL库; </p>
<p><strong>webpack –config webpack.dll.js</strong></p>
</li>
<li><p>第二步:项目中引入DLL库</p>
<p><strong>webpack</strong></p>
</li>
</ul>
</li>
</ul>
<pre><code class="js">// webpack.dll.js
/*
  使用dll技术，对某些库（第三方库：jquery、react、vue...）进行单独打包
    当你运行 webpack 时，默认查找 webpack.config.js 配置文件
    需求：需要运行 webpack.dll.js 文件
      --&gt; webpack --config webpack.dll.js
*/
const &#123; resolve &#125; = require(&#39;path&#39;);
const webpack = require(&#39;webpack&#39;);

module.exports = &#123;
  entry: &#123;
    // 最终打包生成的[name] --&gt; jquery
    // [&#39;jquery&#39;] --&gt; 要打包的库是jquery
    jquery: [&#39;jquery&#39;],
  &#125;,
  output: &#123;
    filename: &#39;[name].js&#39;,
    path: resolve(__dirname, &#39;dll&#39;),
    library: &#39;[name]_[hash]&#39; // 打包的库里面向外暴露出去的内容叫什么名字
  &#125;,
  plugins: [
    // 打包生成一个 manifest.json --&gt; 提供和jquery映射
    new webpack.DllPlugin(&#123;
      name: &#39;[name]_[hash]&#39;, // 映射库的暴露的内容名称
      path: resolve(__dirname, &#39;dll/manifest.json&#39;) // 输出文件路径
    &#125;)
  ],
  mode: &#39;production&#39;
&#125;;
</code></pre>
<pre><code class="js">// webpack.config.js
const &#123; resolve &#125; = require(&#39;path&#39;);
const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);
const webpack = require(&#39;webpack&#39;);
const AddAssetHtmlWebpackPlugin = require(&#39;add-asset-html-webpack-plugin&#39;);

module.exports = &#123;
  entry: &#39;./src/index.js&#39;,
  output: &#123;
    filename: &#39;built.js&#39;,
    path: resolve(__dirname, &#39;build&#39;)
  &#125;,
  plugins: [
    new HtmlWebpackPlugin(&#123;
      template: &#39;./src/index.html&#39;
    &#125;),
    // 告诉webpack哪些库不参与打包，同时使用时的名称也得变~
    new webpack.DllReferencePlugin(&#123;
      manifest: resolve(__dirname, &#39;dll/manifest.json&#39;)
    &#125;),
    // 将某个文件打包输出去，并在html中自动引入该资源
    new AddAssetHtmlWebpackPlugin(&#123;
      filepath: resolve(__dirname, &#39;dll/jquery.js&#39;)
    &#125;)
  ],
  mode: &#39;production&#39;
&#125;;
</code></pre>
<h2 id="优化代码运行的性能"><a href="#优化代码运行的性能" class="headerlink" title="优化代码运行的性能"></a>优化代码运行的性能</h2><h3 id="缓存-hash-chunkhash-contenthash"><a href="#缓存-hash-chunkhash-contenthash" class="headerlink" title="缓存(hash-chunkhash-contenthash)"></a>缓存(hash-chunkhash-contenthash)</h3><pre><code class="js">      hash: 每次wepack构建时会生成一个唯一的hash值。
        问题: 因为js和css同时使用一个hash值。
          如果重新打包，会导致所有缓存失效。（可能我却只改动一个文件）
      chunkhash：根据chunk生成的hash值。如果打包来源于同一个chunk，那么hash值就一样
        问题: js和css的hash值还是一样的
          因为css是在js中被引入的，所以同属于一个chunk
      contenthash: 根据文件的内容生成hash值。不同文件hash值一定不一样 
</code></pre>
<h3 id="tree-shaking"><a href="#tree-shaking" class="headerlink" title="tree shaking"></a>tree shaking</h3><pre><code class="js">/*
  tree shaking：去除无用代码
    前提：1. 必须使用ES6模块化  2. 开启production环境
    作用: 减少代码体积

    在package.json中配置 
      &quot;sideEffects&quot;: false 所有代码都没有副作用（都可以进行tree shaking）
        问题：可能会把css / @babel/polyfill （副作用）文件干掉
      &quot;sideEffects&quot;: [&quot;*.css&quot;, &quot;*.less&quot;]
*/
</code></pre>
<h3 id="code-split"><a href="#code-split" class="headerlink" title="code split"></a>code split</h3><p>当使用 webpack 打包 JavaScript 文件的时候，依赖了第三方库，比如 有两个入口：testa，testb，  都依赖了 jQuery，jQuery就会被打包到这两个文件中，显然这是不太合理的，应该是 jQuery 单独打包一个文件，然后 testa 和 testb 分别引入。</p>
<p>方式一：</p>
<p>通过配置多入口，打包成多个文件</p>
<p>方式二：</p>
<p>动态引入 (dynamic import) JavaScript 文件必然会单独打包</p>
<pre><code class="js">// 通过 /*webpackChunkName:lodash*/ 给构建出的chunk命名，否则会以构建id命名。
import(/*webpackChunkName:&#39;lodash&#39;*/&#39;lodash&#39;)
 .then(params) =&gt; &#123;
  // 导入成功
&#125;)
.catch((error) =&gt; &#39;An error occurred while loading the component&#39;); 
</code></pre>
<p>方式三：</p>
<p>配置webpack的code split  </p>
<pre><code class="js">const path = require(&#39;path&#39;)
const webpack = require(&#39;webpack&#39;)

module.exports = &#123;
    mode: &#39;development&#39;,
    entry: path.resolve(__dirname, &#39;src/index.js&#39;),
    plugins: [
        new webpack.HashedModuleIdsPlugin() // 根据模块的相对路径生成 HASH 作为模块 ID
    ],
    output: &#123;
        path: path.resolve(__dirname, &#39;dist&#39;),
        filename: &#39;[name].[contenthash].js&#39;
    &#125;,
    optimization: &#123;
        runtimeChunk: &#39;single&#39;,
        splitChunks: &#123;
            chunks: &#39;all&#39;, // 默认 async 可选值 all 和 initial
            maxInitialRequests: Infinity, // 一个入口最大的并行请求数
            minSize: 0, // 避免模块体积过小而被忽略
            minChunks: 1, // 默认也是一表示最小引用次数
            cacheGroups: &#123;
                vendor: &#123;
                    test: /[\\/]node_modules[\\/]/, // 如果需要的依赖特别小，可以直接设置成需要打包的依赖名称
                    name(module, chunks, chcheGroupKey) &#123; // 可提供布尔值、字符串和函数，如果是函数，可编写自定义返回值
                        const packageName = module.context.match(/[\\/]node_modules[\\/](.*?)([\\/]|$)/)[1] // 获取模块名称
                        return `npm.$&#123;packageName.replace(&#39;@&#39;, &#39;&#39;)&#125;` // 可选，一般情况下不需要将模块名称 @ 符号去除
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="懒加载-预加载"><a href="#懒加载-预加载" class="headerlink" title="懒加载/预加载"></a>懒加载/预加载</h3><pre><code class="js">  // 懒加载~：当文件需要使用时才加载~
  // 预加载 prefetch：会在使用之前，提前加载js文件 
  // 正常加载可以认为是并行加载（同一时间加载多个文件）  
  // 预加载 prefetch：等其他资源加载完毕，浏览器空闲了，再偷偷加载资源   
  // 魔法注释 webpackPrefetch: true  开启预加载
  import(/* webpackChunkName: &#39;test&#39;, webpackPrefetch: true */&#39;./test&#39;).then((&#123; mul &#125;) =&gt; &#123;
    console.log(mul(4, 5));
  &#125;);
</code></pre>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack的优缺点</title>
    <url>/2022/04/27/webpack%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9/</url>
    <content><![CDATA[<p>优点：<br>（1） webpack 是以 commonJS 的形式来书写脚本滴，但对 AMD/CMD 的支持也很全面，方便旧项目进行代码迁移。<br>（2）能被模块化的不仅仅是 JS 了。<br>（3） 开发便捷，能替代部分 grunt/gulp 的工作，比如打包、压缩混淆、图片转base64等。<br>（4）扩展性强，插件机制完善<br>缺点：<br>● 配置复杂<br>● 不分包bundle.js体积庞大<br>● 只能用于采用模块化开发的项目<br>● 打包慢<br>● ES模块除Module外全用babel转换，但是一部分ES2015 语法的 firefox 与 chrome 浏览器中能直接跑的代码，无法用 webpack 编译</p>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack的工作原理</title>
    <url>/2022/04/27/webpack%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="webpack的工作原理？"><a href="#webpack的工作原理？" class="headerlink" title="webpack的工作原理？"></a>webpack的工作原理？</h1><h2 id="工作原理概括"><a href="#工作原理概括" class="headerlink" title="工作原理概括"></a>工作原理概括</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>在了解webpack原理前，需要掌握以下几个核心概念，以方便后面的理解：</p>
<ol>
<li>Entry:入口指示webpack以哪个文件为入口起点开始打包，分析构建内部依赖图</li>
<li>output:输出指示webpack的打包后的资源bundles输出到哪里去，以及如何命名</li>
<li>Loader:让webpack能够去处理哪些非JavaScrip文件（webpack自身只理解javaScript)</li>
<li>plugin:插件可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量等</li>
<li>mode:模式指示webpack使用相应模式的配置</li>
</ol>
<h3 id="流程概括"><a href="#流程概括" class="headerlink" title="流程概括"></a>流程概括</h3><p>webpack的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：</p>
<ol>
<li>初始化参数：从配置文件和Shell语句中读取与合并参数，得出最终的参数；</li>
<li>开始编译： 用上一步得到的参数初始化Complier对象，加载所有配置的插件，执行对象的run方法开始执行编译；</li>
<li>确定入口： 根据配置中的entry找出所有入口文件；</li>
<li>编译模块：从入口文件出发，调用所有配置的Loader对模块进行翻译，再找出该模块依赖的模块，再递归本步骤知道所有入口依赖的文件都经过了本步骤的处理；</li>
<li>完成模块编译： 在经过第4步使用Loader翻译完所有模块后，得到了每个模块被翻译后的最终内容以及他们之间的依赖关系；</li>
<li>输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的Chunk，再把每个Chunk转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；</li>
<li>输出完成： 在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。<br>在以上过程中，webpack会在特定的时间点广播出特定的时间，插件在监听到感兴趣的时间后会执行特定的逻辑，并且插件可以调用Webpack提供的API改变Webpack的运行结果。</li>
</ol>
<h3 id="流程细节"><a href="#流程细节" class="headerlink" title="流程细节"></a>流程细节</h3><p>Webpack的构建流程可以分为以下三个阶段：</p>
<ol>
<li>初始化：启动构建，读取与合并配置参数，加载Plugin，实例化Complier.</li>
<li>编译：从Entry出发，针对每个Module串行调用对应的Loader去翻译文件内容，再找到该Module依赖的Module，递归地进行编译处理。</li>
<li>输出： 对编译后的Module组合成Chunk，把Chunk转换成文件，输出到文件系统。<br>如果只执行一次构建，以上阶段将会按照顺序各执行一次。但在开启监听模式下，流程将变为如下：</li>
</ol>
<p><img src="/.com//image.png"></p>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>前端模块化</title>
    <url>/2022/04/27/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    <content><![CDATA[<h2 id="模块化开发的好处"><a href="#模块化开发的好处" class="headerlink" title="模块化开发的好处"></a>模块化开发的好处</h2><pre><code>1. 避免变量污染，命名冲突
2. 提高代码复用率
3. 提高了可维护性
4. 方便依赖关系管理
</code></pre>
<blockquote>
<p> 在有 Babel 的情况下，我们可以直接使用 ES6的模块化</p>
</blockquote>
<pre><code class="js">// file a.js
export function a() &#123;&#125;
export function b() &#123;&#125;
// file b.js
export default function() &#123;&#125;

import &#123;a, b&#125; from &#39;./a.js&#39;
import XXX from &#39;./b.js&#39;
</code></pre>
<blockquote>
<p>CommonJS<br><strong>CommonJs 是 Node 独有的规范，浏览器中使用就需要用到 Browserify解析了。</strong></p>
</blockquote>
<pre><code class="js">// a.js
module.exports = &#123;
    a: 1
&#125;
// or
exports.a = 1

// b.js
var module = require(&#39;./a.js&#39;)
module.a // -&gt; log 1
</code></pre>
<blockquote>
<p>在上述代码中，module.exports 和 exports 很容易混淆，让我们来看看大致内部实现</p>
</blockquote>
<pre><code class="js">var module = require(&#39;./a.js&#39;)
module.a
// 这里其实就是包装了一层立即执行函数，这样就不会污染全局变量了，
// 重要的是 module 这里，module 是 Node 独有的一个变量
module.exports = &#123;
    a: 1
&#125;
// 基本实现
var module = &#123;
  exports: &#123;&#125; // exports 就是个空对象
&#125;
// 这个是为什么 exports 和 module.exports 用法相似的原因
var exports = module.exports
var load = function (module) &#123;
    // 导出的东西
    var a = 1
    module.exports = a
    return module.exports
&#125;;
</code></pre>
<blockquote>
<p>再来说说 module.exports 和exports，用法其实是相似的，但是不能对 exports 直接赋值，不会有任何效果。</p>
</blockquote>
<blockquote>
<p>对于 CommonJS 和 ES6 中的模块化的两者区别是：</p>
</blockquote>
<ul>
<li>前者支持动态导入，也就是 require(${path}/xx.js)，后者目前不支持，但是已有提案,前者是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。</li>
<li>而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响</li>
<li>前者在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。</li>
<li>但是后者采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化</li>
<li>后者会编译成 require/exports 来执行的</li>
</ul>
<h2 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h2><p>AMD 是由 RequireJS 提出的</p>
<pre><code class="js">// AMD
define([&#39;./a&#39;, &#39;./b&#39;], function(a, b) &#123;
    a.do()
    b.do()
&#125;)
define(function(require, exports, module) &#123;   
    var a = require(&#39;./a&#39;)  
    a.doSomething()   
    var b = require(&#39;./b&#39;)
    b.doSomething()
&#125;)
</code></pre>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack的loader是什么</title>
    <url>/2022/04/27/webpack%E7%9A%84loader%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<h2 id="Webpack-的-Loader-是什么？"><a href="#Webpack-的-Loader-是什么？" class="headerlink" title="Webpack 的 Loader 是什么？"></a>Webpack 的 Loader 是什么？</h2><p>Webpack 只能理解 JavaScript 和 JSON 文件，这是 Webpack 开箱可用的自带能力。loader 可以让 Webpack 能够去处理其他类型的文件，比如 .scss 和 .ts，并将它们转换为有效的功能离散的 chunk 文件以供应用程序使用，以及被添加到依赖图中，也可将内联图像转换为 data URL。简单来说，loader 可以将一段代码转换成另一端代码，通常用来将一段特殊代码转换成一段浏览器可识别的代码。<br>loader从下到上地取值(evaluate)/执行(execute)，也就是是从后往前执行。在下面的示例中，从 ts-loader开始执行，然后继续执行 css-loader，最后以 raw-loader 为结束。loader 有两个属性：test，正则表达式，用于识别出哪些文件会被转换，use 定义在进行转换时应该使用哪个 loader，可以是字符串、数组和对象。</p>
<h2 id="Loader机制的作用是什么？"><a href="#Loader机制的作用是什么？" class="headerlink" title="Loader机制的作用是什么？"></a>Loader机制的作用是什么？</h2><p>webpack 本身只能处理 JavaScript 和 JSON 文件，而 loader 为 webpack 添加了处理其他类型文件的能力。<br>webpack默认只能打包js文件，配置里的module.rules数组配置了一组规则，告诉 Webpack 在遇到哪些文件时使用哪些 Loader 去加载和转换打包成js。<br>注意：use属性的值需要是一个由 Loader 名称组成的数组，Loader 的执行顺序是由后到前的；每一个 Loader 都可以通过 URL querystring 的方式传入参数，例如css-loader?minimize中的minimize告诉css-loader要开启 CSS 压缩。</p>
<h2 id="有哪些常见的Loader？他们是解决什么问题的？"><a href="#有哪些常见的Loader？他们是解决什么问题的？" class="headerlink" title="有哪些常见的Loader？他们是解决什么问题的？"></a>有哪些常见的Loader？他们是解决什么问题的？</h2><p>● file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件<br>● url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去<br>● source-map-loader：加载额外的 Source Map 文件，以方便断点调试<br>● image-loader：加载并且压缩图片文件<br>● babel-loader：把 ES6 转换成 ES5<br>● css-loader：加载 CSS，支持模块化、压缩、文件导入等特性<br>● style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。<br>● eslint-loader：通过 ESLint 检查 JavaScript 代码</p>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>扫码登录（uniapp&amp;vue）</title>
    <url>/2022/04/27/%E6%89%AB%E7%A0%81%E7%99%BB%E5%BD%95/</url>
    <content><![CDATA[<h2 id="手机app扫码登录网站"><a href="#手机app扫码登录网站" class="headerlink" title="手机app扫码登录网站"></a>手机app扫码登录网站</h2><ol>
<li>用户打开web端网页，进入扫码登录的界面；</li>
<li>从web端服务器获取二维码的唯一标识，用于表示该二维码所对应的用户，方便后面 PC端网页异步轮询xmlhttprequest (ajax)，定期轮询后台 查看用户是否扫描二维码</li>
<li>web端服务器在生成二维码时，与请求会的唯一标识（uuid）进行关联，后端将uuid存储到数据库中，方便后面轮询后台</li>
<li>用户打开APP端，扫描二维码进行授权登录操作</li>
<li>APP客户端从二维码中读取到uuid，带着APP内的身份信息访问服务器 也就是token</li>
<li>服务器获取到用户信息之后，将用户的id更新到数据库前面存储的单条数据uuid中，此时web服务器就能拿到对应的用户id，之后生成登录身份信息返回给浏览器，即用户在web端完成了登录</li>
</ol>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="pc端："><a href="#pc端：" class="headerlink" title="pc端："></a>pc端：</h3><pre><code class="vue">// 首先下载 qrcodejs2 模块  npm i qrcodejs2 --save
// 在组件中使用
&lt;template&gt;
    &lt;div class=&quot;qrcode&quot; ref=&quot;qrCodeUrl&quot;&gt;&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import QRCode from &quot;qrcodejs2&quot;;
import axios from &quot;axios&quot;;
export default &#123;
  data() &#123;
    return &#123;
      uuid: &quot;&quot;,  // 请求回来的唯一标识
      timer: &quot;&quot;,
    &#125;;
  &#125;,
  methods: &#123;
    // 获取唯一id生成二维码
    async getUuid() &#123;
      const &#123;
        data: &#123; uuid &#125;,
      &#125; = await axios.get(&quot;http://127.0.0.1:3000/ewm&quot;);
      this.uuid = uuid;
      // 生成二维码
      this.creatQrCode();
    &#125;,
    creatQrCode() &#123;
      var qrcode = new QRCode(this.$refs.qrCodeUrl, &#123;
        text: JSON.stringify(&#123;
          uuid: this.uuid,
          token: &quot;123&quot;,
        &#125;), // 需要转换为二维码的内容
        width: 100,
        height: 100,
        colorDark: &quot;#000000&quot;,
        colorLight: &quot;#ffffff&quot;,
        correctLevel: QRCode.CorrectLevel.H,
      &#125;);

      // 二维码显示成功之后 运行PC端网页异步轮询xmlhttprequest (ajax)，定期轮询后台  每隔200毫秒向后端发送一次请求 查看是否登录成功
      this.getStatus();
    &#125;,
    // 轮询后端
    async getStatus() &#123;
      let _this = this;
      const &#123;
        data: &#123; status &#125;,
      &#125; = await axios.get(&quot;http://127.0.0.1:3000/isLogin&quot;, &#123;
        params: &#123;
          uuid: this.uuid,
        &#125;,
      &#125;);
      // 如果没有登录成功的话  一直询问是否登录成功
      if (status === 400) &#123;
        this.timer = setTimeout(function () &#123;
          _this.getStatus();
        &#125;, 200);
      &#125;
      clearTimeout(this.timer);
    &#125;,
  &#125;,
  mounted() &#123;
    this.getUuid();
  &#125;,
&#125;;
&lt;/script&gt;
</code></pre>
<h3 id="APP端"><a href="#APP端" class="headerlink" title="APP端"></a>APP端</h3><pre><code class="vue">&lt;template&gt;
    &lt;view class=&quot;content&quot;&gt;
        &lt;view @click=&quot;scan&quot;&gt;扫码验证&lt;/view&gt;
    &lt;/view&gt;
&lt;/template&gt;

&lt;script&gt;
    export default &#123;
        data() &#123;
            return &#123;
            &#125;
        &#125;,
        methods: &#123;
            scan() &#123; //扫码验证
                var _this = this;
                uni.scanCode(&#123;
                    onlyFromCamera: false, //为true只允许相机扫码，不加允许相册扫码
                    success: function(res) &#123;
                        console.log(res.result, &#39;@@@&#39;)
                        // 发送请求将获取的  &#123;&quot;uuid&quot;:1650462410424,&quot;token&quot;:&quot;123&quot;&#125;  数据发送到服务端  服务端返回用户数据到浏览器  浏览器页面进行跳转页面
                        
                        uni.showToast(&#123;
                            title: &#39;扫码成功&#39;
                        &#125;)
                    &#125;,
                    fail: function(err) &#123;
                        console.log(&#39;扫码失败&#39;, err)
                    &#125;
                &#125;)
            &#125;,
        &#125;
    &#125;
&lt;/script&gt;
</code></pre>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>扫码登录</tag>
      </tags>
  </entry>
  <entry>
    <title>是否写过Loader和Plugin？描述一下编写loader或plugin的思路？</title>
    <url>/2022/04/27/%E6%98%AF%E5%90%A6%E5%86%99%E8%BF%87Loader%E5%92%8CPlugin%EF%BC%9F%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8B%E7%BC%96%E5%86%99loader%E6%88%96plugin%E7%9A%84%E6%80%9D%E8%B7%AF%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="是否写过Loader和Plugin？描述一下编写loader或plugin的思路？"><a href="#是否写过Loader和Plugin？描述一下编写loader或plugin的思路？" class="headerlink" title="是否写过Loader和Plugin？描述一下编写loader或plugin的思路？"></a>是否写过Loader和Plugin？描述一下编写loader或plugin的思路？</h2><p>Loader像一个”翻译官”把读到的源文件内容转义成新的文件内容，并且每个Loader通过链式操作，将源文件一步步翻译成想要的样子。<br>编写Loader时要遵循单一原则，每个Loader只做一种”转义”工作。 每个Loader的拿到的是源文件内容（source），可以通过返回值的方式将处理后的内容输出，也可以调用this.callback()方法，将内容返回给webpack。 还可以通过 this.async()生成一个callback函数，再用这个callback将处理后的内容输出出去。 此外webpack还为开发者准备了开发loader的工具函数集——loader-utils。<br>相对于Loader而言，Plugin的编写就灵活了许多。 webpack在运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</p>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器安全插箱跨域</title>
    <url>/2019/10/24/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8%E6%8F%92%E7%AE%B1%E8%B7%A8%E5%9F%9F/</url>
    <content><![CDATA[<p><strong>什么是跨域？</strong></p>
<ul>
<li>概念如下：只要协议、域名、端口有任何一个不同，都被当作是不同的域</li>
</ul>
<p><strong>下面是具体的跨域情况详解</strong></p>
<table>
<thead>
<tr>
<th align="left">URL</th>
<th align="left">说明</th>
<th align="left">是否允许通信</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="http://www.a.com/a.js%E3%80%81http://www.a.com/b.js">http://www.a.com/a.js、http://www.a.com/b.js</a></td>
<td align="left">同一域名下</td>
<td align="left">允许</td>
</tr>
<tr>
<td align="left"><a href="http://www.a.com/lab/a.js%E3%80%81http://www.a.com/script/b.js">http://www.a.com/lab/a.js、http://www.a.com/script/b.js</a></td>
<td align="left">同一域名下不同文件夹</td>
<td align="left">允许</td>
</tr>
<tr>
<td align="left"><a href="http://www.a.com:8000/a.js%E3%80%81http://www.a.com/b.js">http://www.a.com:8000/a.js、http://www.a.com/b.js</a></td>
<td align="left">同一域名，不同端口</td>
<td align="left">不允许</td>
</tr>
<tr>
<td align="left"><a href="http://www.a.com/a.js%E3%80%81https://www.a.com/b.js">http://www.a.com/a.js、https://www.a.com/b.js</a></td>
<td align="left">同一域名，不同协议</td>
<td align="left">不允许</td>
</tr>
<tr>
<td align="left"><a href="http://www.a.com/a.js%E3%80%81http://70.32.92.74/b.js">http://www.a.com/a.js、http://70.32.92.74/b.js</a></td>
<td align="left">域名和域名对应ip</td>
<td align="left">不允许</td>
</tr>
<tr>
<td align="left"><a href="http://www.a.com/a.js%E3%80%81http://script.a.com/b.js">http://www.a.com/a.js、http://script.a.com/b.js</a></td>
<td align="left">主域相同，子域不同</td>
<td align="left">不允许（cookie这种情况下也不允许访问）</td>
</tr>
<tr>
<td align="left"><a href="http://www.a.com/a.js%E3%80%81http://a.com/b.js">http://www.a.com/a.js、http://a.com/b.js</a></td>
<td align="left">同一域名，不同二级域名（同上）</td>
<td align="left">不允许（cookie这种情况下也不允许访问）</td>
</tr>
<tr>
<td align="left"><a href="http://www.cnblogs.com/a.js%E3%80%81http://www.a.com/b.js">http://www.cnblogs.com/a.js、http://www.a.com/b.js</a></td>
<td align="left">不同域名</td>
<td align="left">不允许</td>
</tr>
</tbody></table>
<h2 id="一、document-domain跨域"><a href="#一、document-domain跨域" class="headerlink" title="一、document.domain跨域"></a>一、document.domain跨域</h2><hr>
<ul>
<li>原理：相同主域名不同子域名下的页面，可以设置<code>document.domain</code>让它们同域</li>
<li>限制：同域<code>document</code>提供的是页面间的互操作，需要载入<code>iframe</code>页面</li>
</ul>
<blockquote>
<p>下面几个域名下的页面都是可以通过<code>document.domain</code>跨域互操作的： <code>http://a.com/foo</code>, <code>http://b.a.com/bar</code>, <code>http://c.a.com/bar</code>。 但只能以页面嵌套的方式来进行页面互操作，比如常见的<code>iframe</code>方式就可以完成页面嵌套</p>
</blockquote>
<pre><code>// URL http://a.com/foo
var ifr = document.createElement(&#39;iframe&#39;);
ifr.src = &#39;http://b.a.com/bar&#39;; 
ifr.onload = function()&#123;
    var ifrdoc = ifr.contentDocument || ifr.contentWindow.document;
    ifrdoc.getElementsById(&quot;foo&quot;).innerHTML);
&#125;;

ifr.style.display = &#39;none&#39;;
document.body.appendChild(ifr);
</code></pre>
<ul>
<li>上述代码所在的<code>URL</code>是<code>http://a.com/foo</code>，它对<code>http://b.a.com/bar</code>的<code>DOM</code>访问要求后者将 <code>document.domain</code>往上设置一级</li>
</ul>
<pre><code>// URL http://b.a.com/bar
document.domain = &#39;a.com&#39;
</code></pre>
<ul>
<li><code>document.domain</code>只能从子域设置到主域，往下设置以及往其他域名设置都是不允许的， 在<code>Chrome</code>中给出的错误是这样的</li>
</ul>
<pre><code>Uncaught DOMException: Failed to set the &#39;domain&#39; property on &#39;Document&#39;: &#39;baidu.com&#39; is not a suffix of &#39;b.a.com&#39;
</code></pre>
<h2 id="二、有src的标签"><a href="#二、有src的标签" class="headerlink" title="二、有src的标签"></a>二、有src的标签</h2><hr>
<ul>
<li>原理：所有具有<code>src</code>属性的<code>HTML</code>标签都是可以跨域的，包括<code>, </code></li>
<li>限制：需要创建一个<code>DOM</code>对象，只能用于<code>GET</code>方法</li>
</ul>
<blockquote>
<ul>
<li>在<code>document.body</code>中<code>append</code>一个具有<code>src</code>属性的<code>HTML</code>标签， <code>src</code>属性值指向的<code>URL</code>会以<code>GET</code>方法被访问，该访问是可以跨域的</li>
<li>其实样式表的``标签也是可以跨域的，只要是有<code>src</code>或<code>href</code>的<code>HTML</code>标签都有跨域的能力</li>
</ul>
</blockquote>
<ul>
<li>不同的<code>HTML</code>标签发送<code>HTTP</code>请求的时机不同，例如``在更改<code>src</code>属性时就会发送请求，而<code>script</code>, <code>iframe</code>, <code>link[rel=stylesheet]</code>只有在添加到<code>DOM</code>树之后才会发送<code>HTTP</code>请求：</li>
</ul>
<pre><code>var img = new Image();
img.src = &#39;http://some/picture&#39;;        // 发送HTTP请求

var ifr = $(&#39;&lt;iframe&gt;&#39;, &#123;src: &#39;http://b.a.com/bar&#39;&#125;);
$(&#39;body&#39;).append(ifr);                  // 发送HTTP请求
</code></pre>
<h2 id="三、JSONP"><a href="#三、JSONP" class="headerlink" title="三、JSONP"></a>三、JSONP</h2><hr>
<ul>
<li>原理：``是可以跨域的，而且在跨域脚本中可以直接回调当前脚本的函数</li>
<li>限制：需要创建一个<code>DOM</code>对象并且添加到<code>DOM</code>树，只能用于<code>GET</code>方法</li>
</ul>
<blockquote>
<p><code>JSONP</code>利用的是``可以跨域的特性，跨域<code>URL</code>返回的脚本不仅包含数据，还包含一个回调</p>
</blockquote>
<pre><code>// URL: http://b.a.com/foo
var data = &#123;
    foo: &#39;bar&#39;,
    bar: &#39;foo&#39;
&#125;;
callback(data);
</code></pre>
<ul>
<li>然后在我们在主站<code>http://a.com</code>中，可以这样来跨域获取<code>http://b.a.com</code>的数据：</li>
</ul>
<pre><code>// URL: http://a.com/foo
var callback = function(data)&#123;
    // 处理跨域请求得到的数据
&#125;;
var script = $(&#39;&lt;script&gt;&#39;, &#123;src: &#39;http://b.a.com/bar&#39;&#125;);
$(&#39;body&#39;).append(script);
</code></pre>
<ul>
<li>其实<code>jQuery</code>已经封装了<code>JSONP</code>的使用，我们可以这样来</li>
</ul>
<pre><code>$.getJSON( &quot;http://b.a.com/bar?callback=callback&quot;, function( data )&#123;
    // 处理跨域请求得到的数据
&#125;);
</code></pre>
<blockquote>
<p><code>$.getJSON</code>与<code>$.get</code>的区别是前者会把<code>responseText</code>转换为<code>JSON</code>，而且当<code>URL</code>具有<code>callback</code>参数时， <code>jQuery</code>将会把它解释为一个<code>JSONP</code>请求，创建一个``标签来完成该请求</p>
</blockquote>
<h2 id="四、navigation-对象"><a href="#四、navigation-对象" class="headerlink" title="四、navigation 对象"></a>四、navigation 对象</h2><hr>
<ul>
<li>原理：<code>iframe</code>之间是共享<code>navigator</code>对象的，用它来传递信息</li>
<li>要求：<code>IE6/7</code></li>
</ul>
<blockquote>
<p>有些人注意到了<code>IE6/7</code>的一个漏洞：<code>iframe</code>之间的<code>window.navigator</code>对象是共享的。 我们可以把它作为一个<code>Messenger</code>，通过它来传递信息。比如一个简单的委托：</p>
</blockquote>
<pre><code>// a.com
navigation.onData()&#123;
    // 数据到达的处理函数
&#125;
typeof navigation.getData === &#39;function&#39; 
    || navigation.getData()
// b.com
navigation.getData = function()&#123;
    $.get(&#39;/path/under/b.com&#39;)
        .success(function(data)&#123;
            typeof navigation.onData === &#39;function&#39;
                || navigation.onData(data)
        &#125;);
&#125;
</code></pre>
<blockquote>
<p>与<code>document.navigator</code>类似，<code>window.name</code>也是当前窗口所有页面所共享的。也可以用它来传递信息。 同样蛋疼的办法还有传递<code>Hash</code>（有些人叫锚点），这是因为每次浏览器打开一个<code>URL</code>时，<code>URL</code>后面的<code>#xxx</code>部分会保留下来，那么新的页面可以从这里获得上一个页面的数据</p>
</blockquote>
<h2 id="五、跨域资源共享（CORS）"><a href="#五、跨域资源共享（CORS）" class="headerlink" title="五、跨域资源共享（CORS）"></a>五、跨域资源共享（CORS）</h2><hr>
<ul>
<li>原理：服务器设置<code>Access-Control-Allow-OriginHTTP</code>响应头之后，浏览器将会允许跨域请求</li>
<li>限制：浏览器需要支持<code>HTML5</code>，可以支持<code>POST</code>，<code>PUT</code>等方法</li>
</ul>
<blockquote>
<p>前面提到的跨域手段都是某种意义上的<code>Hack</code>， <code>HTML5</code>标准中提出的跨域资源共享（<code>Cross Origin Resource Share</code>，<code>CORS</code>）才是正道。 它支持其他的<code>HTTP</code>方法如<code>PUT</code>, <code>POST</code>等，可以从本质上解决跨域问题。</p>
</blockquote>
<ul>
<li>例如，从<code>http://a.com</code>要访问<code>http://b.com</code>的数据，通常情况下<code>Chrome</code>会因跨域请求而报错</li>
</ul>
<pre><code>XMLHttpRequest cannot load http://b.com. No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource. Origin &#39;http://a.com&#39; is therefore not allowed access
</code></pre>
<ul>
<li>错误原因是被请求资源没有设置<code>Access-Control-Allow-Origin</code>，所以我们在<code>b.com</code>的服务器中设置这个响应头字段即可</li>
</ul>
<pre><code>Access-Control-Allow-Origin: *              # 允许所有域名访问，或者
Access-Control-Allow-Origin: http://a.com   # 只允许所有域名访问
</code></pre>
<h2 id="六、window-postMessage"><a href="#六、window-postMessage" class="headerlink" title="六、window.postMessage"></a>六、window.postMessage</h2><hr>
<ul>
<li>原理：<code>HTML5</code>允许窗口之间发送消息</li>
<li>限制：浏览器需要支持<code>HTML5</code>，获取窗口句柄后才能相互通信</li>
</ul>
<blockquote>
<p>这是一个安全的跨域通信方法，<code>postMessage(message,targetOrigin)</code>也是<code>HTML5</code>引入的特性。 可以给任何一个<code>window</code>发送消息，不论是否同源。第二个参数可以是*但如果你设置了一个<code>URL</code>但不相符，那么该事件不会被分发。看一个普通的使用方式吧</p>
</blockquote>
<pre><code>// URL: http://a.com/foo
var win = window.open(&#39;http://b.com/bar&#39;);
win.postMessage(&#39;Hello, bar!&#39;, &#39;http://b.com&#39;);
// URL: http://b.com/bar
window.addEventListener(&#39;message&#39;,function(event) &#123;
    console.log(event.data);
&#125;);
</code></pre>
<h2 id="七、访问控制安全的讨论"><a href="#七、访问控制安全的讨论" class="headerlink" title="七、访问控制安全的讨论"></a>七、访问控制安全的讨论</h2><hr>
<ul>
<li>在<code>HTML5</code>之前，<code>JSONP</code>已经成为跨域的事实标准了，<code>jQuery</code>都给出了支持。 值得注意的是它只是<code>Hack</code>，并没有产生额外的安全问题。 因为<code>JSONP</code>要成功获取数据，需要跨域资源所在服务器的配合，比如资源所在服务器需要自愿地回调一个合适的函数，所以服务器仍然有能力控制资源的跨域访问</li>
<li>跨域的正道还是要使用<code>HTML5</code>提供的CORS头字段以及<code>window.postMessage</code>， 可以支持<code>POST</code>, <code>PUT</code>等<code>HTTP</code>方法，从机制上解决跨域问题。 值得注意的是<code>Access-Control-Allow-Origin</code>头字段是资源所在服务器设置的， 访问控制的责任仍然是在提供资源的服务器一方，这和<code>JSONP</code>是一样的</li>
</ul>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title>图解数组计算模块NumPy</title>
    <url>/2020/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/</url>
    <content><![CDATA[<h1 id="第8章图解数组计算模块NumPy"><a href="#第8章图解数组计算模块NumPy" class="headerlink" title="第8章图解数组计算模块NumPy"></a>第8章图解数组计算模块NumPy</h1><p>NumPy为数据分析三剑客之一，主要用于数组计算、矩阵运算和科学计算。对于本章的学习，建议初学者灵活学习，重点掌握数组创建、数组的简单操作和计算即可。<br>为了便于理解，本章运用了大量的示意图，用例简单，力求使您能够轻松地融入NumPy的学习中。通过典型案例，让您充分理解NumPy、应用NumPy。<br>下面让我们揭开NumPy神秘的面纱，开启NumPy之旅。</p>
<h1 id="8-1初识NumPy"><a href="#8-1初识NumPy" class="headerlink" title="8.1初识NumPy"></a>8.1初识NumPy</h1><h2 id="8-1-1NumPy概述"><a href="#8-1-1NumPy概述" class="headerlink" title="8.1.1NumPy概述"></a>8.1.1NumPy概述</h2><p>NumPy（见图8.1），更像是一个魔方（见图8.2），它是Python数组计算、矩阵运算和科学计算的核心库，NumPy这个词来源于Numerical和Python两个单词。NumPy提供了一个高性能的数组对象，让我们轻松创建一维数组、二维数组和多维数组，以及大量的函数和方法，帮助我们轻松地进行数组计算，从而广泛地应用于数据分析、机器学习、图像处理和计算机图形学、数学任务等领域当中。</p>
<p><img src="/.com//image-20211025110157989.png" alt="image-20211025110157989"></p>
<p>​                                                                                                            图8.1　NumPy</p>
<p><img src="/.com//image-20211025110220048.png" alt="image-20211025110220048"></p>
<p>​                                                                                                             图8.2　魔方<br>NumPy的用途是以数组的形式对数据进行操作。机器学习中充斥了大量的数组运算，而NumPy使得这些操作变得简单！由于NumPy是C语言实现的，所以其运算速度非常快。具体功能如下。　</p>
<p>有一个强大的n维数组对象ndarray。　</p>
<p>广播功能函数。　</p>
<p>线性代数、傅立叶变换、随机数生成、图形操作等功能。</p>
<p>整合C/C++/Fortran代码的工具。</p>
<h2 id="8-1-2-安装NumPy模块"><a href="#8-1-2-安装NumPy模块" class="headerlink" title="8.1.2　安装NumPy模块"></a>8.1.2　安装NumPy模块</h2><p>安装NumPy有两种方法。</p>
<h3 id="1．使用pip安装"><a href="#1．使用pip安装" class="headerlink" title="1．使用pip安装"></a>1．使用pip安装</h3><p>安装NumPy最简单的方法是使用pip工具，安装命令如下：</p>
<p>pip install pip</p>
<h3 id="2．在PyCharm开发环境中安装"><a href="#2．在PyCharm开发环境中安装" class="headerlink" title="2．在PyCharm开发环境中安装"></a>2．在PyCharm开发环境中安装</h3><p>（1）运行PyCharm，选择File→Settings命令，打开Settings对话框，选择Project Interpreter选项，然后单击添加模块的按钮，如图8.3所示。</p>
<p><img src="/.com//image-20211025110322698.png" alt="image-20211025110322698"></p>
<p>​                                                                                    图8.3　单击添加模块的按钮<br>（2）在搜索栏中输入需要添加的模块名称为numpy，然后选择需要安装的模块，如图8.4所示。单击Install Package按钮即可安装NumPy模块。</p>
<h3 id="3．安装验证"><a href="#3．安装验证" class="headerlink" title="3．安装验证"></a>3．安装验证</h3><p>测试是否安装成功，程序代码如下：</p>
<p>01  from numpy import *   #导入numpy库<br>02  print(eye(4))          #生成对角矩阵<br>运行程序，输出结果如下：</p>
<p><img src="/.com//image-20211025110347905.png" alt="image-20211025110347905"></p>
<p><img src="/.com//image-20211025111116413.png" alt="image-20211025111116413"></p>
<p>图8.4　在PyCharm开发环境中安装NumPy模块</p>
<h2 id="8-1-3-数组相关概念"><a href="#8-1-3-数组相关概念" class="headerlink" title="8.1.3　数组相关概念"></a>8.1.3　数组相关概念</h2><p>学习NumPy前，我们先了解一下数组相关概念。数组可分为一维数组、二维数组、三维数组，其中三维数组是常见的多维数组，如图8.5所示。</p>
<p><img src="/.com//image-20211025112546228.png" alt="image-20211025112546228"></p>
<p>​                                                                                                 图8.5　数组示意图<br>1．一维数组<br>一维数组很简单，基本和Python列表一样，区别在于数组切片针对的是原始数组（这就意味着，如果对数组进行修改，原始数组也会跟着更改）。<br>2．二维数组<br>二维数组本质是以数组作为数组元素的数组。二维数组包括行和列，类似于表格形状，又称为矩阵。<br>3．三维数组<br>三维数组是指维数为3的数组结构，也称矩阵列表。三维数组是最常见的多维数组，由于其可以用来描述三维空间中的位置或状态而被广泛使用。<br>4．轴的概念</p>
<p>轴是NumPy里的axis，指定某个axis，就是沿着这个axis做相关操作，其中二维数组中两个axis的指向如图8.6所示。<br>对于一维数组，情况有点特殊，它不像二维数组从上向下的操作，而是水平的，因此一维数组其axis=0指向如图8.7所示。</p>
<p><img src="/.com//image-20211025112732987.png" alt="image-20211025112732987"></p>
<p>​                                                                                      图8.6　二维数组两个轴</p>
<p><img src="/.com//image-20211025112750397.png" alt="image-20211025112750397"></p>
<p>​                                                                                     图8.7　一维数组一个轴</p>
<h1 id="8-2-创建数组"><a href="#8-2-创建数组" class="headerlink" title="8.2　创建数组"></a>8.2　创建数组</h1><h2 id="8-2-1-创建简单的数组"><a href="#8-2-1-创建简单的数组" class="headerlink" title="8.2.1　创建简单的数组"></a>8.2.1　创建简单的数组</h2><p>NumPy创建简单的数组主要使用array()函数，语法如下：</p>
<p>numpy.array(object,dtype=None,copy=True,order=’K’,subok=False,ndmin=0)<br>参数说明：　</p>
<p>object：任何具有数组接口方法的对象。　</p>
<p>dtype：数据类型。　</p>
<p>copy：布尔型，可选参数，默认值为True，则object对象被复制；否则，只有当__array__返回副本，object参数为嵌套序列，或者需要副本满足数据类型和顺序要求时，才会生成副本。　</p>
<p>order：元素在内存中的出现顺序，值为K、A、C、F。如果object参数不是数组，则新创建的数组将按行排列（C），如果值为F，则按列排列；如果object参数是一个数组，则C（按行）、F（按列）、A（原顺序）、K（元素在内存中的出现顺序）成立。　</p>
<p>subok：布尔型。如果值为True，则将传递子类；否则返回的数组将强制为基类数组（默认值）。　</p>
<p>ndmin：指定生成数组的最小维数。</p>
<p>【示例01】　演示如何创建数组。（示例位置：资源包\MR\Code\08\01）<br>创建几个简单的数组，效果如图8.8所示。</p>
<p><img src="/.com//image-20211025113205539.png" alt="image-20211025113205539"></p>
<p>​                                                                                                          图8.8　简单数组<br>程序代码如下：</p>
<p><img src="/.com//image-20211025113400111.png" alt="image-20211025113400111"></p>
<h3 id="1．为数组指定数据类型"><a href="#1．为数组指定数据类型" class="headerlink" title="1．为数组指定数据类型"></a>1．为数组指定数据类型</h3><p>【示例02】　为数组指定数据类型。（示例位置：资源包\MR\Code\08\02）<br>NumPy支持比Python更多种类的数据类型，通过dtype参数可以指定数组的数据类型，程序代码如下：</p>
<p><img src="/.com//image-20211025113422663.png" alt="image-20211025113422663"></p>
<p>运行程序，输出结果如下：</p>
<p>[1. 2. 3.]<br>float64<br>&lt;class ‘numpy.float64’&gt;</p>
<h3 id="2．数组的复制"><a href="#2．数组的复制" class="headerlink" title="2．数组的复制"></a>2．数组的复制</h3><p>【示例03】　复制数组。（示例位置：资源包\MR\Code\08\03）<br>当运算和处理数组时，为了不影响到原数组，就需要对原数组进行复制，而对复制后的数组进行修改删除等操作都不会影响到原数组。数组的复制可以通过copy参数实现，程序代码如下：</p>
<p><img src="/.com//image-20211025113521420.png" alt="image-20211025113521420"></p>
<p>运行程序，输出结果如下：</p>
<p>[1 2 3]<br>[3 2 1]<br>数组n2是数组n1的副本，从运行结果得知：虽然修改了数组n2，但是数组n1没有发生变化。</p>
<h3 id="3．通过ndmin参数控制最小维数"><a href="#3．通过ndmin参数控制最小维数" class="headerlink" title="3．通过ndmin参数控制最小维数"></a>3．通过ndmin参数控制最小维数</h3><p>数组可分为一维数组、二维数组和多维数组，通过ndmin参数可以控制数组的最小维数。无论给出的数据的维数是多少，ndmin参数都会根据最小维数创建指定维数的数组。</p>
<p>【示例04】　修改数组的维数。（示例位置：资源包\MR\Code\08\04）<br>ndmin=3，虽然给出的数组是一维的，但是同样会创建一个三维数组，程序代码如下：<br>运行程序，输出结果如下：</p>
<p>[[[1 2 3]]]</p>
<h2 id="8-2-2-不同方式创建数组"><a href="#8-2-2-不同方式创建数组" class="headerlink" title="8.2.2　不同方式创建数组"></a>8.2.2　不同方式创建数组</h2><h3 id="1．创建指定维度和数据类型未初始化的数组"><a href="#1．创建指定维度和数据类型未初始化的数组" class="headerlink" title="1．创建指定维度和数据类型未初始化的数组"></a>1．创建指定维度和数据类型未初始化的数组</h3><p>【示例05】　创建指定维度和未初始化的数组。（示例位置：资源包\MR\Code\08\05）<br>创建指定维度和数据类型未初始化的数组主要使用empty()函数，程序代码如下：</p>
<p>01 import numpy as np<br>02 n = np.empty([2,3])<br>03 print(n)<br>运行程序，输出结果如下：</p>
<p>[[2.22519099e-307 2.33647355e-307 1.23077925e-312]<br>[2.33645827e-307 2.67023123e-307 1.69117157e-306]]<br>这里，数组元素为随机值，因为它们未被初始化。如果要改变数组类型，可以使用dtype参数，如整型，dtype=int。</p>
<h3 id="2．创建指定维度（以0填充）的数组"><a href="#2．创建指定维度（以0填充）的数组" class="headerlink" title="2．创建指定维度（以0填充）的数组"></a>2．创建指定维度（以0填充）的数组</h3><p>【示例06】　创建指定维度（以0填充）的数组。（示例位置：资源包\MR\Code\08\06）<br>创建指定维度并以0填充的数组，主要使用zeros()函数，程序代码如下：</p>
<p>01  import numpy as np<br>02  n = np.zeros(3)<br>03  print(n)<br>运行程序，输出结果如下：</p>
<p>[0. 0. 0.]<br>输出结果默认是浮点型（float）。</p>
<h3 id="3．创建指定维度（以1填充）的数组"><a href="#3．创建指定维度（以1填充）的数组" class="headerlink" title="3．创建指定维度（以1填充）的数组"></a>3．创建指定维度（以1填充）的数组</h3><p>【示例07】　创建指定维度并以1填充的数组。（示例位置：资源包\MR\Code\08\07）<br>创建指定维度并以1填充的数组，主要使用ones()函数，程序代码如下：</p>
<p>01 import numpy as np<br>02 n = np.ones(3)<br>03 print(n)</p>
<p>运行程序，输出结果如下：</p>
<p>[1. 1. 1.]<br>4．创建指定维度和类型的数组并以指定值填充【示例08】　创建以指定值填充的数组。（示例位置：资源包\MR\Code\08\08）<br>创建指定维度和类型的数组并以指定值填充，主要使用full()函数，程序代码如下：</p>
<p>01  import numpy as np<br>02  n = np.full((3,3), 8)<br>03  print(n)<br>运行程序，输出结果如下：</p>
<p>[[8 8 8]<br> [8 8 8]<br> [8 8 8]]</p>
<h2 id="8-2-3-从数值范围创建数组"><a href="#8-2-3-从数值范围创建数组" class="headerlink" title="8.2.3　从数值范围创建数组"></a>8.2.3　从数值范围创建数组</h2><h3 id="1．通过arange-函数创建数组"><a href="#1．通过arange-函数创建数组" class="headerlink" title="1．通过arange()函数创建数组"></a>1．通过arange()函数创建数组</h3><p>arange()函数同Python内置range()函数相似，区别在于返回值，arange()函数返回值是数组，而range()函数返回值是列表。arange()函数的语法如下：</p>
<p>arange([start,] stop[, step,], dtype=None)<br>参数说明：　</p>
<p>start：起始值，默认值为0。　</p>
<p>stop：终止值（不包含）。　</p>
<p>step：步长，默认值为1。　</p>
<p>dtype：创建数组的数据类型，如果不设置数据类型，则使用输入数据的数据类型。</p>
<p>【示例09】　通过数值范围创建数组。（示例位置：资源包\MR\Code\08\09）<br>使用arange()函数通过数值范围创建数组，程序代码如下：</p>
<p>01 import numpy as np<br>02 n=np.arange(1,12,2)<br>03 print(n)<br>运行程序，输出结果如下：</p>
<p>[ 1  3  5  7  9 11]</p>
<h3 id="2．使用linspace-函数创建等差数列"><a href="#2．使用linspace-函数创建等差数列" class="headerlink" title="2．使用linspace()函数创建等差数列"></a>2．使用linspace()函数创建等差数列</h3><p>首先简单了解一下等差数列，等差数列是指如果一个数列从第二项起，每一项与它的前一项的差等于同一个常数，那么这个数列就叫作等差数列。<br>例如，一般成年男鞋的各种尺码，如图8.9所示。</p>
<p><img src="/.com//image-20211025113910259.png" alt="image-20211025113910259"></p>
<p>​                                                                                         图8.9　男鞋尺码对照表</p>
<p>马拉松赛前训练，一周每天的训练量（单位：m），如图8.10所示。</p>
<p><img src="/.com//image-20211025113928239.png" alt="image-20211025113928239"></p>
<p>​                                                                                        图8.10　训练计划<br>在Python中创建等差数列可以使用NumPy的linspace()函数，该函数用于创建一个一维的等差数列的数组，它与arange()函数不同，arange()函数是从开始值到结束值的左闭右开区间（即包括开始值不包括结束值），第三个参数（如果存在）是步长；而linspace()函数是从开始值到结束值的闭区间（可以通过参数endpoint=False，使结束值不是闭区间），并且第三个参数是值的个数。</p>
<p>知识胶囊<br>本文经常会提到诸如“左闭右开区间”“左开右闭区间”“闭区间”等，这里简单介绍一下。“</p>
<p>左闭右开区间”是指包括起始值但不包括终止值的一个数值区间；</p>
<p>“左开右闭区间”是指不包括起始值但包括终止值的一个个数值区间；</p>
<p>“闭区间”是指既包括起始值又包括终止值的一个数值区间。</p>
<p>linspace()函数语法如下：</p>
<p>linspace(start,stop,num=50,endpoint=True,retstep=False,dtype=None)<br>参数说明：　</p>
<p>start：序列的起始值。　</p>
<p>stop：序列的终止值，如果endpoint参数的值为True，则该值包含于数列中。　</p>
<p>num：要生成的等步长的样本数量，默认值为50。　</p>
<p>endpoint：如果值为True，数列中包含stop参数的值；反之则不包含。默认值为True。　</p>
<p>retstep：如果值为True，则生成的数组中会显示间距；反之则不显示。　</p>
<p>dtype：数组的数据类型。</p>
<p>【示例10】　创建马拉松赛前训练等差数列数组。（示例位置：资源包\MR\Code\08\10）<br>创建马拉松赛前训练等差数列数组，程序代码如下：</p>
<p>01 import numpy as np<br>02 n1 = np.linspace(7500,10000,6)<br>03 print(n1)<br>运行程序，输出结果如下：</p>
<p>[ 7500.  8000.  8500.  9000.  9500. 10000.]</p>
<h3 id="3．使用logspace-函数创建等比数列"><a href="#3．使用logspace-函数创建等比数列" class="headerlink" title="3．使用logspace()函数创建等比数列"></a>3．使用logspace()函数创建等比数列</h3><p>首先了解一下等比数列，等比数列是指从第二项起，每一项与它的前一项的比值等于同一个常数的一种数列。<br>例如，在古印度，国王要重赏发明国际象棋的大臣，对他说：我可以满足你的任何要求，大臣说：请给我的棋盘的64个格子都放上小麦，第1个格子放1粒小麦，第2个格子放2粒小麦，第3个格子放4粒小麦，第4个格子放8粒小麦，如图8.11所示。后面每个格子里放的小麦数都是前一个格子里所放小麦数的2倍，直到第64个格子。<br>在Python中创建等比数列可以使用NumPy的logspace()函数，语法如下：</p>
<p><img src="/.com//image-20211025114247449.png" alt="image-20211025114247449"></p>
<p>​                                                                                                            图8.11　棋盘</p>
<p>numpy.logspace(start, stop, num=50, endpoint=True, base=10.0, dtype=None)<br>参数说明：　</p>
<p>start：序列的起始值。　</p>
<p>stop：序列的终止值。如果endpoint参数值为True，则该值包含于数列中。　</p>
<p>num：要生成的等步长的数据样本数量，默认值为50。　</p>
<p>endpoint：如果值为True，则数列中包含stop参数值；反之则不包含。默认值为True。　</p>
<p>base：对数log的底数。　</p>
<p>dtype：数组的数据类型。</p>
<p>【示例11】　通过logspace()函数解决棋盘放置小麦的问题。（示例位置：资源包\MR\Code\08\11）<br>通过logspace()函数计算棋盘中每个格子里放的小麦数是前一个格子里的2倍，直到第64个格子，每个格子里放多少小麦，程序代码如下：</p>
<p>01  import numpy as np<br>02  n = np.logspace(0,63,64,base=2,dtype=’int’)<br>03  print(n)<br>运行程序，输出结果如图8.12所示。</p>
<p><img src="/.com//image-20211025114355783.png" alt="image-20211025114355783"></p>
<p>​                                                                                  图8.12　每个格子里放的小麦数</p>
<p>上述举例出现一个问题：后面大数出现负数，而且都是一样的，这是由于程序中指定的数据类型是int，是32位的，数据范围为-2147483648～2147483647，而我们计算后的数据远远超出了这个范围，因此便出现了溢出现象。解决这一问题，需要指定数据类型为uint64（无符号整数，数据范围为0～18446744073709551615），关键代码如下：</p>
<p>n = np.logspace(0,63,64,base=2,dtype=’uint64’)<br>运行程序，输出结果如图8.13所示。</p>
<p><img src="/.com//image-20211025114438288.png" alt="image-20211025114438288"></p>
<p>​                                                                                     图8.13　每个格子里放的小麦数<br>以上就是每个格子里需要放的小麦数，可见发明国际象棋的大臣是多么聪明。说明<br>关于NumPy数据类型的详细介绍可参见8.3.1节。</p>
<h2 id="8-2-4-生成随机数组"><a href="#8-2-4-生成随机数组" class="headerlink" title="8.2.4　生成随机数组"></a>8.2.4　生成随机数组</h2><p>随机数组的生成主要使用NumPy的random模块，下面介绍几种常用的随机生成数组的函数。</p>
<h3 id="1．rand-函数"><a href="#1．rand-函数" class="headerlink" title="1．rand()函数"></a>1．rand()函数</h3><p>rand()函数用于生成(0,1)之间的随机数组，传入一个值随机生成一维数组，传入一对值则随机生成二维数组，语法如下：</p>
<p>numpy.random.rand(d0,d1,d2,d3,…,dn)<br>参数d0，d1，…，dn为整数，表示维度，可以为空。</p>
<p>【示例12】　随机生成0～1的数组。（示例位置：资源包\MR\Code\08\12）<br>随机生成一维数组和二维数组，代码如下：<br>运行程序，输出结果如下：</p>
<h3 id="2．randn-函数"><a href="#2．randn-函数" class="headerlink" title="2．randn()函数"></a>2．randn()函数</h3><p>randn()函数用于从正态分布中返回随机生成的数组，语法如下：</p>
<p>numpy.random.randn(d0,d1,d2,d3,…,dn)<br>参数d0，d1，…，dn为整数，表示维度，可以为空。</p>
<p>【示例13】　随机生成满足正态分布的数组。（示例位置：资源包\MR\Code\08\13）<br>随机生成满足正态分布的数组，程序代码如下：<br>运行程序，输出结果如下：</p>
<h3 id="3．randint-函数"><a href="#3．randint-函数" class="headerlink" title="3．randint()函数"></a>3．randint()函数</h3><p>randint()函数与NumPy的arange()函数类似。randint()函数用于生成一定范围内的随机数组，左闭右开区间，语法如下：</p>
<p>numpy.random.randint(low,high=None,size=None)</p>
<p>参数说明：　</p>
<p>low：低值（起始值），整数，且当参数high不为空时，参数low应小于参数high；否则程序会出现错误。　</p>
<p>high：高值（终止值），整数。</p>
<p>size：数组维数，整数或者元组，整数表示一维数组，元组表示多维数组。默认值为空，如果为空，则仅返回一个整数。</p>
<p>【示例14】　生成一定范围内的随机数组。（示例位置：资源包\MR\Code\08\14）<br>生成一定范围内的随机数组，程序代码如下：</p>
<p><img src="/.com//image-20211025114630842.png" alt="image-20211025114630842"></p>
<p>运行程序，输出结果如下：</p>
<p><img src="/.com//image-20211025114646241.png" alt="image-20211025114646241"></p>
<h3 id="4．normal-函数"><a href="#4．normal-函数" class="headerlink" title="4．normal()函数"></a>4．normal()函数</h3><p>normal()函数用于生成正态分布的随机数，语法如下：</p>
<p>numpy.random.normal(loc,scale,size)<br>参数说明：　</p>
<p>loc：正态分布的均值，对应正态分布的中心。loc=0说明是一个以y轴为对称轴的正态分布。　</p>
<p>scale：正态分布的标准差，对应正态分布的宽度，scale值越大，正态分布的曲线越“矮胖”；scale值越小，曲线越“高瘦”。　</p>
<p>size：表示数组维数。</p>
<p>【示例15】　生成正态分布的随机数组。（示例位置：资源包\MR\Code\08\15）<br>生成正态分布的随机数组，程序代码如下：</p>
<p>01 import numpy as np<br>02 n = np.random.normal(0, 0.1, 10)<br>03 print(n)<br>运行程序，输出结果如下：</p>
<p>[ 0.08530096  0.0404147  -0.00358281  0.05405901 -0.01677737 -0.02448481<br> 0.13410224 -0.09780364  0.06095256 -0.0431846 ]</p>
<h2 id="8-2-5-从已有的数组中创建数组"><a href="#8-2-5-从已有的数组中创建数组" class="headerlink" title="8.2.5　从已有的数组中创建数组"></a>8.2.5　从已有的数组中创建数组</h2><h3 id="1．asarray-函数"><a href="#1．asarray-函数" class="headerlink" title="1．asarray()函数"></a>1．asarray()函数</h3><p>asarray()函数用于创建数组，其与array()函数类似，语法如下：</p>
<p>numpy.asarray(a,dtype=None,order=None)<br>参数说明：　</p>
<p>a：可以是列表、列表的元组、元组、元组的元组、元组的列表或多维数组。　</p>
<p>dtype：数组的数据类型。　</p>
<p>order：值为C和F，分别代表按行排列和按列排列，即数组元素在内存中的出现顺序。</p>
<p>【示例16】　使用asarray()函数创建数组。（示例位置：资源包\MR\Code\08\16）<br>使用asarray()函数创建数组，程序代码如下：</p>
<p><img src="/.com//image-20211025114735631.png" alt="image-20211025114735631"></p>
<p>运行程序，输出结果如下：</p>
<p><img src="/.com//image-20211025114829679.png" alt="image-20211025114829679"></p>
<h3 id="2．frombuffer-函数"><a href="#2．frombuffer-函数" class="headerlink" title="2．frombuffer()函数"></a>2．frombuffer()函数</h3><p>NumPy的ndarray()数组对象不能像Python列表一样动态地改变其大小，在做数据采集时很不方便。下面介绍如何通过frombuffer()函数实现动态数组。frombuffer()函数接受buffer输入参数，以流的形式将读入的数据转换为数组。frombuffer()函数语法如下：</p>
<p>numpy.frombuffer(buffer,dtype=float,count=-1,offset=0)<br>参数说明：　</p>
<p>buffer：实现了__buffer__方法的对象。　</p>
<p>dtype：数组的数据类型。　</p>
<p>count：读取的数据数量，默认值为-1，表示读取所有数据。　</p>
<p>offset：读取的起始位置，默认值为0。</p>
<p>【示例17】　将字符串“mingrisoft”转换为数组。（示例位置：资源包\MR\Code\08\17）<br>将字符串“mingrisoft”转换为数组，程序代码如下：</p>
<p>01 import numpy as np<br>02 n=np.frombuffer(b’mingrisoft’,dtype=’S1’)<br>03 print(n)<br>关键代码解析：当buffer参数值为字符串时，Python 3默认字符串是Unicode类型，所以要转成Byte string类型，需要在原字符串前加上b。</p>
<h3 id="3．fromiter-函数"><a href="#3．fromiter-函数" class="headerlink" title="3．fromiter()函数"></a>3．fromiter()函数</h3><p>fromiter()函数用于从可迭代对象中建立数组对象，语法如下：</p>
<p>numpy.fromiter(iterable,dtype,count=-1)</p>
<p>参数说明：　</p>
<p>iterable：可迭代对象。　</p>
<p>dtype：数组的数据类型。　</p>
<p>count：读取的数据数量，默认值为-1，表示读取所有数据。</p>
<p>【示例18】　通过可迭代对象创建数组。（示例位置：资源包\MR\Code\08\18）<br>通过可迭代对象创建数组，程序代码如下：</p>
<p><img src="/.com//image-20211025114943273.png" alt="image-20211025114943273"></p>
<p>运行程序，输出结果如下：</p>
<p>[0 2 4 6 8]</p>
<h3 id="4．empty-like-函数"><a href="#4．empty-like-函数" class="headerlink" title="4．empty_like()函数"></a>4．empty_like()函数</h3><p>empty_like()函数用于创建一个与给定数组具有相同维度和数据类型且未初始化的数组，语法如下：</p>
<p>numpy.empty_like(prototype,dtype=None,order=’K’,subok=True)<br>参数说明：　</p>
<p>prototype：给定的数组。　</p>
<p>dtype：覆盖结果的数据类型。　</p>
<p>order：指定数组的内存布局。其中C（按行）、F（按列）、A（原顺序）、K（数据元素在内存中的出现顺序）。　</p>
<p>subok：默认情况下，返回的数组被强制为基类数组。如果值为True，则返回子类。</p>
<p>【示例19】　创建未初始化的数组。（示例位置：资源包\MR\Code\08\19）<br>下面使用empty_like()函数创建一个与给定数组具有相同维数、数据类型以及未初始化的数组，程序代码如下：</p>
<p>01 import numpy as np</p>
<p>02 n = np.empty_like([[1, 2], [3, 4]])<br>03 print(n)<br>运行程序，输出结果如下：</p>
<p>[[0 0]<br> [0 0]]</p>
<h3 id="5．zeros-like-函数"><a href="#5．zeros-like-函数" class="headerlink" title="5．zeros_like()函数"></a>5．zeros_like()函数</h3><p>【示例20】　创建以0填充的数组。（示例位置：资源包\MR\Code\08\20）<br>zeros_like()函数用于创建一个与给定数组维度和数据类型相同，并以0填充的数组，程序代码如下：</p>
<p>01 import numpy as np<br>02 n = np.zeros_like([[0.1,0.2,0.3], [0.4,0.5,0.6]])<br>03 print(n)<br>运行程序，输出结果如下：</p>
<p>[[0. 0. 0.]<br> [0. 0. 0.]]说明<br>参数说明请参见empty_like()函数。</p>
<h3 id="6．ones-like-函数"><a href="#6．ones-like-函数" class="headerlink" title="6．ones_like()函数"></a>6．ones_like()函数</h3><p>【示例21】　创建以1填充的数组。（示例位置：资源包\MR\Code\08\21）<br>ones_like()函数用于创建一个与给定数组维度和数据类型相同，并以1填充的数组，程序代码如下：</p>
<p>01 import numpy as np<br>02 n = np.ones_like([[0.1,0.2,0.3], [0.4,0.5,0.6]])</p>
<p>03 print(n)<br>运行程序，输出结果如下：</p>
<p>[[1. 1. 1.]<br>[1. 1. 1.]]说明<br>参数说明请参见empty_like()函数。</p>
<h3 id="7．full-like-函数"><a href="#7．full-like-函数" class="headerlink" title="7．full_like()函数"></a>7．full_like()函数</h3><p>full_like()函数用于创建一个与给定数组维度和数据类型相同，并以指定值填充的数组，语法如下：</p>
<p>numpy.full_like(a, fill_value, dtype=None, order=’K’, subok=True)<br>参数说明：　</p>
<p>a：给定的数组。　</p>
<p>fill_value：填充值。　</p>
<p>dtype：数组的数据类型，默认值为None，则使用给定数组的数据类型。　</p>
<p>order：指定数组的内存布局。其中C（按行）、F（按列）、A（原顺序）、K（数组元素在内存中的出现顺序）。　</p>
<p>subok：默认情况下，返回的数组被强制为基类数组。如果值为True，则返回子类。</p>
<p>【示例22】　创建以指定值“0.2”填充的数组。（示例位置：资源包\MR\Code\08\22）<br>创建一个与给定数组维度和数据类型相同，并以指定值“0.2”填充的数组，程序代码如下：</p>
<p><img src="/.com//image-20211025115141215.png" alt="image-20211025115141215"></p>
<p>运行程序，输出结果如下：</p>
<p>[1 1 1 1 1 1]<br>[0 0 0 0 0 0]<br>[0.2 0.2 0.2 0.2 0.2 0.2]</p>
<h1 id="8-3-数组的基本操作"><a href="#8-3-数组的基本操作" class="headerlink" title="8.3　数组的基本操作"></a>8.3　数组的基本操作</h1><h3 id="8-3-1-数据类型"><a href="#8-3-1-数据类型" class="headerlink" title="8.3.1　数据类型"></a>8.3.1　数据类型</h3><p>在对数组进行基本操作前，首先了解一下NumPy的数据类型。NumPy的数据类型比Python数据类型增加了更多种类的数值类型，如表8.1所示。为了区别Python数据类型，像bool、int、float、complex、str等数据类型的名称末尾都加了短下画线“_”。</p>
<p>​                                                                                            表8.1　NumPy数据类型表</p>
<p><img src="/.com//image-20211025115201641.png" alt="image-20211025115201641"></p>
<p>每一种数据类型都有相应的数据转换函数。举例如下：</p>
<p>np.int8(3.141)</p>
<p>结果为3。</p>
<p>np.float64(8)<br>结果为8.0。</p>
<p>np.float(True)<br>结果为1.0。</p>
<p>bool(1)<br>结果为True。<br>在创建ndarray数组时，可以直接指定数值类型，关键代码如下：</p>
<p>a = np.arange(8, dtype=float)<br>结果为[0. 1. 2. 3. 4. 5. 6. 7.]。</p>
<p>注意<br>复数不能转换成为整数类型或者浮点数，例如以下的代码会出现错误提示：</p>
<p>float(8+ 1j)</p>
<h3 id="8-3-2-数组运算"><a href="#8-3-2-数组运算" class="headerlink" title="8.3.2　数组运算"></a>8.3.2　数组运算</h3><p>不用编写循环即可对数据执行批量运算，这就是NumPy数组运算的特点，NumPy称之为矢量化。大小相等的数组之间的任何算术运算NumPy都可以实现。本节主要介绍简单的数组运算，如加、减、乘、除、幂运算等。下面创建两个简单的NumPy数组，即n1和n2，数组n1包括元素1和2，数组n2包括元素3和4，如图8.14所示。接下来实现这两个数组的运算。</p>
<p><img src="/.com//image-20211025115248732.png" alt="image-20211025115248732"></p>
<p>​                                                                                                              图8.14　数组示意图</p>
<h4 id="1．加法运算"><a href="#1．加法运算" class="headerlink" title="1．加法运算"></a>1．加法运算</h4><p>例如，加法运算是数组中对应位置的元素相加（即每行对应相加），如图8.15所示。</p>
<p><img src="/.com//image-20211025115350997.png" alt="image-20211025115350997"></p>
<p>​                                                                              图8.15　数组加法运算示意图</p>
<p>【示例23】　数组加法运算。（示例位置：资源包\MR\Code\08\23）<br>在程序中直接将两个数组相加即可，即n1+n2，程序代码如下：<br>运行程序，输出结果如下：</p>
<p>[4 6]</p>
<h4 id="2．减法、乘法和除法运算"><a href="#2．减法、乘法和除法运算" class="headerlink" title="2．减法、乘法和除法运算"></a>2．减法、乘法和除法运算</h4><p>除了加法运算，还可以实现数组的减法、乘法和除法，如图8.16所示。</p>
<p><img src="/.com//image-20211025115411699.png" alt="image-20211025115411699"></p>
<p>​                                                                  图8.16　数组的减法、乘法和除法运算示意图</p>
<p>【示例24】　数组的减法、乘法和除法运算。（示例位置：资源包\MR\Code\06\24）<br>同样，在程序中直接将两个数组相减、相乘或相除即可，程序代码如下：</p>
<p><img src="/.com//image-20211025115431957.png" alt="image-20211025115431957"></p>
<p>运行程序，输出结果如下：</p>
<p>[-2 -2]<br>[3 8]<br>[0.33333333 0.5  ]</p>
<h4 id="3．幂运算"><a href="#3．幂运算" class="headerlink" title="3．幂运算"></a>3．幂运算</h4><p>幂是数组中对应位置元素的幂运算，用两个“*”表示，如图8.17所示。</p>
<p><img src="/.com//image-20211025115515999.png" alt="image-20211025115515999"></p>
<p>​                                                                                   图8.17　数组幂运算示意图</p>
<p>【示例25】　数组的幂运算。（示例位置：资源包\MR\Code\08\25）<br>从图8.17中得知：数组n1的元素1和数组n2的元素3，通过幂运算得到的是1的3次幂；数组n1的元素2和数组n2的元素4，通过幂运算得到的是2的4次幂，程序代码如下：</p>
<p><img src="/.com//image-20211025115559819.png" alt="image-20211025115559819"></p>
<p>运行程序，输出结果如下：</p>
<p>[ 1 16]</p>
<h4 id="4．比较运算"><a href="#4．比较运算" class="headerlink" title="4．比较运算"></a>4．比较运算</h4><p>【示例26】　数组的比较运算。（示例位置：资源包\MR\Code\08\26）<br>数组的比较运算是数组中对应位置元素的比较运算，比较后的结果是布尔值数组，程序代码如下：</p>
<p><img src="/.com//image-20211025115614452.png" alt="image-20211025115614452"></p>
<p>运行程序，输出结果如下：</p>
<p>[False False]<br>[False False]</p>
<p>[ True  True]<br>[ True  True]</p>
<h4 id="5．数组的标量运算"><a href="#5．数组的标量运算" class="headerlink" title="5．数组的标量运算"></a>5．数组的标量运算</h4><p>首先了解两个概念，即标量和向量。标量其实就是一个单独的数；而向量是一组数，这组数是顺序排列的，这里我们理解为数组。那么，数组的标量运算也可以理解为是向量与标量之间的运算。<br>例如，马拉松赛前训练，一周里每天的训练量以“米”（m）为单位，下面将其转换为以“千米”为单位，如图8.18所示。</p>
<p><img src="/.com//image-20211025115659337.png" alt="image-20211025115659337"></p>
<p>​                                                                                             图8.18　数组的标量运算示意图</p>
<p>【示例27】　数组的标量运算。（示例位置：资源包\MR\Code\08\27）<br>在程序中，米转换为千米直接输入n1/1000即可，程序代码如下：</p>
<p><img src="/.com//image-20211025115723224.png" alt="image-20211025115723224"></p>
<p>运行程序，输出结果如下：</p>
<p>[ 7500  8000  8500  9000  9500 10000]<br>[ 7.5  8.   8.5  9.   9.5 10. ]<br>上述运算过程，在NumPy中叫作“广播机制”，它是一个非常有用的功能。</p>
<h3 id="8-3-3-数组的索引和切片"><a href="#8-3-3-数组的索引和切片" class="headerlink" title="8.3.3　数组的索引和切片"></a>8.3.3　数组的索引和切片</h3><p>NumPy数组元素是通过数组的索引和切片来访问和修改的，因此索引和切片是NumPy中最重要、最常用的操作。</p>
<h4 id="1．索引"><a href="#1．索引" class="headerlink" title="1．索引"></a>1．索引</h4><p>所谓数组的索引，即用于标记数组中对应元素的唯一数字，从0开始，即数组中的第一个元素的索引是0，以此类推。NumPy数组可以使用标准Python语法x[obj]的语法对数组进行索引，其中x是数组，obj是索引。</p>
<p>【示例28】　获取一维数组中的元素。（示例位置：资源包\MR\Code\08\28）<br>获取一维数组n1中索引为0的元素，程序代码如下：</p>
<p>01  import numpy as np<br>02  n1=np.array([1,2,3])   #创建一维数组<br>03  print(n1[0])           #输出一维数组的第一个元素<br>运行程序，输出结果如下：</p>
<p>1</p>
<p>【示例29】　获取二维数组中的元素。（示例位置：资源包\MR\Code\08\29）<br>再举一个例子，通过索引获取二维数组中的元素，程序代码如下：</p>
<p>01  import numpy as np<br>02  n1=np.array([[1,2,3],[4,5,6]])   #创建二维数组<br>03  print(n1[1] [2])                  #输出二维数组中第2行第3列的元素<br>运行程序，输出结果如下：</p>
<p>6</p>
<h4 id="2．切片式索引"><a href="#2．切片式索引" class="headerlink" title="2．切片式索引"></a>2．切片式索引</h4><p>数组的切片可以理解为对数组的分割，按照等分或者不等分，将一个数组切割为多个片段，它与Python中列表的切片操作一样。NumPy中的切片用冒号分隔切片参数来进行切片操作，语法如下：</p>
<p>[start:stop:step]<br>参数说明：　</p>
<p>start：起始索引。</p>
<p>stop：终止索引。　</p>
<p>step：步长。</p>
<p>【示例30】　实现简单的数组切片操作。（示例位置：资源包\MR\Code\08\30）<br>实现简单的切片操作，对数组n1进行切片式索引操作，如图8.19所示。</p>
<p><img src="/.com//image-20211026163649468.png" alt="image-20211026163649468"></p>
<p>​                                                                                  图8.19　切片式索引示意图<br>程序代码如下：</p>
<p><img src="/.com//image-20211026163739258.png" alt="image-20211026163739258"></p>
<p>运行程序，输出结果如下：</p>
<p>1<br>2<br>[1 2]<br>[2 3]<br>[1 2]<br>切片式索引操作需要注意以下几点。<br>（1）索引是左闭右开区间，如上述代码中的n1[0:2]，只能取到索引从0～1的元素，而取不到索引为2的元素。<br>（2）当没有start参数时，代表从索引0开始取数，如上述代码中的n1[:2]。<br>（3）start、stop和step这3个参数都可以是负数，代表反向索引。以step参数为例，如图8.20所示。</p>
<p><img src="/.com//image-20211026163851780.png" alt="image-20211026163851780"></p>
<p>​                                                                                        图8.20　反向索引示意图</p>
<p>【示例31】　常用的切片式索引操作。（示例位置：资源包\MR\Code\08\31）<br>常用的切片式索引操作，程序代码如下：</p>
<p><img src="/.com//image-20211026163919986.png" alt="image-20211026163919986"></p>
<p>运行程序，输出结果如下：</p>
<p><img src="/.com//image-20211026163946683.png" alt="image-20211026163946683"></p>
<h4 id="3．二维数组索引"><a href="#3．二维数组索引" class="headerlink" title="3．二维数组索引"></a>3．二维数组索引</h4><p>二维数组索引可以使用array[n,m]的方式，以逗号分隔，表示第n个数组的，第m个元素。</p>
<p>【示例32】　二维数组的简单索引操作。（示例位置：资源包\MR\Code\08\32）<br>创建一个3行4列的二维数组，实现简单的索引操作，效果如图8.21所示。</p>
<p><img src="/.com//image-20211026164056410.png" alt="image-20211026164056410"></p>
<p>​                                                                                                图8.21　二维数组索引示意图<br>程序代码如下：</p>
<p><img src="/.com//image-20211026164124849.png" alt="image-20211026164124849"></p>
<p>运行程序，输出结果如下：</p>
<p>[4 5 6 7]<br>6<br>[ 8  9 10 11]<br>上述代码中，n[1]表示第2个数组，n[1,2]表示第2个数组第3个元素，它等同于n[1][2]，表示数组n中第2行第3列的值，实际上n[1] [2]是先索引第一个维度得到一个数组，然后在此基础上再索引。</p>
<h4 id="4．二维数组切片式索引"><a href="#4．二维数组切片式索引" class="headerlink" title="4．二维数组切片式索引"></a>4．二维数组切片式索引</h4><p>【示例33】　二维数组的切片操作。（示例位置：资源包\MR\Code\08\33）<br>创建一个二维数组，实现各种切片式索引操作，效果如图8.22所示。</p>
<p><img src="/.com//image-20211026164351235.png" alt="image-20211026164351235"></p>
<p>​                                                                            图8.22　二维数组切片式索引示意图</p>
<p>程序代码如下：</p>
<p><img src="/.com//image-20211026164653494.png" alt="image-20211026164653494"></p>
<p>运行程序，输出结果如下：</p>
<p><img src="/.com//image-20211026164710619.png" alt="image-20211026164710619"></p>
<h3 id="8-3-4-数组重塑"><a href="#8-3-4-数组重塑" class="headerlink" title="8.3.4　数组重塑"></a>8.3.4　数组重塑</h3><p>数组重塑实际是更改数组的形状，例如，将原来2行3列的数组重塑为3行4列的数组。在NumPy中主要使用reshape()方法，该方法用于改变数组的形状。</p>
<h4 id="1．一维数组重塑"><a href="#1．一维数组重塑" class="headerlink" title="1．一维数组重塑"></a>1．一维数组重塑</h4><p>一维数组重塑就是将数组重塑为多行多列的数组。</p>
<p>【示例34】　将一维数组重塑为二维数组。（示例位置：资源包\MR\Code\08\34）<br>创建一个一维数组，然后通过reshape()方法将其改为2行3列的二维数组，程序代码如下：</p>
<p><img src="/.com//image-20211026164736044.png" alt="image-20211026164736044"></p>
<p>运行程序，输出结果如下：</p>
<p><img src="/.com//image-20211026164756364.png" alt="image-20211026164756364"></p>
<p>需要注意的是，数组重塑是基于数组元素不发生改变的情况，重塑后的数组所包含的元素个数必须与原数组元素个数相同，如果数组元素发生改变，程序就会报错。</p>
<p>【示例35】　将一行古诗转换为4行5列的二维数组。（示例位置：资源包\MR\Code\08\35）<br>将一行20列的数据转换为4行5列的二维数组，效果如图8.23所示。</p>
<p><img src="/.com//image-20211026164923273.png" alt="image-20211026164923273"></p>
<p>​                                                                                                 图8.23　数组重塑示意图<br>程序代码如下：</p>
<p><img src="/.com//image-20211026164947021.png" alt="image-20211026164947021"></p>
<p>运行程序，输出结果如下：</p>
<p><img src="/.com//image-20211026165004423.png" alt="image-20211026165004423"></p>
<h4 id="2．多维数组重塑"><a href="#2．多维数组重塑" class="headerlink" title="2．多维数组重塑"></a>2．多维数组重塑</h4><p>多维数组重塑同样使用reshape()方法。</p>
<p>【示例36】　将2行3列的数组重塑为3行2列的数组。（示例位置：资源包\MR\Code\08\36）<br>将2行3列的二维数组重塑为3行2列的二维数组，程序代码如下：</p>
<p><img src="/.com//image-20211026165037961.png" alt="image-20211026165037961"></p>
<p>运行程序，输出结果如下：</p>
<p><img src="/.com//image-20211026165053942.png" alt="image-20211026165053942"></p>
<h4 id="3．数组转置"><a href="#3．数组转置" class="headerlink" title="3．数组转置"></a>3．数组转置</h4><p>数组转置是指数组的行列转换，可以通过数组的T属性和transpose()函数实现。</p>
<p>【示例37】　将二维数组中的行列转置。（示例位置：资源包\MR\Code\08\37）<br>通过T属性将4行6列的二维数组中的行变成列，列变成行，程序代码如下：</p>
<p><img src="/.com//image-20211026165138211.png" alt="image-20211026165138211"></p>
<p>运行程序，输出结果如下：</p>
<p><img src="/.com//image-20211026165155864.png" alt="image-20211026165155864"></p>
<p>【示例38】　转换客户销售数据。（示例位置：资源包\MR\Code\08\38）<br>上述举例可能不太直观，下面再举一个例子，转换客户销售数据，对比效果如图8.24所示。</p>
<p><img src="/.com//image-20211026165234909.png" alt="image-20211026165234909"></p>
<p>​                                                                     图8.24　客户销售数据转换对比示意图<br>程序代码如下：</p>
<p><img src="/.com//image-20211026165254710.png" alt="image-20211026165254710"></p>
<p>运行程序，输出结果如下：</p>
<p><img src="/.com//image-20211026165309989.png" alt="image-20211026165309989"></p>
<p>transpose()函数也可以实现数组转置。例如，上述举例用transpose()函数实现，关键代码如下：</p>
<p>01  n = np.array([[‘A’,100],[‘B’,200],[‘C’,300],[‘D’,400],[‘E’,500]])<br>02  print(n.transpose())                           #transpose()函数行列转置<br>运行程序，输出结果如下：</p>
<p><img src="/.com//image-20211026165407591.png" alt="image-20211026165407591"></p>
<h3 id="8-3-5-数组的增、删、改、查"><a href="#8-3-5-数组的增、删、改、查" class="headerlink" title="8.3.5　数组的增、删、改、查"></a>8.3.5　数组的增、删、改、查</h3><p>数组增、删、改、查的方法有很多种，下面介绍几种常用的方法。</p>
<h4 id="1．数组的增加"><a href="#1．数组的增加" class="headerlink" title="1．数组的增加"></a>1．数组的增加</h4><p>数组数据的增加可以按照水平方向增加数据，也可以按照垂直方向增加数据。水平方向增加数据主要使用hstack()函数，垂直方向增加数据主要使用vstack()函数。</p>
<p>【示例39】　为数组增加数据。（示例位置：资源包\MR\Code\08\39）<br>创建两个二维数组，然后实现数组数据的增加，程序代码如下：</p>
<p><img src="/.com//image-20211026165507946.png" alt="image-20211026165507946"></p>
<p>运行程序，输出结果如下：</p>
<p><img src="/.com//image-20211026165522416.png" alt="image-20211026165522416"></p>
<h4 id="2．数组的删除"><a href="#2．数组的删除" class="headerlink" title="2．数组的删除"></a>2．数组的删除</h4><p>数组的删除主要使用delete()方法。</p>
<p>【示例40】　删除指定的数组。（示例位置：资源包\MR\Code\08\40）<br>删除指定的数组，程序代码如下：</p>
<p><img src="/.com//image-20211026165543012.png" alt="image-20211026165543012"></p>
<p>运行程序，输出结果如下：</p>
<p><img src="/.com//image-20211026165601688.png" alt="image-20211026165601688"></p>
<p>那么，对于不想要的数组或数组元素还可以通过索引和切片方法只选取需要的数组或数组元素。</p>
<h4 id="3．数组的修改"><a href="#3．数组的修改" class="headerlink" title="3．数组的修改"></a>3．数组的修改</h4><p>修改数组或数组元素时，直接为数组或数组元素赋值即可。</p>
<p>【示例41】　修改指定的数组。（示例位置：资源包\MR\Code\08\41）<br>修改指定的数组，程序代码如下：</p>
<p><img src="/.com//image-20211026165836901.png" alt="image-20211026165836901"></p>
<p>运行程序，输出结果如下：</p>
<p><img src="/.com//image-20211026165851666.png" alt="image-20211026165851666"></p>
<h4 id="4．数组的查询"><a href="#4．数组的查询" class="headerlink" title="4．数组的查询"></a>4．数组的查询</h4><p>数组的查询同样可以使用索引和切片方法来获取指定范围的数组或数组元素，还可以通过where()函数查询符合条件的数组或数组元素。where()函数语法如下：</p>
<p>numpy.where(condition,x,y)<br>上述语法，第一个参数为一个布尔数组，第二个参数和第三个参数可以是标量也可以是数组。满足条件（参数condition），输出参数x，不满足条件输出参数y。</p>
<p>【示例42】　按指定条件查询数组。（示例位置：资源包\MR\Code\08\42）<br>数组查询，大于5输出2，不大于5输出0，程序代码如下：</p>
<p><img src="/.com//image-20211026165929414.png" alt="image-20211026165929414"></p>
<p>运行程序，输出结果如下：</p>
<p>[0 1 2 3 4 5 6 7 8 9]<br>[0 0 0 0 0 0 2 2 2 2]<br>如果不指定参数x和y，则输出满足条件的数组元素的坐</p>
<p>标。例如，上述举例不指定参数x和y，关键代码如下：</p>
<p>01  n2=n1[np.where(n1&gt;5)]<br>02  print(n2)<br>运行程序，输出结果如下：</p>
<p>[6 7 8 9]</p>
<h1 id="8-4-NumPy矩阵的基本操作"><a href="#8-4-NumPy矩阵的基本操作" class="headerlink" title="8.4　NumPy矩阵的基本操作"></a>8.4　NumPy矩阵的基本操作</h1><p>在数学中经常会看到矩阵，而在程序中常用的是数组，可以简单地理解为，矩阵是数学的概念，而数组是计算机程序设计领域的概念。在NumPy中，矩阵是数组的分支，数组和矩阵有些时候是通用的，二维数组也称矩阵。下面简单介绍矩阵的基本操作。</p>
<h2 id="8-4-1-创建矩阵"><a href="#8-4-1-创建矩阵" class="headerlink" title="8.4.1　创建矩阵"></a>8.4.1　创建矩阵</h2><p>NumPy函数库中存在两种不同的数据类型（矩阵matrix和数组array），它们都可以用于处理行列表示的数组元素，虽然它们看起来很相似，但是在这两种数据类型上执行相同的数学运算，可能得到不同的结果。<br>在NumPy中，矩阵应用十分广泛。例如，每个图像可以被看作像素值矩阵。假设一个像素值仅为0和1，那么5×5大小的图像就是一个5×5的矩阵，如图8.25所示；而3×3大小的图像就是一个3×3的矩阵，如图8.26所示。</p>
<p><img src="/.com//image-20211026170015304.png" alt="image-20211026170015304"></p>
<p>​                                                                                             图8.25　5×5矩阵示意图</p>
<p><img src="/.com//image-20211026170035799.png" alt="image-20211026170035799"></p>
<p>​                                                                                                图8.26　3×3矩阵示意图<br>关于矩阵就简单了解到这里，下面介绍如何在NumPy中创建矩阵。</p>
<p>【示例43】　创建简单矩阵。（示例位置：资源包\MR\Code\08\43）<br>使用mat()函数创建矩阵，程序代码如下：</p>
<p><img src="/.com//image-20211026170127022.png" alt="image-20211026170127022"></p>
<p>运行程序，输出结果如下：</p>
<p><img src="/.com//image-20211026170143985.png" alt="image-20211026170143985"></p>
<p>从运行结果得知：mat()函数创建的是矩阵类型，array()函数创建的是数组类型，而用mat()函数创建的矩阵才能进行一些线性代数的操作。</p>
<p>【示例44】　使用mat()函数创建常见的矩阵。（示例位置：资源包\MR\Code\08\44）<br>下面使用mat()函数创建常见的矩阵。<br>（1）创建一个3×3的0（零）矩阵，程序代码如下：</p>
<p><img src="/.com//image-20211026170213383.png" alt="image-20211026170213383"></p>
<p>运行程序，输出结果如下：</p>
<p><img src="/.com//image-20211026170242743.png" alt="image-20211026170242743"></p>
<p>（2）创建一个2×4的1矩阵，程序代码如下：</p>
<p><img src="/.com//image-20211026170348020.png" alt="image-20211026170348020"></p>
<p>运行程序，输出结果如下：</p>
<p><img src="/.com//image-20211026170431915.png" alt="image-20211026170431915"></p>
<p>（3）使用random模块的rand()函数创建一个3×3为0～1随机产生的二维数组，并将其转换为矩阵，程序代码如下：</p>
<p>01  import numpy as np</p>
<p>02  data1 = np.mat(np.random.rand(3,3))<br>03  print(data1)<br>运行程序，输出结果如下：</p>
<p><img src="/.com//image-20211026170511819.png" alt="image-20211026170511819"></p>
<p>（4）创建一个1～8的随机整数矩阵，程序代码如下：</p>
<p>01 import numpy as np<br>02 data1 = np.mat(np.random.randint(1,8,size=(3,5)))<br>03 print(data1)<br>运行程序，输出结果如下：</p>
<p><img src="/.com//image-20211026170540232.png" alt="image-20211026170540232"></p>
<p>（5）创建对角矩阵，程序代码如下：</p>
<p><img src="/.com//image-20211026170625799.png" alt="image-20211026170625799"></p>
<p>运行程序，输出结果如下：</p>
<p><img src="/.com//image-20211026170642474.png" alt="image-20211026170642474"></p>
<p>（6）创建对角线矩阵，程序代码如下：</p>
<p><img src="/.com//image-20211026170716487.png" alt="image-20211026170716487"></p>
<p>运行程序，输出结果如下：</p>
<p><img src="/.com//image-20211026170742422.png" alt="image-20211026170742422"></p>
<p>说明<br>mat()函数只适用于二维矩阵，维数超过2以后，mat()</p>
<p>函数就不适用了，从这一点来看array()函数更具通用性。</p>
<h2 id="8-4-2-矩阵运算"><a href="#8-4-2-矩阵运算" class="headerlink" title="8.4.2　矩阵运算"></a>8.4.2　矩阵运算</h2><p>如果两个矩阵大小相同，我们可以使用算术运算符“+”“-”“*”“/”对矩阵进行加、减、乘、除的运算。</p>
<p>【示例45】　矩阵加法运算。（示例位置：资源包\MR\Code\08\45）<br>创建两个矩阵data1和data2，实现矩阵的加法运算，效果如图8.27所示。</p>
<p><img src="/.com//image-20211026170836683.png" alt="image-20211026170836683"></p>
<p>​                                                                  图8.27　矩阵的加法运算示意图<br>程序代码如下：</p>
<p><img src="/.com//image-20211026170917227.png" alt="image-20211026170917227"></p>
<p>运行程序，输出结果如下：</p>
<p><img src="/.com//image-20211026170933858.png" alt="image-20211026170933858"></p>
<p>【示例46】　矩阵减法、乘法和除法运算。（示例位置：资源包\MR\Code\08\46）<br>除了加法运算，还可以实现矩阵的减法、乘法和除法运算。接下来实现上述矩阵的减法和除法运算，程序代码如下：<br>运行程序，输出结果如下：</p>
<p><img src="/.com//image-20211026170952257.png" alt="image-20211026170952257"></p>
<p>当对上述矩阵实现乘法运算时，程序出现了错误，原因是矩阵的乘法运算，要求左边矩阵的列和右边矩阵的行数要一致。由于上述矩阵data2只有一行，所以导致程序出错。</p>
<p>【示例47】　修改矩阵并进行乘法运算。（示例位置：资源包\MR\Code\08\47）</p>
<p>将矩阵data2改为2×2矩阵，再进行矩阵的乘法运算，程序代码如下：</p>
<p><img src="/.com//image-20211026171103706.png" alt="image-20211026171103706"></p>
<p>运行程序，输出结果如下：</p>
<p><img src="/.com//image-20211026171125494.png" alt="image-20211026171125494"></p>
<p>上述举例，是两个矩阵直接相乘，称之为矩阵相乘。矩阵相乘是第一个矩阵中与该元素行号相同的元素与第二个矩阵中与该元素列号相同的元素，两两相乘后再求和，运算过程如图8.28所示。例如，1×1+2×3=7，是第一个矩阵第1行元素与第二个矩阵第1列元素，两两相乘求和得到的。</p>
<p><img src="/.com//image-20211026171144696.png" alt="image-20211026171144696"></p>
<p>​                                                                         图8.28　矩阵相乘运算过程示意图<br>数组运算和矩阵运算的一个关键区别是矩阵相乘使用的是点乘。点乘，也称点积，是数组中元素对应位置一一相乘之后求和的操作，在NumPy中专门提供了点乘方法，即dot()方法，该方法返回的是两个数组的点积。</p>
<p>【示例48】　数组相乘与数组点乘比较。（示例位置：资源包\MR\Code\08\48）<br>数组相乘与数组点乘运算，程序代码如下：</p>
<p><img src="/.com//image-20211026171207973.png" alt="image-20211026171207973"></p>
<p>运行程序，输出结果如下：</p>
<p><img src="/.com//image-20211026171222686.png" alt="image-20211026171222686"></p>
<p>【示例49】　矩阵元素之间的相乘运算。（示例位置：资源包\MR\Code\08\49）<br>要实现矩阵对应元素之间的相乘可以使用multiply()函数，程序代码如下：</p>
<p><img src="/.com//image-20211026171240997.png" alt="image-20211026171240997"></p>
<p>运行程序，输出结果如下：</p>
<p><img src="/.com//image-20211026173555512.png" alt="image-20211026173555512"></p>
<h2 id="8-4-3-矩阵转换"><a href="#8-4-3-矩阵转换" class="headerlink" title="8.4.3　矩阵转换"></a>8.4.3　矩阵转换</h2><h3 id="1．矩阵转置"><a href="#1．矩阵转置" class="headerlink" title="1．矩阵转置"></a>1．矩阵转置</h3><p>【示例50】　使用T属性实现矩阵转置。（示例位置：资源包\MR\Code\08\50）<br>矩阵转置与数组转置一样使用T属性，程序代码如下：</p>
<p>01  import numpy as np<br>02  n1 = np.mat(‘1 3 3;4 5 6;7 12 9’)            #创建矩阵，使用分号隔开数据<br>03  print(‘矩阵转置结果为：\n’,n1.T)             #矩阵转置<br>运行程序，输出结果如下：</p>
<p><img src="/.com//image-20211026173620078.png" alt="image-20211026173620078"></p>
<h3 id="2．矩阵求逆"><a href="#2．矩阵求逆" class="headerlink" title="2．矩阵求逆"></a>2．矩阵求逆</h3><p>【示例51】　实现矩阵逆运算。（示例位置：资源包\MR\Code\08\51）<br>矩阵要可逆，否则意味着该矩阵为奇异矩阵（即矩阵的行列式的值为0）。矩阵求逆主要使用I属性，程序代码如下：</p>
<p>01  import numpy as np<br>02  n1 = np.mat(‘1 3 3;4 5 6;7 12 9’)       #创建矩阵，使用分号隔开数据<br>03  print(‘矩阵的逆矩阵结果为：\n’,n1.I)    #逆矩阵<br>运行程序，输出结果如下：</p>
<p><img src="/.com//image-20211026173645127.png" alt="image-20211026173645127"></p>
<h1 id="8-5-NumPy常用统计分析函数"><a href="#8-5-NumPy常用统计分析函数" class="headerlink" title="8.5　NumPy常用统计分析函数"></a>8.5　NumPy常用统计分析函数</h1><h2 id="8-5-1-数学运算函数"><a href="#8-5-1-数学运算函数" class="headerlink" title="8.5.1　数学运算函数"></a>8.5.1　数学运算函数</h2><p>NumPy包含大量的数学运算的函数，包括三角函数、算术运算函数、复数处理函数等，如表8.2所示。</p>
<p>​                                                                                        表8.2　数学运算函数</p>
<p><img src="/.com//image-20211026173754018.png" alt="image-20211026173754018"></p>
<p>下面介绍几个常用的数学运算函数。</p>
<h3 id="1．算术函数"><a href="#1．算术函数" class="headerlink" title="1．算术函数"></a>1．算术函数</h3><h3 id="（1）加、减、乘、除"><a href="#（1）加、减、乘、除" class="headerlink" title="（1）加、减、乘、除"></a>（1）加、减、乘、除</h3><p>NumPy算术函数包含简单的加、减、乘、除运算，如add()函数、subtract()函数、multiply()函数和divide()函数。这里要注意的是，数组必须具有相同的形状或符合数组广播规则。</p>
<p>【示例52】　数组加、减、乘、除运算。（示例位置：资源包\MR\Code\08\52）<br>数组加、减、乘、除运算，程序代码如下：</p>
<p><img src="/.com//image-20211026173820639.png" alt="image-20211026173820639"></p>
<p>运行程序，输出结果如下：</p>
<p><img src="/.com//image-20211026173836746.png" alt="image-20211026173836746"></p>
<h3 id="（2）倒数"><a href="#（2）倒数" class="headerlink" title="（2）倒数"></a>（2）倒数</h3><p>reciprocal()函数用于返回数组中各元素的倒数。如4/3的倒数是3/4。</p>
<p>【示例53】　计算数组元素的倒数。（示例位置：资源包\MR\Code\08\53）<br>计算数组元素的倒数，程序代码如下：</p>
<p>01 import numpy as np<br>02 a = np.array([0.25, 1.75, 2, 100])<br>03 print(np.reciprocal(a))<br>运行程序，输出结果如下：</p>
<p>[4.  0.57142857 0.5  0.01  ]</p>
<h3 id="（3）求幂"><a href="#（3）求幂" class="headerlink" title="（3）求幂"></a>（3）求幂</h3><p>power()函数将第一个数组中的元素作为底数，计算它与第二个数组中相应元素的幂。</p>
<p>【示例54】　数组元素的幂运算。（示例位置：资源包\MR\Code\08\54）<br>对数组元素幂运算，程序代码如下：</p>
<p>01 import numpy as np<br>02 n1 = np.array([10, 100, 1000])<br>03 print(np.power(n1, 3))<br>04 n2= np.array([1, 2, 3])<br>05 print(np.power(n1, n2))<br>运行程序，输出结果如下：</p>
<p>[  1000  1000000 1000000000]<br>[    10    10000 1000000000]</p>
<h3 id="（4）取余"><a href="#（4）取余" class="headerlink" title="（4）取余"></a>（4）取余</h3><p>mod()函数用于计算数组之间相应元素相除后的余数。</p>
<p>【示例55】　对数组元素取余。（示例位置：资源包\MR\Code\08\55）<br>对数组元素取余，程序代码如下：</p>
<p>01  import numpy as np<br>02  n1 = np.array([10, 20, 30])<br>03  n2 = np.array([4, 5, -8])<br>04  print(np.mod(n1, n2))<br>运行程序，输出结果如下：</p>
<p>[ 2  0 -2]</p>
<p>知识胶囊<br>下面重点介绍NumPy负数取余的算法，公式如下：<br>r=a-n*[a//n]<br>其中r为余数，a是被除数，n是除数，“//”为运算取商时保留整数的下界，即偏向于较小的整数。根据负数取余的3种情况，举例如下：<br>r=30-(-8)<em>(30//(-8))=30-(-8)</em>(-4)=30-32=-2<br>r=-30-(-8)<em>(-30//(-8))=-30-(-8)</em>(3)=-30-24=-6<br>r=-30-(8)<em>(-30//(8))=-30-(8)</em>(-4)=-30+32=2</p>
<h3 id="2．舍入函数"><a href="#2．舍入函数" class="headerlink" title="2．舍入函数"></a>2．舍入函数</h3><h3 id="（1）四舍五入around-函数"><a href="#（1）四舍五入around-函数" class="headerlink" title="（1）四舍五入around()函数"></a>（1）四舍五入around()函数</h3><p>四舍五入在NumPy中应用比较多，主要使用around()函数，该函数返回指定小数位数的四舍五入值，语法如下：</p>
<p>numpy.around(a,decimals)<br>参数说明：　</p>
<p>a：数组。　</p>
<p>decimals：舍入的小数位数，默认值为0，如果为负，整数将四舍五入到小数点左侧的位置。</p>
<p>【示例56】　将数组中的一组数字四舍五入。（示例位置：资源包\MR\Code\08\56）<br>将数组中的一组数字四舍五入，程序代码如下：<br>运行程序，输出结果如下：</p>
<p>[  2.   7. 100.   0.  3.  -2.]<br>[  1.55   6.82 100.    0.12   3.14  -2.35]<br>[  0.  10. 100.   0.  0.  -0.]</p>
<h3 id="（2）向上取整ceil-函数"><a href="#（2）向上取整ceil-函数" class="headerlink" title="（2）向上取整ceil()函数"></a>（2）向上取整ceil()函数</h3><p>ceil()函数用于返回大于或者等于指定表达式的最小整数，即向上取整。</p>
<p>【示例57】　对数组元素向上取整。（示例位置：资源包\MR\Code\08\57）<br>对数组元素向上取整，程序代码如下：<br>运行程序，输出结果如下：</p>
<p>[-1.  2. -0.  1. 15.]</p>
<h3 id="（3）向下取整floor-函数"><a href="#（3）向下取整floor-函数" class="headerlink" title="（3）向下取整floor()函数"></a>（3）向下取整floor()函数</h3><p>floor()函数用于返回小于或者等于指定表达式的最大整数，即向下取整。</p>
<p>【示例58】　对数组元素向下取整。（示例位置：资源包\MR\Code\08\58）</p>
<p>对数组元素向下取整，程序代码如下：</p>
<p>01  import numpy as np<br>02  n = np.array([-1.8, 1.66, -0.2, 0.888, 15])     #创建数组<br>03  print(np.floor(n))                              #向下取整<br>运行程序，输出结果如下：</p>
<p>[-2.  1. -1.  0. 15.]</p>
<h3 id="3．三角函数"><a href="#3．三角函数" class="headerlink" title="3．三角函数"></a>3．三角函数</h3><p>NumPy提供了标准的三角函数，即sin()函数、cos()函数和tan()函数。</p>
<p>【示例59】　计算数组的正弦值、余弦值和正切值。（示例位置：资源包\MR\Code\08\59）<br>计算数组元素的正弦值、余弦值和正切值，程序代码如下：</p>
<p><img src="/.com//image-20211026174155746.png" alt="image-20211026174155746"></p>
<p>运行程序，输出结果如下：</p>
<p><img src="/.com//image-20211026174212800.png" alt="image-20211026174212800"></p>
<p>arcsin()函数、arccos()函数和arctan()函数用于返回给定角度的sin、cos和tan的反三角函数。这些函数的结果可以通过degrees()函数将弧度转换为角度。</p>
<p>【示例60】　将弧度转换为角度。（示例位置：资源包\MR\Code\08\60）<br>首先计算不同角度的正弦值，然后使用arcsin()函数计算角度的反正弦，返回值以弧度为单位，最后使用degrees()函数将弧度转换为角度来验证结果，程序代码如下：</p>
<p><img src="/.com//image-20211026174231238.png" alt="image-20211026174231238"></p>
<p>运行程序，输出结果如下：</p>
<p><img src="/.com//image-20211026174311391.png" alt="image-20211026174311391"></p>
<p>arccos()函数和arctan()函数的用法与arcsin()函数的用法差不多，这里不再举例。</p>
<h2 id="8-5-2-统计分析函数"><a href="#8-5-2-统计分析函数" class="headerlink" title="8.5.2　统计分析函数"></a>8.5.2　统计分析函数</h2><p>统计分析函数是对整个NumPy数组或某条轴的数据进行统计运算，函数介绍如表8.3所示。</p>
<p>​                                                                                           表8.3　统计分析函数</p>
<p><img src="/.com//image-20211026174357030.png" alt="image-20211026174357030"></p>
<p>下面介绍几个常用的统计函数。首先创建一个数组，如图8.29所示。</p>
<p><img src="/.com//image-20211026174437338.png" alt="image-20211026174437338"></p>
<p>​                                                                                          图8.29　数组示意图</p>
<h3 id="1．求和sum-函数"><a href="#1．求和sum-函数" class="headerlink" title="1．求和sum()函数"></a>1．求和sum()函数</h3><p>【示例61】　对数组元素求和。（示例位置：资源包\MR\Code\08\61）<br>对数组元素求和、对数组元素按行和按列求和，程序代码如下：</p>
<p><img src="/.com//image-20211026174535205.png" alt="image-20211026174535205"></p>
<p>运行程序，输出结果如下：</p>
<p><img src="/.com//image-20211026174553779.png" alt="image-20211026174553779"></p>
<h3 id="2．求平均值mean-函数"><a href="#2．求平均值mean-函数" class="headerlink" title="2．求平均值mean()函数"></a>2．求平均值mean()函数</h3><p>【示例62】　对数组元素求平均值。（示例位置：资源包\MR\Code\08\62）<br>对数组元素求平均值、对数组元素按行求平均值和按列求平均值，关键代码如下：</p>
<p><img src="/.com//image-20211026174622127.png" alt="image-20211026174622127"></p>
<p>运行程序，输出结果如下：</p>
<p><img src="/.com//image-20211026174644781.png" alt="image-20211026174644781"></p>
<h3 id="3．求最大值max-函数和最小值min-函数"><a href="#3．求最大值max-函数和最小值min-函数" class="headerlink" title="3．求最大值max()函数和最小值min()函数"></a>3．求最大值max()函数和最小值min()函数</h3><p>【示例63】　对数组元素求最大值和最小值。（示例位置：资源包\MR\Code\08\63）<br>对数组元素求最大值和最小值，关键代码如下：</p>
<p><img src="/.com//image-20211026174704524.png" alt="image-20211026174704524"></p>
<p>运行程序，输出结果如下：</p>
<p><img src="/.com//image-20211026174733324.png" alt="image-20211026174733324"></p>
<p>对二维数组求最大值在实际应用中非常广泛。例如，统计销售冠军。</p>
<h3 id="4．求加权平均average-函数"><a href="#4．求加权平均average-函数" class="headerlink" title="4．求加权平均average()函数"></a>4．求加权平均average()函数</h3><p>在日常生活中，常用平均数表示一组数据的“平均水平”。在一组数据里，一个数据出现的次数称为权。将一组数据与出现的次数相乘再平均就是“加权平均”。加权平均能够反映一组数据中各个数据的重要程度，以及对整体趋势的影响。加权平均在日常生活应用非常广泛，如考试成绩、股票价格、竞技比赛等。</p>
<p>【示例64】　计算电商各活动销售的加权平均价。（示例位置：资源包\MR\Code\08\64）<br>某电商在开学季、6.18、双十一、双十二等活动价格均不同，下面计算加权平均价，程序代码如下：</p>
<p><img src="/.com//image-20211026174836425.png" alt="image-20211026174836425"></p>
<p>运行程序，输出结果如下：</p>
<p>加权平均价：<br>34.84920634920635</p>
<h3 id="5．中位数median-函数"><a href="#5．中位数median-函数" class="headerlink" title="5．中位数median()函数"></a>5．中位数median()函数</h3><p>中位数用来衡量数据取值的中等水平或一般水平，可以避免极端值的影响。在数据处理过程中，当数据中存在少量异常值时，它不受其影响，基于这一特点，一般使用中位数来评价分析结果。<br>那么，什么是中位数？将各个变量值按大小顺序排列起来，形成一个数列，居于数列中间位置的那个数即为中位数。例如，1、2、3、4、5这5个数，中位数就是中间的数字3，而1、2、3、4、5、6这6个数，中位数则是中间两个数的平均值，即3.5。</p>
<p>知识胶囊<br>中位数与平均数不同，它不受异常值的影响。例如，将1、2、3、4、5、6改为1、2、3、4、5、288，中位数依然是3.5。</p>
<p>【示例65】　计算电商活动价格的中位数。（示例位置：资源包\MR\Code\08\65）<br>计算电商在开学季、6.18、双十一、双十二等活动价格的中位数，程序代码如下：<br>运行程序，输出结果如下：</p>
<p>数组排序：<br>[33.6 34.5 36. 37.8 39. 39.8]数组中位数为：<br>36.9</p>
<h3 id="6．方差、标准差"><a href="#6．方差、标准差" class="headerlink" title="6．方差、标准差"></a>6．方差、标准差</h3><p>方差、标准差的定义在第4章已经介绍过了，这里不再赘述，直接进入主题。</p>
<p>【示例66】　求数组的方差和标准差。（示例位置：资源包\MR\Code\08\66）<br>在NumPy中实现方差和标准差，程序代码如下：<br>运行程序，输出结果如下：</p>
<p>数组方差：<br>5.168055555555551数组标准差：<br>2.2733357771247853</p>
<h2 id="8-5-3-数组的排序"><a href="#8-5-3-数组的排序" class="headerlink" title="8.5.3　数组的排序"></a>8.5.3　数组的排序</h2><p>数组的排序是对数组元素进行排序。</p>
<h3 id="1．sort-函数"><a href="#1．sort-函数" class="headerlink" title="1．sort()函数"></a>1．sort()函数</h3><p>使用sort()函数进行排序，直接改变原数组，参数axis指定按行排序还是按列排序。</p>
<p>【示例67】　对数组元素按行和列排序。（示例位置：资源包\MR\Code\08\67）<br>对数组元素排序，程序代码如下：</p>
<p><img src="/.com//image-20211026175022606.png" alt="image-20211026175022606"></p>
<p>运行程序，输出结果如下：</p>
<p><img src="/.com//image-20211026175038158.png" alt="image-20211026175038158"></p>
<h3 id="2．argsort-函数"><a href="#2．argsort-函数" class="headerlink" title="2．argsort()函数"></a>2．argsort()函数</h3><p>使用argsort()函数对数组进行排序，返回升序排序之后数组值从小到大的索引值。</p>
<p>【示例68】　对数组元素升序排序。（示例位置：资源包\MR\Code\08\68）<br>对数组元素排序，程序代码如下：</p>
<p><img src="/.com//image-20211026175100199.png" alt="image-20211026175100199"></p>
<p>运行程序，输出结果如下：</p>
<p>升序排序后的索引值：<br>[6 3 2 0 5 8 1 4 7]<br>排序后的顺序重构原数组：<br>[1 2 3 4 5 6 7 8 9]</p>
<h3 id="3．lexsort-函数"><a href="#3．lexsort-函数" class="headerlink" title="3．lexsort()函数"></a>3．lexsort()函数</h3><p>lexsort()函数用于对多个序列进行排序。可以把它当作是对电子表格进行排序，每一列代表一个序列，排序时优先照顾靠后的列。</p>
<p>【示例69】　通过排序解决成绩相同学生的录取问题。（示例位置：资源包\MR\Code\08\69）<br>某重点高中，精英班录取学生按照总成绩录取。由于名额有限，因此当总成绩相同时，数学成绩高的优先录取；当总成绩和数学成绩都相同时，按照英语成绩高的优先录取。下面使用lexsort()函数对学生成绩进行排序，程序代码如下：</p>
<p><img src="/.com//image-20211026175145965.png" alt="image-20211026175145965"></p>
<p>运行程序，输出结果如下：</p>
<p><img src="/.com//image-20211026175200074.png" alt="image-20211026175200074"></p>
<p>上述举例，按照数学、英语和总分进行升序排序，总成绩620分的两名同学，按照数学成绩高的优先录取原则进行第一轮排序，总分615分的两名同学，同时他们的数学成绩也相同，则按照英语成绩高的优先录取原则进行第二轮排序。</p>
<h1 id="8-6-综合应用"><a href="#8-6-综合应用" class="headerlink" title="8.6　综合应用"></a>8.6　综合应用</h1><h2 id="8-6-1-案例1：NumPy实现正态分布"><a href="#8-6-1-案例1：NumPy实现正态分布" class="headerlink" title="8.6.1　案例1：NumPy实现正态分布"></a>8.6.1　案例1：NumPy实现正态分布</h2><p>案例位置：资源包\MR\Code\08\example\01<br>首先简单了解一下什么是正态分布。正态分布，也称“常态分布”，又名高斯分布，它在数据分析的许多方面有着重大的影响力。<br>正态分布是应用最广泛、最常见的一种数据分布形式。正态分布像一只倒扣的钟，两头低，中间高，左右对称，大部分数据集中在平均值附近，小部分在两端。例如，学生成绩的分布，高分和低分的成绩一般是少数，分布在两端，而大部分成绩集中在中间，如图8.30所示。<br>下面使用NumPy生成均值为0，标准差为0.1的一维正态分布样本1000个，并用图表显示出来，效果如图8.31所示。</p>
<p><img src="/.com//image-20211026175247307.png" alt="image-20211026175247307"></p>
<p>​                                                                             图8.30　学生成绩正态分布示意图</p>
<p><img src="/.com//image-20211026175307086.png" alt="image-20211026175307086"></p>
<p>​                                                                                               图8.31　正态分布图</p>
<p>程序代码如下：</p>
<p><img src="/.com//image-20211026175329461.png" alt="image-20211026175329461"></p>
<h2 id="8-6-2-案例2：NumPy用于图像灰度处理"><a href="#8-6-2-案例2：NumPy用于图像灰度处理" class="headerlink" title="8.6.2　案例2：NumPy用于图像灰度处理"></a>8.6.2　案例2：NumPy用于图像灰度处理</h2><p>案例位置：资源包\MR\Code\08\example\02<br>首先了解一下图像，图像其实是由若干像素组成，每一个像素都有明确的位置和被分配的颜色值，因此一张图像也就构成了一个像素矩阵。例如，一张灰度图片的像素块，如图8.32所示。</p>
<p><img src="/.com//image-20211026175347296.png" alt="image-20211026175347296"></p>
<p>​                                                                                      图8.32　灰度图片像素矩阵示意图<br>从图8.32得知：灰度图的数据是一个二维数组，颜色取值为0～255，其中，0为黑色，255为白色。从0～255逐渐由暗色变为亮色。由此可见，图像灰度处理是不是就可以通过数组计算来实现呢？<br>接下来，了解一个公式，RGB转换成灰度图像的常用公式：</p>
<p>Gray = R<em>0.299 + G</em>0.587 + B*0.114<br>其中，Gray表示灰度值，R、G、B表示红、绿、蓝颜色值，0.299、0.587、0.114表示灰度公式的固定值。</p>
<p>下面使用NumPy结合Matplotlib实现图像的灰度处理，程序代码如下：</p>
<p><img src="/.com//image-20211026175446668.png" alt="image-20211026175446668"></p>
<p>上述代码，显示灰度图时，需要在imshow()函数中设置参数cmap=”gray”。<br>运行程序，对比效果如图8.33和图8.34所示。</p>
<p><img src="/.com//image-20211026175502299.png" alt="image-20211026175502299"></p>
<p>​                                                                                                    图8.33　原图</p>
<p><img src="/.com//image-20211026175527183.png" alt="image-20211026175527183"></p>
<p>​                                                                                                          图8.34　灰度图像</p>
<h1 id="8-7-小结"><a href="#8-7-小结" class="headerlink" title="8.7　小结"></a>8.7　小结</h1><p>通过本章的学习，能够掌握NumPy的常用操作，即从数组创建到数组的基本操作和运算。对于数据统计分析来说，这些内容已经足够了；而对于人工智能、机器学习，还需要更加深入地学习NumPy相关知识。另外，当数据量非常大时，NumPy可以带来百倍以上的速度提升。</p>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
  </entry>
  <entry>
    <title>浏览器渲染原理</title>
    <url>/2019/12/25/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="一、浏览器如何渲染网页"><a href="#一、浏览器如何渲染网页" class="headerlink" title="一、浏览器如何渲染网页"></a>一、浏览器如何渲染网页</h2><p><strong>概述：浏览器渲染一共有五步</strong></p>
<ol>
<li>处理 <code>HTML</code> 并构建 <code>DOM</code> 树。</li>
<li>处理 <code>CSS</code>构建 <code>CSSOM</code> 树。</li>
<li>将 <code>DOM</code> 与 <code>CSSOM</code> 合并成一个渲染树。</li>
<li>根据渲染树来布局，计算每个节点的位置。</li>
<li>调用 <code>GPU</code> 绘制，合成图层，显示在屏幕上</li>
</ol>
<blockquote>
<p>第四步和第五步是最耗时的部分，这两步合起来，就是我们通常所说的渲染</p>
</blockquote>
<p>具体如下图过程如下图所示</p>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/19.png" alt="img"></p>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/20.png" alt="img"></p>
<p><strong>渲染</strong></p>
<ul>
<li>网页生成的时候，至少会渲染一次</li>
<li>在用户访问的过程中，还会不断重新渲染</li>
</ul>
<blockquote>
<p>重新渲染需要重复之前的第四步(重新生成布局)+第五步(重新绘制)或者只有第五个步(重新绘制)</p>
</blockquote>
<ul>
<li>在构建 <code>CSSOM</code> 树时，会阻塞渲染，直至 <code>CSSOM</code>树构建完成。并且构建 <code>CSSOM</code> 树是一个十分消耗性能的过程，所以应该尽量保证层级扁平，减少过度层叠，越是具体的 <code>CSS</code> 选择器，执行速度越慢</li>
<li>当 <code>HTML</code> 解析到 <code>script</code> 标签时，会暂停构建 <code>DOM</code>，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 <code>JS</code> 文件。并且<code>CSS</code>也会影响 <code>JS</code> 的执行，只有当解析完样式表才会执行 <code>JS</code>，所以也可以认为这种情况下，<code>CSS</code> 也会暂停构建 <code>DOM</code></li>
</ul>
<h2 id="二、浏览器渲染五个阶段"><a href="#二、浏览器渲染五个阶段" class="headerlink" title="二、浏览器渲染五个阶段"></a>二、浏览器渲染五个阶段</h2><h3 id="2-1-第一步：解析HTML标签，构建DOM树"><a href="#2-1-第一步：解析HTML标签，构建DOM树" class="headerlink" title="2.1 第一步：解析HTML标签，构建DOM树"></a>2.1 第一步：解析HTML标签，构建DOM树</h3><blockquote>
<p>在这个阶段，引擎开始解析<code>html</code>，解析出来的结果会成为一棵<code>dom</code>树<br><code>dom</code>的目的至少有<code>2</code>个</p>
</blockquote>
<ul>
<li>作为下个阶段渲染树状图的输入</li>
<li>成为网页和脚本的交互界面。(最常用的就是<code>getElementById</code>等等)</li>
</ul>
<p><strong>当解析器到达script标签的时候，发生下面四件事情</strong></p>
<ol>
<li><code>html</code>解析器停止解析,</li>
<li>如果是外部脚本，就从外部网络获取脚本代码</li>
<li>将控制权交给<code>js</code>引擎，执行<code>js</code>代码</li>
<li>恢复<code>html</code>解析器的控制权</li>
</ol>
<blockquote>
<p>由此可以得到第一个结论1</p>
</blockquote>
<ul>
<li>由于``标签是阻塞解析的，将脚本放在网页尾部会加速代码渲染。</li>
<li><code>defer</code>和<code>async</code>属性也能有助于加载外部脚本。</li>
<li><code>defer</code>使得脚本会在<code>dom</code>完整构建之后执行；</li>
<li><code>async</code>标签使得脚本只有在完全<code>available</code>才执行，并且是以非阻塞的方式进行的</li>
</ul>
<h3 id="2-2-第二步：解析CSS标签，构建CSSOM树"><a href="#2-2-第二步：解析CSS标签，构建CSSOM树" class="headerlink" title="2.2 第二步：解析CSS标签，构建CSSOM树"></a>2.2 第二步：解析CSS标签，构建CSSOM树</h3><ul>
<li>我们已经看到<code>html</code>解析器碰到脚本后会做的事情，接下来我们看下<code>html</code>解析器碰到样式表会发生的情况</li>
<li><code>js</code>会阻塞解析，因为它会修改文档(<code>document</code>)。<code>css</code>不会修改文档的结构，如果这样的话，似乎看起来<code>css</code>样式不会阻塞浏览器<code>html</code>解析。但是事实上 <code>css</code>样式表是阻塞的。阻塞是指当<code>cssom</code>树建立好之后才会进行下一步的解析渲染</li>
</ul>
<p><strong>通过以下手段可以减轻cssom带来的影响</strong></p>
<ul>
<li>将<code>script</code>脚本放在页面底部</li>
<li>尽可能快的加载<code>css</code>样式表</li>
<li>将样式表按照<code>media type</code>和<code>media query</code>区分，这样有助于我们将<code>css</code>资源标记成非阻塞渲染的资源。</li>
<li>非阻塞的资源还是会被浏览器下载，只是优先级较低</li>
</ul>
<h3 id="2-3-第三步：把DOM和CSSOM组合成渲染树（render-tree）"><a href="#2-3-第三步：把DOM和CSSOM组合成渲染树（render-tree）" class="headerlink" title="2.3 第三步：把DOM和CSSOM组合成渲染树（render tree）"></a>2.3 第三步：把DOM和CSSOM组合成渲染树（render tree）</h3><p><img src="https://poetries1.gitee.io/img-repo/2019/10/21.png" alt="img"></p>
<h3 id="2-4-第四步：在渲染树的基础上进行布局，计算每个节点的几何结构"><a href="#2-4-第四步：在渲染树的基础上进行布局，计算每个节点的几何结构" class="headerlink" title="2.4 第四步：在渲染树的基础上进行布局，计算每个节点的几何结构"></a>2.4 第四步：在渲染树的基础上进行布局，计算每个节点的几何结构</h3><blockquote>
<p>布局(<code>layout</code>)：定位坐标和大小，是否换行，各种<code>position</code>, <code>overflow</code>, <code>z-index</code>属性</p>
</blockquote>
<h3 id="2-5-调用-GPU-绘制，合成图层，显示在屏幕上"><a href="#2-5-调用-GPU-绘制，合成图层，显示在屏幕上" class="headerlink" title="2.5 调用 GPU 绘制，合成图层，显示在屏幕上"></a>2.5 调用 GPU 绘制，合成图层，显示在屏幕上</h3><blockquote>
<p>将渲染树的各个节点绘制到屏幕上，这一步被称为绘制<code>painting</code></p>
</blockquote>
<h2 id="三、渲染优化相关"><a href="#三、渲染优化相关" class="headerlink" title="三、渲染优化相关"></a>三、渲染优化相关</h2><h3 id="3-1-Load-和-DOMContentLoaded-区别"><a href="#3-1-Load-和-DOMContentLoaded-区别" class="headerlink" title="3.1 Load 和 DOMContentLoaded 区别"></a>3.1 Load 和 DOMContentLoaded 区别</h3><ul>
<li><code>Load</code> 事件触发代表页面中的 <code>DOM</code>，<code>CSS</code>，<code>JS</code>，图片已经全部加载完毕。</li>
<li><code>DOMContentLoaded</code> 事件触发代表初始的 <code>HTML</code> 被完全加载和解析，不需要等待 <code>CSS</code>，<code>JS</code>，图片加载</li>
</ul>
<h3 id="3-2-图层"><a href="#3-2-图层" class="headerlink" title="3.2 图层"></a>3.2 图层</h3><blockquote>
<p>一般来说，可以把普通文档流看成一个图层。特定的属性可以生成一个新的图层。不同的图层渲染互不影响，所以对于某些频繁需要渲染的建议单独生成一个新图层，提高性能。但也不能生成过多的图层，会引起反作用。</p>
</blockquote>
<p><strong>通过以下几个常用属性可以生成新图层</strong></p>
<ul>
<li><code>3D</code> 变换：<code>translate3d</code>、<code>translateZ</code></li>
<li><code>will-change</code></li>
<li><code>video</code>、<code>iframe</code> 标签</li>
<li>通过动画实现的 <code>opacity</code> 动画转换</li>
<li><code>position: fixed</code></li>
</ul>
<h3 id="3-3-重绘（Repaint）和回流（Reflow）"><a href="#3-3-重绘（Repaint）和回流（Reflow）" class="headerlink" title="3.3 重绘（Repaint）和回流（Reflow）"></a>3.3 重绘（Repaint）和回流（Reflow）</h3><blockquote>
<p>重绘和回流是渲染步骤中的一小节，但是这两个步骤对于性能影响很大</p>
</blockquote>
<ul>
<li>重绘是当节点需要更改外观而不会影响布局的，比如改变 <code>color</code> 就叫称为重绘</li>
<li>回流是布局或者几何属性需要改变就称为回流。</li>
</ul>
<blockquote>
<p>回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变深层次的节点很可能导致父节点的一系列回流</p>
</blockquote>
<p><strong>以下几个动作可能会导致性能问题</strong></p>
<ul>
<li>改变 <code>window</code> 大小</li>
<li>改变字体</li>
<li>添加或删除样式</li>
<li>文字改变</li>
<li>定位或者浮动</li>
<li>盒模型</li>
</ul>
<p><strong>很多人不知道的是，重绘和回流其实和 Event loop 有关</strong></p>
<ul>
<li>当 <code>Event loop</code> 执行完<code>Microtasks</code> 后，会判断 <code>document</code> 是否需要更新。因为浏览器是 <code>60Hz</code> 的刷新率，每 <code>16ms</code> 才会更新一次。</li>
<li>然后判断是否有 <code>resize</code> 或者 <code>scroll</code> ，有的话会去触发事件，所以 <code>resize</code> 和 <code>scroll</code> 事件也是至少 <code>16ms</code>才会触发一次，并且自带节流功能。</li>
<li>判断是否触发了 <code>media query</code></li>
<li>更新动画并且发送事件</li>
<li>判断是否有全屏操作事件</li>
<li>执行 <code>requestAnimationFrame</code> 回调</li>
<li>执行 <code>IntersectionObserver</code> 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好</li>
<li>更新界面</li>
<li>以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 <code>requestIdleCallback</code> 回调</li>
</ul>
<p><strong>常见的引起重绘的属性</strong></p>
<ul>
<li><code>color</code></li>
<li><code>border-style</code></li>
<li><code>visibility</code></li>
<li><code>background</code></li>
<li><code>text-decoration</code></li>
<li><code>background-image</code></li>
<li><code>background-position</code></li>
<li><code>background-repeat</code></li>
<li><code>outline-color</code></li>
<li><code>outline</code></li>
<li><code>outline-style</code></li>
<li><code>border-radius</code></li>
<li><code>outline-width</code></li>
<li><code>box-shadow</code></li>
<li><code>background-size</code></li>
</ul>
<h3 id="3-4-常见引起回流属性和方法"><a href="#3-4-常见引起回流属性和方法" class="headerlink" title="3.4 常见引起回流属性和方法"></a>3.4 常见引起回流属性和方法</h3><blockquote>
<p>任何会改变元素几何信息(元素的位置和尺寸大小)的操作，都会触发重排，下面列一些栗子</p>
</blockquote>
<ul>
<li>添加或者删除可见的<code>DOM</code>元素；</li>
<li>元素尺寸改变——边距、填充、边框、宽度和高度</li>
<li>内容变化，比如用户在<code>input</code>框中输入文字</li>
<li>浏览器窗口尺寸改变——<code>resize</code>事件发生时</li>
<li>计算 <code>offsetWidth</code> 和 <code>offsetHeight</code> 属性</li>
<li>设置 <code>style</code> 属性的值</li>
</ul>
<p><strong>回流影响的范围</strong></p>
<blockquote>
<p>由于浏览器渲染界面是基于流失布局模型的，所以触发重排时会对周围DOM重新排列，影响的范围有两种</p>
</blockquote>
<ul>
<li>全局范围：从根节点<code>html</code>开始对整个渲染树进行重新布局。</li>
<li>局部范围：对渲染树的某部分或某一个渲染对象进行重新布局</li>
</ul>
<p><strong>全局范围回流</strong></p>
<pre><code>&lt;body&gt;
  &lt;div class=&quot;hello&quot;&gt;
    &lt;h4&gt;hello&lt;/h4&gt;
    &lt;p&gt;&lt;strong&gt;Name:&lt;/strong&gt;BDing&lt;/p&gt;
    &lt;h5&gt;male&lt;/h5&gt;
    &lt;ol&gt;
      &lt;li&gt;coding&lt;/li&gt;
      &lt;li&gt;loving&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/div&gt;
&lt;/body&gt;
</code></pre>
<blockquote>
<p>当<code>p</code>节点上发生<code>reflow</code>时，<code>hello</code>和<code>body</code>也会重新渲染，甚至<code>h5</code>和<code>ol</code>都会收到影响</p>
</blockquote>
<p><strong>局部范围回流</strong></p>
<blockquote>
<p>用局部布局来解释这种现象：把一个<code>dom</code>的宽高之类的几何信息定死，然后在<code>dom</code>内部触发重排，就只会重新渲染该<code>dom</code>内部的元素，而不会影响到外界</p>
</blockquote>
<h3 id="3-5-减少重绘和回流"><a href="#3-5-减少重绘和回流" class="headerlink" title="3.5 减少重绘和回流"></a>3.5 减少重绘和回流</h3><blockquote>
<p>使用 <code>translate</code> 替代 <code>top</code></p>
</blockquote>
<pre><code>&lt;div class=&quot;test&quot;&gt;&lt;/div&gt;
&lt;style&gt;
    .test &#123;
        position: absolute;
        top: 10px;
        width: 100px;
        height: 100px;
        background: red;
    &#125;
&lt;/style&gt;
&lt;script&gt;
    setTimeout(() =&gt; &#123;
        // 引起回流
        document.querySelector(&#39;.test&#39;).style.top = &#39;100px&#39;
    &#125;, 1000)
&lt;/script&gt;
</code></pre>
<ul>
<li>使用 <code>visibility</code> 替换 <code>display: none</code> ，因为前者只会引起重绘，后者会引发回流（改变了布局）</li>
<li>把 <code>DOM</code> 离线后修改，比如：先把 <code>DOM</code> 给 <code>display:none</code> (有一次 <code>Reflow)</code>，然后你修改<code>100</code>次，然后再把它显示出来</li>
<li>不要把 <code>DOM</code> 结点的属性值放在一个循环里当成循环里的变量</li>
</ul>
<pre><code>for(let i = 0; i &lt; 1000; i++) &#123;
    // 获取 offsetTop 会导致回流，因为需要去获取正确的值
    console.log(document.querySelector(&#39;.test&#39;).style.offsetTop)
&#125;
</code></pre>
<ul>
<li>不要使用 <code>table</code> 布局，可能很小的一个小改动会造成整个 <code>table</code> 的重新布局</li>
<li>动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 <code>requestAnimationFrame</code></li>
<li><code>CSS</code>选择符从右往左匹配查找，避免 <code>DOM</code>深度过深</li>
<li>将频繁运行的动画变为图层，图层能够阻止该节点回流影响别的元素。比如对于 <code>video</code>标签，浏览器会自动将该节点变为图层。</li>
</ul>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/22.png" alt="img"></p>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/23.png" alt="img"></p>
<blockquote>
<p><a href="http://blog.poetries.top/2018/01/12/fed-performance-optimization/#%E5%85%AD%E3%80%81%E9%87%8D%E7%BB%98%E4%B8%8E%E5%9B%9E%E6%B5%81">重绘与回流</a></p>
</blockquote>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>深浅拷贝</title>
    <url>/2021/04/27/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<h2 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h2><h2 id="深浅拷贝都只针对于引用数据类型"><a href="#深浅拷贝都只针对于引用数据类型" class="headerlink" title="深浅拷贝都只针对于引用数据类型"></a>深浅拷贝都只针对于引用数据类型</h2><ul>
<li>浅拷贝<ul>
<li>只复制指向对象的指针，而不复制对象本身，新旧对象还是共享一个内存；</li>
</ul>
</li>
<li>深拷贝<ul>
<li>另外创建一个一模一样的对象，新对象跟源对象不共享内存，修改新对象不会影响到源对象</li>
</ul>
</li>
</ul>
<h2 id="1、深拷贝与浅拷贝的区别"><a href="#1、深拷贝与浅拷贝的区别" class="headerlink" title="1、深拷贝与浅拷贝的区别"></a>1、深拷贝与浅拷贝的区别</h2><p>如何区分深拷贝与浅拷贝，简单点来说，就是假设B复制了A，当修改A时，看B是否会发生变化，如果B也跟着变了，说明这是浅拷贝；如果B没变，那就是深拷贝。</p>
<h2 id="2、栈堆、基本数据类型、引用数据类型"><a href="#2、栈堆、基本数据类型、引用数据类型" class="headerlink" title="2、栈堆、基本数据类型、引用数据类型"></a>2、栈堆、基本数据类型、引用数据类型</h2><p>栈堆：存放数据的地方</p>
<p>基本数据类型：number，string，boolean，null，undefined</p>
<p>引用数据类型：function，Array，object</p>
<p>tips：基本数据类型保存在栈内存，引用类型保存在堆内存中。根本原因在于保存在栈内存的必须是大小固定的数据，引用类型的大小不固定，只能保存在堆内存中，但是可以把它的地址写在栈内存中以供我们访问。 </p>
<h2 id="3、浅拷贝"><a href="#3、浅拷贝" class="headerlink" title="3、浅拷贝"></a>3、浅拷贝</h2><p>浅拷贝指的就是仅拷贝对象的地址，这样会使被拷贝的对象会因为拷贝的对象的数据改变而改变 </p>
<pre><code class="js">&lt;script&gt;
    let a = [1,2,3];
    let b = a;
    console.log(&#39;添加元素前的 a=&#39; + a);
    console.log(&#39;添加元素前的 b=&#39; + b);
    b.push(4)
    console.log(&#39;添加元素后的 a=&#39; + a);
    console.log(&#39;添加元素后的 b=&#39; + b);
&lt;/script&gt;
</code></pre>
<p><img src="/.com//2.png"><br><img src="/.com//3.png"><br>如上图，b拷贝a就是浅拷贝，b拷贝的仅是a的地址，当b改变时其实就是堆里面的数据改变了，因为a的地址指向的也是这个堆，所以a的内容也改变了。</p>
<h2 id="4、深拷贝"><a href="#4、深拷贝" class="headerlink" title="4、深拷贝"></a>4、深拷贝</h2><p><strong>深拷贝是指拷贝一个对象的数据之前先给拷贝的对象创建一个堆地址，这样当拷贝的对象指向的堆中的数据改变时，被拷贝的对象堆中的数据并不会被改变（意思就是a，b指向不同的堆）</strong></p>
<pre><code class="js">&lt;script&gt;
    let a = [1,2,3];
    let b = [];
    for(let j = 0; j &lt; a.length; j++)&#123;
        b.push(a[j]);
    &#125; 
    console.log(&#39;添加元素前的 a=&#39; + a);
    console.log(&#39;添加元素前的 b=&#39; + b);
    b.push(4)
    console.log(&#39;添加元素后的 a=&#39; + a);
    console.log(&#39;添加元素后的 b=&#39; + b);
&lt;/script&gt;
</code></pre>
<p><img src="/.com//4.png"><br>（2）深拷贝方法二</p>
<pre><code class="js">&lt;script&gt;
    let a = [1,2,3];
    let b = [...a];
    console.log(&#39;添加元素前的 a=&#39; + a);
    console.log(&#39;添加元素前的 b=&#39; + b);
    b.push(4)
    console.log(&#39;添加元素后的 a=&#39; + a);
    console.log(&#39;添加元素后的 b=&#39; + b);
&lt;/script&gt;
</code></pre>
<p><img src="/.com//5.png"><br><img src="/.com//6.png"></p>
<h2 id="5、JS中拷贝Array的slice和concat方法"><a href="#5、JS中拷贝Array的slice和concat方法" class="headerlink" title="5、JS中拷贝Array的slice和concat方法"></a>5、JS中拷贝Array的slice和concat方法</h2><h3 id="5-1-slice拷贝"><a href="#5-1-slice拷贝" class="headerlink" title="5.1 slice拷贝"></a>5.1 slice拷贝</h3><pre><code class="js">&lt;script&gt;
    let a = [1,2,3];
    let b = a.slice();
    console.log(a===b);
    console.log(&#39;添加元素前的 a=&#39; + a);
    console.log(&#39;添加元素前的 b=&#39; + b);
    b.push(4)
    console.log(&#39;添加元素后的 a=&#39; + a);
    console.log(&#39;添加元素后的 b=&#39; + b);
&lt;/script&gt;
</code></pre>
<p><img src="/.com//7.png"></p>
<h3 id="5-2-concat拷贝"><a href="#5-2-concat拷贝" class="headerlink" title="5.2 concat拷贝"></a>5.2 concat拷贝</h3><pre><code class="js">&lt;script&gt;
    let a = [1,2,3];
    let b = a.concat();
    console.log(a===b);
    console.log(&#39;添加元素前的 a=&#39; + a);
    console.log(&#39;添加元素前的 b=&#39; + b);
    b.push(4)
    console.log(&#39;添加元素后的 a=&#39; + a);
    console.log(&#39;添加元素后的 b=&#39; + b);
&lt;/script&gt;
</code></pre>
<p><img src="/.com//8.png"><br>看到结果，如果你觉得，这两个方法是深拷贝，那就恭喜你跳进了坑里！<br>来看看有意思的例子吧</p>
<pre><code class="js">var a = [[1,2,3],4,5];
var b = a.slice();
console.log(a === b);
a[0][0] = 6;
console.log(a);
console.log(b);
</code></pre>
<p><img src="/.com//9.png"></p>
<p>可以看到slice和contact对于第一层是深拷贝，但对于多层的时候，是复制的引用，所以是浅拷贝</p>
<h2 id="6、JSON对象的parse和stringify都是深拷贝"><a href="#6、JSON对象的parse和stringify都是深拷贝" class="headerlink" title="6、JSON对象的parse和stringify都是深拷贝"></a>6、JSON对象的parse和stringify都是深拷贝</h2><pre><code class="js">&lt;script&gt;
    let obj = &#123;name:&#39;cancan&#39;,age:23,company : &#123; name : &#39;阿里&#39;, address : &#39;杭州&#39;&#125; &#125;;
    let obj_json = JSON.parse(JSON.stringify(obj));
    console.log(obj === obj_json);
    obj.company.name = &quot;cancan82&quot;;
    obj.name = &quot;haha&quot;;
    console.log(obj);
    console.log(obj_json);
&lt;/script&gt;
</code></pre>
<p><img src="/.com//10.png"></p>
<h2 id="浅拷贝实现方法"><a href="#浅拷贝实现方法" class="headerlink" title="浅拷贝实现方法"></a>浅拷贝实现方法</h2><pre><code class="js">1.Object.assign方法
var obj = &#123;
    a:1,
    b:2
&#125;
var obj1 = Object.assign(&#123;&#125;,obj)
obj1.a = 3:
console.log(obj.a) // 3


2.解构赋值
var obj1 = &#123;a: 1, b: 2&#125;
var obj2 = &#123;...obj1&#125;
obj2.a = 4
console.log(obj1, obj2)
</code></pre>
<h2 id="深拷贝实现方法"><a href="#深拷贝实现方法" class="headerlink" title="深拷贝实现方法"></a>深拷贝实现方法</h2><pre><code class="js">1.json.stringify()方法

var obj1 = [&#123;
    name: &#39;臧三&#39;,
    childs: [&#39;小明&#39;, &#39;小芳&#39;]
&#125;]
var obj2 = JSON.parse(JSON.stringify(obj1))
obj2[0].childs = []
console.log(obj1, obj2)


2.递归方法

var obj1 = [&#123;
    name: &#39;臧三&#39;,
    childs: [&#39;小明&#39;, &#39;小芳&#39;],
    fn: function() &#123;&#125;,
    age: undefined
&#125;]

var obj2 = extend(obj1)
obj2[0].childs = []
console.log(obj1, obj2)

function extend(data) &#123;
    if (typeof data === &#39;object&#39; &amp;&amp; data) &#123;
        let val = typeof data.length === &#39;number&#39; ? [] : &#123;&#125;
        for(let i in data) &#123;
            val[i] = extend(data[i])
        &#125;
        return val
    &#125; else &#123;
        return data
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>深浅拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器缓存原理</title>
    <url>/2019/12/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="一、浏览器缓存基本认识"><a href="#一、浏览器缓存基本认识" class="headerlink" title="一、浏览器缓存基本认识"></a>一、浏览器缓存基本认识</h1><p><strong>分为强缓存和协商缓存</strong></p>
<ol>
<li>浏览器在加载资源时，先根据这个资源的一些<code>http header</code>判断它是否命中强缓存，强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器。比如某个<code>css</code>文件，如果浏览器在加载它所在的网页时，这个<code>css</code>文件的缓存配置命中了强缓存，浏览器就直接从缓存中加载这个<code>css</code>，连请求都不会发送到网页所在服务器</li>
<li>当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，通过服务器端依据资源的另外一些<code>http header</code>验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源，于是浏览器就又会从自己的缓存中去加载这个资源</li>
<li><strong>强缓存与协商缓存的共同点是</strong>：如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据；区别是：<strong>强缓存不发请求到服务器</strong>，协商缓存会发请求到服务器</li>
<li>当协商缓存也没有命中的时候，浏览器直接从服务器加载资源数据</li>
</ol>
<h1 id="二、强缓存的原理"><a href="#二、强缓存的原理" class="headerlink" title="二、强缓存的原理"></a>二、强缓存的原理</h1><h2 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h2><blockquote>
<p>当浏览器对某个资源的请求命中了强缓存时，返回的<code>http</code>状态为<code>200</code>，在<code>chrome</code>的开发者工具的<code>network</code>里面<code>size</code>会显示为<code>from cache</code>，比如京东的首页里就有很多静态资源配置了强缓存，用<code>chrome</code>打开几次，再用<code>f12</code>查看<code>network</code>，可以看到有不少请求就是从缓存中加载的</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/1.png" alt="img"></p>
<ul>
<li>强缓存是利用<code>Expires</code>或者<code>Cache-Control</code>这两个<code>http response header</code>实现的，它们都用来表示资源在客户端缓存的有效期。</li>
</ul>
<blockquote>
<pre><code>Expires`是`http1.0`提出的一个表示资源过期时间的`header`，它描述的是一个绝对时间，由服务器返回，用`GMT`格式的字符串表示，如：`Expires:Thu, 31 Dec 2037 23:55:55 GMT
</code></pre>
</blockquote>
<h2 id="2-2-Expires缓存原理"><a href="#2-2-Expires缓存原理" class="headerlink" title="2.2 Expires缓存原理"></a>2.2 Expires缓存原理</h2><ol>
<li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在<code>respone</code>的<code>header</code>加上<code>Expires</code>，如</li>
</ol>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/2.png" alt="img"></p>
<ol>
<li>浏览器在接收到这个资源后，会把这个资源连同所有<code>response header</code>一起缓存下来（所以缓存命中的请求返回的<code>header</code>并不是来自服务器，而是来自之前缓存的<code>header</code>）</li>
<li>浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，拿出它的<code>Expires</code>跟当前的请求时间比较，如果请求时间在<code>Expires</code>指定的时间之前，就能命中缓存，否则就不行</li>
<li>如果缓存没有命中，浏览器直接从服务器加载资源时，<code>Expires Header</code>在重新加载的时候会被更新</li>
</ol>
<blockquote>
<pre><code>Expires`是较老的强缓存管理`header`，由于它是服务器返回的一个绝对时间，在服务器时间与客户端时间相差较大时，缓存管理容易出现问题，比如随意修改下客户端时间，就能影响缓存命中的结果。所以在`http1.1`的时候，提出了一个新的`header`，就是`Cache-Control`，这是一个相对时间，在配置缓存的时候，以秒为单位，用数值表示，如：`Cache-Control:max-age=315360000
</code></pre>
</blockquote>
<h2 id="2-3-Cache-Control缓存原理"><a href="#2-3-Cache-Control缓存原理" class="headerlink" title="2.3 Cache-Control缓存原理"></a>2.3 Cache-Control缓存原理</h2><ol>
<li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在<code>respone</code>的<code>header</code>加上<code>Cache-Control</code>，如：</li>
</ol>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/3.png" alt="img"></p>
<ol>
<li>浏览器在接收到这个资源后，会把这个资源连同所有<code>response header</code>一起缓存下来</li>
<li>浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和<code>Cache-Control</code>设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行</li>
<li>如果缓存没有命中，浏览器直接从服务器加载资源时，<code>Cache-Control Header</code>在重新加载的时候会被更新</li>
</ol>
<ul>
<li><code>Cache-Control</code>描述的是一个相对时间，在进行缓存命中的时候，都是利用客户端时间进行判断，所以相比较<code>Expires</code>，<code>Cache-Control</code>的缓存管理更有效，安全一些。</li>
<li>这两个<code>header</code>可以只启用一个，也可以同时启用，当<code>response header</code>中，<code>Expires</code>和<code>Cache-Control</code>同时存在时，<code>Cache-Control</code>优先级高于<code>Expires</code>：</li>
</ul>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/4.png" alt="img"></p>
<h1 id="三、强缓存的管理"><a href="#三、强缓存的管理" class="headerlink" title="三、强缓存的管理"></a>三、强缓存的管理</h1><blockquote>
<p>前面介绍的是强缓存的原理，在实际应用中我们会碰到需要强缓存的场景和不需要强缓存的场景，通常有2种方式来设置是否启用强缓存</p>
</blockquote>
<ol>
<li>通过代码的方式，在<code>web</code>服务器返回的响应中添加<code>Expires</code>和<code>Cache-Control Header</code></li>
<li>通过配置<code>web</code>服务器的方式，让<code>web</code>服务器在响应资源的时候统一添加<code>Expires</code>和<code>Cache-Control Header</code></li>
</ol>
<blockquote>
<p>比如在javaweb里面，我们可以使用类似下面的代码设置强缓存</p>
</blockquote>
<pre><code>java.util.Date date = new java.util.Date();    
response.setDateHeader(&quot;Expires&quot;,date.getTime()+20000); //Expires:过时期限值 
response.setHeader(&quot;Cache-Control&quot;, &quot;public&quot;); //Cache-Control来控制页面的缓存与否,public:浏览器和缓存服务器都可以缓存页面信息；
response.setHeader(&quot;Pragma&quot;, &quot;Pragma&quot;); //Pragma:设置页面是否缓存，为Pragma则缓存，no-cache则不缓存
</code></pre>
<blockquote>
<p>还可以通过类似下面的<code>java</code>代码设置不启用强缓存</p>
</blockquote>
<pre><code>response.setHeader( &quot;Pragma&quot;, &quot;no-cache&quot; );   
response.setDateHeader(&quot;Expires&quot;, 0);   
response.addHeader( &quot;Cache-Control&quot;, &quot;no-cache&quot; );//浏览器和缓存服务器都不应该缓存页面信息
</code></pre>
<ul>
<li><code>nginx</code>和<code>apache</code>作为专业的<code>web</code>服务器，都有专门的配置文件，可以配置<code>expires</code>和<code>cache-control</code>，这方面的知识，如果你对运维感兴趣的话，可以在百度上搜索<code>nginx</code> 设置 <code>expires cache-control</code>或 <code>apache 设置 expires cache-control</code> 都能找到不少相关的文章。</li>
<li>由于在开发的时候不会专门去配置强缓存，而浏览器又默认会缓存图片，<code>css</code>和<code>js</code>等静态资源，所以开发环境下经常会因为强缓存导致资源没有及时更新而看不到最新的效果，解决这个问题的方法有很多，常用的有以下几种</li>
</ul>
<p><strong>处理缓存带来的问题</strong></p>
<ol>
<li>直接<code>ctrl+f5</code>，这个办法能解决页面直接引用的资源更新的问题</li>
<li>使用浏览器的隐私模式开发</li>
<li>如果用的是<code>chrome</code>，可以<code>f12</code>在<code>network</code>那里把缓存给禁掉（这是个非常有效的方法）</li>
</ol>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/5.png" alt="img"></p>
<ol>
<li>在开发阶段，给资源加上一个动态的参数，如<code>css/index.css?v=0.0001</code>，由于每次资源的修改都要更新引用的位置，同时修改参数的值，所以操作起来不是很方便，除非你是在动态页面比如jsp里开发就可以用服务器变量来解决（<code>v=$&#123;sysRnd&#125;</code>），或者你能用一些前端的构建工具来处理这个参数修改的问题</li>
<li>如果资源引用的页面，被嵌入到了一个<code>iframe</code>里面，可以在<code>iframe</code>的区域右键单击重新加载该页面，以<code>chrome</code>为例</li>
</ol>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/6.png" alt="img"></p>
<ol>
<li>如果缓存问题出现在<code>ajax</code>请求中，最有效的解决办法就是<code>ajax</code>的请求地址追加随机数</li>
<li>还有一种情况就是动态设置<code>iframe</code>的<code>src</code>时，有可能也会因为缓存问题，导致看不到最新的效果，这时候在要设置的<code>src</code>后面添加随机数也能解决问题</li>
<li>如果你用的是<code>grunt</code>和<code>gulp</code>、<code>webpack</code>这种前端工具开发，通过它们的插件比如<code>grunt-contrib-connect</code>来启动一个静态服务器，则完全不用担心开发阶段的资源更新问题，因为在这个静态服务器下的所有资源返回的<code>respone header</code>中，<code>cache-control</code>始终被设置为不缓存</li>
</ol>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/7.png" alt="img"></p>
<h1 id="四、强缓存的应用"><a href="#四、强缓存的应用" class="headerlink" title="四、强缓存的应用"></a>四、强缓存的应用</h1><blockquote>
<p>强缓存是前端性能优化最有力的工具，没有之一，对于有大量静态资源的网页，一定要利用强缓存，提高响应速度。通常的做法是，为这些静态资源全部配置一个超时时间超长的<code>Expires</code>或<code>Cache-Control</code>，这样用户在访问网页时，只会在第一次加载时从服务器请求静态资源，其它时候只要缓存没有失效并且用户没有强制刷新的条件下都会从自己的缓存中加载，比如前面提到过的京东首页缓存的资源，它的缓存过期时间都设置到了<code>2026</code>年</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/8.png" alt="img"></p>
<blockquote>
<p>然而这种缓存配置方式会带来一个新的问题，就是发布时资源更新的问题，比如某一张图片，在用户访问第一个版本的时候已经缓存到了用户的电脑上，当网站发布新版本，替换了这个图片时，已经访问过第一个版本的用户由于缓存的设置，导致在默认的情况下不会请求服务器最新的图片资源，除非他清掉或禁用缓存或者强制刷新，否则就看不到最新的图片效果</p>
</blockquote>
<p>这个问题已经有成熟的解决方案，具体内容可阅读知乎这篇文章详细了解：<a href="http://www.zhihu.com/question/20790576">http://www.zhihu.com/question/20790576</a></p>
<p>文章提到的东西都属于理论上的解决方案，不过现在已经有很多前端工具能够实际地解决这个问题，由于每个工具涉及到的内容细节都有很多，本文没有办法一一深入介绍。有兴趣的可以去了解下<code>grunt</code> <code>gulp</code> <code>webpack</code> <code>fis</code>还有edp这几个工具，基于这几个工具都能解决这个问题，尤其是<code>fis</code>和<code>edp</code>是百度推出的前端开发平台，有现成的文档可以参考：</p>
<p><a href="http://fis.baidu.com/fis3/api/index.html">http://fis.baidu.com/fis3/api/index.html</a></p>
<p><a href="http://ecomfe.github.io/edp/doc/initialization/install/">http://ecomfe.github.io/edp/doc/initialization/install/</a></p>
<blockquote>
<p>强缓存还有一点需要注意的是，通常都是针对静态资源使用，动态资源需要慎用，除了服务端页面可以看作动态资源外，那些引用静态资源的<code>html</code>也可以看作是动态资源，如果这种<code>html</code>也被缓存，当这些<code>html</code>更新之后，可能就没有机制能够通知浏览器这些html有更新，尤其是前后端分离的应用里，页面都是纯<code>html</code>页面，每个访问地址可能都是直接访问<code>html</code>页面，这些页面通常不加强缓存，以保证浏览器访问这些页面时始终请求服务器最新的资源</p>
</blockquote>
<h1 id="五、协商缓存的原理"><a href="#五、协商缓存的原理" class="headerlink" title="五、协商缓存的原理"></a>五、协商缓存的原理</h1><h2 id="5-1-介绍"><a href="#5-1-介绍" class="headerlink" title="5.1 介绍"></a>5.1 介绍</h2><blockquote>
<p>当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的<code>http</code>状态为<code>304</code>并且会显示一个<code>Not Modified</code>的字符串，比如你打开京东的首页，按<code>f12</code>打开开发者工具，再按<code>f5</code>刷新页面，查看<code>network</code>，可以看到有不少请求就是命中了协商缓存的</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/9.png" alt="img"></p>
<blockquote>
<p>查看单个请求的<code>Response Header</code>，也能看到<code>304</code>的状态码和<code>Not Modified</code>的字符串，只要看到这个就可说明这个资源是命中了协商缓存，然后从客户端缓存中加载的，而不是服务器最新的资源</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/10.png" alt="img"></p>
<h2 id="5-2-Last-Modified，If-Modified-Since控制协商缓存"><a href="#5-2-Last-Modified，If-Modified-Since控制协商缓存" class="headerlink" title="5.2 Last-Modified，If-Modified-Since控制协商缓存"></a>5.2 Last-Modified，If-Modified-Since控制协商缓存</h2><ol>
<li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在<code>respone</code>的<code>header</code>加上<code>Last-Modified</code>的<code>header</code>，这个<code>header</code>表示这个资源在服务器上的最后修改时间</li>
</ol>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/11.png" alt="img"></p>
<ol>
<li>浏览器再次跟服务器请求这个资源时，在<code>request</code>的<code>header</code>上加上<code>If-Modified-Since</code>的<code>header</code>，这个<code>header</code>的值就是上一次请求时返回的<code>Last-Modified</code>的值</li>
</ol>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/12.png" alt="img"></p>
<ol>
<li>服务器再次收到资源请求时，根据浏览器传过来<code>If-Modified-Since</code>和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回<code>304 Not Modified</code>，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回<code>304 Not Modified</code>的响应时，<code>response header</code>中不会再添加<code>Last-Modified</code>的<code>header</code>，因为既然资源没有变化，那么<code>Last-Modified</code>也就不会改变，这是服务器返回<code>304</code>时的<code>response header</code></li>
</ol>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/13.png" alt="img"></p>
<ol>
<li>浏览器收到<code>304</code>的响应后，就会从缓存中加载资源</li>
<li>如果协商缓存没有命中，浏览器直接从服务器加载资源时，<code>Last-Modified</code> <code>Header</code>在重新加载的时候会被更新，下次请求时，<code>If-Modified-Since</code>会启用上次返回的<code>Last-Modified</code>值</li>
</ol>
<blockquote>
<p>【<code>Last-Modified</code>，<code>If-Modified-Since</code>】都是根据服务器时间返回的<code>header</code>，一般来说，在没有调整服务器时间和篡改客户端缓存的情况下，这两个<code>header</code>配合起来管理协商缓存是非常可靠的，但是有时候也会服务器上资源其实有变化，但是最后修改时间却没有变化的情况，而这种问题又很不容易被定位出来，而当这种情况出现的时候，就会影响协商缓存的可靠性。所以就有了另外一对<code>header</code>来管理协商缓存，这对<code>header</code>就是【<code>ETag</code>、<code>If-None-Match</code>】。它们的缓存管理的方式是</p>
</blockquote>
<h2 id="5-3-ETag、If-None-Match控制协商缓存"><a href="#5-3-ETag、If-None-Match控制协商缓存" class="headerlink" title="5.3 ETag、If-None-Match控制协商缓存"></a>5.3 ETag、If-None-Match控制协商缓存</h2><ol>
<li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在<code>respone</code>的<code>header</code>加上<code>ETag</code>的<code>header</code>，这个<code>header</code>是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，只要资源有变化这个串就不同，跟最后修改时间没有关系，所以能很好的补充<code>Last-Modified</code>的问题</li>
</ol>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/14.png" alt="img"></p>
<ol>
<li>浏览器再次跟服务器请求这个资源时，在<code>request</code>的<code>header</code>上加上<code>If-None-Match</code>的<code>header</code>，这个<code>header</code>的值就是上一次请求时返回的<code>ETag</code>的值</li>
</ol>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/15.png" alt="img"></p>
<ol>
<li>服务器再次收到资源请求时，根据浏览器传过来<code>If-None-Match</code>和然后再根据资源生成一个新的<code>ETag</code>，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回<code>304 Not Modified</code>，但是不会返回资源内容；如果有变化，就正常返回资源内容。与<code>Last-Modified</code>不一样的是，当服务器返回<code>304 Not Modified</code>的响应时，由于<code>ETag</code>重新生成过，<code>response header</code>中还会把这个<code>ETag</code>返回，即使这个<code>ETag</code>跟之前的没有变化</li>
</ol>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/16.png" alt="img"></p>
<ol>
<li>浏览器收到<code>304</code>的响应后，就会从缓存中加载资源。</li>
</ol>
<h1 id="六、协商缓存的管理"><a href="#六、协商缓存的管理" class="headerlink" title="六、协商缓存的管理"></a>六、协商缓存的管理</h1><blockquote>
<p>协商缓存跟强缓存不一样，强缓存不发请求到服务器，所以有时候资源更新了浏览器还不知道，但是协商缓存会发请求到服务器，所以资源是否更新，服务器肯定知道。大部分<code>web</code>服务器都默认开启协商缓存，而且是同时启用【<code>Last-Modified</code>，<code>If-Modified-Since</code>】和【<code>ETag</code>、<code>If-None-Match</code>】，比如<code>apache</code>:</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/17.png" alt="img"></p>
<blockquote>
<p>如果没有协商缓存，每个到服务器的请求，就都得返回资源内容，这样服务器的性能会极差。</p>
</blockquote>
<ul>
<li>【<code>Last-Modified</code>，<code>If-Modified-Since</code>】和【<code>ETag</code>、<code>If-None-Match</code>】一般都是同时启用，这是为了处理<code>Last-Modified</code>不可靠的情况。</li>
</ul>
<p><strong>有一种场景需要注意</strong></p>
<ul>
<li>分布式系统里多台机器间文件的<code>Last-Modified</code>必须保持一致，以免负载均衡到不同机器导致比对失败；</li>
<li>分布式系统尽量关闭掉<code>ETag</code>(每台机器生成的<code>ETag</code>都会不一样）；</li>
<li>京东页面的资源请求，返回的<code>repsones header</code>就只有<code>Last-Modified</code>，没有<code>ETag</code>：</li>
</ul>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/18.png" alt="img"></p>
<blockquote>
<p>协商缓存需要配合强缓存使用，你看前面这个截图中，除了<code>Last-Modified</code>这个<code>header</code>，还有强缓存的相关<code>header</code>，因为如果不启用强缓存的话，协商缓存根本没有意义</p>
</blockquote>
<h1 id="七、相关浏览器行为对缓存的影响"><a href="#七、相关浏览器行为对缓存的影响" class="headerlink" title="七、相关浏览器行为对缓存的影响"></a>七、相关浏览器行为对缓存的影响</h1><blockquote>
<p>如果资源已经被浏览器缓存下来，在缓存失效之前，再次请求时，默认会先检查是否命中强缓存，如果强缓存命中则直接读取缓存，如果强缓存没有命中则发请求到服务器检查是否命中协商缓存，如果协商缓存命中，则告诉浏览器还是可以从缓存读取，否则才从服务器返回最新的资源。这是默认的处理方式，这个方式可能被浏览器的行为改变：</p>
</blockquote>
<ul>
<li>当<code>ctrl+f5</code>强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；</li>
<li>当<code>f5</code>刷新网页时，跳过强缓存，但是会检查协商缓存</li>
</ul>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>Loader和Plugin的不同？</title>
    <url>/2022/04/27/webpack/Loader%E5%92%8CPlugin%E7%9A%84%E4%B8%8D%E5%90%8C%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="Loader和Plugin的不同？"><a href="#Loader和Plugin的不同？" class="headerlink" title="Loader和Plugin的不同？"></a>Loader和Plugin的不同？</h2><p><strong>不同的作用</strong><br>● Loader直译为”加载器”。Webpack将一切文件视为模块，但是webpack原生是只能解析js文件，如果想将其他文件也打包的话，就会用到loader。 所以Loader的作用是让webpack拥有了加载和解析非JavaScript文件的能力。<br>● Plugin直译为”插件”。Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。<br><strong>不同的用法</strong></p>
<ol>
<li>Loader在module.rules中配置，也就是说他作为模块的解析规则而存在。 类型为数组，每一项都是一个Object，里面描述了对于什么类型的文件（test），使用什么加载(loader)和使用的参数（options）</li>
<li>Plugin在plugins中单独配置。 类型为数组，每一项是一个plugin的实例，参数都通过构造函数传入。</li>
</ol>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>防抖节流</title>
    <url>/2022/04/27/%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<p><strong>防抖</strong></p>
<blockquote>
<p>在事件被触发的n秒后再执行回调,如果这n秒又被触发，则重新计时.高频操作下，只执行最后一次.</p>
</blockquote>
<pre><code class="js">    &lt;script&gt;
        // 防抖  用户触发事件过于频繁
        let inp = document.getElementsByTagName(&#39;input&#39;)
        inp[0].oninput = deco(function () &#123;
            console.log(this.value)
        &#125;, 500)

        function deco(fn, time) &#123;
            let t = null;
            return function () &#123;
                if (t) &#123;
                    clearTimeout(t)
                &#125;
                t = setTimeout(() =&gt; &#123;
                    fn.call(this)
                &#125;, time)
            &#125;
        &#125;
    &lt;/script&gt;
</code></pre>
<p><strong>节流</strong></p>
<blockquote>
<p>一定时间内 控制触发的次数</p>
</blockquote>
<pre><code class="js">&lt;script&gt;
  window.onscroll = fn(function () &#123;
        console.log(1111111)
    &#125;, 500)

    function fn(fn1, time) &#123;
        let flag = true;
        return function () &#123;
            if (flag) &#123;
                setTimeout(() =&gt; &#123;
                    fn1.call(this)
                    flag = true
                &#125;, time)
            &#125;
            flag = false;
        &#125;
    &#125;
&lt;/script&gt;
</code></pre>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>防抖节流</tag>
      </tags>
  </entry>
</search>
