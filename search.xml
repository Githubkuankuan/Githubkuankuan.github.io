<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JavaScript-es7、8</title>
    <url>/2021/11/26/JavaScript-es7%E3%80%818/</url>
    <content><![CDATA[<h1 id="ECMASript-7-新特性"><a href="#ECMASript-7-新特性" class="headerlink" title="ECMASript 7 新特性"></a>ECMASript 7 新特性</h1><h2 id="Array-prototype-includes"><a href="#Array-prototype-includes" class="headerlink" title="Array.prototype.includes"></a>Array.prototype.includes</h2><blockquote>
<p> includes 方法用来检测数组中是否包含某个元素，返回布尔类型值</p>
</blockquote>
<pre><code class="javascript">&lt;script&gt;
    // includes   indexOf
    // const mingzhu = [&#39;西游记&#39;,&#39;红楼梦&#39;,&#39;三国演义&#39;,&#39;水浒传&#39;];

    //判断
    // console.log(mingzhu.includes(&#39;西游记&#39;));
    // console.log(mingzhu.includes(&#39;金瓶梅&#39;));    
&lt;/script&gt;
</code></pre>
<h2 id="指数操作符"><a href="#指数操作符" class="headerlink" title="指数操作符"></a>指数操作符</h2><blockquote>
<p>在 ES7 中引入指数运算符「**」，用来实现幂运算，功能与 Math.pow 结果相同</p>
</blockquote>
<pre><code class="javascript">// **
console.log(2 ** 10);// 
console.log(Math.pow(2, 10));
</code></pre>
<h1 id="ECMASript-8-新特性"><a href="#ECMASript-8-新特性" class="headerlink" title="ECMASript 8 新特性"></a>ECMASript 8 新特性</h1><h2 id="async-和-await"><a href="#async-和-await" class="headerlink" title="async 和 await"></a>async 和 await</h2><h3 id="async-函数"><a href="#async-函数" class="headerlink" title="async 函数"></a>async 函数</h3><blockquote>
<ol>
<li><p>async 函数的返回值为 promise 对象， </p>
</li>
<li><p>promise 对象的结果由 async 函数执行的返回值决定</p>
</li>
</ol>
</blockquote>
<pre><code class="javascript">&lt;script&gt;
    //async 函数
    async function fn()&#123;
        // 返回一个字符串
        // return &#39;尚硅谷&#39;;
        // 返回的结果不是一个 Promise 类型的对象, 返回的结果就是成功 Promise 对象
        // return;
        //抛出错误, 返回的结果是一个失败的 Promise
        // throw new Error(&#39;出错啦!&#39;);
        //返回的结果如果是一个 Promise 对象
        return new Promise((resolve, reject)=&gt;&#123;
            resolve(&#39;成功的数据&#39;);
            // reject(&quot;失败的错误&quot;);
        &#125;);
    &#125;

    const result = fn();

    //调用 then 方法
    result.then(value =&gt; &#123;
        console.log(value);
    &#125;, reason =&gt; &#123;
        console.warn(reason);
    &#125;)
&lt;/script&gt;
</code></pre>
<h3 id="await-表达式"><a href="#await-表达式" class="headerlink" title="await 表达式"></a>await 表达式</h3><blockquote>
<ol>
<li>await 必须写在 async 函数中</li>
<li>await 右侧的表达式一般为 promise 对象 </li>
<li> await 返回的是 promise 成功的值 </li>
<li>await 的 promise 失败了, 就会抛出异常, 需要通过 try…catch 捕获处理</li>
</ol>
</blockquote>
<pre><code class="javascript">&lt;script&gt;
    //创建 promise 对象
    const p = new Promise((resolve, reject) =&gt; &#123;
        // resolve(&quot;用户数据&quot;);
        reject(&quot;失败啦!&quot;);
    &#125;)

    // await 要放在 async 函数中.
    async function main() &#123;
        try &#123;
            let result = await p;
            //
            console.log(result);
        &#125; catch (e) &#123;
            console.log(e);
        &#125;
    &#125;
    //调用函数
    main();
&lt;/script&gt;
</code></pre>
<h3 id="async和await结合读取文件"><a href="#async和await结合读取文件" class="headerlink" title="async和await结合读取文件"></a>async和await结合读取文件</h3><pre><code class="javascript">//1. 引入 fs 模块
const fs = require(&quot;fs&quot;);

//读取『为学』
function readWeiXue() &#123;
    return new Promise((resolve, reject) =&gt; &#123;
        fs.readFile(&quot;./resources/为学.md&quot;, (err, data) =&gt; &#123;
            //如果失败
            if (err) reject(err);
            //如果成功
            resolve(data);
        &#125;)
    &#125;)
&#125;

function readChaYangShi() &#123;
    return new Promise((resolve, reject) =&gt; &#123;
        fs.readFile(&quot;./resources/插秧诗.md&quot;, (err, data) =&gt; &#123;
            //如果失败
            if (err) reject(err);
            //如果成功
            resolve(data);
        &#125;)
    &#125;)
&#125;

function readGuanShu() &#123;
    return new Promise((resolve, reject) =&gt; &#123;
        fs.readFile(&quot;./resources/观书有感.md&quot;, (err, data) =&gt; &#123;
            //如果失败
            if (err) reject(err);
            //如果成功
            resolve(data);
        &#125;)
    &#125;)
&#125;

//声明一个 async 函数
async function main()&#123;
    //获取为学内容
    let weixue = await readWeiXue();
    //获取插秧诗内容
    let chayang = await readChaYangShi();
    // 获取观书有感
    let guanshu = await readGuanShu();

    console.log(weixue.toString());
    console.log(chayang.toString());
    console.log(guanshu.toString());
&#125;

main();
</code></pre>
<h3 id="async与await封装AJAX请求"><a href="#async与await封装AJAX请求" class="headerlink" title="async与await封装AJAX请求"></a>async与await封装AJAX请求</h3><pre><code class="javascript">&lt;script&gt;
    // 发送 AJAX 请求, 返回的结果是 Promise 对象
    function sendAJAX(url) &#123;
        return new Promise((resolve, reject) =&gt; &#123;
            //1. 创建对象
            const x = new XMLHttpRequest();

            //2. 初始化
            x.open(&#39;GET&#39;, url);

            //3. 发送
            x.send();

            //4. 事件绑定
            x.onreadystatechange = function () &#123;
                if (x.readyState === 4) &#123;
                    if (x.status &gt;= 200 &amp;&amp; x.status &lt; 300) &#123;
                        //成功啦
                        resolve(x.response);
                    &#125;else&#123;
                        //如果失败
                        reject(x.status);
                    &#125;
                &#125;
            &#125;
        &#125;)
    &#125;

    //promise then 方法测试
    // sendAJAX(&quot;https://api.apiopen.top/getJoke&quot;).then(value=&gt;&#123;
    //     console.log(value);
    // &#125;, reason=&gt;&#123;&#125;)

    // async 与 await 测试  axios
    async function main()&#123;
        //发送 AJAX 请求
        let result = await sendAJAX(&quot;https://api.apiopen.top/getJoke&quot;);
        //再次测试
        let tianqi = await sendAJAX(&#39;https://www.tianqiapi.com/api/?version=v1&amp;city=%E5%8C%97%E4%BA%AC&amp;appid=23941491&amp;appsecret=TXoD5e8P&#39;)

        console.log(tianqi);
    &#125;

    main();
    
&lt;/script&gt;
</code></pre>
<h3 id="对象方法扩展"><a href="#对象方法扩展" class="headerlink" title="对象方法扩展"></a>对象方法扩展</h3><h4 id="Object-values-和-Object-entries"><a href="#Object-values-和-Object-entries" class="headerlink" title="Object.values 和 Object.entries"></a>Object.values 和 Object.entries</h4><blockquote>
<ol>
<li>Object.values()方法返回一个给定对象的所有可枚举属性值的数组</li>
<li>Object.entries()方法返回一个给定对象自身可遍历属性 [key,value] 的数组</li>
</ol>
</blockquote>
<h4 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors"></a>Object.getOwnPropertyDescriptors</h4><blockquote>
<p>该方法返回指定对象所有自身属性的描述对象</p>
</blockquote>
<pre><code>&lt;script&gt;
    //声明对象
    const school = &#123;
        name:&quot;恋爱学院&quot;,
        cities:[&#39;北京&#39;,&#39;上海&#39;,&#39;深圳&#39;],
        xueke: [&#39;前端&#39;,&#39;Java&#39;,&#39;大数据&#39;,&#39;运维&#39;]
    &#125;;

    //获取对象所有的键
    // console.log(Object.keys(school));
    //获取对象所有的值
    // console.log(Object.values(school));
    //entries
    // console.log(Object.entries(school));
    //创建 Map
    // const m = new Map(Object.entries(school));
    // console.log(m.get(&#39;cities&#39;));

    //对象属性的描述对象
    // console.log(Object.getOwnPropertyDescriptors(school));

    // const obj = Object.create(null, &#123;
    //     name: &#123;
    //         //设置值
    //         value: &#39;恋爱学院&#39;,
    //         //属性特性
    //         writable: true,
    //         configurable: true,
    //         enumerable: true
    //     &#125; 
    // &#125;);
&lt;/script&gt;
</code></pre>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>es7、es8</tag>
      </tags>
  </entry>
  <entry>
    <title>Django filter中用contains和icontains区别</title>
    <url>/2021/11/24/Django-filter%E4%B8%AD%E7%94%A8contains%E5%92%8Cicontains%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>用 django 的人经常会用到filter过滤集合的功能，这里对比下contains和icontains区别：</p>
<pre><code class="python">queryset.filter(name__contains=&quot;e&quot;)
queryset.filter(name__icontains=&quot;e&quot;)
</code></pre>
<p>打印一下这两行代码对应的sql语句就会看到区别：</p>
<pre><code class="python">&#39;contains&#39;: &#39;LIKE BINARY %s&#39;,
&#39;icontains&#39;: &#39;LIKE %s&#39;,
</code></pre>
<p>这其中的BINARY到底代表什么意思呢，答案是 <strong>精确大小写</strong><br>而’icontains’中的’i’表示<strong>忽略大小写</strong></p>
<p>这其中的BINARY到底代表什么意思呢，答案是 <strong>精确大小写</strong><br>而’icontains’中的’i’表示<strong>忽略大小写</strong></p>
<p>举例：</p>
<pre><code>select * from plant where name like BINARY &#39;%e%&#39;;
2   eee

select * from plant where name like &#39;%e%&#39;;
1   Ezs
2   eee
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>JavaScript-es9、10、11</title>
    <url>/2021/11/26/JavaScript-es9%E3%80%8110%E3%80%8111/</url>
    <content><![CDATA[<h1 id="ECMASript-9-新特性"><a href="#ECMASript-9-新特性" class="headerlink" title="ECMASript 9 新特性"></a>ECMASript 9 新特性</h1><h2 id="Rest-Spread-属性"><a href="#Rest-Spread-属性" class="headerlink" title="Rest/Spread 属性"></a>Rest/Spread 属性</h2><blockquote>
<p>Rest 参数与 spread 扩展运算符在 ES6 中已经引入，不过 ES6 中只针对于数组， 在 ES9 中为对象提供了像数组一样的 rest 参数和扩展运算符</p>
</blockquote>
<pre><code class="javascript">&lt;!-- 
    Rest 参数与 spread 扩展运算符在 ES6 中已经引入，不过 ES6 中只针对于数组，
    在 ES9 中为对象提供了像数组一样的 rest 参数和扩展运算符
    --&gt;
&lt;script&gt;
    //rest 参数
    function connect(&#123;host, port, ...user&#125;)&#123;
        console.log(host);
        console.log(port);
        console.log(user);
    &#125;

    connect(&#123;
        host: &#39;127.0.0.1&#39;,
        port: 3306,
        username: &#39;root&#39;,
        password: &#39;root&#39;,
        type: &#39;master&#39;
    &#125;);


    //对象合并
    const skillOne = &#123;
        q: &#39;天音波&#39;
    &#125;

    const skillTwo = &#123;
        w: &#39;金钟罩&#39;
    &#125;

    const skillThree = &#123;
        e: &#39;天雷破&#39;
    &#125;
    const skillFour = &#123;
        r: &#39;猛龙摆尾&#39;
    &#125;

    const mangseng = &#123;...skillOne, ...skillTwo, ...skillThree, ...skillFour&#125;;

    console.log(mangseng)

    // ...skillOne   =&gt;  q: &#39;天音波&#39;, w: &#39;金钟罩&#39;

&lt;/script&gt;
</code></pre>
<h2 id="正则表达式命名捕获组"><a href="#正则表达式命名捕获组" class="headerlink" title="正则表达式命名捕获组"></a>正则表达式命名捕获组</h2><blockquote>
<p>ES9 允许命名捕获组使用符号『?』,这样获取捕获结果可读性更强</p>
</blockquote>
<pre><code class="javascript">&lt;script&gt;
    //声明一个字符串
    // let str = &#39;&lt;a href=&quot;https://kuankuan.xyz/&quot;&gt;宽宽博客&lt;/a&gt;&#39;;

    // //提取 url 与 『标签文本』
    // const reg = /&lt;a href=&quot;(.*)&quot;&gt;(.*)&lt;\/a&gt;/;

    // //执行
    // const result = reg.exec(str);

    // console.log(result);
    // // console.log(result[1]);
    // // console.log(result[2]);

    
    let str = &#39;&lt;a href=&quot;https://kuankuan.xyz/&quot;&gt;宽宽博客&lt;/a&gt;&#39;;
    //分组命名
    const reg = /&lt;a href=&quot;(?&lt;url&gt;.*)&quot;&gt;(?&lt;text&gt;.*)&lt;\/a&gt;/;

    const result = reg.exec(str);

    console.log(result.groups.url);

    console.log(result.groups.text);
&lt;/script&gt;
</code></pre>
<h2 id="正则表达式反向断言"><a href="#正则表达式反向断言" class="headerlink" title="正则表达式反向断言"></a>正则表达式反向断言</h2><blockquote>
<p>ES9 支持反向断言，通过对匹配结果前面的内容进行判断，对匹配进行筛选。</p>
</blockquote>
<pre><code class="javascript">&lt;script&gt;
    //声明字符串
    let str = &#39;JS5211314你知道么555啦啦啦&#39;;
    //正向断言
    const reg = /\d+(?=啦)/;
    const result = reg.exec(str);

    //反向断言
    const reg = /(?&lt;=么)\d+/;
    const result = reg.exec(str);
    console.log(result);
&lt;/script&gt;
</code></pre>
<h2 id="正则表达式-dotAll-模式"><a href="#正则表达式-dotAll-模式" class="headerlink" title="正则表达式 dotAll 模式"></a>正则表达式 dotAll 模式</h2><blockquote>
<p>正则表达式中点.匹配除回车外的任何单字符，标记『s』改变这种行为，允许行 终止符出现</p>
</blockquote>
<pre><code class="javascript">&lt;script&gt;
    //dot  .  元字符  除换行符以外的任意单个字符
    let str = `
    &lt;ul&gt;
        &lt;li&gt;
            &lt;a&gt;肖生克的救赎&lt;/a&gt;
            &lt;p&gt;上映日期: 1994-09-10&lt;/p&gt;
        &lt;/li&gt;
        &lt;li&gt;
            &lt;a&gt;阿甘正传&lt;/a&gt;
            &lt;p&gt;上映日期: 1994-07-06&lt;/p&gt;
        &lt;/li&gt;
    &lt;/ul&gt;`;
    //声明正则
    // const reg = /&lt;li&gt;\s+&lt;a&gt;(.*?)&lt;\/a&gt;\s+&lt;p&gt;(.*?)&lt;\/p&gt;/;
    const reg = /&lt;li&gt;.*?&lt;a&gt;(.*?)&lt;\/a&gt;.*?&lt;p&gt;(.*?)&lt;\/p&gt;/gs;
    //执行匹配
    // const result = reg.exec(str);
    let result;
    let data = [];
    while(result = reg.exec(str))&#123;
        data.push(&#123;title: result[1], time: result[2]&#125;);
    &#125;
    //输出结果
    console.log(data);
&lt;/script&gt;
</code></pre>
<h1 id="ECMASript-10-新特性"><a href="#ECMASript-10-新特性" class="headerlink" title="ECMASript 10 新特性"></a>ECMASript 10 新特性</h1><h2 id="1-Object-fromEntries"><a href="#1-Object-fromEntries" class="headerlink" title="1-Object.fromEntries"></a>1-Object.fromEntries</h2><pre><code class="javascript">&lt;script&gt;
    //二维数组
    // const result = Object.fromEntries([
    //     [&#39;name&#39;,&#39;恋爱学院&#39;],
    //     [&#39;xueke&#39;, &#39;Java,大数据,前端,云计算&#39;]
    // ]);

    //Map
    // const m = new Map();
    // m.set(&#39;name&#39;,&#39;ATGUIGU&#39;);
    // const result = Object.fromEntries(m);

    //Object.entries ES8
    const arr = Object.entries(&#123;
        name: &quot;恋爱学院&quot;
    &#125;)
    console.log(arr);
&lt;/script&gt;
</code></pre>
<h2 id="2-trimStart与trimEnd"><a href="#2-trimStart与trimEnd" class="headerlink" title="2-trimStart与trimEnd"></a>2-trimStart与trimEnd</h2><pre><code class="javascript">&lt;script&gt;    
    // trim
    let str = &#39;   iloveyou   &#39;;

    console.log(str);
    console.log(str.trimStart());
    console.log(str.trimEnd());
&lt;/script&gt;
</code></pre>
<h2 id="3-Array-prototype-flat与flatMap"><a href="#3-Array-prototype-flat与flatMap" class="headerlink" title="3-Array.prototype.flat与flatMap"></a>3-Array.prototype.flat与flatMap</h2><pre><code class="javascript">&lt;script&gt;
    //flat 平
    //将多维数组转化为低位数组
    // const arr = [1,2,3,4,[5,6]];
    // const arr = [1,2,3,4,[5,6,[7,8,9]]];
    //参数为深度 是一个数字
    // console.log(arr.flat(2));  

    //flatMap
    const arr = [1,2,3,4];
    const result = arr.flatMap(item =&gt; [item * 10]);
    console.log(result);
&lt;/script&gt;
</code></pre>
<h2 id="4-Symbol-prototype-description"><a href="#4-Symbol-prototype-description" class="headerlink" title="4-Symbol.prototype.description"></a>4-Symbol.prototype.description</h2><pre><code class="javascript">&lt;script&gt;
    //创建 Symbol
    let s = Symbol(&#39;恋爱学院&#39;);

    console.log(s.description);
&lt;/script&gt;
</code></pre>
<h1 id="ECMASript-11-新特性"><a href="#ECMASript-11-新特性" class="headerlink" title="ECMASript 11 新特性"></a>ECMASript 11 新特性</h1><h2 id="1-私有属性"><a href="#1-私有属性" class="headerlink" title="1-私有属性"></a>1-私有属性</h2><pre><code class="JavaScript">&lt;script&gt;
    class Person&#123;
        //公有属性
        name;
        //私有属性
        #age;
        #weight;
        //构造方法
        constructor(name, age, weight)&#123;
            this.name = name;
            this.#age = age;
            this.#weight = weight;
        &#125;

        intro()&#123;
            console.log(this.name);
            console.log(this.#age);
            console.log(this.#weight);
        &#125;
    &#125;

    //实例化
    const girl = new Person(&#39;晓红&#39;, 18, &#39;45kg&#39;);

    // console.log(girl.name);
    // console.log(girl.#age);
    // console.log(girl.#weight);

    girl.intro();
&lt;/script&gt;
</code></pre>
<h2 id="2-Promise-allSettled"><a href="#2-Promise-allSettled" class="headerlink" title="2-Promise.allSettled"></a>2-Promise.allSettled</h2><pre><code class="JavaScript">&lt;script&gt;
    //声明两个promise对象
    const p1 = new Promise((resolve, reject)=&gt;&#123;
        setTimeout(()=&gt;&#123;
            resolve(&#39;商品数据 - 1&#39;);
        &#125;,1000)
    &#125;);

    const p2 = new Promise((resolve, reject)=&gt;&#123;
        setTimeout(()=&gt;&#123;
            resolve(&#39;商品数据 - 2&#39;);
            // reject(&#39;出错啦!&#39;);
        &#125;,1000)
    &#125;);

    //调用 allsettled 方法
    // const result = Promise.allSettled([p1, p2]);
    
    // const res = Promise.all([p1, p2]);

    console.log(res);

&lt;/script&gt;
</code></pre>
<h2 id="3-String-prototype-matchAll"><a href="#3-String-prototype-matchAll" class="headerlink" title="3-String.prototype.matchAll"></a>3-String.prototype.matchAll</h2><pre><code class="JavaScript">&lt;script&gt;
    let str = `&lt;ul&gt;
        &lt;li&gt;
            &lt;a&gt;肖生克的救赎&lt;/a&gt;
            &lt;p&gt;上映日期: 1994-09-10&lt;/p&gt;
        &lt;/li&gt;
        &lt;li&gt;
            &lt;a&gt;阿甘正传&lt;/a&gt;
            &lt;p&gt;上映日期: 1994-07-06&lt;/p&gt;
        &lt;/li&gt;
    &lt;/ul&gt;`;

    //声明正则
    const reg = /&lt;li&gt;.*?&lt;a&gt;(.*?)&lt;\/a&gt;.*?&lt;p&gt;(.*?)&lt;\/p&gt;/sg

    //调用方法
    const result = str.matchAll(reg);

    // for(let v of result)&#123;
    //     console.log(v);
    // &#125;

    const arr = [...result];

    console.log(arr);    
&lt;/script&gt;
</code></pre>
<h2 id="4-可选链操作符"><a href="#4-可选链操作符" class="headerlink" title="4-可选链操作符"></a>4-可选链操作符</h2><pre><code class="JavaScript">&lt;script&gt;
    // ?.
    function main(config)&#123;
        // const dbHost = config &amp;&amp; config.db &amp;&amp; config.db.host;
        const dbHost = config?.db?.host;

        console.log(dbHost);
    &#125;

    main(&#123;
        db: &#123;
            host:&#39;192.168.1.100&#39;,
            username: &#39;root&#39;
        &#125;,
        cache: &#123;
            host: &#39;192.168.1.200&#39;,
            username:&#39;admin&#39;
        &#125;
    &#125;)
&lt;/script&gt;
</code></pre>
<h2 id="5-动态import加载"><a href="#5-动态import加载" class="headerlink" title="5-动态import加载"></a>5-动态import加载</h2><pre><code class="javascript">&lt;body&gt;
    &lt;button id=&quot;btn&quot;&gt;点击&lt;/button&gt;
    &lt;script src=&quot;./js/app.js&quot; type=&quot;module&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
</code></pre>
<pre><code class="javascript">// import * as m1 from &quot;./hello.js&quot;;
//获取元素
const btn = document.getElementById(&#39;btn&#39;);

btn.onclick = function()&#123;
    import(&#39;./hello.js&#39;).then(module =&gt; &#123;
        module.hello();
    &#125;);
&#125;
</code></pre>
<pre><code class="javascript">export function hello()&#123;
    alert(&#39;Hello&#39;);
&#125;
</code></pre>
<h2 id="6-BigInt"><a href="#6-BigInt" class="headerlink" title="6-BigInt"></a>6-BigInt</h2><pre><code class="JavaScript">&lt;script&gt;
    //大整形
    // let n = 521n;
    // console.log(n, typeof(n));

    //函数
    // let n = 123;
    // console.log(BigInt(n));
    // console.log(BigInt(1.2));

    //大数值运算
    let max = Number.MAX_SAFE_INTEGER;
    console.log(max);
    console.log(max + 1);
    console.log(max + 2);

    console.log(BigInt(max))
    console.log(BigInt(max) + BigInt(1))
    console.log(BigInt(max) + BigInt(2))
&lt;/script&gt;
</code></pre>
<h2 id="7-globalThis"><a href="#7-globalThis" class="headerlink" title="7-globalThis"></a>7-globalThis</h2><pre><code class="javascript">&lt;script&gt;
    console.log(globalThis);
&lt;/script&gt;
</code></pre>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>es9、es10、es11</tag>
      </tags>
  </entry>
  <entry>
    <title>if__name__==&#39;__main__&#39; 理解和总结</title>
    <url>/2021/11/24/if-name-main-%E7%90%86%E8%A7%A3%E5%92%8C%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h1><p>在Python当中，如果代码写得规范一些，通常会写上一句“if <strong>name</strong>==’<strong>main</strong>:”作为程序的入口，但似乎没有这么一句代码，程序也能正常运行。这句代码多余吗？原理又在哪里？本篇博文对此进行总结说明。</p>
<h1 id="二、程序入口"><a href="#二、程序入口" class="headerlink" title="二、程序入口"></a>二、程序入口</h1><p> 学过Java、C、C++的程序员应该都知道，每次开启一个程序，都必须写一个主函数作为程序的入口，也就是我们常说的main函数。如下所示， main()就是Java中的一个main函数。</p>
<pre><code class="java">public class HelloWorld &#123;

    public static void main(String[] args) &#123;

        System.out.println(&quot;HelloWorld&quot;);

    &#125;
&#125;    
</code></pre>
<p>与 Java、C、C++ 等几种语言不同的是，Python是一种解释型脚本语言，在执行之前不同要将所有代码先编译成中间代码，Python程序运行时是从模块顶行开始，逐行进行翻译执行，所以，最顶层（没有被缩进）的代码都会被执行，所以Python中并不需要一个统一的main()作为程序的入口。在某种意义上讲，“if <strong>name</strong>==’<strong>main</strong>:”也像是一个标志，象征着Java等语言中的程序主入口，告诉其他程序员，代码入口在此——这是“if <strong>name</strong>==’<strong>main</strong>:”这条代码的意义之一。</p>
<h1 id="三、模块引入"><a href="#三、模块引入" class="headerlink" title="三、模块引入"></a>三、模块引入</h1><p> 我们知道，当我们把模块A中的代码在模块B中进行import A时，只要B模块代码运行到该import语句，模块A的代码会被执行。</p>
<h4 id="模块A："><a href="#模块A：" class="headerlink" title="模块A："></a>模块A：</h4><pre><code class="python"># 模块A

a = 100

print(&#39;你好，我是模块A……&#39;)

print(a)
</code></pre>
<h4 id="模块B："><a href="#模块B：" class="headerlink" title="模块B："></a>模块B：</h4><pre><code class="python"># 模块B

from package01 import A

b = 200

print(&#39;你好，我是模块B……&#39;)

print(b)
</code></pre>
<p>运行模块B时，输出结果如下：</p>
<pre><code class="python">你好，我是模块A……

100

你好，我是模块B……

200
</code></pre>
<p>如果在模块A中，我们有部分的代码不想在被导入到B时直接被运行，但在直接运行A时可直接运行，那该怎么做呢？那就可以用到“if <strong>name</strong>==’<strong>main</strong>:”这行代码了，我们队上面用到的A模块代码进行修改：</p>
<h4 id="A模块代码修改为："><a href="#A模块代码修改为：" class="headerlink" title="A模块代码修改为："></a>A模块代码修改为：</h4><pre><code class="python"># 模块A

a = 100

print(&#39;你好，我是模块A……&#39;)

if __name__==&#39;__main__&#39;:

    print(a)
</code></pre>
<h4 id="B模块不做修改，直接执行B模块，输出结果如下："><a href="#B模块不做修改，直接执行B模块，输出结果如下：" class="headerlink" title="B模块不做修改，直接执行B模块，输出结果如下："></a>B模块不做修改，直接执行B模块，输出结果如下：</h4><pre><code class="python">你好，我是模块A……

你好，我是模块B……

200
</code></pre>
<p>看到了吗，A模块中的a的值就没有再被输出了。所以，当你要导入某个模块，但又不想改模块的部分代码被直接执行，那就可以这一部分代码放在“if <strong>name</strong>==’<strong>main</strong>‘:”内部。</p>
<h1 id="四、’name‘与“-main-”"><a href="#四、’name‘与“-main-”" class="headerlink" title="四、’name‘与“____main____”"></a>四、’<strong><strong>name</strong></strong>‘与“____main____”</h1><p>看到现在也许心中还是疑惑，为什么会这样，那么现在我们来说一说“if <strong>name</strong>==’<strong>main</strong>‘:”的原理。</p>
<p>“____name____”是Python的内置变量，用于指代当前模块。我们修改上面用到的A模块和B模块，在模块中分别输出模块的名称：</p>
<h4 id="模块A"><a href="#模块A" class="headerlink" title="模块A:"></a>模块A:</h4><pre><code class="python"># 模块A

print(&#39;你好，我是模块A……&#39;)

print(&#39;模块A中__name__的值：&#123;&#125;&#39;.format(__name__))

print(&#39;-------------------------&#39;)
</code></pre>
<h4 id="模块B：-1"><a href="#模块B：-1" class="headerlink" title="模块B："></a>模块B：</h4><pre><code class="python"># 模块B

from package01 import A

print(&#39;你好，我是模块B……&#39;)

print(&#39;模块B中__name__的值：&#123;&#125;&#39;.format(__name__))
</code></pre>
<h4 id="执行A模块时，输出结果："><a href="#执行A模块时，输出结果：" class="headerlink" title="执行A模块时，输出结果："></a>执行A模块时，输出结果：</h4><pre><code class="python">你好，我是模块A……

模块A中__name__的值：__main__

-------------------------

执行B模块时，输出结果：

你好，我是模块A……

模块A中__name__的值：package01.A

-------------------------

你好，我是模块B……

模块B中__name__的值：__main__
</code></pre>
<blockquote>
<p>发现神奇之处了吗？当哪个模块被直接执行时，该模块“____name____”的值就是“____main____”，当被导入另一模块时，“__name__”的值就是模块的真实名称。用一个类比来解释一下：记得小时候要轮流打算教室，轮到自己的时候（模块被直接执行的时候），我们会说今天是“我”（__main__）值日，称呼其他人时，我们就会直接喊他们的名字。所以，“__main__”就相当于当事人，或者说第一人称的“我”。</p>
</blockquote>
<blockquote>
<p>所以，当运行“if <strong>name</strong>==’<strong>main</strong>‘:”语句时，如果当前模块时被直接执行，__name__的值就是__main__，条件判断的结果为True，“if <strong>name</strong>==’<strong>main</strong>‘:”下面的代码块就会被执行。</p>
</blockquote>
<h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p>“if <strong>name</strong>==’<strong>main</strong>‘:”语句的用处与原理大概也讲清楚了，如果没说明白，或者是我没理解到位，请给我留言。另外多说一句，“if <strong>name</strong>==’<strong>main</strong>‘:”很多时候看似无用，但是，出于代码的规范性，还是有必要的。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/11/09/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;
</code></pre>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server
</code></pre>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate
</code></pre>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy
</code></pre>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>第一篇博客</title>
    <url>/2021/11/10/one/</url>
    <content><![CDATA[<h1 id="这是第一篇博客内容"><a href="#这是第一篇博客内容" class="headerlink" title="这是第一篇博客内容"></a>这是第一篇博客内容</h1><p>为什么会突然搭建一个自己博客呢？  好问题！<br>在  **B站 ** 上看到一个资深程序员的一篇博客内容: 说一个代码代码习惯良好的程序员都会有自己的博客<br>后来我信誓旦旦的开始了我的搭建之旅！<br>现在也是搭建完成了  因为一个项目，没有及时的发布一篇博客内容。<br>好了认识一个吧   我叫大路宽宽！</p>
]]></content>
  </entry>
  <entry>
    <title>javascript-es6</title>
    <url>/2021/11/26/javascript-es6/</url>
    <content><![CDATA[<h1 id="let-定义变量："><a href="#let-定义变量：" class="headerlink" title="let 定义变量："></a>let 定义变量：</h1><p>声明变量</p>
<pre><code class="javascript">let a;

let b,c,d;

let e = 100;

let f = 521, g = &#39;iloveyou&#39;, h = [];
</code></pre>
<ol>
<li>变量不能重复声明</li>
</ol>
<pre><code class="javascript">let star = &#39;罗志祥&#39;;
let star = &#39;小猪&#39;;
</code></pre>
<ol start="2">
<li>块儿级作用域  全局, 函数, eval</li>
</ol>
<pre><code class="javascript">if else while for 

&#123;
    let girl = &#39;周扬青&#39;;
&#125;

console.log(girl);
</code></pre>
<ol start="3">
<li>不存在变量提升</li>
</ol>
<pre><code class="javascript">console.log(song);

let song = &#39;恋爱达人&#39;;
</code></pre>
<ol start="4">
<li>不影响作用域链</li>
</ol>
<pre><code class="javascript">&#123;
    let school = &#39;恋爱学院&#39;;
    function fn()&#123;
        console.log(school);
    &#125;
    fn();
&#125;
</code></pre>
<blockquote>
<p>let 关键字用来声明变量，使用 let 声明的变量有几个特点：</p>
<pre><code>1) 不允许重复声明
2) 块儿级作用域
3) 不存在变量提升
4) 不影响作用域链
</code></pre>
</blockquote>
<h1 id="let-案例"><a href="#let-案例" class="headerlink" title="let 案例"></a>let 案例</h1><p>点击 DIV 换色</p>
<pre><code class="javascript">&lt;style&gt;

    .item &#123;

      width: 100px;

      height: 50px;

      border: solid 1px rgb(42, 156, 156);

      float: left;

      margin-right: 10px;

    &#125;

&lt;/style&gt;

&lt;html&gt;
    &lt;div class=&quot;container&quot;&gt;

    &lt;h2 class=&quot;page-header&quot;&gt;点击切换颜色&lt;/h2&gt;

        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;

        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;

        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;

      &lt;/div&gt;

&lt;script&gt;

    //获取div元素对象
    let items = document.getElementsByClassName(&#39;item&#39;);

    //遍历并绑定事件
    for(let i = 0;i&lt;items.length;i++)&#123;
        items[i].onclick = function()&#123;
        //修改当前元素的背景颜色
        // this.style.background = &#39;pink&#39;;
        items[i].style.background = &#39;pink&#39;;
    &#125;
&#125;

&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h1 id="const-定义常量"><a href="#const-定义常量" class="headerlink" title="const 定义常量"></a>const 定义常量</h1><pre><code class="javascript">//声明常量

const SCHOOL = &#39;恋爱学院&#39;;

//1. 一定要赋初始值

const A;

//2. 一般常量使用大写(潜规则)

const a = 100;

//3. 常量的值不能修改

SCHOOL = &#39;LIANAIXUEYUAN&#39;;

//4. 块儿级作用域

&#123;
    const PLAYER = &#39;UZI&#39;;
&#125;

console.log(PLAYER);

//5. 对于数组和对象的元素修改, 不算做对常量的修改, 不会报错

const TEAM = [&#39;UZI&#39;,&#39;MXLG&#39;,&#39;Ming&#39;,&#39;Letme&#39;];
TEAM.push(&#39;Meiko&#39;);
</code></pre>
<blockquote>
<p>const 关键字用来声明常量，const 声明有以下特点</p>
<pre><code>1) 声明必须赋初始值
2) 标识符一般为大写
3) 不允许重复声明
4) 值不允许修改
5) 块儿级作用域
</code></pre>
</blockquote>
<pre><code>  注意: 对象属性修改和数组元素变化不会出发 const 错误
  应用场景：声明对象类型使用 const，非对象类型声明选择 let
</code></pre>
<h1 id="变量解构赋值"><a href="#变量解构赋值" class="headerlink" title="变量解构赋值"></a>变量解构赋值</h1><pre><code class="javascript">//ES6 允许按照一定模式从数组和对象中提取值，对变量进行赋值，
//这被称为解构赋值。
//1. 数组的结构
const F4 = [&#39;小沈阳&#39;,&#39;刘能&#39;,&#39;赵四&#39;,&#39;宋小宝&#39;];
let [xiao, liu, zhao, song] = F4;
console.log(xiao);
console.log(liu);
console.log(zhao);
console.log(song);

//2. 对象的解构
const zhao = &#123;
    name: &#39;赵本山&#39;,
    age: &#39;不详&#39;,
    xiaopin: function()&#123;
        console.log(&quot;我可以演小品&quot;);
    &#125;
&#125;;

let &#123;name, age, xiaopin&#125; = zhao;
console.log(name);
console.log(age);
console.log(xiaopin);
xiaopin();

let &#123;xiaopin&#125; = zhao;
xiaopin();
</code></pre>
<blockquote>
<p>注意：频繁使用对象方法、数组元素，就可以使用解构赋值形式</p>
</blockquote>
<h1 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h1><blockquote>
<p>模板字符串（template string）是增强版的字符串，用反引号（`）标识，特点：</p>
<pre><code>1) 字符串中可以出现换行符
2) 可以使用 $&#123;xxx&#125; 形式输出变量
   注意：当遇到字符串与变量拼接的情况使用模板字符串
</code></pre>
</blockquote>
<pre><code class="javasciprt">// ES6 引入新的声明字符串的方式 『``』 &#39;&#39; &quot;&quot; 
//1. 声明
let str = `我也是一个字符串哦!`;
console.log(str, typeof str);

//2. 内容中可以直接出现换行符
let str = `&lt;ul&gt;
        &lt;li&gt;沈腾&lt;/li&gt;
        &lt;li&gt;玛丽&lt;/li&gt;
        &lt;li&gt;魏翔&lt;/li&gt;
        &lt;li&gt;艾伦&lt;/li&gt;
        &lt;/ul&gt;`;

//3. 变量拼接
let lovest = &#39;魏翔&#39;;
let out = `$&#123;lovest&#125;是我心目中最搞笑的演员!!`;
console.log(out);
</code></pre>
<h1 id="简化对象写法"><a href="#简化对象写法" class="headerlink" title="简化对象写法"></a>简化对象写法</h1><pre><code class="javascript">//ES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。
//这样的书写更加简洁
let name = &#39;恋爱学院&#39;;
let change = function()&#123;
    console.log(&#39;我们可以改变你!!&#39;);
&#125;

const school = &#123;
    name,
    change,
    improve()&#123;
    console.log(&quot;我们可以提高你的技能&quot;);
    &#125;
&#125;

console.log(school);
</code></pre>
<h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><pre><code class="javascript">// ES6 允许使用「箭头」（=&gt;）定义函数。
//声明一个函数
let fn = function() &#123;

&#125;
let fn = (a, b) =&gt; &#123;
    return a + b;
&#125;

//调用函数
let result = fn(1, 2);
console.log(result);


//1. this 是静态的. this 始终指向函数声明时所在作用域下的 this 的值
function getName() &#123;
    console.log(this.name);
&#125;
let getName2 = () =&gt; &#123;
    console.log(this.name);
&#125;

//设置 window 对象的 name 属性
window.name = &#39;恋爱学院&#39;;
const school = &#123;
    name: &quot;LIANAIXUEYUAN&quot;
&#125;

//直接调用
getName();
getName2();

//call 方法调用
getName.call(school);
getName2.call(school);

//2. 不能作为构造实例化对象
let Person = (name, age) =&gt; &#123;
    this.name = name;
    this.age = age;
    &#125;
let me = new Person(&#39;xiao&#39;, 30);
console.log(me);

//3. 不能使用 arguments 变量
let fn = () =&gt; &#123;
    console.log(arguments);
&#125;
fn(1, 2, 3);

//4. 箭头函数的简写
//1) 省略小括号, 当形参有且只有一个的时候
let add = n =&gt; &#123;
    return n + n;
&#125;
console.log(add(9));
//2) 省略花括号, 当代码体只有一条语句的时候, 此时 return 必须省略
// 而且语句的执行结果就是函数的返回值
let pow = n =&gt; n * n;

console.log(pow(8));
</code></pre>
<h1 id="箭头函数实践"><a href="#箭头函数实践" class="headerlink" title="箭头函数实践"></a>箭头函数实践</h1><pre><code class="javascript">&lt;style&gt;
    div &#123;
        width: 200px;
        height: 200px;
        background: #58a;
    &#125;
&lt;/style&gt;

&lt;html&gt;
    &lt;div id=&quot;ad&quot;&gt;&lt;/div&gt;    
&lt;/html&gt;
&lt;script&gt;
        //需求-1  点击 div 2s 后颜色变成『粉色』
        //获取元素
        let ad = document.getElementById(&#39;ad&#39;);
        //绑定事件
        ad.addEventListener(&quot;click&quot;, function() &#123;
            //保存 this 的值
            // let _this = this;
            //定时器
            setTimeout(() =&gt; &#123;
                //修改背景颜色 this
                // console.log(this);
                // _this.style.background = &#39;pink&#39;;
                this.style.background = &#39;pink&#39;;
            &#125;, 2000);
        &#125;);

        //需求-2  从数组中返回偶数的元素
        const arr = [1, 6, 9, 10, 100, 25];
        // const result = arr.filter(function(item)&#123;
        //     if(item % 2 === 0)&#123;
        //         return true;
        //     &#125;else&#123;
        //         return false;
        //     &#125;
        // &#125;);

        const result = arr.filter(item =&gt; item % 2 === 0);

        console.log(result);

        // 箭头函数适合与 this 无关的回调. 定时器, 数组的方法回调
        // 箭头函数不适合与 this 有关的回调.  事件回调, 对象的方法
    &lt;/script&gt;
</code></pre>
<h1 id="rest-参数"><a href="#rest-参数" class="headerlink" title="rest 参数"></a>rest 参数</h1><blockquote>
<p>ES6 引入 rest 参数，用于获取函数的实参，用来代替 arguments</p>
<p>注意：rest 参数非常适合不定个数参数函数的场景</p>
</blockquote>
<pre><code class="javascript">&lt;script&gt;
    // ES6 引入 rest 参数，用于获取函数的实参，用来代替 arguments
    // ES5 获取实参的方式
    function date() &#123;
        console.log(arguments);
    &#125;
    date(&#39;白芷&#39;, &#39;阿娇&#39;, &#39;思慧&#39;);

    // rest 参数
    function date(...args) &#123;
        console.log(args); // filter some every map 
    &#125;
    date(&#39;阿娇&#39;, &#39;柏芝&#39;, &#39;思慧&#39;);

    // rest 参数必须要放到参数最后
    function fn(a, b, ...args) &#123;
        console.log(a);
        console.log(b);
        console.log(args);
    &#125;
    fn(1, 2, 3, 4, 5, 6);
&lt;/script&gt;
</code></pre>
<h1 id="spread-扩展运算符"><a href="#spread-扩展运算符" class="headerlink" title="spread 扩展运算符"></a>spread 扩展运算符</h1><blockquote>
<p>扩展运算符（spread）也是三个点（…）。它好比 rest 参数的逆运算，将一 9 更多 Java –大数据 –前端 –python 人工智能资料下载，可访问百度：尚硅谷官网 个数组转为用逗号分隔的参数序列，对数组进行解包。</p>
</blockquote>
<pre><code class="javascript">&lt;script&gt;
    // 『...』 扩展运算符能将『数组』转换为逗号分隔的『参数序列』
    //声明一个数组 ...
    const tfboys = [&#39;易烊千玺&#39;,&#39;王源&#39;,&#39;王俊凯&#39;];
    // =&gt; &#39;易烊千玺&#39;,&#39;王源&#39;,&#39;王俊凯&#39;

    // 声明一个函数
    function chunwan()&#123;
        console.log(arguments);
    &#125;

    chunwan(...tfboys);// chunwan(&#39;易烊千玺&#39;,&#39;王源&#39;,&#39;王俊凯&#39;)
&lt;/script&gt;
</code></pre>
<h1 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h1><blockquote>
<p>ES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，是一种类似于字符串的数据类型。</p>
<p>Symbol 特点 </p>
<ol>
<li>Symbol 的值是唯一的，用来解决命名冲突的问题 </li>
<li>Symbol 值不能与其他数据进行运算 </li>
<li>Symbol 定义 的 对象属 性 不能 使 用 for…in 循 环遍 历 ，但 是可 以 使 用 Reflect.ownKeys 来获取对象的所有键名</li>
</ol>
</blockquote>
<pre><code class="javascript">&lt;script&gt;
    //创建Symbol
    let s = Symbol();
    // console.log(s, typeof s);
    let s2 = Symbol(&#39;恋爱学院&#39;);
    let s3 = Symbol(&#39;恋爱学院&#39;);
    //Symbol.for 创建
    let s4 = Symbol.for(&#39;恋爱学院&#39;);
    let s5 = Symbol.for(&#39;恋爱学院&#39;);

    //不能与其他数据进行运算
    //    let result = s + 100;
    //    let result = s &gt; 100;
    //    let result = s + s;

    // USONB  you are so niubility 
    // u  undefined
    // s  string  symbol
    // o  object
    // n  null number
    // b  boolean
&lt;/script&gt;
</code></pre>
<h1 id="Symbol创建对象属性"><a href="#Symbol创建对象属性" class="headerlink" title="Symbol创建对象属性"></a>Symbol创建对象属性</h1><pre><code class="javascript">&lt;script&gt;
    //向对象中添加方法 up down
    let game = &#123;
        name:&#39;俄罗斯方块&#39;,
        up: function()&#123;&#125;,
        down: function()&#123;&#125;
    &#125;;
    
    //声明一个对象
    let methods = &#123;
        up: Symbol(),
        down: Symbol()
    &#125;;

    game[methods.up] = function()&#123;
        console.log(&quot;我可以改变形状&quot;);
    &#125;

    game[methods.down] = function()&#123;
        console.log(&quot;我可以快速下降!!&quot;);
    &#125;

    console.log(game);

    let youxi = &#123;
        name:&quot;狼人杀&quot;,
        [Symbol(&#39;say&#39;)]: function()&#123;
            console.log(&quot;我可以发言&quot;)
        &#125;,
        [Symbol(&#39;zibao&#39;)]: function()&#123;
            console.log(&#39;我可以自爆&#39;);
        &#125;
    &#125;

    console.log(youxi)
&lt;/script&gt;
</code></pre>
<h1 id="Symbol内置属性"><a href="#Symbol内置属性" class="headerlink" title="Symbol内置属性"></a>Symbol内置属性</h1><pre><code class="javascript">&lt;script&gt;
    class Person &#123;
        static[Symbol.hasInstance](param) &#123;
            console.log(param);
            console.log(&quot;我被用来检测类型了&quot;);
            return false;
        &#125;
    &#125;

    let o = &#123;&#125;;

    console.log(o instanceof Person);

    const arr = [1, 2, 3];
    const arr2 = [4, 5, 6];
    arr2[Symbol.isConcatSpreadable] = false;
    console.log(arr.concat(arr2));
&lt;/script&gt; 
    ...
</code></pre>
<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><blockquote>
<p>遍历器（Iterator）就是一种机制。它是一种接口，为各种不同的数据结构提 供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作。 </p>
<p>ES6 创造了一种新的遍历命令 for…of 循环，Iterator 接口主要供 for…of 消费 </p>
<ol start="2">
<li>原生具备 iterator 接口的数据(可用 for of 遍历) <ol>
<li>a) Array</li>
<li>b) Arguments</li>
<li>c) Set </li>
<li>d) Map</li>
<li>e) String</li>
<li>f) TypedArray</li>
<li>g) NodeList </li>
</ol>
</li>
<li><ol start="3">
<li>工作原理 <ol>
<li>a) 创建一个指针对象，指向当前数据结构的起始位置 </li>
<li>b) 第一次调用对象的 next 方法，指针自动指向数据结构的第一个成员 </li>
<li>c) 接下来不断调用 next 方法，指针一直往后移动，直到指向最后一个成员 </li>
<li>d) 每调用 next 方法返回一个包含 value 和 done 属性的对象 注: 需要自定义遍历数据的时候，要想到迭代器。</li>
</ol>
</li>
</ol>
</li>
</ol>
</blockquote>
<pre><code class="javascript">&lt;script&gt;
    //声明一个数组
    const xiyou = [&#39;唐僧&#39;,&#39;孙悟空&#39;,&#39;猪八戒&#39;,&#39;沙僧&#39;];

    //使用 for...of 遍历数组
    // for(let v of xiyou)&#123;
    //     console.log(v);
    // &#125;

    let iterator = xiyou[Symbol.iterator]();

    //调用对象的next方法
    console.log(iterator.next());
    console.log(iterator.next());
    console.log(iterator.next());
    console.log(iterator.next());
    console.log(iterator.next());
&lt;/script&gt;
</code></pre>
<h1 id="迭代器自定义遍历对象"><a href="#迭代器自定义遍历对象" class="headerlink" title="迭代器自定义遍历对象"></a>迭代器自定义遍历对象</h1><pre><code class="javascript">&lt;script&gt;
    //声明一个对象
    const banji = &#123;
        name: &quot;终极一班&quot;,
        stus: [
            &#39;xiaoming&#39;,
            &#39;xiaoning&#39;,
            &#39;xiaotian&#39;,
            &#39;knight&#39;
        ],
        [Symbol.iterator]() &#123;
            //索引变量
            let index = 0;
            //
            let _this = this;
            return &#123;
                next: function () &#123;
                    if (index &lt; _this.stus.length) &#123;
                        const result = &#123; value: _this.stus[index], done: false &#125;;
                        //下标自增
                        index++;
                        //返回结果
                        return result;
                    &#125;else&#123;
                        return &#123;value: undefined, done: true&#125;;
                    &#125;
                &#125;
            &#125;;
        &#125;
    &#125;

    //遍历这个对象 
    for (let v of banji) &#123;
        console.log(v);
    &#125;
&lt;/script&gt;
</code></pre>
<h1 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h1><blockquote>
<ol>
<li>‘*’ 的位置没有限制 </li>
<li>生成器函数返回的结果是迭代器对象，调用迭代器对象的 next 方法可以得到 yield 语句后的值 </li>
<li>yield 相当于函数的暂停标记，也可以认为是函数的分隔符，每调用一次 next 方法，执行一段代码 </li>
<li>next 方法可以传递实参，作为 yield 语句的返回值</li>
</ol>
</blockquote>
<pre><code class="javascript">&lt;script&gt;    
    //生成器其实就是一个特殊的函数
    //异步编程  纯回调函数  node fs  ajax mongodb
    //函数代码的分隔符
    function * gen()&#123;
        // console.log(111);
        yield &#39;一只没有耳朵&#39;;
        // console.log(222);
        yield &#39;一只没有尾部&#39;;
        // console.log(333);
        yield &#39;真奇怪&#39;;
        // console.log(444);
    &#125;

    let iterator = gen();
    console.log(iterator.next());
    console.log(iterator.next());
    console.log(iterator.next());
    console.log(iterator.next());

    //遍历
    // for(let v of gen())&#123;
    //     console.log(v);
    // &#125;

&lt;/script&gt;
</code></pre>
<h1 id="生成器函数参数"><a href="#生成器函数参数" class="headerlink" title="生成器函数参数"></a>生成器函数参数</h1><pre><code class="javascript">&lt;script&gt;
    function * gen(arg)&#123;
        console.log(arg);
        let one = yield 111;
        console.log(one);
        let two = yield 222;
        console.log(two);
        let three = yield 333;
        console.log(three);
    &#125;

    //执行获取迭代器对象
    let iterator = gen(&#39;AAA&#39;);
    console.log(iterator.next());
    //next方法可以传入实参
    console.log(iterator.next(&#39;BBB&#39;));
    console.log(iterator.next(&#39;CCC&#39;));
    console.log(iterator.next(&#39;DDD&#39;));
    
&lt;/script&gt;
</code></pre>
<h1 id="生成器函数实例"><a href="#生成器函数实例" class="headerlink" title="生成器函数实例"></a>生成器函数实例</h1><pre><code class="javascript">&lt;script&gt;
    // 异步编程  文件操作 网络操作(ajax, request) 数据库操作
    // 1s 后控制台输出 111  2s后输出 222  3s后输出 333 
    // 回调地狱
    // setTimeout(() =&gt; &#123;
    //     console.log(111);
    //     setTimeout(() =&gt; &#123;
    //         console.log(222);
    //         setTimeout(() =&gt; &#123;
    //             console.log(333);
    //         &#125;, 3000);
    //     &#125;, 2000);
    // &#125;, 1000);

    function one()&#123;
        setTimeout(()=&gt;&#123;
            console.log(111);
            iterator.next();
        &#125;,1000)
    &#125;

    function two()&#123;
        setTimeout(()=&gt;&#123;
            console.log(222);
            iterator.next();
        &#125;,2000)
    &#125;

    function three()&#123;
        setTimeout(()=&gt;&#123;
            console.log(333);
            iterator.next();
        &#125;,3000)
    &#125;

    function * gen()&#123;
        yield one();
        yield two();
        yield three();
    &#125;

    //调用生成器函数
    let iterator = gen();
    iterator.next();

&lt;/script&gt;
</code></pre>
<h1 id="生成器函数实例-2"><a href="#生成器函数实例-2" class="headerlink" title="生成器函数实例-2"></a>生成器函数实例-2</h1><pre><code class="javascript">&lt;script&gt;
    //模拟获取  用户数据  订单数据  商品数据 
    function getUsers()&#123;
        setTimeout(()=&gt;&#123;
            let data = &#39;用户数据&#39;;
            //调用 next 方法, 并且将数据传入
            iterator.next(data);
        &#125;, 1000);
    &#125;

    function getOrders()&#123;
        setTimeout(()=&gt;&#123;
            let data = &#39;订单数据&#39;;
            iterator.next(data);
        &#125;, 1000)
    &#125;

    function getGoods()&#123;
        setTimeout(()=&gt;&#123;
            let data = &#39;商品数据&#39;;
            iterator.next(data);
        &#125;, 1000)
    &#125;

    function * gen()&#123;
        let users = yield getUsers();
        let orders = yield getOrders();
        let goods = yield getGoods();
    &#125;

    //调用生成器函数
    let iterator = gen();
    iterator.next();
&lt;/script&gt;
</code></pre>
<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><blockquote>
<p>Promise 是 ES6 引入的异步编程的新解决方案。语法上 Promise 是一个构造函数， 用来封装异步操作并可以获取其成功或失败的结果。</p>
<p>\1) Promise 构造函数: Promise (excutor) {}</p>
<p>\2) Promise.prototype.then 方法</p>
<p>\3) Promise.prototype.catch 方法</p>
</blockquote>
<pre><code class="md">   插秧诗
     布袋和尚 
手把青秧插满田，
低头便见水中天。
心地清净方为道，
退步原来是向前。

   观书有感 
    作者：朱熹
半亩方塘一鉴开，
天光云影共徘徊。
问渠那得清如许？
为有源头活水来。

   为学
天下事有难易乎？
为之，则难者亦易矣；
不为，则易者亦难矣
</code></pre>
<h1 id="1-Promise基本语法"><a href="#1-Promise基本语法" class="headerlink" title="1-Promise基本语法"></a>1-Promise基本语法</h1><pre><code class="javascript">&lt;script&gt;
    //实例化 Promise 对象
    const p = new Promise(function(resolve, reject)&#123;
        setTimeout(function()&#123;
            //
            // let data = &#39;数据库中的用户数据&#39;;
            // resolve
            // resolve(data);

            let err = &#39;数据读取失败&#39;;
            reject(err);
        &#125;, 1000);
    &#125;);

    //调用 promise 对象的 then 方法
    p.then(function(value)&#123;
        console.log(value);
    &#125;, function(reason)&#123;
        console.error(reason);
    &#125;)
&lt;/script&gt;
</code></pre>
<h1 id="2-Promise封装读取文件"><a href="#2-Promise封装读取文件" class="headerlink" title="2-Promise封装读取文件"></a>2-Promise封装读取文件</h1><pre><code class="javascript">//1. 引入 fs 模块
const fs = require(&#39;fs&#39;);

//2. 调用方法读取文件
// fs.readFile(&#39;./resources/为学.md&#39;, (err, data)=&gt;&#123;
//     //如果失败, 则抛出错误
//     if(err) throw err;
//     //如果没有出错, 则输出内容
//     console.log(data.toString());
// &#125;);

//3. 使用 Promise 封装
const p = new Promise(function(resolve, reject)&#123;
    fs.readFile(&quot;./resources/为学.mda&quot;, (err, data)=&gt;&#123;
        //判断如果失败
        if(err) reject(err);
        //如果成功
        resolve(data);
    &#125;);
&#125;);

p.then(function(value)&#123;
    console.log(value.toString());
&#125;, function(reason)&#123;
    console.log(&quot;读取失败!!&quot;);
&#125;);
</code></pre>
<h1 id="3-Promise封装AJAX"><a href="#3-Promise封装AJAX" class="headerlink" title="3-Promise封装AJAX"></a>3-Promise封装AJAX</h1><pre><code class="javascript">&lt;script&gt;
    // 接口地址: https://api.apiopen.top/getJoke
    const p = new Promise((resolve, reject) =&gt; &#123;
        //1. 创建对象
        const xhr = new XMLHttpRequest();

        //2. 初始化
        xhr.open(&quot;GET&quot;, &quot;https://api.apiopen.top/getJ&quot;);

        //3. 发送
        xhr.send();

        //4. 绑定事件, 处理响应结果
        xhr.onreadystatechange = function () &#123;
            //判断
            if (xhr.readyState === 4) &#123;
                //判断响应状态码 200-299
                if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) &#123;
                    //表示成功
                    resolve(xhr.response);
                &#125; else &#123;
                    //如果失败
                    reject(xhr.status);
                &#125;
            &#125;
        &#125;
    &#125;)
    
    //指定回调
    p.then(function(value)&#123;
        console.log(value);
    &#125;, function(reason)&#123;
        console.error(reason);
    &#125;);
&lt;/script&gt;
</code></pre>
<h1 id="4-Promise-then方法"><a href="#4-Promise-then方法" class="headerlink" title="4-Promise-then方法"></a>4-Promise-then方法</h1><pre><code class="javascript">&lt;script&gt;
    //创建 promise 对象
    const p = new Promise((resolve, reject)=&gt;&#123;
        setTimeout(()=&gt;&#123;
            resolve(&#39;用户数据&#39;);
            // reject(&#39;出错啦&#39;);
        &#125;, 1000)
    &#125;);

    //调用 then 方法  then方法的返回结果是 Promise 对象, 对象状态由回调函数的执行结果决定
    //1. 如果回调函数中返回的结果是 非 promise 类型的属性, 状态为成功, 返回值为对象的成功的值

    // const result = p.then(value =&gt; &#123;
    //     console.log(value);
    //     //1. 非 promise 类型的属性
    //     // return &#39;iloveyou&#39;;
    //     //2. 是 promise 对象
    //     // return new Promise((resolve, reject)=&gt;&#123;
    //     //     // resolve(&#39;ok&#39;);
    //     //     reject(&#39;error&#39;);
    //     // &#125;);
    //     //3. 抛出错误
    //     // throw new Error(&#39;出错啦!&#39;);
    //     throw &#39;出错啦!&#39;;
    // &#125;, reason=&gt;&#123;
    //     console.warn(reason);
    // &#125;);

    //链式调用
    p.then(value=&gt;&#123;

    &#125;).then(value=&gt;&#123;

    &#125;);
&lt;/script&gt;
</code></pre>
<h1 id="5-Promise-catch方法"><a href="#5-Promise-catch方法" class="headerlink" title="5-Promise-catch方法"></a>5-Promise-catch方法</h1><pre><code class="javascript">&lt;script&gt;
    const p = new Promise((resolve, reject)=&gt;&#123;
        setTimeout(()=&gt;&#123;
            //设置 p 对象的状态为失败, 并设置失败的值
            reject(&quot;出错啦!&quot;);
        &#125;, 1000)
    &#125;);

    // p.then(function(value)&#123;&#125;, function(reason)&#123;
    //     console.error(reason);
    // &#125;);

    p.catch(function(reason)&#123;
        console.warn(reason);
    &#125;);
&lt;/script&gt;
</code></pre>
<h1 id="6-Promise实践-读取多个文件"><a href="#6-Promise实践-读取多个文件" class="headerlink" title="6-Promise实践-读取多个文件"></a>6-Promise实践-读取多个文件</h1><pre><code class="javascript">//引入 fs 模块
const fs = require(&quot;fs&quot;);

// fs.readFile(&#39;./resources/为学.md&#39;, (err, data1)=&gt;&#123;
//     fs.readFile(&#39;./resources/插秧诗.md&#39;, (err, data2)=&gt;&#123;
//         fs.readFile(&#39;./resources/观书有感.md&#39;, (err, data3)=&gt;&#123;
//             let result = data1 + &#39;\r\n&#39; +data2  +&#39;\r\n&#39;+ data3;
//             console.log(result);
//         &#125;);
//     &#125;);
// &#125;);

//使用 promise 实现
const p = new Promise((resolve, reject) =&gt; &#123;
    fs.readFile(&quot;./resources/为学.md&quot;, (err, data) =&gt; &#123;
        resolve(data);
    &#125;);
&#125;);

p.then(value =&gt; &#123;
    return new Promise((resolve, reject) =&gt; &#123;
        fs.readFile(&quot;./resources/插秧诗.md&quot;, (err, data) =&gt; &#123;
            resolve([value, data]);
        &#125;);
    &#125;);
&#125;).then(value =&gt; &#123;
    return new Promise((resolve, reject) =&gt; &#123;
        fs.readFile(&quot;./resources/观书有感.md&quot;, (err, data) =&gt; &#123;
            //压入
            value.push(data);
            resolve(value);
        &#125;);
    &#125;)
&#125;).then(value =&gt; &#123;
    console.log(value.join(&#39;\r\n&#39;));
&#125;);
</code></pre>
<h1 id="set集合"><a href="#set集合" class="headerlink" title="set集合"></a>set集合</h1><pre><code class="javascript">&lt;script&gt;
    //声明一个 set
    let s = new Set();
    let s2 = new Set([&#39;大事儿&#39;,&#39;小事儿&#39;,&#39;好事儿&#39;,&#39;坏事儿&#39;,&#39;小事儿&#39;]);

    //元素个数
    // console.log(s2.size);
    //添加新的元素
    // s2.add(&#39;喜事儿&#39;);
    //删除元素
    // s2.delete(&#39;坏事儿&#39;);
    //检测
    // console.log(s2.has(&#39;糟心事&#39;));
    //清空
    // s2.clear();
    // console.log(s2);

    for(let v of s2)&#123;
        console.log(v);
    &#125;
    
&lt;/script&gt;
</code></pre>
<h1 id="Set集合实践"><a href="#Set集合实践" class="headerlink" title="Set集合实践"></a>Set集合实践</h1><pre><code class="JavaScript">&lt;script&gt;
    let arr = [1,2,3,4,5,4,3,2,1];
    //1. 数组去重
    // let result = [...new Set(arr)];
    // console.log(result);
    //2. 交集
    let arr2 = [4,5,6,5,6];
    // let result = [...new Set(arr)].filter(item =&gt; &#123;
    //     let s2 = new Set(arr2);// 4 5 6
    //     if(s2.has(item))&#123;
    //         return true;
    //     &#125;else&#123;
    //         return false;
    //     &#125;
    // &#125;);
    // let result = [...new Set(arr)].filter(item =&gt; new Set(arr2).has(item));
    // console.log(result);

    //3. 并集
    // let union = [...new Set([...arr, ...arr2])];
    // console.log(union);

    //4. 差集
    let diff = [...new Set(arr)].filter(item =&gt; !(new Set(arr2).has(item)));
    console.log(diff);

&lt;/script&gt;
</code></pre>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><pre><code class="javascript">&lt;script&gt;
    //声明 Map
    let m = new Map();

    //添加元素
    m.set(&#39;name&#39;,&#39;恋爱学院&#39;);
    m.set(&#39;change&#39;, function()&#123;
        console.log(&quot;我们可以改变你!!&quot;);
    &#125;);
    let key = &#123;
        school : &#39;ATGUIGU&#39;
    &#125;;
    m.set(key, [&#39;北京&#39;,&#39;上海&#39;,&#39;深圳&#39;]);

    //size
    // console.log(m.size);

    //删除
    // m.delete(&#39;name&#39;);

    //获取
    // console.log(m.get(&#39;change&#39;));
    // console.log(m.get(key));

    //清空
    // m.clear();

    //遍历
    for(let v of m)&#123;
        console.log(v);
    &#125;

    // console.log(m);

&lt;/script&gt;
</code></pre>
<h1 id="class类"><a href="#class类" class="headerlink" title="class类"></a>class类</h1><pre><code class="JavaScript">&lt;script&gt;
    //手机
    function Phone(brand, price)&#123;
        this.brand = brand;
        this.price = price;
    &#125;

    //添加方法
    Phone.prototype.call = function()&#123;
        console.log(&quot;我可以打电话!!&quot;);
    &#125;

    //实例化对象
    let Huawei = new Phone(&#39;华为&#39;, 5999);
    Huawei.call();
    console.log(Huawei);

    //class
    class Shouji&#123;
        //构造方法 名字不能修改
        constructor(brand, price)&#123;
            this.brand = brand;
            this.price = price;
        &#125;

        //方法必须使用该语法, 不能使用 ES5 的对象完整形式
        call()&#123;
            console.log(&quot;我可以打电话!!&quot;);
        &#125;
    &#125;

    let onePlus = new Shouji(&quot;1+&quot;, 1999);

    console.log(onePlus);
&lt;/script&gt;
</code></pre>
<h1 id="class-的-get-set"><a href="#class-的-get-set" class="headerlink" title="class 的 get-set"></a>class 的 get-set</h1><pre><code class="JavaScript">&lt;script&gt;
    // get 和 set  
    class Phone&#123;
        get price()&#123;
            console.log(&quot;价格属性被读取了&quot;);
            return &#39;iloveyou&#39;;
        &#125;

        set price(newVal)&#123;
            console.log(&#39;价格属性被修改了&#39;);
        &#125;
    &#125;

    //实例化对象
    let s = new Phone();

    // console.log(s.price);
    s.price = &#39;free&#39;;
&lt;/script&gt;
</code></pre>
<h1 id="类继承"><a href="#类继承" class="headerlink" title="类继承"></a>类继承</h1><pre><code class="JavaScript">&lt;script&gt;
    //手机
    function Phone(brand, price)&#123;
        this.brand = brand;
        this.price = price;
    &#125;

    Phone.prototype.call = function()&#123;
        console.log(&quot;我可以打电话&quot;);
    &#125;

    //智能手机
    function SmartPhone(brand, price, color, size)&#123;
        Phone.call(this, brand, price);
        this.color = color;
        this.size = size;
    &#125;

    //设置子级构造函数的原型
    SmartPhone.prototype = new Phone;
    SmartPhone.prototype.constructor = SmartPhone;

    //声明子类的方法
    SmartPhone.prototype.photo = function()&#123;
        console.log(&quot;我可以拍照&quot;)
    &#125;

    SmartPhone.prototype.playGame = function()&#123;
        console.log(&quot;我可以玩游戏&quot;);
    &#125;

    const chuizi = new SmartPhone(&#39;锤子&#39;,2499,&#39;黑色&#39;,&#39;5.5inch&#39;);

    console.log(chuizi);

&lt;/script&gt;
</code></pre>
<h1 id="类继承-2"><a href="#类继承-2" class="headerlink" title="类继承-2"></a>类继承-2</h1><pre><code class="JavaScript">&lt;script&gt;
    class Phone&#123;
        //构造方法
        constructor(brand, price)&#123;
            this.brand = brand;
            this.price = price;
        &#125;
        //父类的成员属性
        call()&#123;
            console.log(&quot;我可以打电话!!&quot;);
        &#125;
    &#125;

    class SmartPhone extends Phone &#123;
        //构造方法
        constructor(brand, price, color, size)&#123;
            super(brand, price);// Phone.call(this, brand, price)
            this.color = color;
            this.size = size;
        &#125;

        photo()&#123;
            console.log(&quot;拍照&quot;);
        &#125;

        playGame()&#123;
            console.log(&quot;玩游戏&quot;);
        &#125;

        call()&#123;
            console.log(&#39;我可以进行视频通话&#39;);
        &#125;
    &#125;

    const xiaomi = new SmartPhone(&#39;小米&#39;,799,&#39;黑色&#39;,&#39;4.7inch&#39;);
    // console.log(xiaomi);
    xiaomi.call();
    xiaomi.photo();
    xiaomi.playGame();
&lt;/script&gt;
</code></pre>
<h1 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h1><pre><code class="JavaScript">&lt;script&gt;
    // function Phone()&#123;

    // &#125;
    // Phone.name = &#39;手机&#39;;
    // Phone.change = function()&#123;
    //     console.log(&quot;我可以改变世界&quot;);
    // &#125;
    // Phone.prototype.size = &#39;5.5inch&#39;;

    // let nokia = new Phone();

    // console.log(nokia.name);
    // // nokia.change();
    // console.log(nokia.size);

    class Phone&#123;
        //静态属性
        static name = &#39;手机&#39;;
        static change()&#123;
            console.log(&quot;我可以改变世界&quot;);
        &#125;
    &#125;

    let nokia = new Phone();
    console.log(nokia.name);
    console.log(Phone.name);
&lt;/script&gt;
</code></pre>
<h1 id="对象方法扩展"><a href="#对象方法扩展" class="headerlink" title="对象方法扩展"></a>对象方法扩展</h1><pre><code class="JavaScript">&lt;script&gt;
    //1. Object.is 判断两个值是否完全相等 
    console.log(Object.is(120, 120));// === 
    console.log(Object.is(NaN, NaN));// === 
    console.log(NaN === NaN);// === 

    //2. Object.assign 对象的合并
    const config1 = &#123;
        host: &#39;localhost&#39;,
        port: 3306,
        name: &#39;root&#39;,
        pass: &#39;root&#39;,
        test: &#39;test&#39;
    &#125;;
    const config2 = &#123;
        host: &#39;http://atguigu.com&#39;,
        port: 33060,
        name: &#39;atguigu.com&#39;,
        pass: &#39;iloveyou&#39;,
        test2: &#39;test2&#39;
    &#125;
    console.log(Object.assign(config1, config2));

    //3. Object.setPrototypeOf 设置原型对象  Object.getPrototypeof
    const school = &#123;
        name: &#39;尚硅谷&#39;
    &#125;
    const cities = &#123;
        xiaoqu: [&#39;北京&#39;,&#39;上海&#39;,&#39;深圳&#39;]
    &#125;
    Object.setPrototypeOf(school, cities);
    console.log(Object.getPrototypeOf(school));
    console.log(school);
&lt;/script&gt;
</code></pre>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title>numpy</title>
    <url>/2021/12/09/numPy/</url>
    <content><![CDATA[<p>测试是否安装成功，程序代码如下：</p>
<p>01  from numpy import *   #导入numpy库<br>02  print(eye(4))          #生成对角矩阵<br>运行程序，输出结果如下：</p>
<p>​                                                                                     图8.7　一维数组一个轴</p>
<h1 id="8-2-创建数组"><a href="#8-2-创建数组" class="headerlink" title="8.2　创建数组"></a>8.2　创建数组</h1><h2 id="8-2-1-创建简单的数组"><a href="#8-2-1-创建简单的数组" class="headerlink" title="8.2.1　创建简单的数组"></a>8.2.1　创建简单的数组</h2><p>NumPy创建简单的数组主要使用array()函数，语法如下：</p>
<p>numpy.array(object,dtype=None,copy=True,order=’K’,subok=False,ndmin=0)<br>参数说明：　</p>
<p>object：任何具有数组接口方法的对象。　</p>
<p>dtype：数据类型。　</p>
<p>copy：布尔型，可选参数，默认值为True，则object对象被复制；否则，只有当__array__返回副本，object参数为嵌套序列，或者需要副本满足数据类型和顺序要求时，才会生成副本。　</p>
<p>order：元素在内存中的出现顺序，值为K、A、C、F。如果object参数不是数组，则新创建的数组将按行排列（C），如果值为F，则按列排列；如果object参数是一个数组，则C（按行）、F（按列）、A（原顺序）、K（元素在内存中的出现顺序）成立。　</p>
<p>subok：布尔型。如果值为True，则将传递子类；否则返回的数组将强制为基类数组（默认值）。　</p>
<p>ndmin：指定生成数组的最小维数。</p>
<p>【示例03】　复制数组。（示例位置：资源包\MR\Code\08\03）<br>当运算和处理数组时，为了不影响到原数组，就需要对原数组进行复制，而对复制后的数组进行修改删除等操作都不会影响到原数组。数组的复制可以通过copy参数实现，程序代码如下：</p>
<p>copy=True 新数组改变 旧数组不改变 否则反之<br>ndmin=3，虽然给出的数组是一维的，但是同样会创建一个三维数组，程序代码如下：<br>运行程序，输出结果如下：</p>
<p>[[[1 2 3]]]</p>
<h3 id="1．创建指定维度和数据类型未初始化的数组"><a href="#1．创建指定维度和数据类型未初始化的数组" class="headerlink" title="1．创建指定维度和数据类型未初始化的数组"></a>1．创建指定维度和数据类型未初始化的数组</h3><p>【示例05】　创建指定维度和未初始化的数组。（示例位置：资源包\MR\Code\08\05）<br>创建指定维度和数据类型未初始化的数组主要使用empty()函数，程序代码如下：</p>
<p>01 import numpy as np<br>02 n = np.empty([2,3])<br>03 print(n)<br>运行程序，输出结果如下：</p>
<p>[[2.22519099e-307 2.33647355e-307 1.23077925e-312]<br>[2.33645827e-307 2.67023123e-307 1.69117157e-306]]<br>这里，数组元素为随机值，因为它们未被初始化。如果要改变数组类型，可以使用dtype参数，如整型，dtype=int。</p>
<h3 id="2．创建指定维度（以0填充）的数组"><a href="#2．创建指定维度（以0填充）的数组" class="headerlink" title="2．创建指定维度（以0填充）的数组"></a>2．创建指定维度（以0填充）的数组</h3><p>【示例06】　创建指定维度（以0填充）的数组。（示例位置：资源包\MR\Code\08\06）<br>创建指定维度并以0填充的数组，主要使用zeros()函数，程序代码如下：</p>
<p>01  import numpy as np<br>02  n = np.zeros(3)<br>03  print(n)<br>运行程序，输出结果如下：</p>
<p>[0. 0. 0.]<br>输出结果默认是浮点型（float）。</p>
<h3 id="3．创建指定维度（以1填充）的数组"><a href="#3．创建指定维度（以1填充）的数组" class="headerlink" title="3．创建指定维度（以1填充）的数组"></a>3．创建指定维度（以1填充）的数组</h3><p>【示例07】　创建指定维度并以1填充的数组。（示例位置：资源包\MR\Code\08\07）<br>创建指定维度并以1填充的数组，主要使用ones()函数，程序代码如下：</p>
<p>01 import numpy as np<br>02 n = np.ones(3)<br>03 print(n)</p>
<p>运行程序，输出结果如下：</p>
<p>[1. 1. 1.]<br>4．创建指定维度和类型的数组并以指定值填充【示例08】　创建以指定值填充的数组。（示例位置：资源包\MR\Code\08\08）<br>创建指定维度和类型的数组并以指定值填充，主要使用full()函数，程序代码如下：</p>
<p>01  import numpy as np<br>02  n = np.full((3,3), 8)<br>03  print(n)<br>运行程序，输出结果如下：</p>
<p>[[8 8 8]<br> [8 8 8]<br> [8 8 8]]</p>
<h2 id="8-2-3-从数值范围创建数组"><a href="#8-2-3-从数值范围创建数组" class="headerlink" title="8.2.3　从数值范围创建数组"></a>8.2.3　从数值范围创建数组</h2><h3 id="1．通过arange-函数创建数组"><a href="#1．通过arange-函数创建数组" class="headerlink" title="1．通过arange()函数创建数组"></a>1．通过arange()函数创建数组</h3><p>arange()函数同Python内置range()函数相似，区别在于返回值，arange()函数返回值是数组，而range()函数返回值是列表。arange()函数的语法如下：</p>
<p>arange([start,] stop[, step,], dtype=None)<br>参数说明：　</p>
<p>start：起始值，默认值为0。　</p>
<p>stop：终止值（不包含）。　</p>
<p>step：步长，默认值为1。　</p>
<p>dtype：创建数组的数据类型，如果不设置数据类型，则使用输入数据的数据类型。</p>
<p>01 import numpy as np<br>02 n=np.arange(1,12,2)<br>03 print(n)<br>运行程序，输出结果如下：</p>
<p>[ 1  3  5  7  9 11]</p>
<h3 id="2．使用linspace-函数创建等差数列"><a href="#2．使用linspace-函数创建等差数列" class="headerlink" title="2．使用linspace()函数创建等差数列"></a>2．使用linspace()函数创建等差数列</h3><p>首先简单了解一下等差数列，等差数列是指如果一个数列从第二项起，每一项与它的前一项的差等于同一个常数，那么这个数列就叫作等差数列。<br>例如，一般成年男鞋的各种尺码，如图8.9所示。</p>
<p>​                                                                                        图8.10　训练计划<br>在Python中创建等差数列可以使用NumPy的linspace()函数，该函数用于创建一个一维的等差数列的数组，它与arange()函数不同，arange()函数是从开始值到结束值的左闭右开区间（即包括开始值不包括结束值），第三个参数（如果存在）是步长；而linspace()函数是从开始值到结束值的闭区间（可以通过参数endpoint=False，使结束值不是闭区间），并且第三个参数是值的个数。</p>
<p>linspace()函数语法如下：</p>
<p>linspace(start,stop,num=50,endpoint=True,retstep=False,dtype=None)<br>参数说明：　</p>
<p>start：序列的起始值。　</p>
<p>stop：序列的终止值，如果endpoint参数的值为True，则该值包含于数列中。　</p>
<p>num：要生成的等步长的样本数量，默认值为50。　</p>
<p>endpoint：如果值为True，数列中包含stop参数的值；反之则不包含。默认值为True。　</p>
<p>retstep：如果值为True，则生成的数组中会显示间距；反之则不显示。　</p>
<p>dtype：数组的数据类型。</p>
<p>01 import numpy as np<br>02 n1 = np.linspace(7500,10000,6)<br>03 print(n1)<br>运行程序，输出结果如下：</p>
<p>[ 7500.  8000.  8500.  9000.  9500. 10000.]</p>
<h3 id="3．使用logspace-函数创建等比数列"><a href="#3．使用logspace-函数创建等比数列" class="headerlink" title="3．使用logspace()函数创建等比数列"></a>3．使用logspace()函数创建等比数列</h3><p>在Python中创建等比数列可以使用NumPy的logspace()函数，语法如下：</p>
<p>numpy.logspace(start, stop, num=50, endpoint=True, base=10.0, dtype=None)<br>参数说明：　</p>
<p>start：序列的起始值。　</p>
<p>stop：序列的终止值。如果endpoint参数值为True，则该值包含于数列中。　</p>
<p>num：要生成的等步长的数据样本数量，默认值为50。　</p>
<p>endpoint：如果值为True，则数列中包含stop参数值；反之则不包含。默认值为True。　</p>
<p>base：对数log的底数。　</p>
<p>dtype：数组的数据类型。                            </p>
<p>01  import numpy as np<br>02  n = np.logspace(0,63,64,base=2,dtype=’int’)<br>03  print(n)</p>
<p>​                                                                                  图8.12　每个格子里放的小麦数</p>
<p>上述举例出现一个问题：后面大数出现负数，而且都是一样的，这是由于程序中指定的数据类型是int，是32位的，数据范围为-2147483648～2147483647，而我们计算后的数据远远超出了这个范围，因此便出现了溢出现象。解决这一问题，需要指定数据类型为uint64（无符号整数，数据范围为0～18446744073709551615），关键代码如下：</p>
<p>n = np.logspace(0,63,64,base=2,dtype=’uint64’)</p>
<h2 id><a href="#" class="headerlink" title></a></h2><p>随机数组的生成主要使用NumPy的random模块，下面介绍几种常用的随机生成数组的函数。</p>
<h3 id="1．rand"><a href="#1．rand" class="headerlink" title="1．rand()"></a>1．rand()</h3><p>rand()函数用于生成(0,1)之间的随机数组，传入一个值随机生成一维数组，传入一对值则随机生成二维数组，语法如下：</p>
<p>numpy.random.rand(d0,d1,d2,d3,…,dn)<br>参数d0，d1，…，dn为整数，表示维度，可以为空。</p>
<p>【示例12】　随机生成0～1的数组。（示例位置：资源包\MR\Code\08\12）<br>随机生成一维数组和二维数组，代码如下：<br>运行程序，输出结果如下：</p>
<h3 id="2．randn"><a href="#2．randn" class="headerlink" title="2．randn()"></a>2．randn()</h3><p>randn()函数用于从正态分布中返回随机生成的数组，语法如下：</p>
<p>numpy.random.randn(d0,d1,d2,d3,…,dn)<br>参数d0，d1，…，dn为整数，表示维度，可以为空。</p>
<p>【示例13】　随机生成满足正态分布的数组。（示例位置：资源包\MR\Code\08\13）<br>随机生成满足正态分布的数组，程序代码如下：<br>运行程序，输出结果如下：</p>
<h3 id="3．randint"><a href="#3．randint" class="headerlink" title="3．randint()"></a>3．randint()</h3><p>randint()函数与NumPy的arange()函数类似。randint()函数用于生成一定范围内的随机数组，左闭右开区间，语法如下：</p>
<p>numpy.random.randint(low,high=None,size=None)</p>
<p>参数说明：　</p>
<p>low：低值（起始值），整数，且当参数high不为空时，参数low应小于参数high；否则程序会出现错误。　</p>
<p>high：高值（终止值），整数。</p>
<p>size：数组维数，整数或者元组，整数表示一维数组，元组表示多维数组。默认值为空，如果为空，则仅返回一个整数。</p>
<h3 id="4．normal"><a href="#4．normal" class="headerlink" title="4．normal()"></a>4．normal()</h3><p>normal()函数用于生成正态分布的随机数，语法如下：</p>
<p>numpy.random.normal(loc,scale,size)<br>参数说明：　</p>
<p>loc：正态分布的均值，对应正态分布的中心。loc=0说明是一个以y轴为对称轴的正态分布。　</p>
<p>scale：正态分布的标准差，对应正态分布的宽度，scale值越大，正态分布的曲线越“矮胖”；scale值越小，曲线越“高瘦”。　size：表示数组维数。</p>
<p>【示例15】　生成正态分布的随机数组。（示例位置：资源包\MR\Code\08\15）<br>生成正态分布的随机数组，程序代码如下：</p>
<p>01 import numpy as np<br>02 n = np.random.normal(0, 0.1, 10)<br>03 print(n)<br>运行程序，输出结果如下：</p>
<p>[ 0.08530096  0.0404147  -0.00358281  0.05405901 -0.01677737 -0.02448481<br> 0.13410224 -0.09780364  0.06095256 -0.0431846 ]</p>
<h2 id="-1"><a href="#-1" class="headerlink" title></a></h2><h3 id="1．asarray-函数"><a href="#1．asarray-函数" class="headerlink" title="1．asarray()函数"></a>1．asarray()函数</h3><p>asarray()函数用于创建数组，其与array()函数类似，语法如下：</p>
<p>numpy.asarray(a,dtype=None,order=None)<br>参数说明：　</p>
<p>a：可以是列表、列表的元组、元组、元组的元组、元组的列表或多维数组。　</p>
<p>dtype：数组的数据类型。　</p>
<p>order：值为C和F，分别代表按行排列和按列排列，即数组元素在内存中的出现顺序。</p>
<h3 id="4．empty-like-函数"><a href="#4．empty-like-函数" class="headerlink" title="4．empty_like()函数"></a>4．empty_like()函数</h3><p>empty_like()函数用于创建一个与给定数组具有相同维度和数据类型且未初始化的数组，语法如下：</p>
<p>numpy.empty_like(prototype,dtype=None,order=’K’,subok=True)<br>参数说明：　</p>
<p>prototype：给定的数组。　</p>
<p>dtype：覆盖结果的数据类型。　</p>
<p>order：指定数组的内存布局。其中C（按行）、F（按列）、A（原顺序）、K（数据元素在内存中的出现顺序）。　</p>
<p>subok：默认情况下，返回的数组被强制为基类数组。如果值为True，则返回子类。</p>
<p>【示例19】　创建未初始化的数组。（示例位置：资源包\MR\Code\08\19）<br>下面使用empty_like()函数创建一个与给定数组具有相同维数、数据类型以及未初始化的数组，程序代码如下：</p>
<p>01 import numpy as np</p>
<p>02 n = np.empty_like([[1, 2], [3, 4]])<br>03 print(n)<br>运行程序，输出结果如下：</p>
<p>[[0 0]<br> [0 0]]</p>
<h3 id="5．zeros-like-函数"><a href="#5．zeros-like-函数" class="headerlink" title="5．zeros_like()函数"></a>5．zeros_like()函数</h3><p>【示例20】　创建以0填充的数组。（示例位置：资源包\MR\Code\08\20）<br>zeros_like()函数用于创建一个与给定数组维度和数据类型相同，并以0填充的数组，程序代码如下：</p>
<p>01 import numpy as np<br>02 n = np.zeros_like([[0.1,0.2,0.3], [0.4,0.5,0.6]])<br>03 print(n)<br>运行程序，输出结果如下：</p>
<p>[[0. 0. 0.]<br> [0. 0. 0.]]说明<br>参数说明请参见empty_like()函数。</p>
<h3 id="6．ones-like-函数"><a href="#6．ones-like-函数" class="headerlink" title="6．ones_like()函数"></a>6．ones_like()函数</h3><p>【示例21】　创建以1填充的数组。（示例位置：资源包\MR\Code\08\21）<br>ones_like()函数用于创建一个与给定数组维度和数据类型相同，并以1填充的数组，程序代码如下：</p>
<p>01 import numpy as np<br>02 n = np.ones_like([[0.1,0.2,0.3], [0.4,0.5,0.6]])</p>
<p>03 print(n)<br>运行程序，输出结果如下：</p>
<p>[[1. 1. 1.]<br>[1. 1. 1.]]说明<br>参数说明请参见empty_like()函数。</p>
<h3 id="7．full-like-函数"><a href="#7．full-like-函数" class="headerlink" title="7．full_like()函数"></a>7．full_like()函数</h3><p>full_like()函数用于创建一个与给定数组维度和数据类型相同，并以指定值填充的数组，语法如下：</p>
<p>numpy.full_like(a, fill_value, dtype=None, order=’K’, subok=True)<br>参数说明：　</p>
<p>a：给定的数组。　</p>
<p>fill_value：填充值。　</p>
<p>dtype：数组的数据类型，默认值为None，则使用给定数组的数据类型。　</p>
<p>order：指定数组的内存布局。其中C（按行）、F（按列）、A（原顺序）、K（数组元素在内存中的出现顺序）。　</p>
<p>subok：默认情况下，返回的数组被强制为基类数组。如果值为True，则返回子类。</p>
<h3 id="8-3-1-数据类型"><a href="#8-3-1-数据类型" class="headerlink" title="8.3.1　数据类型"></a>8.3.1　数据类型</h3><p>在对数组进行基本操作前，首先了解一下NumPy的数据类型。NumPy的数据类型比Python数据类型增加了更多种类的数值类型，如表8.1所示。为了区别Python数据类型，像bool、int、float、complex、str等数据类型的名称末尾都加了短下画线“_”。</p>
<p>每一种数据类型都有相应的数据转换函数。举例如下：</p>
<p>np.int8(3.141)</p>
<p>结果为3。</p>
<p>np.float64(8)<br>结果为8.0。</p>
<p>np.float(True)<br>结果为1.0。</p>
<p>bool(1)<br>结果为True。<br>在创建ndarray数组时，可以直接指定数值类型，关键代码如下：</p>
<p>a = np.arange(8, dtype=float)<br>结果为[0. 1. 2. 3. 4. 5. 6. 7.]。</p>
<p>注意<br>复数不能转换成为整数类型或者浮点数，例如以下的代码会出现错误提示：</p>
<p>float(8+ 1j)</p>
<h3 id="-2"><a href="#-2" class="headerlink" title></a></h3><h3 id="数组索引和切片"><a href="#数组索引和切片" class="headerlink" title="数组索引和切片"></a>数组索引和切片</h3><p>NumPy数组元素是通过数组的索引和切片来访问和修改的，因此索引和切片是NumPy中最重要、最常用的操作。</p>
<h4 id="1．索引"><a href="#1．索引" class="headerlink" title="1．索引"></a>1．索引</h4><p>所谓数组的索引，即用于标记数组中对应元素的唯一数字，从0开始，即数组中的第一个元素的索引是0，以此类推。NumPy数组可以使用标准Python语法x[obj]的语法对数组进行索引，其中x是数组，obj是索引。</p>
<p>【示例28】　获取一维数组中的元素。（示例位置：资源包\MR\Code\08\28）<br>获取一维数组n1中索引为0的元素，程序代码如下：</p>
<p>01  import numpy as np<br>02  n1=np.array([1,2,3])   #创建一维数组<br>03  print(n1[0])           #输出一维数组的第一个元素<br>运行程序，输出结果如下：</p>
<p>1</p>
<p>【示例29】　获取二维数组中的元素。（示例位置：资源包\MR\Code\08\29）<br>再举一个例子，通过索引获取二维数组中的元素，程序代码如下：</p>
<p>01  import numpy as np<br>02  n1=np.array([[1,2,3],[4,5,6]])   #创建二维数组<br>03  print(n1[1] [2])                  #输出二维数组中第2行第3列的元素<br>运行程序，输出结果如下：</p>
<p>6</p>
<h4 id="2．切片式索引"><a href="#2．切片式索引" class="headerlink" title="2．切片式索引"></a>2．切片式索引</h4><p>数组的切片可以理解为对数组的分割，按照等分或者不等分，将一个数组切割为多个片段，它与Python中列表的切片操作一样。NumPy中的切片用冒号分隔切片参数来进行切片操作，语法如下：</p>
<p>[start:stop:step]<br>参数说明：　</p>
<p>start：起始索引。</p>
<p>stop：终止索引。　</p>
<p>step：步长。</p>
<p>【示例30】　实现简单的数组切片操作。（示例位置：资源包\MR\Code\08\30）<br>实现简单的切片操作，对数组n1进行切片式索引操作，如图8.19所示。</p>
<p>切片式索引操作需要注意以下几点。<br>（1）索引是左闭右开区间，如上述代码中的n1[0:2]，只能取到索引从0～1的元素，而取不到索引为2的元素。<br>（2）当没有start参数时，代表从索引0开始取数，如上述代码中的n1[:2]。<br>（3）start、stop和step这3个参数都可以是负数，代表反向索引。以step参数为例，如图8.20所示。</p>
<p>【示例31】　常用的切片式索引操作。（示例位置：资源包\MR\Code\08\31）<br>常用的切片式索引操作，程序代码如下：</p>
<p>运行程序，输出结果如下：</p>
<h4 id="3．二维数组索引"><a href="#3．二维数组索引" class="headerlink" title="3．二维数组索引"></a>3．二维数组索引</h4><p>二维数组索引可以使用array[n,m]的方式，以逗号分隔，表示第n个数组的，第m个元素。</p>
<p>【示例32】　二维数组的简单索引操作。（示例位置：资源包\MR\Code\08\32）<br>创建一个3行4列的二维数组，实现简单的索引操作，效果如图8.21所示。</p>
<p>​                                                                                                图8.21　二维数组索引示意图<br>程序代码如下：</p>
<p>上述代码中，n[1]表示第2个数组，n[1,2]表示第2个数组第3个元素，它等同于n[1][2]，表示数组n中第2行第3列的值，实际上n[1] [2]是先索引第一个维度得到一个数组，然后在此基础上再索引。</p>
<h4 id="4．二维数组切片式索引"><a href="#4．二维数组切片式索引" class="headerlink" title="4．二维数组切片式索引"></a>4．二维数组切片式索引</h4><p>import numpy as np </p>
<p>创建3行3列的二维数组</p>
<p>n=np.array([[1,2,3],[4,5,6],[7,8,9]])</p>
<p>print(n[:2,1:])  #输出第1行至第3行（不包括第三行）的第二列至最后一列的元素</p>
<p>print(n[1,:2])    # 输出第2行的第1列至第3列（不包括第3列）的以元素</p>
<p>pirnt(n[:2,2])   # 输出第1行至第3行（不包括第3行）的第3列的元素</p>
<p>print(n[:,:1])      #输出所有行的第一列至第二列（不包括第2列）的元素</p>
<h3 id="8-3-4-数组重塑"><a href="#8-3-4-数组重塑" class="headerlink" title="8.3.4　数组重塑"></a>8.3.4　数组重塑</h3><p>数组重塑实际是更改数组的形状，例如，将原来2行3列的数组重塑为3行4列的数组。在NumPy中主要使用reshape()方法，该方法用于改变数组的形状。</p>
<h4 id="3．数组转置"><a href="#3．数组转置" class="headerlink" title="3．数组转置"></a>3．数组转置</h4><p>数组转置是指数组的行列转换，可以通过数组的T属性和transpose()函数实现。</p>
<p>01  n = np.array([[‘A’,100],[‘B’,200],[‘C’,300],[‘D’,400],[‘E’,500]])<br>02  print(n.transpose())                           #transpose()函数行列转置</p>
<h4 id="1．数组的增加"><a href="#1．数组的增加" class="headerlink" title="1．数组的增加"></a>1．数组的增加</h4><p>数组数据的增加可以按照水平方向增加数据，也可以按照垂直方向增加数据。水平方向增加数据主要使用hstack()函数，垂直方向增加数据主要使用vstack()函数。</p>
<h4 id="2．数组的删除"><a href="#2．数组的删除" class="headerlink" title="2．数组的删除"></a>2．数组的删除</h4><p>数组的删除主要使用delete()方法。</p>
<p>【示例40】　删除指定的数组。（示例位置：资源包\MR\Code\08\40）<br>删除指定的数组，程序代码如下：</p>
<p>np.delete(n1,2,axis=0)   # 删除第3行</p>
<p>np.delete(n1,(1,2),axis=1)  # 删除第二行和第三行</p>
<h4 id="3．数组的修改"><a href="#3．数组的修改" class="headerlink" title="3．数组的修改"></a>3．数组的修改</h4><p>修改数组或数组元素时，直接为数组或数组元素赋值即可。</p>
<p>【示例41】　修改指定的数组。（示例位置：资源包\MR\Code\08\41）<br>修改指定的数组，程序代码如下：</p>
<p>运行程序，输出结果如下：</p>
<h4 id="4．数组的查询"><a href="#4．数组的查询" class="headerlink" title="4．数组的查询"></a>4．数组的查询</h4><p>数组的查询同样可以使用索引和切片方法来获取指定范围的数组或数组元素，还可以通过where()函数查询符合条件的数组或数组元素。where()函数语法如下：</p>
<p>numpy.where(condition,x,y)<br>上述语法，第一个参数为一个布尔数组，第二个参数和第三个参数可以是标量也可以是数组。满足条件（参数condition），输出参数x，不满足条件输出参数y。</p>
<p>【示例42】　按指定条件查询数组。（示例位置：资源包\MR\Code\08\42）<br>数组查询，大于5输出2，不大于5输出0，程序代码如下：</p>
<p>运行程序，输出结果如下：</p>
<p>[0 1 2 3 4 5 6 7 8 9]<br>[0 0 0 0 0 0 2 2 2 2]<br>如果不指定参数x和y，则输出满足条件的数组元素的坐</p>
<p>标。例如，上述举例不指定参数x和y，关键代码如下：</p>
<p>01  n2=n1[np.where(n1&gt;5)]<br>02  print(n2)<br>运行程序，输出结果如下：</p>
<p>（3）使用random模块的rand()函数创建一个3×3为0～1随机产生的二维数组，并将其转换为矩阵，程序代码如下：</p>
<p>01  import numpy as np</p>
<p>02  data1 = np.mat(np.random.rand(3,3))<br>03  print(data1)</p>
<p>（4）创建一个1～8的随机整数矩阵，程序代码如下：</p>
<p>01 import numpy as np<br>02 data1 = np.mat(np.random.randint(1,8,size=(3,5)))<br>03 print(data1)<br>运行程序，输出结果如下：</p>
<h2 id="矩阵运算"><a href="#矩阵运算" class="headerlink" title="矩阵运算"></a>矩阵运算</h2><p>​                                                                         图8.28　矩阵相乘运算过程示意图<br>数组运算和矩阵运算的一个关键区别是矩阵相乘使用的是点乘。点乘，也称点积，是数组中元素对应位置一一相乘之后求和的操作，在NumPy中专门提供了点乘方法，即dot()方法，该方法返回的是两个数组的点积。</p>
<p>【示例49】　矩阵元素之间的相乘运算。（示例位置：资源包\MR\Code\08\49）<br>要实现矩阵对应元素之间的相乘可以使用multiply()函数，程序代码如下：</p>
<h2 id="8-4-3-矩阵转换"><a href="#8-4-3-矩阵转换" class="headerlink" title="8.4.3　矩阵转换"></a>8.4.3　矩阵转换</h2><h3 id="1．矩阵转置"><a href="#1．矩阵转置" class="headerlink" title="1．矩阵转置"></a>1．矩阵转置</h3><p>【示例50】　使用T属性实现矩阵转置。（示例位置：资源包\MR\Code\08\50）<br>矩阵转置与数组转置一样使用T属性，程序代码如下：</p>
<p>01  import numpy as np<br>02  n1 = np.mat(‘1 3 3;4 5 6;7 12 9’)            #创建矩阵，使用分号隔开数据<br>03  print(‘矩阵转置结果为：\n’,n1.T)             #矩阵转置<br>运行程序，输出结果如下：</p>
<h3 id="2．矩阵求逆"><a href="#2．矩阵求逆" class="headerlink" title="2．矩阵求逆"></a>2．矩阵求逆</h3><p>【示例51】　实现矩阵逆运算。（示例位置：资源包\MR\Code\08\51）<br>矩阵要可逆，否则意味着该矩阵为奇异矩阵（即矩阵的行列式的值为0）。矩阵求逆主要使用I属性，程序代码如下：</p>
<p>01  import numpy as np<br>02  n1 = np.mat(‘1 3 3;4 5 6;7 12 9’)       #创建矩阵，使用分号隔开数据<br>03  print(‘矩阵的逆矩阵结果为：\n’,n1.I)    #逆矩阵<br>运行程序，输出结果如下：</p>
<h2 id="8-5-1-数学运算函数"><a href="#8-5-1-数学运算函数" class="headerlink" title="8.5.1　数学运算函数"></a>8.5.1　数学运算函数</h2><p>NumPy包含大量的数学运算的函数，包括三角函数、算术运算函数、复数处理函数等，如表8.2所示。</p>
<p>下面介绍几个常用的数学运算函数。</p>
<h3 id="1．算术函数"><a href="#1．算术函数" class="headerlink" title="1．算术函数"></a>1．算术函数</h3><h3 id="（1）加、减、乘、除"><a href="#（1）加、减、乘、除" class="headerlink" title="（1）加、减、乘、除"></a>（1）加、减、乘、除</h3><p>NumPy算术函数包含简单的加、减、乘、除运算，如add()函数、subtract()函数、multiply()函数和divide()函数。这里要注意的是，数组必须具有相同的形状或符合数组广播规则。</p>
<p>【示例52】　数组加、减、乘、除运算。（示例位置：资源包\MR\Code\08\52）<br>数组加、减、乘、除运算，程序代码如下：</p>
<p>运行程序，输出结果如下：</p>
<h3 id="（2）倒数"><a href="#（2）倒数" class="headerlink" title="（2）倒数"></a>（2）倒数</h3><p>reciprocal()函数用于返回数组中各元素的倒数。如4/3的倒数是3/4。</p>
<p>【示例53】　计算数组元素的倒数。（示例位置：资源包\MR\Code\08\53）<br>计算数组元素的倒数，程序代码如下：</p>
<p>01 import numpy as np<br>02 a = np.array([0.25, 1.75, 2, 100])<br>03 print(np.reciprocal(a))<br>运行程序，输出结果如下：</p>
<p>[4.  0.57142857 0.5  0.01  ]</p>
<h3 id="（3）求幂"><a href="#（3）求幂" class="headerlink" title="（3）求幂"></a>（3）求幂</h3><p>power()函数将第一个数组中的元素作为底数，计算它与第二个数组中相应元素的幂。</p>
<p>【示例54】　数组元素的幂运算。（示例位置：资源包\MR\Code\08\54）<br>对数组元素幂运算，程序代码如下：</p>
<p>01 import numpy as np<br>02 n1 = np.array([10, 100, 1000])<br>03 print(np.power(n1, 3))<br>04 n2= np.array([1, 2, 3])<br>05 print(np.power(n1, n2))<br>运行程序，输出结果如下：</p>
<p>[  1000  1000000 1000000000]<br>[    10    10000 1000000000]</p>
<h3 id="（4）取余"><a href="#（4）取余" class="headerlink" title="（4）取余"></a>（4）取余</h3><p>mod()函数用于计算数组之间相应元素相除后的余数。</p>
<p>【示例55】　对数组元素取余。（示例位置：资源包\MR\Code\08\55）<br>对数组元素取余，程序代码如下：</p>
<p>01  import numpy as np<br>02  n1 = np.array([10, 20, 30])<br>03  n2 = np.array([4, 5, -8])<br>04  print(np.mod(n1, n2))<br>运行程序，输出结果如下：</p>
<p>[ 2  0 -2]</p>
<h3 id="2．舍入函数"><a href="#2．舍入函数" class="headerlink" title="2．舍入函数"></a>2．舍入函数</h3><h3 id="（1）四舍五入around-函数"><a href="#（1）四舍五入around-函数" class="headerlink" title="（1）四舍五入around()函数"></a>（1）四舍五入around()函数</h3><p>四舍五入在NumPy中应用比较多，主要使用around()函数，该函数返回指定小数位数的四舍五入值，语法如下：</p>
<p>numpy.around(a,decimals)<br>参数说明：　</p>
<p>a：数组。　</p>
<p>decimals：舍入的小数位数，默认值为0，如果为负，整数将四舍五入到小数点左侧的位置。</p>
<h3 id="（2）向上取整ceil-函数"><a href="#（2）向上取整ceil-函数" class="headerlink" title="（2）向上取整ceil()函数"></a>（2）向上取整ceil()函数</h3><p>ceil()函数用于返回大于或者等于指定表达式的最小整数，即向上取整。</p>
<p>【示例57】　对数组元素向上取整。（示例位置：资源包\MR\Code\08\57）<br>对数组元素向上取整，程序代码如下：<br>运行程序，输出结果如下：</p>
<p>[-1.  2. -0.  1. 15.]</p>
<h3 id="（3）向下取整floor-函数"><a href="#（3）向下取整floor-函数" class="headerlink" title="（3）向下取整floor()函数"></a>（3）向下取整floor()函数</h3><p>floor()函数用于返回小于或者等于指定表达式的最大整数，即向下取整。</p>
<p>【示例58】　对数组元素向下取整。（示例位置：资源包\MR\Code\08\58）</p>
<p>对数组元素向下取整，程序代码如下：</p>
<p>01  import numpy as np<br>02  n = np.array([-1.8, 1.66, -0.2, 0.888, 15])     #创建数组<br>03  print(np.floor(n))                              #向下取整<br>运行程序，输出结果如下：</p>
<p>[-2.  1. -1.  0. 15.]</p>
<h2 id="8-5-2-统计分析函数"><a href="#8-5-2-统计分析函数" class="headerlink" title="8.5.2　统计分析函数"></a>8.5.2　统计分析函数</h2><h3 id="4．加权平均average"><a href="#4．加权平均average" class="headerlink" title="4．加权平均average()"></a>4．加权平均average()</h3><p>在日常生活中，常用平均数表示一组数据的“平均水平”。在一组数据里，一个数据出现的次数称为权。将一组数据与出现的次数相乘再平均就是“加权平均”。加权平均能够反映一组数据中各个数据的重要程度，以及对整体趋势的影响。加权平均在日常生活应用非常广泛，如考试成绩、股票价格、竞技比赛等。</p>
<p>【示例64】　计算电商各活动销售的加权平均价。（示例位置：资源包\MR\Code\08\64）<br>某电商在开学季、6.18、双十一、双十二等活动价格均不同，下面计算加权平均价，程序代码如下：</p>
<p><img src="/2021/12/09/numPy/image-20211026174836425.png" alt="image-20211026174836425"></p>
<p>运行程序，输出结果如下：</p>
<p>加权平均价：<br>34.84920634920635</p>
<h3 id="5．中位数median"><a href="#5．中位数median" class="headerlink" title="5．中位数median()"></a>5．中位数median()</h3><p>中位数用来衡量数据取值的中等水平或一般水平，可以避免极端值的影响。在数据处理过程中，当数据中存在少量异常值时，它不受其影响，基于这一特点，一般使用中位数来评价分析结果。<br>那么，什么是中位数？将各个变量值按大小顺序排列起来，形成一个数列，居于数列中间位置的那个数即为中位数。例如，1、2、3、4、5这5个数，中位数就是中间的数字3，而1、2、3、4、5、6这6个数，中位数则是中间两个数的平均值，即3.5。</p>
<p>知识胶囊<br>中位数与平均数不同，它不受异常值的影响。例如，将1、2、3、4、5、6改为1、2、3、4、5、288，中位数依然是3.5。</p>
<p>【示例65】　计算电商活动价格的中位数。（示例位置：资源包\MR\Code\08\65）<br>计算电商在开学季、6.18、双十一、双十二等活动价格的中位数，程序代码如下：<br>运行程序，输出结果如下：</p>
<p>数组排序：<br>[33.6 34.5 36. 37.8 39. 39.8]数组中位数为：<br>36.9</p>
<h2 id="8-5-3-数组的排序"><a href="#8-5-3-数组的排序" class="headerlink" title="8.5.3　数组的排序"></a>8.5.3　数组的排序</h2><p>数组的排序是对数组元素进行排序。</p>
<h3 id="1．sort"><a href="#1．sort" class="headerlink" title="1．sort()"></a>1．sort()</h3><p>使用sort()函数进行排序，直接改变原数组，参数axis指定按行排序还是按列排序。</p>
<h3 id="2．argsort-函数"><a href="#2．argsort-函数" class="headerlink" title="2．argsort()函数"></a>2．argsort()函数</h3><p>使用argsort()函数对数组进行排序，返回升序排序之后数组值从小到大的索引值。</p>
<h3 id="3．lexsort-函数"><a href="#3．lexsort-函数" class="headerlink" title="3．lexsort()函数"></a>3．lexsort()函数</h3><p>lexsort()函数用于对多个序列进行排序。可以把它当作是对电子表格进行排序，每一列代表一个序列，排序时优先照顾靠后的列。</p>
<h2 id="NumPy用于图像灰度处理"><a href="#NumPy用于图像灰度处理" class="headerlink" title="NumPy用于图像灰度处理"></a>NumPy用于图像灰度处理</h2><p>案例位置：资源包\MR\Code\08\example\02<br>首先了解一下图像，图像其实是由若干像素组成，每一个像素都有明确的位置和被分配的颜色值，因此一张图像也就构成了一个像素矩阵。例如，一张灰度图片的像素块，如图8.32所示。</p>
<p>​                                                                                      图8.32　灰度图片像素矩阵示意图<br>从图8.32得知：灰度图的数据是一个二维数组，颜色取值为0～255，其中，0为黑色，255为白色。从0～255逐渐由暗色变为亮色。由此可见，图像灰度处理是不是就可以通过数组计算来实现呢？<br>接下来，了解一个公式，RGB转换成灰度图像的常用公式：</p>
<p>Gray = R<em>0.299 + G</em>0.587 + B*0.114<br>其中，Gray表示灰度值，R、G、B表示红、绿、蓝颜色值，0.299、0.587、0.114表示灰度公式的固定值。</p>
<p>下面使用NumPy结合Matplotlib实现图像的灰度处理，程序代码如下：</p>
<p>上述代码，显示灰度图时，需要在imshow()函数中设置参数cmap=”gray”。</p>
]]></content>
      <categories>
        <category>数据分析文档</category>
      </categories>
  </entry>
  <entry>
    <title>Vue  脚手架</title>
    <url>/2021/11/24/vue%E8%84%9A%E6%89%8B%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><h2 id="脚手架文件结构"><a href="#脚手架文件结构" class="headerlink" title="脚手架文件结构"></a>脚手架文件结构</h2><pre><code>├── node_modules 
├── public
│   ├── favicon.ico: 页签图标
│   └── index.html: 主页面
├── src
│   ├── assets: 存放静态资源
│   │   └── logo.png
│   │── component: 存放组件
│   │   └── HelloWorld.vue
│   │── App.vue: 汇总所有组件
│   │── main.js: 入口文件
├── .gitignore: git版本管制忽略的配置
├── babel.config.js: babel的配置文件
├── package.json: 应用包配置文件 
├── README.md: 应用描述文件
├── package-lock.json：包版本控制文件
</code></pre>
<h2 id="关于不同版本的Vue"><a href="#关于不同版本的Vue" class="headerlink" title="关于不同版本的Vue"></a>关于不同版本的Vue</h2><ol>
<li>vue.js与vue.runtime.xxx.js的区别：<ol>
<li>vue.js是完整版的Vue，包含：核心功能 + 模板解析器。</li>
<li>vue.runtime.xxx.js是运行版的Vue，只包含：核心功能；没有模板解析器。</li>
</ol>
</li>
<li>因为vue.runtime.xxx.js没有模板解析器，所以不能使用template这个配置项，需要使用render函数接收到的createElement函数去指定具体内容。</li>
</ol>
<h2 id="vue-config-js配置文件"><a href="#vue-config-js配置文件" class="headerlink" title="vue.config.js配置文件"></a>vue.config.js配置文件</h2><ol>
<li>使用vue inspect &gt; output.js可以查看到Vue脚手架的默认配置。</li>
<li>使用vue.config.js可以对脚手架进行个性化定制，详情见：<a href="https://cli.vuejs.org/zh">https://cli.vuejs.org/zh</a></li>
</ol>
<h2 id="ref属性"><a href="#ref属性" class="headerlink" title="ref属性"></a>ref属性</h2><ol>
<li>被用来给元素或子组件注册引用信息（id的替代者）</li>
<li>应用在html标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象（vc）</li>
<li>使用方式：<ol>
<li>打标识：<code>&lt;h1 ref=&quot;xxx&quot;&gt;.....&lt;/h1&gt;</code> 或 <code>&lt;School ref=&quot;xxx&quot;&gt;&lt;/School&gt;</code></li>
<li>获取：<code>this.$refs.xxx</code></li>
</ol>
</li>
</ol>
<h2 id="props配置项"><a href="#props配置项" class="headerlink" title="props配置项"></a>props配置项</h2><ol>
<li><p>功能：让组件接收外部传过来的数据</p>
</li>
<li><p>传递数据：<code>&lt;Demo name=&quot;xxx&quot;/&gt;</code></p>
</li>
<li><p>接收数据：</p>
<ol>
<li><p>第一种方式（只接收）：<code>props:[&#39;name&#39;] </code></p>
</li>
<li><p>第二种方式（限制类型）：<code>props:&#123;name:String&#125;</code></p>
</li>
<li><p>第三种方式（限制类型、限制必要性、指定默认值）：</p>
<pre><code class="js">props:&#123;
    name:&#123;
    type:String, //类型
    required:true, //必要性
    default:&#39;老王&#39; //默认值
    &#125;
&#125;
</code></pre>
</li>
</ol>
<blockquote>
<p>备注：props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中一份，然后去修改data中的数据。</p>
</blockquote>
</li>
</ol>
<h2 id="mixin-混入"><a href="#mixin-混入" class="headerlink" title="mixin(混入)"></a>mixin(混入)</h2><ol>
<li><p>功能：可以把多个组件共用的配置提取成一个混入对象</p>
</li>
<li><p>使用方式：</p>
<p> 第一步定义混合：</p>
<pre><code class="vue">&#123;
    data()&#123;....&#125;,
    methods:&#123;....&#125;
    ....
&#125;
</code></pre>
<p> 第二步使用混入：</p>
<p> ​    全局混入：<code>Vue.mixin(xxx)</code><br> ​    局部混入：<code>mixins:[&#39;xxx&#39;]    </code></p>
</li>
</ol>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><ol>
<li><p>功能：用于增强Vue</p>
</li>
<li><p>本质：包含install方法的一个对象，install的第一个参数是Vue，第二个以后的参数是插件使用者传递的数据。</p>
</li>
<li><p>定义插件：</p>
<pre><code class="js">对象.install = function (Vue, options) &#123;
    // 1. 添加全局过滤器
    Vue.filter(....)

    // 2. 添加全局指令
    Vue.directive(....)

    // 3. 配置全局混入(合)
    Vue.mixin(....)

    // 4. 添加实例方法
    Vue.prototype.$myMethod = function () &#123;...&#125;
    Vue.prototype.$myProperty = xxxx
&#125;
</code></pre>
</li>
<li><p>使用插件：<code>Vue.use()</code></p>
</li>
</ol>
<h2 id="scoped样式"><a href="#scoped样式" class="headerlink" title="scoped样式"></a>scoped样式</h2><ol>
<li>作用：让样式在局部生效，防止冲突。</li>
<li>写法：<code>&lt;style scoped&gt;</code></li>
</ol>
<h2 id="总结TodoList案例"><a href="#总结TodoList案例" class="headerlink" title="总结TodoList案例"></a>总结TodoList案例</h2><ol>
<li><p>组件化编码流程：</p>
<p> ​    (1).拆分静态组件：组件要按照功能点拆分，命名不要与html元素冲突。</p>
<p> ​    (2).实现动态组件：考虑好数据的存放位置，数据是一个组件在用，还是一些组件在用：</p>
<p> ​            1).一个组件在用：放在组件自身即可。</p>
<p> ​            2). 一些组件在用：放在他们共同的父组件上（<span style="color:red">状态提升</span>）。</p>
<p> ​    (3).实现交互：从绑定事件开始。</p>
</li>
<li><p>props适用于：</p>
<p> ​    (1).父组件 ==&gt; 子组件 通信</p>
<p> ​    (2).子组件 ==&gt; 父组件 通信（要求父先给子一个函数）</p>
</li>
<li><p>使用v-model时要切记：v-model绑定的值不能是props传过来的值，因为props是不可以修改的！</p>
</li>
<li><p>props传过来的若是对象类型的值，修改对象中的属性时Vue不会报错，但不推荐这样做。</p>
</li>
</ol>
<h2 id="webStorage"><a href="#webStorage" class="headerlink" title="webStorage"></a>webStorage</h2><ol>
<li><p>存储内容大小一般支持5MB左右（不同浏览器可能还不一样）</p>
</li>
<li><p>浏览器端通过 Window.sessionStorage 和 Window.localStorage 属性来实现本地存储机制。</p>
</li>
<li><p>相关API：</p>
<ol>
<li><p><code>xxxxxStorage.setItem(&#39;key&#39;, &#39;value&#39;);</code></p>
<pre><code>             该方法接受一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新其对应的值。
</code></pre>
</li>
<li><p><code>xxxxxStorage.getItem(&#39;person&#39;);</code></p>
<p> ​        该方法接受一个键名作为参数，返回键名对应的值。</p>
</li>
<li><p><code>xxxxxStorage.removeItem(&#39;key&#39;);</code></p>
<p> ​        该方法接受一个键名作为参数，并把该键名从存储中删除。</p>
</li>
<li><p><code> xxxxxStorage.clear()</code></p>
<p> ​        该方法会清空存储中的所有数据。</p>
</li>
</ol>
</li>
<li><p>备注：</p>
<ol>
<li>SessionStorage存储的内容会随着浏览器窗口关闭而消失。</li>
<li>LocalStorage存储的内容，需要手动清除才会消失。</li>
<li><code>xxxxxStorage.getItem(xxx)</code>如果xxx对应的value获取不到，那么getItem的返回值是null。</li>
<li><code>JSON.parse(null)</code>的结果依然是null。</li>
</ol>
</li>
</ol>
<h2 id="组件的自定义事件"><a href="#组件的自定义事件" class="headerlink" title="组件的自定义事件"></a>组件的自定义事件</h2><ol>
<li><p>一种组件间通信的方式，适用于：<strong style="color:red">子组件 ===&gt; 父组件</strong></p>
</li>
<li><p>使用场景：A是父组件，B是子组件，B想给A传数据，那么就要在A中给B绑定自定义事件（<span style="color:red">事件的回调在A中</span>）。</p>
</li>
<li><p>绑定自定义事件：</p>
<ol>
<li><p>第一种方式，在父组件中：<code>&lt;Demo @atguigu=&quot;test&quot;/&gt;</code>  或 <code>&lt;Demo v-on:atguigu=&quot;test&quot;/&gt;</code></p>
</li>
<li><p>第二种方式，在父组件中：</p>
<pre><code class="js">&lt;Demo ref=&quot;demo&quot;/&gt;
......
mounted()&#123;
   this.$refs.xxx.$on(&#39;atguigu&#39;,this.test)
&#125;
</code></pre>
</li>
<li><p>若想让自定义事件只能触发一次，可以使用<code>once</code>修饰符，或<code>$once</code>方法。</p>
</li>
</ol>
</li>
<li><p>触发自定义事件：<code>this.$emit(&#39;atguigu&#39;,数据)</code>        </p>
</li>
<li><p>解绑自定义事件<code>this.$off(&#39;atguigu&#39;)</code></p>
</li>
<li><p>组件上也可以绑定原生DOM事件，需要使用<code>native</code>修饰符。</p>
</li>
<li><p>注意：通过<code>this.$refs.xxx.$on(&#39;atguigu&#39;,回调)</code>绑定自定义事件时，回调<span style="color:red">要么配置在methods中</span>，<span style="color:red">要么用箭头函数</span>，否则this指向会出问题！</p>
</li>
</ol>
<h2 id="全局事件总线（GlobalEventBus）"><a href="#全局事件总线（GlobalEventBus）" class="headerlink" title="全局事件总线（GlobalEventBus）"></a>全局事件总线（GlobalEventBus）</h2><ol>
<li><p>一种组件间通信的方式，适用于<span style="color:red">任意组件间通信</span>。</p>
</li>
<li><p>安装全局事件总线：</p>
<pre><code class="js">new Vue(&#123;
    ......
    beforeCreate() &#123;
        Vue.prototype.$bus = this //安装全局事件总线，$bus就是当前应用的vm
    &#125;,
    ......
&#125;) 
</code></pre>
</li>
<li><p>使用事件总线：</p>
<ol>
<li><p>接收数据：A组件想接收数据，则在A组件中给$bus绑定自定义事件，事件的<span style="color:red">回调留在A组件自身。</span></p>
<pre><code class="js">methods()&#123;
  demo(data)&#123;......&#125;
&#125;
......
mounted() &#123;
  this.$bus.$on(&#39;xxxx&#39;,this.demo)
&#125;
</code></pre>
</li>
<li><p>提供数据：<code>this.$bus.$emit(&#39;xxxx&#39;,数据)</code></p>
</li>
</ol>
</li>
<li><p>最好在beforeDestroy钩子中，用$off去解绑<span style="color:red">当前组件所用到的</span>事件。</p>
</li>
</ol>
<h2 id="消息订阅与发布（pubsub）"><a href="#消息订阅与发布（pubsub）" class="headerlink" title="消息订阅与发布（pubsub）"></a>消息订阅与发布（pubsub）</h2><ol>
<li><p>  一种组件间通信的方式，适用于<span style="color:red">任意组件间通信</span>。</p>
</li>
<li><p>使用步骤：</p>
<ol>
<li><p>安装pubsub：<code>npm i pubsub-js</code></p>
</li>
<li><p>引入: <code>import pubsub from &#39;pubsub-js&#39;</code></p>
</li>
<li><p>接收数据：A组件想接收数据，则在A组件中订阅消息，订阅的<span style="color:red">回调留在A组件自身。</span></p>
<pre><code class="js">methods()&#123;
  demo(data)&#123;......&#125;
&#125;
......
mounted() &#123;
  this.pid = pubsub.subscribe(&#39;xxx&#39;,this.demo) //订阅消息
&#125;
</code></pre>
</li>
<li><p>提供数据：<code>pubsub.publish(&#39;xxx&#39;,数据)</code></p>
</li>
<li><p>最好在beforeDestroy钩子中，用<code>PubSub.unsubscribe(pid)</code>去<span style="color:red">取消订阅。</span></p>
<h2 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h2></li>
</ol>
</li>
<li><p>语法：<code>this.$nextTick(回调函数)</code></p>
</li>
<li><p>作用：在下一次 DOM 更新结束后执行其指定的回调。</p>
</li>
<li><p>什么时候用：当改变数据后，要基于更新后的新DOM进行某些操作时，要在nextTick所指定的回调函数中执行。</p>
</li>
</ol>
<h2 id="Vue封装的过度与动画"><a href="#Vue封装的过度与动画" class="headerlink" title="Vue封装的过度与动画"></a>Vue封装的过度与动画</h2><ol>
<li><p>作用：在插入、更新或移除 DOM元素时，在合适的时候给元素添加样式类名。</p>
</li>
<li><p>图示：<img src="https://img04.sogoucdn.com/app/a/100520146/5990c1dff7dc7a8fb3b34b4462bd0105" style="width:60%"></p>
</li>
<li><p>写法：</p>
<ol>
<li><p>准备好样式：</p>
<ul>
<li>元素进入的样式：<ol>
<li>v-enter：进入的起点</li>
<li>v-enter-active：进入过程中</li>
<li>v-enter-to：进入的终点</li>
</ol>
</li>
<li>元素离开的样式：<ol>
<li>v-leave：离开的起点</li>
<li>v-leave-active：离开过程中</li>
<li>v-leave-to：离开的终点</li>
</ol>
</li>
</ul>
</li>
<li><p>使用<code>&lt;transition&gt;</code>包裹要过度的元素，并配置name属性：</p>
<pre><code class="vue">&lt;transition name=&quot;hello&quot;&gt;
    &lt;h1 v-show=&quot;isShow&quot;&gt;你好啊！&lt;/h1&gt;
&lt;/transition&gt;
</code></pre>
</li>
<li><p>备注：若有多个元素需要过度，则需要使用：<code>&lt;transition-group&gt;</code>，且每个元素都要指定<code>key</code>值。</p>
</li>
</ol>
</li>
</ol>
<h2 id="vue脚手架配置代理"><a href="#vue脚手架配置代理" class="headerlink" title="vue脚手架配置代理"></a>vue脚手架配置代理</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>​    在vue.config.js中添加如下配置：</p>
<pre><code class="js">devServer:&#123;
  proxy:&quot;http://localhost:5000&quot;
&#125;
</code></pre>
<p>说明：</p>
<ol>
<li>优点：配置简单，请求资源时直接发给前端（8080）即可。</li>
<li>缺点：不能配置多个代理，不能灵活的控制请求是否走代理。</li>
<li>工作方式：若按照上述配置代理，当请求了前端不存在的资源时，那么该请求会转发给服务器 （优先匹配前端资源）</li>
</ol>
<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>​    编写vue.config.js配置具体代理规则：</p>
<pre><code class="js">module.exports = &#123;
    devServer: &#123;
      proxy: &#123;
      &#39;/api1&#39;: &#123;// 匹配所有以 &#39;/api1&#39;开头的请求路径
        target: &#39;http://localhost:5000&#39;,// 代理目标的基础路径
        changeOrigin: true,
        pathRewrite: &#123;&#39;^/api1&#39;: &#39;&#39;&#125;
      &#125;,
      &#39;/api2&#39;: &#123;// 匹配所有以 &#39;/api2&#39;开头的请求路径
        target: &#39;http://localhost:5001&#39;,// 代理目标的基础路径
        changeOrigin: true,
        pathRewrite: &#123;&#39;^/api2&#39;: &#39;&#39;&#125;
      &#125;
    &#125;
  &#125;
&#125;
/*
   changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000
   changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:8080
   changeOrigin默认值为true
*/
</code></pre>
<p>说明：</p>
<ol>
<li>优点：可以配置多个代理，且可以灵活的控制请求是否走代理。</li>
<li>缺点：配置略微繁琐，请求资源时必须加前缀。</li>
</ol>
<h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><ol>
<li><p>作用：让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式，适用于 <strong style="color:red">父组件 ===&gt; 子组件</strong> 。</p>
</li>
<li><p>分类：默认插槽、具名插槽、作用域插槽</p>
</li>
<li><p>使用方式：</p>
<ol>
<li><p>默认插槽：</p>
<pre><code class="vue">父组件中：
        &lt;Category&gt;
           &lt;div&gt;html结构1&lt;/div&gt;
        &lt;/Category&gt;
子组件中：
        &lt;template&gt;
            &lt;div&gt;
               &lt;!-- 定义插槽 --&gt;
               &lt;slot&gt;插槽默认内容...&lt;/slot&gt;
            &lt;/div&gt;
        &lt;/template&gt;
</code></pre>
</li>
<li><p>具名插槽：</p>
<pre><code class="vue">父组件中：
        &lt;Category&gt;
            &lt;template slot=&quot;center&quot;&gt;
              &lt;div&gt;html结构1&lt;/div&gt;
            &lt;/template&gt;

            &lt;template v-slot:footer&gt;
               &lt;div&gt;html结构2&lt;/div&gt;
            &lt;/template&gt;
        &lt;/Category&gt;
子组件中：
        &lt;template&gt;
            &lt;div&gt;
               &lt;!-- 定义插槽 --&gt;
               &lt;slot name=&quot;center&quot;&gt;插槽默认内容...&lt;/slot&gt;
               &lt;slot name=&quot;footer&quot;&gt;插槽默认内容...&lt;/slot&gt;
            &lt;/div&gt;
        &lt;/template&gt;
</code></pre>
</li>
<li><p>作用域插槽：</p>
<ol>
<li><p>理解：<span style="color:red">数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。</span>（games数据在Category组件中，但使用数据所遍历出来的结构由App组件决定）</p>
</li>
<li><p>具体编码：</p>
<pre><code class="vue">父组件中：
        &lt;Category&gt;
            &lt;template scope=&quot;scopeData&quot;&gt;
                &lt;!-- 生成的是ul列表 --&gt;
                &lt;ul&gt;
                    &lt;li v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/li&gt;
                &lt;/ul&gt;
            &lt;/template&gt;
        &lt;/Category&gt;

        &lt;Category&gt;
            &lt;template slot-scope=&quot;scopeData&quot;&gt;
                &lt;!-- 生成的是h4标题 --&gt;
                &lt;h4 v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/h4&gt;
            &lt;/template&gt;
        &lt;/Category&gt;
子组件中：
        &lt;template&gt;
            &lt;div&gt;
                &lt;slot :games=&quot;games&quot;&gt;&lt;/slot&gt;
            &lt;/div&gt;
        &lt;/template&gt;
        
        &lt;script&gt;
            export default &#123;
                name:&#39;Category&#39;,
                props:[&#39;title&#39;],
                //数据在子组件自身
                data() &#123;
                    return &#123;
                        games:[&#39;红色警戒&#39;,&#39;穿越火线&#39;,&#39;劲舞团&#39;,&#39;超级玛丽&#39;]
                    &#125;
                &#125;,
            &#125;
        &lt;/script&gt;
</code></pre>
<p>```</p>
</li>
</ol>
</li>
</ol>
<p>```</p>
</li>
</ol>
<h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><p>​        在Vue中实现集中式状态（数据）管理的一个Vue插件，对vue应用中多个组件的共享状态进行集中式的管理（读/写），也是一种组件间通信的方式，且适用于任意组件间通信。</p>
<h3 id="2-何时使用？"><a href="#2-何时使用？" class="headerlink" title="2.何时使用？"></a>2.何时使用？</h3><p>​        多个组件需要共享数据时</p>
<h3 id="3-搭建vuex环境"><a href="#3-搭建vuex环境" class="headerlink" title="3.搭建vuex环境"></a>3.搭建vuex环境</h3><ol>
<li><p>创建文件：<code>src/store/index.js</code></p>
<pre><code class="js">//引入Vue核心库
import Vue from &#39;vue&#39;
//引入Vuex
import Vuex from &#39;vuex&#39;
//应用Vuex插件
Vue.use(Vuex)

//准备actions对象——响应组件中用户的动作
const actions = &#123;&#125;
//准备mutations对象——修改state中的数据
const mutations = &#123;&#125;
//准备state对象——保存具体的数据
const state = &#123;&#125;

//创建并暴露store
export default new Vuex.Store(&#123;
    actions,
    mutations,
    state
&#125;)
</code></pre>
</li>
<li><p>在<code>main.js</code>中创建vm时传入<code>store</code>配置项</p>
<pre><code class="js">......
//引入store
import store from &#39;./store&#39;
......

//创建vm
new Vue(&#123;
    el:&#39;#app&#39;,
    render: h =&gt; h(App),
    store
&#125;)
</code></pre>
</li>
</ol>
<h3 id="4-基本使用"><a href="#4-基本使用" class="headerlink" title="4.基本使用"></a>4.基本使用</h3><ol>
<li><p>初始化数据、配置<code>actions</code>、配置<code>mutations</code>，操作文件<code>store.js</code></p>
<pre><code class="js">//引入Vue核心库
import Vue from &#39;vue&#39;
//引入Vuex
import Vuex from &#39;vuex&#39;
//引用Vuex
Vue.use(Vuex)

const actions = &#123;
    //响应组件中加的动作
    jia(context,value)&#123;
        // console.log(&#39;actions中的jia被调用了&#39;,miniStore,value)
        context.commit(&#39;JIA&#39;,value)
    &#125;,
&#125;

const mutations = &#123;
    //执行加
    JIA(state,value)&#123;
        // console.log(&#39;mutations中的JIA被调用了&#39;,state,value)
        state.sum += value
    &#125;
&#125;

//初始化数据
const state = &#123;
   sum:0
&#125;

//创建并暴露store
export default new Vuex.Store(&#123;
    actions,
    mutations,
    state,
&#125;)
</code></pre>
</li>
<li><p>组件中读取vuex中的数据：<code>$store.state.sum</code></p>
</li>
<li><p>组件中修改vuex中的数据：<code>$store.dispatch(&#39;action中的方法名&#39;,数据)</code> 或 <code>$store.commit(&#39;mutations中的方法名&#39;,数据)</code></p>
<blockquote>
<p> 备注：若没有网络请求或其他业务逻辑，组件中也可以越过actions，即不写<code>dispatch</code>，直接编写<code>commit</code></p>
</blockquote>
</li>
</ol>
<h3 id="5-getters的使用"><a href="#5-getters的使用" class="headerlink" title="5.getters的使用"></a>5.getters的使用</h3><ol>
<li><p>概念：当state中的数据需要经过加工后再使用时，可以使用getters加工。</p>
</li>
<li><p>在<code>store.js</code>中追加<code>getters</code>配置</p>
<pre><code class="js">......

const getters = &#123;
    bigSum(state)&#123;
        return state.sum * 10
    &#125;
&#125;

//创建并暴露store
export default new Vuex.Store(&#123;
    ......
    getters
&#125;)
</code></pre>
</li>
<li><p>组件中读取数据：<code>$store.getters.bigSum</code></p>
</li>
</ol>
<h3 id="6-四个map方法的使用"><a href="#6-四个map方法的使用" class="headerlink" title="6.四个map方法的使用"></a>6.四个map方法的使用</h3><ol>
<li><p><strong>mapState方法：</strong>用于帮助我们映射<code>state</code>中的数据为计算属性</p>
<pre><code class="js">computed: &#123;
    //借助mapState生成计算属性：sum、school、subject（对象写法）
     ...mapState(&#123;sum:&#39;sum&#39;,school:&#39;school&#39;,subject:&#39;subject&#39;&#125;),
         
    //借助mapState生成计算属性：sum、school、subject（数组写法）
    ...mapState([&#39;sum&#39;,&#39;school&#39;,&#39;subject&#39;]),
&#125;,
</code></pre>
</li>
<li><p><strong>mapGetters方法：</strong>用于帮助我们映射<code>getters</code>中的数据为计算属性</p>
<pre><code class="js">computed: &#123;
    //借助mapGetters生成计算属性：bigSum（对象写法）
    ...mapGetters(&#123;bigSum:&#39;bigSum&#39;&#125;),

    //借助mapGetters生成计算属性：bigSum（数组写法）
    ...mapGetters([&#39;bigSum&#39;])
&#125;,
</code></pre>
</li>
<li><p><strong>mapActions方法：</strong>用于帮助我们生成与<code>actions</code>对话的方法，即：包含<code>$store.dispatch(xxx)</code>的函数</p>
<pre><code class="js">methods:&#123;
    //靠mapActions生成：incrementOdd、incrementWait（对象形式）
    ...mapActions(&#123;incrementOdd:&#39;jiaOdd&#39;,incrementWait:&#39;jiaWait&#39;&#125;)

    //靠mapActions生成：incrementOdd、incrementWait（数组形式）
    ...mapActions([&#39;jiaOdd&#39;,&#39;jiaWait&#39;])
&#125;
</code></pre>
</li>
<li><p><strong>mapMutations方法：</strong>用于帮助我们生成与<code>mutations</code>对话的方法，即：包含<code>$store.commit(xxx)</code>的函数</p>
<pre><code class="js">methods:&#123;
    //靠mapActions生成：increment、decrement（对象形式）
    ...mapMutations(&#123;increment:&#39;JIA&#39;,decrement:&#39;JIAN&#39;&#125;),
    
    //靠mapMutations生成：JIA、JIAN（对象形式）
    ...mapMutations([&#39;JIA&#39;,&#39;JIAN&#39;]),
&#125;
</code></pre>
</li>
</ol>
<blockquote>
<p>备注：mapActions与mapMutations使用时，若需要传递参数需要：在模板中绑定事件时传递好参数，否则参数是事件对象。</p>
</blockquote>
<h3 id="7-模块化-命名空间"><a href="#7-模块化-命名空间" class="headerlink" title="7.模块化+命名空间"></a>7.模块化+命名空间</h3><ol>
<li><p>目的：让代码更好维护，让多种数据分类更加明确。</p>
</li>
<li><p>修改<code>store.js</code></p>
<pre><code class="javascript">const countAbout = &#123;
  namespaced:true,//开启命名空间
  state:&#123;x:1&#125;,
  mutations: &#123; ... &#125;,
  actions: &#123; ... &#125;,
  getters: &#123;
    bigSum(state)&#123;
       return state.sum * 10
    &#125;
  &#125;
&#125;

const personAbout = &#123;
  namespaced:true,//开启命名空间
  state:&#123; ... &#125;,
  mutations: &#123; ... &#125;,
  actions: &#123; ... &#125;
&#125;

const store = new Vuex.Store(&#123;
  modules: &#123;
    countAbout,
    personAbout
  &#125;
&#125;)
</code></pre>
</li>
<li><p>开启命名空间后，组件中读取state数据：</p>
<pre><code class="js">//方式一：自己直接读取
this.$store.state.personAbout.list
//方式二：借助mapState读取：
...mapState(&#39;countAbout&#39;,[&#39;sum&#39;,&#39;school&#39;,&#39;subject&#39;]),
</code></pre>
</li>
<li><p>开启命名空间后，组件中读取getters数据：</p>
<pre><code class="js">//方式一：自己直接读取
this.$store.getters[&#39;personAbout/firstPersonName&#39;]
//方式二：借助mapGetters读取：
...mapGetters(&#39;countAbout&#39;,[&#39;bigSum&#39;])
</code></pre>
</li>
<li><p>开启命名空间后，组件中调用dispatch</p>
<pre><code class="js">//方式一：自己直接dispatch
this.$store.dispatch(&#39;personAbout/addPersonWang&#39;,person)
//方式二：借助mapActions：
...mapActions(&#39;countAbout&#39;,&#123;incrementOdd:&#39;jiaOdd&#39;,incrementWait:&#39;jiaWait&#39;&#125;)
</code></pre>
</li>
<li><p>开启命名空间后，组件中调用commit</p>
<pre><code class="js">//方式一：自己直接commit
this.$store.commit(&#39;personAbout/ADD_PERSON&#39;,person)
//方式二：借助mapMutations：
...mapMutations(&#39;countAbout&#39;,&#123;increment:&#39;JIA&#39;,decrement:&#39;JIAN&#39;&#125;),
</code></pre>
</li>
</ol>
<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><ol>
<li>理解： 一个路由（route）就是一组映射关系（key - value），多个路由需要路由器（router）进行管理。</li>
<li>前端路由：key是路径，value是组件。</li>
</ol>
<h3 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1.基本使用"></a>1.基本使用</h3><ol>
<li><p>安装vue-router，命令：<code>npm i vue-router</code></p>
</li>
<li><p>应用插件：<code>Vue.use(VueRouter)</code></p>
</li>
<li><p>编写router配置项:</p>
<pre><code class="js">//引入VueRouter
import VueRouter from &#39;vue-router&#39;
//引入Luyou 组件
import About from &#39;../components/About&#39;
import Home from &#39;../components/Home&#39;

//创建router实例对象，去管理一组一组的路由规则
const router = new VueRouter(&#123;
    routes:[
        &#123;
            path:&#39;/about&#39;,
            component:About
        &#125;,
        &#123;
            path:&#39;/home&#39;,
            component:Home
        &#125;
    ]
&#125;)

//暴露router
export default router
</code></pre>
</li>
<li><p>实现切换（active-class可配置高亮样式）</p>
<pre><code class="vue">&lt;router-link active-class=&quot;active&quot; to=&quot;/about&quot;&gt;About&lt;/router-link&gt;
</code></pre>
</li>
<li><p>指定展示位置</p>
<pre><code class="vue">&lt;router-view&gt;&lt;/router-view&gt;
</code></pre>
</li>
</ol>
<h3 id="2-几个注意点"><a href="#2-几个注意点" class="headerlink" title="2.几个注意点"></a>2.几个注意点</h3><ol>
<li>路由组件通常存放在<code>pages</code>文件夹，一般组件通常存放在<code>components</code>文件夹。</li>
<li>通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载。</li>
<li>每个组件都有自己的<code>$route</code>属性，里面存储着自己的路由信息。</li>
<li>整个应用只有一个router，可以通过组件的<code>$router</code>属性获取到。</li>
</ol>
<h3 id="3-多级路由（多级路由）"><a href="#3-多级路由（多级路由）" class="headerlink" title="3.多级路由（多级路由）"></a>3.多级路由（多级路由）</h3><ol>
<li><p>配置路由规则，使用children配置项：</p>
<pre><code class="js">routes:[
    &#123;
        path:&#39;/about&#39;,
        component:About,
    &#125;,
    &#123;
        path:&#39;/home&#39;,
        component:Home,
        children:[ //通过children配置子级路由
            &#123;
                path:&#39;news&#39;, //此处一定不要写：/news
                component:News
            &#125;,
            &#123;
                path:&#39;message&#39;,//此处一定不要写：/message
                component:Message
            &#125;
        ]
    &#125;
]
</code></pre>
</li>
<li><p>跳转（要写完整路径）：</p>
<pre><code class="vue">&lt;router-link to=&quot;/home/news&quot;&gt;News&lt;/router-link&gt;
</code></pre>
</li>
</ol>
<h3 id="4-路由的query参数"><a href="#4-路由的query参数" class="headerlink" title="4.路由的query参数"></a>4.路由的query参数</h3><ol>
<li><p>传递参数</p>
<pre><code class="vue">&lt;!-- 跳转并携带query参数，to的字符串写法 --&gt;
&lt;router-link :to=&quot;/home/message/detail?id=666&amp;title=你好&quot;&gt;跳转&lt;/router-link&gt;
                
&lt;!-- 跳转并携带query参数，to的对象写法 --&gt;
&lt;router-link 
    :to=&quot;&#123;
        path:&#39;/home/message/detail&#39;,
        query:&#123;
           id:666,
            title:&#39;你好&#39;
        &#125;
    &#125;&quot;
&gt;跳转&lt;/router-link&gt;
</code></pre>
</li>
<li><p>接收参数：</p>
<pre><code class="js">$route.query.id
$route.query.title
</code></pre>
</li>
</ol>
<h3 id="5-命名路由"><a href="#5-命名路由" class="headerlink" title="5.命名路由"></a>5.命名路由</h3><ol>
<li><p>作用：可以简化路由的跳转。</p>
</li>
<li><p>如何使用</p>
<ol>
<li><p>给路由命名：</p>
<pre><code class="js">&#123;
    path:&#39;/demo&#39;,
    component:Demo,
    children:[
        &#123;
            path:&#39;test&#39;,
            component:Test,
            children:[
                &#123;
                      name:&#39;hello&#39; //给路由命名
                    path:&#39;welcome&#39;,
                    component:Hello,
                &#125;
            ]
        &#125;
    ]
&#125;
</code></pre>
</li>
<li><p>简化跳转：</p>
<pre><code class="vue">&lt;!--简化前，需要写完整的路径 --&gt;
&lt;router-link to=&quot;/demo/test/welcome&quot;&gt;跳转&lt;/router-link&gt;

&lt;!--简化后，直接通过名字跳转 --&gt;
&lt;router-link :to=&quot;&#123;name:&#39;hello&#39;&#125;&quot;&gt;跳转&lt;/router-link&gt;

&lt;!--简化写法配合传递参数 --&gt;
&lt;router-link 
    :to=&quot;&#123;
        name:&#39;hello&#39;,
        query:&#123;
           id:666,
            title:&#39;你好&#39;
        &#125;
    &#125;&quot;
&gt;跳转&lt;/router-link&gt;
</code></pre>
</li>
</ol>
</li>
</ol>
<h3 id="6-路由的params参数"><a href="#6-路由的params参数" class="headerlink" title="6.路由的params参数"></a>6.路由的params参数</h3><ol>
<li><p>配置路由，声明接收params参数</p>
<pre><code class="js">&#123;
    path:&#39;/home&#39;,
    component:Home,
    children:[
        &#123;
            path:&#39;news&#39;,
            component:News
        &#125;,
        &#123;
            component:Message,
            children:[
                &#123;
                    name:&#39;xiangqing&#39;,
                    path:&#39;detail/:id/:title&#39;, //使用占位符声明接收params参数
                    component:Detail
                &#125;
            ]
        &#125;
    ]
&#125;
</code></pre>
</li>
<li><p>传递参数</p>
<pre><code class="vue">&lt;!-- 跳转并携带params参数，to的字符串写法 --&gt;
&lt;router-link :to=&quot;/home/message/detail/666/你好&quot;&gt;跳转&lt;/router-link&gt;
                
&lt;!-- 跳转并携带params参数，to的对象写法 --&gt;
&lt;router-link 
    :to=&quot;&#123;
        name:&#39;xiangqing&#39;,
        params:&#123;
           id:666,
            title:&#39;你好&#39;
        &#125;
    &#125;&quot;
&gt;跳转&lt;/router-link&gt;
</code></pre>
<blockquote>
<p>特别注意：路由携带params参数时，若使用to的对象写法，则不能使用path配置项，必须使用name配置！</p>
</blockquote>
</li>
<li><p>接收参数：</p>
<pre><code class="js">$route.params.id
$route.params.title
</code></pre>
</li>
</ol>
<h3 id="7-路由的props配置"><a href="#7-路由的props配置" class="headerlink" title="7.路由的props配置"></a>7.路由的props配置</h3><p>​    作用：让路由组件更方便的收到参数</p>
<pre><code class="js">&#123;
    name:&#39;xiangqing&#39;,
    path:&#39;detail/:id&#39;,
    component:Detail,

    //第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件
    // props:&#123;a:900&#125;

    //第二种写法：props值为布尔值，布尔值为true，则把路由收到的所有params参数通过props传给Detail组件
    // props:true
    
    //第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件
    props(route)&#123;
        return &#123;
            id:route.query.id,
            title:route.query.title
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="8-lt-router-link-gt-的replace属性"><a href="#8-lt-router-link-gt-的replace属性" class="headerlink" title="8.&lt;router-link&gt;的replace属性"></a>8.<code>&lt;router-link&gt;</code>的replace属性</h3><ol>
<li>作用：控制路由跳转时操作浏览器历史记录的模式</li>
<li>浏览器的历史记录有两种写入方式：分别为<code>push</code>和<code>replace</code>，<code>push</code>是追加历史记录，<code>replace</code>是替换当前记录。路由跳转时候默认为<code>push</code></li>
<li>如何开启<code>replace</code>模式：<code>&lt;router-link replace .......&gt;News&lt;/router-link&gt;</code></li>
</ol>
<h3 id="9-编程式路由导航"><a href="#9-编程式路由导航" class="headerlink" title="9.编程式路由导航"></a>9.编程式路由导航</h3><ol>
<li><p>作用：不借助<code>&lt;router-link&gt; </code>实现路由跳转，让路由跳转更加灵活</p>
</li>
<li><p>具体编码：</p>
<pre><code class="js">//$router的两个API
this.$router.push(&#123;
    name:&#39;xiangqing&#39;,
        params:&#123;
            id:xxx,
            title:xxx
        &#125;
&#125;)

this.$router.replace(&#123;
    name:&#39;xiangqing&#39;,
        params:&#123;
            id:xxx,
            title:xxx
        &#125;
&#125;)
this.$router.forward() //前进
this.$router.back() //后退
this.$router.go() //可前进也可后退
</code></pre>
</li>
</ol>
<h3 id="10-缓存路由组件"><a href="#10-缓存路由组件" class="headerlink" title="10.缓存路由组件"></a>10.缓存路由组件</h3><ol>
<li><p>作用：让不展示的路由组件保持挂载，不被销毁。</p>
</li>
<li><p>具体编码：</p>
<pre><code class="vue">&lt;keep-alive include=&quot;News&quot;&gt; 
    &lt;router-view&gt;&lt;/router-view&gt;
&lt;/keep-alive&gt;
</code></pre>
</li>
</ol>
<h3 id="11-两个新的生命周期钩子"><a href="#11-两个新的生命周期钩子" class="headerlink" title="11.两个新的生命周期钩子"></a>11.两个新的生命周期钩子</h3><ol>
<li>作用：路由组件所独有的两个钩子，用于捕获路由组件的激活状态。</li>
<li>具体名字：<ol>
<li><code>activated</code>路由组件被激活时触发。</li>
<li><code>deactivated</code>路由组件失活时触发。</li>
</ol>
</li>
</ol>
<h3 id="12-路由守卫"><a href="#12-路由守卫" class="headerlink" title="12.路由守卫"></a>12.路由守卫</h3><ol>
<li><p>作用：对路由进行权限控制</p>
</li>
<li><p>分类：全局守卫、独享守卫、组件内守卫</p>
</li>
<li><p>全局守卫:</p>
<pre><code class="js">//全局前置守卫：初始化时执行、每次路由切换前执行
router.beforeEach((to,from,next)=&gt;&#123;
    console.log(&#39;beforeEach&#39;,to,from)
    if(to.meta.isAuth)&#123; //判断当前路由是否需要进行权限控制
        if(localStorage.getItem(&#39;school&#39;) === &#39;atguigu&#39;)&#123; //权限控制的具体规则
            next() //放行
        &#125;else&#123;
            alert(&#39;暂无权限查看&#39;)
            // next(&#123;name:&#39;guanyu&#39;&#125;)
        &#125;
    &#125;else&#123;
        next() //放行
    &#125;
&#125;)

//全局后置守卫：初始化时执行、每次路由切换后执行
router.afterEach((to,from)=&gt;&#123;
    console.log(&#39;afterEach&#39;,to,from)
    if(to.meta.title)&#123; 
        document.title = to.meta.title //修改网页的title
    &#125;else&#123;
        document.title = &#39;vue_test&#39;
    &#125;
&#125;)
</code></pre>
</li>
<li><p>独享守卫:</p>
<pre><code class="js">beforeEnter(to,from,next)&#123;
    console.log(&#39;beforeEnter&#39;,to,from)
    if(to.meta.isAuth)&#123; //判断当前路由是否需要进行权限控制
        if(localStorage.getItem(&#39;school&#39;) === &#39;atguigu&#39;)&#123;
            next()
        &#125;else&#123;
            alert(&#39;暂无权限查看&#39;)
            // next(&#123;name:&#39;guanyu&#39;&#125;)
        &#125;
    &#125;else&#123;
        next()
    &#125;
&#125;
</code></pre>
</li>
<li><p>组件内守卫：</p>
<pre><code class="js">//进入守卫：通过路由规则，进入该组件时被调用
beforeRouteEnter (to, from, next) &#123;
&#125;,
//离开守卫：通过路由规则，离开该组件时被调用
beforeRouteLeave (to, from, next) &#123;
&#125;
</code></pre>
</li>
</ol>
<h3 id="13-路由器的两种工作模式"><a href="#13-路由器的两种工作模式" class="headerlink" title="13.路由器的两种工作模式"></a>13.路由器的两种工作模式</h3><ol>
<li>对于一个url来说，什么是hash值？—— #及其后面的内容就是hash值。</li>
<li>hash值不会包含在 HTTP 请求中，即：hash值不会带给服务器。</li>
<li>hash模式：<ol>
<li>地址中永远带着#号，不美观 。</li>
<li>若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法。</li>
<li>兼容性较好。</li>
</ol>
</li>
<li>history模式：<ol>
<li>地址干净，美观 。</li>
<li>兼容性和hash模式相比略差。</li>
<li>应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题。</li>
</ol>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Vue  单文件</title>
    <url>/2021/11/24/vue%E5%8D%95%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="初识Vue："><a href="#初识Vue：" class="headerlink" title="初识Vue："></a>初识Vue：</h1><p>​        1.想让Vue工作，就必须创建一个Vue实例，且要传入一个配置对象；</p>
<p>​        2.root容器里的代码依然符合html规范，只不过混入了一些特殊的Vue语法；</p>
<p>​        3.root容器里的代码被称为【Vue模板】；</p>
<p>​        4.Vue实例和容器是一一对应的；</p>
<p>​        5.真实开发中只有一个Vue实例，并且会配合着组件一起使用；</p>
<p>​        6.中的xxx要写js表达式，且xxx可以自动读取到data中的所有属性；</p>
<p>​        7.一旦data中的数据发生改变，那么页面中用到该数据的地方也会自动更新；</p>
<p>​        注意区分：js表达式 和 js代码(语句)</p>
<pre><code class="javascript">            1.表达式：一个表达式会产生一个值，可以放在任何一个需要值的地方：

​                  (1). a

​                  (2). a+b

​                  (3). demo(1)

​                  (4). x === y ? &#39;a&#39; : &#39;b&#39;
</code></pre>
<pre><code>            2.js代码(语句)

​                  (1). if()&#123;&#125;

​                  (2). for()&#123;&#125;
</code></pre>
<h1 id="Vue模板语法有2大类："><a href="#Vue模板语法有2大类：" class="headerlink" title="Vue模板语法有2大类："></a>Vue模板语法有2大类：</h1><h2 id="1-插值语法："><a href="#1-插值语法：" class="headerlink" title="1.插值语法："></a>1.插值语法：</h2><p>​              功能：用于解析标签体内容。</p>
<p>​              写法：，xxx是js表达式，且可以直接读取到data中的所有属性。</p>
<h2 id="2-指令语法："><a href="#2-指令语法：" class="headerlink" title="2.指令语法："></a>2.指令语法：</h2><p>​              功能：用于解析标签（包括：标签属性、标签体内容、绑定事件…..）。</p>
<p>​              举例：v-bind:href=”xxx” 或 简写为 :href=”xxx”，xxx同样要写js表达式，</p>
<p>​                   且可以直接读取到data中的所有属性。</p>
<p>​              备注：Vue中有很多的指令，且形式都是：v-????，此处我们只是拿v-bind举个例子。</p>
<h1 id="Vue中有2种数据绑定的方式："><a href="#Vue中有2种数据绑定的方式：" class="headerlink" title="Vue中有2种数据绑定的方式："></a>Vue中有2种数据绑定的方式：</h1><p>​          1.单向绑定(v-bind)：数据只能从data流向页面。</p>
<p>​          2.双向绑定(v-model)：数据不仅能从data流向页面，还可以从页面流向data。</p>
<p>​            备注：</p>
<p>​                1.双向绑定一般都应用在表单类元素上（如：input、select等）</p>
<p>​                2.v-model:value 可以简写为 v-model，因为v-model默认收集的就是value值。</p>
<h1 id="data与el的2种写法"><a href="#data与el的2种写法" class="headerlink" title="data与el的2种写法"></a>data与el的2种写法</h1><h2 id="1-el有2种写法"><a href="#1-el有2种写法" class="headerlink" title="1.el有2种写法"></a>1.el有2种写法</h2><p>​                  (1).new Vue时候配置el属性。</p>
<p>​                  (2).先创建Vue实例，随后再通过vm.$mount(‘#root’)指定el的值。</p>
<h2 id="2-data有2种写法"><a href="#2-data有2种写法" class="headerlink" title="2.data有2种写法"></a>2.data有2种写法</h2><p>​                  (1).对象式</p>
<p>​                  (2).函数式</p>
<p>​                  如何选择：目前哪种写法都可以，以后学习到组件时，data必须使用函数式，否则会报错。</p>
<h2 id="3-一个重要的原则："><a href="#3-一个重要的原则：" class="headerlink" title="3.一个重要的原则："></a>3.一个重要的原则：</h2><p>​                  由Vue管理的函数，一定不要写箭头函数，一旦写了箭头函数，this就不再是Vue实例了。</p>
<h1 id="MVVM模型"><a href="#MVVM模型" class="headerlink" title="MVVM模型"></a>MVVM模型</h1><pre><code>            \1. M：模型(Model) ：data中的数据

​            \2. V：视图(View) ：模板代码

​            \3. VM：视图模型(ViewModel)：Vue实例
</code></pre>
<p>​      观察发现：</p>
<p>​            1.data中所有的属性，最后都出现在了vm身上。</p>
<p>​            2.vm身上所有的属性 及 Vue原型上所有属性，在Vue模板中都可以直接使用。</p>
<h1 id="回顾Object-defineproperty方法"><a href="#回顾Object-defineproperty方法" class="headerlink" title="回顾Object.defineproperty方法"></a>回顾Object.defineproperty方法</h1><pre><code class="javascript">&lt;script type=&quot;text/javascript&quot; &gt;
let number = 18
let person = &#123;
name:&#39;张三&#39;,
sex:&#39;男&#39;,
&#125;

Object.defineProperty(person,&#39;age&#39;,&#123;
// value:18,
// enumerable:true, //控制属性是否可以枚举，默认值是false
// writable:true, //控制属性是否可以被修改，默认值是false
// configurable:true //控制属性是否可以被删除，默认值是false

//当有人读取person的age属性时，get函数(getter)就会被调用，且返回值就是age的值
get()&#123;
console.log(&#39;有人读取age属性了&#39;)
return number
&#125;,

//当有人修改person的age属性时，set函数(setter)就会被调用，且会收到修改的具体值
set(value)&#123;
console.log(&#39;有人修改了age属性，且值是&#39;,value)
number = value
&#125;

&#125;)

// console.log(Object.keys(person))

console.log(person)
&lt;/script&gt;
</code></pre>
<h1 id="何为数据代理"><a href="#何为数据代理" class="headerlink" title="何为数据代理"></a>何为数据代理</h1><pre><code class="javascript">&lt;!-- 数据代理：通过一个对象代理对另一个对象中属性的操作（读/写）--&gt;
        &lt;script type=&quot;text/javascript&quot; &gt;
            let obj = &#123;x:100&#125;
            let obj2 = &#123;y:200&#125;

            Object.defineProperty(obj2,&#39;x&#39;,&#123;
                get()&#123;
                    return obj.x
                &#125;,
                set(value)&#123;
                    obj.x = value
                &#125;
            &#125;)
        &lt;/script&gt;
</code></pre>
<h1 id="Vue中的数据代理"><a href="#Vue中的数据代理" class="headerlink" title="Vue中的数据代理"></a>Vue中的数据代理</h1><pre><code class="javascript">1.Vue中的数据代理：
    通过vm对象来代理data对象中属性的操作（读/写）
2.Vue中数据代理的好处：
    更加方便的操作data中的数据
3.基本原理：
    通过Object.defineProperty()把data对象中所有属性添加到vm上。
    为每一个添加到vm上的属性，都指定一个getter/setter。
    在getter/setter内部去操作（读/写）data中对应的属性。
</code></pre>
<h1 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h1><p>事件的基本使用：</p>
<pre><code class="javascript">              1.使用v-on:xxx 或 @xxx 绑定事件，其中xxx是事件名；

​              2.事件的回调需要配置在methods对象中，最终会在vm上；

​              3.methods中配置的函数，不要用箭头函数！否则this就不是vm了；

​              4.methods中配置的函数，都是被Vue所管理的函数，this的指向是vm 或 组件实例对象；

​              5.@click=&quot;demo&quot; 和 @click=&quot;demo($event)&quot; 效果一致，但后者可以传参；
</code></pre>
<pre><code class="javascript">Vue中的事件修饰符：

​            1.prevent：阻止默认事件（常用）；

​            2.stop：阻止事件冒泡（常用）；

​            3.once：事件只触发一次（常用）；

​            4.capture：使用事件的捕获模式；

​            5.self：只有event.target是当前操作的元素时才触发事件；

​            6.passive：事件的默认行为立即执行，无需等待事件回调执行完毕；
</code></pre>
<pre><code class="javascript">1.Vue中常用的按键别名：
                            回车 =&gt; enter
                            删除 =&gt; delete (捕获“删除”和“退格”键)
                            退出 =&gt; esc
                            空格 =&gt; space
                            换行 =&gt; tab (特殊，必须配合keydown去使用)
                            上 =&gt; up
                            下 =&gt; down
                            左 =&gt; left
                            右 =&gt; right

                2.Vue未提供别名的按键，可以使用按键原始的key值去绑定，但注意要转为kebab-case（短横线命名）

                3.系统修饰键（用法特殊）：ctrl、alt、shift、meta
                            (1).配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发。
                            (2).配合keydown使用：正常触发事件。

                4.也可以使用keyCode去指定具体的按键（不推荐）

                5.Vue.config.keyCodes.自定义键名 = 键码，可以去定制按键别名
</code></pre>
<h1 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h1><h3 id="插值语法实现"><a href="#插值语法实现" class="headerlink" title="插值语法实现"></a>插值语法实现</h3><pre><code>html
    &lt;!-- 准备好一个容器--&gt;
        &lt;div id=&quot;root&quot;&gt;
            姓：&lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; &lt;br/&gt;&lt;br/&gt;
            名：&lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt; &lt;br/&gt;&lt;br/&gt;
            全名：&lt;span&gt;&#123;&#123;firstName&#125;&#125;-&#123;&#123;lastName&#125;&#125;&lt;/span&gt;
        &lt;/div&gt;
js
    new Vue(&#123;
            el:&#39;#root&#39;,
            data:&#123;
                firstName:&#39;张&#39;,
                lastName:&#39;三&#39;
            &#125;
        &#125;)
</code></pre>
<h3 id="methods实现"><a href="#methods实现" class="headerlink" title="methods实现"></a>methods实现</h3><pre><code>html 
    &lt;!-- 准备好一个容器--&gt;
        &lt;div id=&quot;root&quot;&gt;
            姓：&lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; &lt;br/&gt;&lt;br/&gt;
            名：&lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt; &lt;br/&gt;&lt;br/&gt;
            全名：&lt;span&gt;&#123;&#123;fullName()&#125;&#125;&lt;/span&gt;
        &lt;/div&gt;
js 
    new Vue(&#123;
            el:&#39;#root&#39;,
            data:&#123;
                firstName:&#39;张&#39;,
                lastName:&#39;三&#39;
            &#125;,
            methods: &#123;
                fullName()&#123;
                    console.log(&#39;@---fullName&#39;)
                    return this.firstName + &#39;-&#39; + this.lastName
                &#125;
            &#125;,
        &#125;)
</code></pre>
<h3 id="计算属性实现"><a href="#计算属性实现" class="headerlink" title="计算属性实现"></a>计算属性实现</h3><pre><code>计算属性：
    1.定义：要用的属性不存在，要通过已有属性计算得来。
    2.原理：底层借助了Objcet.defineproperty方法提供的getter和setter。
    3.get函数什么时候执行？
        (1).初次读取时会执行一次。
        (2).当依赖的数据发生改变时会被再次调用。
    4.优势：与methods实现相比，内部有缓存机制（复用），效率更高，调试方便。
    5.备注：
        1.计算属性最终会出现在vm上，直接读取使用即可。
        2.如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变。
html
        &lt;div id=&quot;root&quot;&gt;
            姓：&lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; &lt;br/&gt;&lt;br/&gt;
            名：&lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt; &lt;br/&gt;&lt;br/&gt;
            测试：&lt;input type=&quot;text&quot; v-model=&quot;x&quot;&gt; &lt;br/&gt;&lt;br/&gt;
            全名：&lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;br/&gt;&lt;br/&gt;
            &lt;!-- 全名：&lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;br/&gt;&lt;br/&gt;
            全名：&lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;br/&gt;&lt;br/&gt;
            全名：&lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; --&gt;
        &lt;/div&gt;
js 
    const vm = new Vue(&#123;
            el:&#39;#root&#39;,
            data:&#123;
                firstName:&#39;张&#39;,
                lastName:&#39;三&#39;,
                x:&#39;你好&#39;
            &#125;,
            methods: &#123;
                demo()&#123;
                    
                &#125;
            &#125;,
            computed:&#123;
                fullName:&#123;
                    //get有什么作用？当有人读取fullName时，get就会被调用，且返回值就作为fullName的值
                    //get什么时候调用？1.初次读取fullName时。2.所依赖的数据发生变化时。
                    get()&#123;
                        console.log(&#39;get被调用了&#39;)
                        // console.log(this) //此处的this是vm
                        return this.firstName + &#39;-&#39; + this.lastName
                    &#125;,
                    //set什么时候调用? 当fullName被修改时。
                    set(value)&#123;
                        console.log(&#39;set&#39;,value)
                        const arr = value.split(&#39;-&#39;)
                        this.firstName = arr[0]
                        this.lastName = arr[1]
                    &#125;
                &#125;
            &#125;
        &#125;)
</code></pre>
<h4 id="简写"><a href="#简写" class="headerlink" title="简写"></a>简写</h4><pre><code>html
    &lt;div id=&quot;root&quot;&gt;
        姓：&lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; &lt;br/&gt;&lt;br/&gt;
        名：&lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt; &lt;br/&gt;&lt;br/&gt;
        全名：&lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;br/&gt;&lt;br/&gt;
    &lt;/div&gt;
js
    const vm = new Vue(&#123;
            el:&#39;#root&#39;,
            data:&#123;
                firstName:&#39;张&#39;,
                lastName:&#39;三&#39;,
            &#125;,
            computed:&#123;
                //简写
                fullName()&#123;
                    console.log(&#39;get被调用了&#39;)
                    return this.firstName + &#39;-&#39; + this.lastName
                &#125;
            &#125;
        &#125;)
</code></pre>
<h1 id="监视属性"><a href="#监视属性" class="headerlink" title="监视属性"></a>监视属性</h1><pre><code>html
    &lt;div id=&quot;root&quot;&gt;
            &lt;h2&gt;今天天气很&#123;&#123;info&#125;&#125;&lt;/h2&gt;
            &lt;!-- 绑定事件的时候：@xxx=&quot;yyy&quot; yyy可以写一些简单的语句 --&gt;
            &lt;!-- &lt;button @click=&quot;isHot = !isHot&quot;&gt;切换天气&lt;/button&gt; --&gt;
            &lt;button @click=&quot;changeWeather&quot;&gt;切换天气&lt;/button&gt;
    &lt;/div&gt;
    
js
    const vm = new Vue(&#123;
            el:&#39;#root&#39;,
            data:&#123;
                isHot:true,
            &#125;,
            computed:&#123;
                info()&#123;
                    return this.isHot ? &#39;炎热&#39; : &#39;凉爽&#39;
                &#125;
            &#125;,
            methods: &#123;
                changeWeather()&#123;
                    this.isHot = !this.isHot
                &#125;
            &#125;,
        &#125;)
</code></pre>
<h4 id="监视属性watch："><a href="#监视属性watch：" class="headerlink" title="监视属性watch："></a>监视属性watch：</h4><pre><code>          1.当被监视的属性变化时, 回调函数自动调用, 进行相关操作

​          2.监视的属性必须存在，才能进行监视！！

​          3.监视的两种写法：

​              (1).new Vue时传入watch配置

​              (2).通过vm.$watch监视
</code></pre>
<pre><code>            /* watch:&#123;
                isHot:&#123;
                    immediate:true, //初始化时让handler调用一下
                    //handler什么时候调用？当isHot发生改变时。
                    handler(newValue,oldValue)&#123;
                        console.log(&#39;isHot被修改了&#39;,newValue,oldValue)
                    &#125;
                &#125;
            &#125; */
            
            
            
            
            vm.$watch(&#39;isHot&#39;,&#123;
                immediate:true, //初始化时让handler调用一下
                //handler什么时候调用？当isHot发生改变时。
                handler(newValue,oldValue)&#123;
                console.log(&#39;isHot被修改了&#39;,newValue,oldValue)
                &#125;
            &#125;)
</code></pre>
<h2 id="深度监视："><a href="#深度监视：" class="headerlink" title="深度监视："></a>深度监视：</h2><pre><code>            (1).Vue中的watch默认不监测对象内部值的改变（一层）。

​            (2).配置deep:true可以监测对象内部值改变（多层）。

​        备注：

​            (1).Vue自身可以监测对象内部值的改变，但Vue提供的watch默认不可以！

​            (2).使用watch时根据数据的具体结构，决定是否采用深度监视。
</code></pre>
<h2 id="简写-1"><a href="#简写-1" class="headerlink" title="简写"></a>简写</h2><pre><code>watch: &#123;
            //正常写法
            /* isHot:&#123;
                // immediate:true, //初始化时让handler调用一下
                // deep:true,//深度监视
                handler(newValue,oldValue)&#123;
                    console.log(&#39;isHot被修改了&#39;,newValue,oldValue)
                &#125;
            &#125;, */
            //简写
            /* isHot(newValue,oldValue)&#123;
                console.log(&#39;isHot被修改了&#39;,newValue,oldValue,this)
            &#125; */
        &#125;
</code></pre>
<h1 id="computed和watch之间的区别："><a href="#computed和watch之间的区别：" class="headerlink" title="computed和watch之间的区别："></a>computed和watch之间的区别：</h1><pre><code>            1.computed能完成的功能，watch都可以完成。

​            2.watch能完成的功能，computed不一定能完成，例如：watch可以进行异步操作。

​        两个重要的小原则：

​              1.所被Vue管理的函数，最好写成普通函数，这样this的指向才是vm 或 组件实例对象。

​              2.所有不被Vue所管理的函数（定时器的回调函数、ajax的回调函数等、Promise的回调函数），最好写成箭头函数，

​                这样this的指向才是vm 或 组件实例对象。
</code></pre>
<h1 id="收集表单数据"><a href="#收集表单数据" class="headerlink" title="收集表单数据"></a>收集表单数据</h1><pre><code>收集表单数据：
    若：&lt;input type=&quot;text&quot;/&gt;，则v-model收集的是value值，用户输入的就是value值。
    若：&lt;input type=&quot;radio&quot;/&gt;，则v-model收集的是value值，且要给标签配置value值。
    若：&lt;input type=&quot;checkbox&quot;/&gt;
    1.没有配置input的value属性，那么收集的就是checked（勾选 or 未勾选，是布尔值）
    2.配置input的value属性:
    (1)v-model的初始值是非数组，那么收集的就是checked（勾选 or 未勾选，是布尔值）
    (2)v-model的初始值是数组，那么收集的的就是value组成的数组
    备注：v-model的三个修饰符：
    lazy：失去焦点再收集数据
    number：输入字符串转为有效的数字
    trim：输入首尾空格过滤
</code></pre>
<pre><code>&lt;form @submit.prevent=&quot;demo&quot;&gt;
                账号：&lt;input type=&quot;text&quot; v-model.trim=&quot;userInfo.account&quot;&gt; &lt;br/&gt;&lt;br/&gt;
                密码：&lt;input type=&quot;password&quot; v-model=&quot;userInfo.password&quot;&gt; &lt;br/&gt;&lt;br/&gt;
                年龄：&lt;input type=&quot;number&quot; v-model.number=&quot;userInfo.age&quot;&gt; &lt;br/&gt;&lt;br/&gt;
                性别：
                男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; v-model=&quot;userInfo.sex&quot; value=&quot;male&quot;&gt;
                女&lt;input type=&quot;radio&quot; name=&quot;sex&quot; v-model=&quot;userInfo.sex&quot; value=&quot;female&quot;&gt; &lt;br/&gt;&lt;br/&gt;
                爱好：
                学习&lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.hobby&quot; value=&quot;study&quot;&gt;
                打游戏&lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.hobby&quot; value=&quot;game&quot;&gt;
                吃饭&lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.hobby&quot; value=&quot;eat&quot;&gt;
                &lt;br/&gt;&lt;br/&gt;
                所属校区
                &lt;select v-model=&quot;userInfo.city&quot;&gt;
                    &lt;option value=&quot;&quot;&gt;请选择校区&lt;/option&gt;
                    &lt;option value=&quot;beijing&quot;&gt;北京&lt;/option&gt;
                    &lt;option value=&quot;shanghai&quot;&gt;上海&lt;/option&gt;
                    &lt;option value=&quot;shenzhen&quot;&gt;深圳&lt;/option&gt;
                    &lt;option value=&quot;wuhan&quot;&gt;武汉&lt;/option&gt;
                &lt;/select&gt;
                &lt;br/&gt;&lt;br/&gt;
                其他信息：
                &lt;textarea v-model.lazy=&quot;userInfo.other&quot;&gt;&lt;/textarea&gt; &lt;br/&gt;&lt;br/&gt;
                &lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.agree&quot;&gt;阅读并接受&lt;a href=&quot;http://www.atguigu.com&quot;&gt;《用户协议》&lt;/a&gt;
                &lt;button&gt;提交&lt;/button&gt;
&lt;/form&gt;
            
            
            
            
data:&#123;
    userInfo:&#123;
    account:&#39;&#39;,
    password:&#39;&#39;,
    age:18,
    sex:&#39;female&#39;,
    hobby:[],
    city:&#39;beijing&#39;,
    other:&#39;&#39;,
    agree:&#39;&#39;
&#125;
</code></pre>
<h1 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h1><pre><code>过滤器：
    定义：对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑的处理）。
    语法：
    1.注册过滤器：Vue.filter(name,callback) 或 new Vue&#123;filters:&#123;&#125;&#125;
    2.使用过滤器：&#123;&#123; xxx | 过滤器名&#125;&#125;  或  v-bind:属性 = &quot;xxx | 过滤器名&quot;
    备注：
    1.过滤器也可以接收额外参数、多个过滤器也可以串联
    2.并没有改变原本的数据, 是产生新的对应的数据
</code></pre>
<pre><code>    //全局过滤器
    Vue.filter(&#39;mySlice&#39;,function(value)&#123;
        return value.slice(0,4)
    &#125;)

    //局部过滤器
    filters:&#123;
        timeFormater(value,str=&#39;YYYY年MM月DD日 HH:mm:ss&#39;)&#123;
        // console.log(&#39;@&#39;,value)
        return dayjs(value).format(str)
        &#125;
    &#125;
</code></pre>
<h1 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h1><pre><code>我们学过的指令：
    v-bind    : 单向绑定解析表达式, 可简写为 :xxx
    v-model    : 双向数据绑定
    v-for      : 遍历数组/对象/字符串
    v-on       : 绑定事件监听, 可简写为@
    v-if          : 条件渲染（动态控制节点是否存存在）
    v-else     : 条件渲染（动态控制节点是否存存在）
    v-show     : 条件渲染 (动态控制节点是否展示)
    v-text指令：
    1.作用：向其所在的节点中渲染文本内容。
    2.与插值语法的区别：v-text会替换掉节点中的内容，&#123;&#123;xx&#125;&#125;则不会。
</code></pre>
<pre><code>v-html指令：
    1.作用：向指定节点中渲染包含html结构的内容。
    2.与插值语法的区别：
    (1).v-html会替换掉节点中所有的内容，&#123;&#123;xx&#125;&#125;则不会。
    (2).v-html可以识别html结构。
    3.严重注意：v-html有安全性问题！！！！
    (1).在网站上动态渲染任意HTML是非常危险的，容易导致XSS攻击。
    (2).一定要在可信的内容上使用v-html，永不要用在用户提交的内容上！
</code></pre>
<pre><code>v-cloak指令（没有值）：

            1.本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v-cloak属性。
            2.使用css配合v-cloak可以解决网速慢时页面展示出&#123;&#123;xxx&#125;&#125;的问题。
v-once指令：
            1.v-once所在节点在初次动态渲染后，就视为静态内容了。
            2.以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能。
v-pre指令：
            1.跳过其所在节点的编译过程。
            2.可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译。
</code></pre>
<h1 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h1><img src="/2021/11/24/vue%E5%8D%95%E6%96%87%E4%BB%B6/Users\kuankuan\AppData\Roaming\Typora\typora-user-images\image-20210910095050679.png" alt="image-20210910095050679" style="zoom:150%;">

<pre><code>directives:&#123;
            //big函数何时会被调用？1.指令与元素成功绑定时（一上来）。2.指令所在的模板被重新解析时。
            /* &#39;big-number&#39;(element,binding)&#123;
            // console.log(&#39;big&#39;)
                element.innerText = binding.value * 10
            &#125;, */
            big(element,binding)&#123;
            console.log(&#39;big&#39;,this) //注意此处的this是window
            // console.log(&#39;big&#39;)
                element.innerText = binding.value * 10
            &#125;,
            fbind:&#123;
            //指令与元素成功绑定时（一上来）
            bind(element,binding)&#123;
                element.value = binding.value
            &#125;,
            //指令所在元素被插入页面时
            inserted(element,binding)&#123;
                element.focus()
            &#125;,
            //指令所在的模板被重新解析时
            update(element,binding)&#123;
                element.value = binding.value
            &#125;
           &#125;
        &#125;
</code></pre>
<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p>生命周期：</p>
<p>​            1.又名：生命周期回调函数、生命周期函数、生命周期钩子。</p>
<p>​            2.是什么：Vue在关键时刻帮我们调用的一些特殊名称的函数。</p>
<p>​            3.生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的。</p>
<p>​            4.生命周期函数中的this指向是vm 或 组件实例对象。</p>
<pre><code>常用的生命周期钩子：
                        1.mounted: 发送ajax请求、启动定时器、绑定自定义事件、订阅消息等【初始化操作】。
                        2.beforeDestroy: 清除定时器、解绑自定义事件、取消订阅消息等【收尾工作】。

                关于销毁Vue实例
                        1.销毁后借助Vue开发者工具看不到任何信息。
                        2.销毁后自定义事件会失效，但原生DOM事件依然有效。
                        3.一般不会在beforeDestroy操作数据，因为即便操作数据，也不会再触发更新流程了。
</code></pre>
<h1 id="1-一个重要的内置关系：VueComponent-prototype-proto-Vue-prototype"><a href="#1-一个重要的内置关系：VueComponent-prototype-proto-Vue-prototype" class="headerlink" title="1.一个重要的内置关系：VueComponent.prototype.proto === Vue.prototype"></a>1.一个重要的内置关系：VueComponent.prototype.<strong>proto</strong> === Vue.prototype</h1><h1 id="2-为什么要有这个关系：让组件实例对象（vc）可以访问到-Vue原型上的属性、方法。"><a href="#2-为什么要有这个关系：让组件实例对象（vc）可以访问到-Vue原型上的属性、方法。" class="headerlink" title="2.为什么要有这个关系：让组件实例对象（vc）可以访问到 Vue原型上的属性、方法。"></a>2.为什么要有这个关系：让组件实例对象（vc）可以访问到 Vue原型上的属性、方法。</h1>]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>数据统计分析</title>
    <url>/2021/12/09/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="第9章-数据统计分析案例"><a href="#第9章-数据统计分析案例" class="headerlink" title="第9章　数据统计分析案例"></a>第9章　数据统计分析案例</h1><p>本章以案例为主，通过简单的知识讲解使读者了解数据统计分析中常用的分析方法，如对比分析，同比、定比和环比分析，贡献度分析，差异化分析，相关性分析和时间序列分析的概念。通过典型案例，将数据统计分析方法与前面学习的内容相结合，力求将所学内容应用到实践中。</p>
<h1 id="9-1-对比分析"><a href="#9-1-对比分析" class="headerlink" title="9.1　对比分析"></a>9.1　对比分析</h1><h2 id="9-1-1-什么是对比分析"><a href="#9-1-1-什么是对比分析" class="headerlink" title="9.1.1　什么是对比分析"></a>9.1.1　什么是对比分析</h2><p>对比分析法是将两个或两个以上的数据进行比较，分析其中的差异，从而揭示这些事物代表的发展变化情况和规律性。<br>特点：非常直观地看出事物某方面的变化或差距，而且可以准确、量化地表示出变化的差距是多少。<br>对比分析法通常是把两个相互联系的指标数据进行比较，从数量上展示和说明研究对象规模的大小、水平的高低、速度的快慢，以及各种关系是否协调。对比分析一般来说有以下几种对比方法：纵向对比、横向对比、标准对比、实际与计划对比。</p>
<h2 id="9-1-2-案例：对比分析各品牌销量表现TOP10"><a href="#9-1-2-案例：对比分析各品牌销量表现TOP10" class="headerlink" title="9.1.2　案例：对比分析各品牌销量表现TOP10"></a>9.1.2　案例：对比分析各品牌销量表现TOP10</h2><p>案例位置：资源包\MR\Code\09\example\01<br>对比国产各品牌汽车2020年1月销量，效果如图9.1所示。<br>程序代码如下：</p>
<p><img src="/2021/12/09/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%5Cimage-20211101091340914.png" alt="image-20211101091340914"></p>
<p><img src="/2021/12/09/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%5Cimage-20211101091429952.png" alt="image-20211101091429952"></p>
<p>​                                                                                     图9.1　对比分析各品牌销量表现TOP10</p>
<h1 id="9-2-同比、定比和环比分析"><a href="#9-2-同比、定比和环比分析" class="headerlink" title="9.2　同比、定比和环比分析"></a>9.2　同比、定比和环比分析</h1><p>在数据分析中，有一个重要的分析方法，叫趋势分析法，即将两期或连续数期报告中某一指标进行对比，确定其增减变动的方向、数额和幅度，以确定该指标的变动趋势。趋势分析法中的指标，有同比分析、定比（定基比）分析和环比分析，以及同比增长率分析、定比（定基比）增长率分析和环比增长率分析。</p>
<h2 id="9-2-1-同比、定比和环比概述"><a href="#9-2-1-同比、定比和环比概述" class="headerlink" title="9.2.1　同比、定比和环比概述"></a>9.2.1　同比、定比和环比概述</h2><p>首先了解一下同比、定比和环比的概念。　</p>
<p>同比：本期数据与历史同期数据比较。例如，2021年11月份与2020年11月份相比较。　</p>
<p>定比：本期数据与特定时期的数据比较。例如，2021年11月与2019年12月份相比较。　</p>
<p>环比：本期数据与上期数据比较。例如，2021年11月份与2020年11月份相比较。</p>
<p>同比的好处是可以排除一部分季节因素；环比的好处是可以更直观地表明阶段性的变换，但是会受季节性因素影响；定比常用于财务数据分析。下面来看一个生活中经常出现的场景。　同比：去年这个这时候这条裙子我还能穿，现在穿不进去啦！　定比：年龄，50岁是25岁的两倍。　环比：这个月好像比上个月胖了。<br>下面简单介绍一下同比、定比和环比计算的公式。</p>
<h3 id="1．同比"><a href="#1．同比" class="headerlink" title="1．同比"></a>1．同比</h3><p>同比的计算公式如下：</p>
<p><img src="/2021/12/09/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%5Cimage-20211101091544403.png" alt="image-20211101091544403"></p>
<h3 id="2．定比"><a href="#2．定比" class="headerlink" title="2．定比"></a>2．定比</h3><p>定比的计算公式如下：</p>
<p><img src="/2021/12/09/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%5Cimage-20211101091601809.png" alt="image-20211101091601809"></p>
<h3 id="3．环比"><a href="#3．环比" class="headerlink" title="3．环比"></a>3．环比</h3><p>环比增长率反映本期比上期增长了多少，公式如下：</p>
<p><img src="/2021/12/09/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%5Cimage-20211101091624602.png" alt="image-20211101091624602"></p>
<p>环比发展速度是本期水平与前一期水平之比，反映前后两期的发展变化情况，公式如下：</p>
<p><img src="/2021/12/09/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%5Cimage-20211101091640229.png" alt="image-20211101091640229"></p>
<h2 id="9-2-2-案例1：京东电商单品销量同比增长情况分析"><a href="#9-2-2-案例1：京东电商单品销量同比增长情况分析" class="headerlink" title="9.2.2　案例1：京东电商单品销量同比增长情况分析"></a>9.2.2　案例1：京东电商单品销量同比增长情况分析</h2><p>案例位置：资源包\MR\Code\09\example\02\01<br>下面分析2020年2月与2019年2月相比，京东电商《零基础学Python（全彩版）》一书销量同比增长情况，效果如图9.2所示。<br>从分析结果得知：上海、武汉同比增长较小。</p>
<p><img src="/2021/12/09/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%5Cimage-20211101091708101.png" alt="image-20211101091708101"></p>
<p>​                                                                                                              图9.2　同比分析<br>程序代码如下：</p>
<p><img src="/2021/12/09/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%5Cimage-20211101091740885.png" alt="image-20211101091740885"></p>
<h2 id="9-2-3-案例2：单品销量定比分析"><a href="#9-2-3-案例2：单品销量定比分析" class="headerlink" title="9.2.3　案例2：单品销量定比分析"></a>9.2.3　案例2：单品销量定比分析</h2><p>案例位置：资源包\MR\Code\09\example\02\02<br>下面实现京东电商《零基础学Python（全彩版）》一书2019年销量定比分析，以2019年1月为基期，基点为1，效果如图9.3所示。</p>
<p><img src="/2021/12/09/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%5Cimage-20211101091933203.png" alt="image-20211101091933203"></p>
<p>​                                                                                                      图9.3　定比分析<br>从图9.3中可以看到，6月开始呈现连续小幅度增长，到11月开始大幅度增长，定比指数较10月提高了3.028个点。<br>程序代码如下：</p>
<p><img src="/2021/12/09/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%5Cimage-20211101092002261.png" alt="image-20211101092002261"></p>
<h2 id="9-2-4-案例3：单品销量环比增长情况分析"><a href="#9-2-4-案例3：单品销量环比增长情况分析" class="headerlink" title="9.2.4　案例3：单品销量环比增长情况分析"></a>9.2.4　案例3：单品销量环比增长情况分析</h2><p>案例位置：资源包\MR\Code\09\example\02\03<br>下面分析京东电商《零基础学Python（全彩版）》一书2019年销量环比增长情况，效果如图9.4所示。</p>
<p><img src="/2021/12/09/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%5Cimage-20211101092041392.png" alt="image-20211101092041392"></p>
<p>​                                                                                                    图9.4　环比分析<br>程序代码如下：</p>
<p><img src="/2021/12/09/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%5Cimage-20211101092113806.png" alt="image-20211101092113806"></p>
<p>实用技巧<br>在使用Matplotlib绘制图表时，发现了一个警告Warining，如图9.5所示。</p>
<p><img src="/2021/12/09/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%5Cimage-20211101092157969.png" alt="image-20211101092157969"></p>
<p>​                                                                                                                  图9.5　警告信息<br>完整警告信息如下：<br>MatplotlibDeprecationWarning:<br>Adding an axes using the same arguments as a previous axes currently reuses the earlier instance. In a future version, a new instance will always be created and returned. Meanwhile, this warning can be suppressed, and the future behavior ensured, by passing a unique label to each axes instance.<br>“Adding an axes using the same arguments as a previous axes “<br>解决方法：<br>出现上述警告，原因是在创建画布fig=plt.figure()后就设置了图表标题或坐标轴标签，将图表标题或坐标轴标签相关代码放置在定义子图ax=fig.add_subplot(111)代码后就不会出现警告信息了。</p>
<h1 id="9-3-贡献度分析（帕累托法则）"><a href="#9-3-贡献度分析（帕累托法则）" class="headerlink" title="9.3　贡献度分析（帕累托法则）"></a>9.3　贡献度分析（帕累托法则）</h1><h2 id="9-3-1-什么是贡献度分析"><a href="#9-3-1-什么是贡献度分析" class="headerlink" title="9.3.1　什么是贡献度分析"></a>9.3.1　什么是贡献度分析</h2><p>贡献度分析又称80/20法则、二八法则、帕累托法则、帕累托定律、最省力法则或不平衡原则。<br>该法则是由意大利经济学家“帕累托”提出的。80/20法则认为：原因和结果、投入和产出、努力和报酬之间本来存在着无法解释的不平衡。例如，一个公司80%的利润常常来自20%的产品，那么使用贡献度分析就可以分析获利最高的20%的产品。<br>下面简单介绍一下贡献率相关算法。</p>
<p><img src="/2021/12/09/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%5Cimage-20211101092249403.png" alt="image-20211101092249403"></p>
<p>通过上述公式得出累计贡献率，当累计贡献率接近80%时（不一定正好是80%)，然后找到该产品在图表中相应的位置并进行标注。说明<br>真正的比例不一定正好是80%:20%。80/20法则表明在多数情况下该关系很可能是不平衡的，并且接近于80/20。</p>
<h2 id="9-3-2-案例：产品贡献度分析"><a href="#9-3-2-案例：产品贡献度分析" class="headerlink" title="9.3.2　案例：产品贡献度分析"></a>9.3.2　案例：产品贡献度分析</h2><p>案例位置：资源包\MR\Code\09\example\03<br>下面分析淘宝电商全彩系列图书2018年上半年销售收入占比80%的产品。首先，使用9.3.1节中的公式计算产品累计贡献率，结果如图9.6所示。从图9.6中可以看出，到图书编号B13时，累计贡献率就已达到了0.817665（接近总销售收入的80%），其中共有10种产品，接下来在图表中进行标注，如图9.7所示。</p>
<p><img src="/2021/12/09/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%5Cimage-20211101092358482.png" alt="image-20211101092358482"></p>
<p>​                                                                                         图9.6　输出累计贡献率</p>
<p><img src="/2021/12/09/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%5Cimage-20211101092428830.png" alt="image-20211101092428830"></p>
<p>​                                                                                                   图9.7　产品贡献度分析<br>程序代码如下：</p>
<p><img src="/2021/12/09/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%5Cimage-20211101092455112.png" alt="image-20211101092455112"></p>
<h1 id="9-4-差异化分析"><a href="#9-4-差异化分析" class="headerlink" title="9.4　差异化分析"></a>9.4　差异化分析</h1><h2 id="9-4-1-差异化概述"><a href="#9-4-1-差异化概述" class="headerlink" title="9.4.1　差异化概述"></a>9.4.1　差异化概述</h2><p>任何事物都存在差异，如同上课听讲，有人津津有味，有人昏昏欲睡。<br>那么，通过差异化分析，比较不同事物之间在某个指标上存在的差异，根据差异定制不同的策略。对于产品而言，差异化分析是指企业在其提供给顾客的产品上，通过各种方法满足顾客的偏好，使顾客能够把它同其他竞争企业提供的同类产品有效地区别开来，从而使企业在市场竞争中占据有利的地位。<br>比较常见的有性别差异、年龄差异。通过差异化分析比较不同性别之间在某个指标上存在的差异，通过分析结果对不同性别定制不同的方案。例如，分析不同性别的同学在学习成绩上的差异，了解男生和女生之间的这些差异，因材施教，定制不同的弥补弱项的方案。对于女生，可以有意识地培养她的思维能力；而对于男生，可以买些书籍，来增强他薄弱的方面。<br>年龄差异化分析，了解不同年龄的需求，投其所好，使企业的利润最大化。例如，网购、自媒体、汽车、旅游等行业，通过年龄差异化分析，找出不同年龄段用户群体的喜好，从而增加产品销量。</p>
<h2 id="9-4-2-案例：学生成绩性别差异分析"><a href="#9-4-2-案例：学生成绩性别差异分析" class="headerlink" title="9.4.2　案例：学生成绩性别差异分析"></a>9.4.2　案例：学生成绩性别差异分析</h2><p>案例位置：资源包\MR\Code\09\example\04<br>“女孩喜欢毛绒玩具，男孩喜欢车”这大概是天生的。<br>科学研究表明，男孩和女孩的差别在相当程度上是由生理基础决定的。通过高科技扫描就可以发现，男孩和女孩的大脑都会有某些部位比对方相应的部位更发达、更忙碌。<br>随着孩子的成长，这种天生的性别差异就会对孩子的学习有所影响，并且不断强化。而反过来，学习的本身也在改变着大脑的机能发育。因为当孩子玩耍和学习时，相对应的脑细胞就会更加活跃且随时更新，而那些不经常使用的部分将会逐渐退化萎缩。<br>下面我们用数据说话，通过雷达图分析男生、女生各科成绩差异，效果如图9.8所示。</p>
<p><img src="/2021/12/09/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%5Cimage-20211101093258671.png" alt="image-20211101093258671"></p>
<p>​                                                                                 图9.8　男生、女生各科成绩差异分析<br>从分析结果得知：男生数学和物理高于女生，而女生在英语和语文上略占优势。针对性别差异造成学习成绩的差距，应该采取因材施教，从而提高女生的数学和物理成绩</p>
<p>男生的语文和英语成绩。<br>程序代码如下：</p>
<p><img src="/2021/12/09/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%5Cimage-20211101093347266.png" alt="image-20211101093347266"></p>
<h1 id="9-5-相关性分析"><a href="#9-5-相关性分析" class="headerlink" title="9.5　相关性分析"></a>9.5　相关性分析</h1><h2 id="9-5-1-相关性概述"><a href="#9-5-1-相关性概述" class="headerlink" title="9.5.1　相关性概述"></a>9.5.1　相关性概述</h2><p>任何事物之间都存在一定的联系。例如，夏天温度的高低与空调的销量就存在相关性。当温度升高时，空调的销量也会相应提高。<br>相关性分析是指对多个具备相关关系的数据进行分析，从而衡量数据之间的相关程度或密切程度。相关性可以应用到所有数据的分析过程中。如果一组数据的改变引发另一组数据朝相同方向变化，那么这两组数据存在正相关性，例如，身高与体重，一般个子高的人体重会重一些，个子矮的人体重会轻一些；如果一组数据的改变引发另一组数据朝相反方向变化，那么这两组数据存在负相关性，例如，运动与体重。</p>
<h2 id="9-5-2-案例：广告展现量与费用成本相关性分析"><a href="#9-5-2-案例：广告展现量与费用成本相关性分析" class="headerlink" title="9.5.2　案例：广告展现量与费用成本相关性分析"></a>9.5.2　案例：广告展现量与费用成本相关性分析</h2><p>案例位置：资源包\MR\Code\09\example\05<br>为了促进销售，电商营销必然要投入广告，这样就会产生广告展现量和费用成本相关的数据。通常情况下，我们认为费用高，广告效果就好，它们之间必然存在联系，但仅通过主观判断没有说服力，无法证明数据之间关系的真实存在，也无法度量它们之间关系的强弱。因此，我们要通过相关性分析来找出数据之间的关系。<br>下面来看一下费用成本与广告展现量相关数据情况（由于数据太多，只显示部分数据），如图9.9和图9.10所示。</p>
<p><img src="/2021/12/09/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%5Cimage-20211101093655985.png" alt="image-20211101093655985"></p>
<p>​                                                                                                图9.9　费用成本</p>
<p><img src="/2021/12/09/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%5Cimage-20211101093722813.png" alt="image-20211101093722813"></p>
<p>​                                                                                                图9.10　广告展现量<br>相关性分析方法很多，简单的相关性分析方法是将数据进行可视化处理，单纯从数据的角度很难发现数据之间的趋势和联系，而将数据绘制成图表后就可以直观地看出数据之间的趋势和联系。<br>下面通过散点图看一看广告展现量与费用成本的相关性，效果如图9.11所示。</p>
<p><img src="/2021/12/09/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%5Cimage-20211101093751243.png" alt="image-20211101093751243"></p>
<p>​                                                                                                            图9.11　散点图<br>首先对数据进行简单处理，由于“费用.xlsx”表中同一天会产生多个类型的费用，所以需要按天统计费用，然后将“展现量.xlsx”和“费用.xlsx”两张表的数据合并，最后绘制散点图，程序代码如下：</p>
<p><img src="/2021/12/09/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%5Cimage-20211101093837899.png" alt="image-20211101093837899"></p>
<p>虽然图表清晰地展示了广告展现量与费用成本的相关性，但无法判断数据之间有什么关系，相关关系也没有准确地度量，并且数据超过两组时也无法完成各组数据的相关性分析。<br>下面再介绍一种方法——相关系数方法。相关系数是反映数据之间关系密切程度的统计指标，相关系数的取值区间为1～-1。1表示数据之间完全正相关（线性相关）；-1表示数据之间完全负相关；0表示数据之间不相关。数据越接近0表示相关关系越弱，越接近1表示相关关系越强。<br>计算相关系数需要一定的计算公式，而在Python中无须使用烦琐的公式，通过DataFrame对象提供的corr()函数就可以轻松实现，关键代码如下：</p>
<p>data.corr()<br>运行程序，输出结果如图9.12所示。</p>
<p><img src="/2021/12/09/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%5Cimage-20211101093902187.png" alt="image-20211101093902187"></p>
<pre><code>                                                                                             图9.12　各组数据的相关系数
</code></pre>
<p>从分析结果得知：“费用”与“费用”自身的相关性是1，与“展现量”“点击量”的相关系数分别是0.856013、0.858597；“展现量”与“展现量”自身的相关性是1，与“点击量”“订单金额”的相关系数分别是0.938554、0.728037。那么，除了“商品关注数”相关系数比较低，其他都很高，可以看出“费用”与“展现量”“点击量”等有一定的正相关性，而且相关性很强。<br>相关系数的优点是可以通过数字对变量的关系进行度量，并且带有方向性，1表示正相关，-1表示负相关，越靠近0相关性越弱。缺点是无法利用这种关系对数据进行预测。</p>
<h1 id="9-6-时间序列分析"><a href="#9-6-时间序列分析" class="headerlink" title="9.6　时间序列分析"></a>9.6　时间序列分析</h1><h2 id="9-6-1-时间序列概述"><a href="#9-6-1-时间序列概述" class="headerlink" title="9.6.1　时间序列概述"></a>9.6.1　时间序列概述</h2><p>顾名思义，时间序列就是按照时间顺序排列的一组数据序列。时间序列分析就是找出数据变化发展的规律，从而预测未来的走势。<br>时间序列分析有以下几种表现形式。　长期趋势变化：受某种因素的影响，数据依据时间变化，按某种规则稳步增长或下降。使用的分析方法有移动平均法、指数平滑法等。　季节性周期变化：受季节更替等因素影响，数据依据固定周期规则性的变化。季节性周期变化，不局限于自然季节，还包括月、周等短期周期。例如，空调、羽绒服、冷饮的销售，双十一、双十二流量在一周之内的波动等。采用的方法为季节指数。　循环变化：指一种较长时间的上、下起伏周期性波动，一般循环时间为2～15年。　随机性变化：由许多不确定因素引起的数据变化，在时间序列中无法预计。</p>
<h2 id="9-6-2-案例：年增长趋势和季节性波动分析"><a href="#9-6-2-案例：年增长趋势和季节性波动分析" class="headerlink" title="9.6.2　案例：年增长趋势和季节性波动分析"></a>9.6.2　案例：年增长趋势和季节性波动分析</h2><p>案例位置：资源包\MR\Code\09\example\06<br>下面分析淘宝店铺近3年增长趋势和季节性波动，如图9.13所示。从分析结果得出，近3年淘宝店铺收入呈现持续稳定增长趋势，但2019年有所下降，季节性波动比较明显，每年的第4季度是销售“旺季”。<br>程序代码如下：</p>
<p><img src="/2021/12/09/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%5Cimage-20211101094004956.png" alt="image-20211101094004956"></p>
<p><img src="/2021/12/09/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%5Cimage-20211101094315925.png" alt="image-20211101094315925"></p>
<p>​                                                                                                             图9.13　年增长趋势和季节性波动</p>
<h1 id="9-7-小结"><a href="#9-7-小结" class="headerlink" title="9.7　小结"></a>9.7　小结</h1><p>本章通过常用的数据分析方法并结合图表，以案例的形式呈现，每一种分析方法都对应一个恰当的分析案例，一张贴切的图表，力求使读者能够真正理解数据分析，并将其应用到实际数据分析工作中。每一个案例都经过作者反复揣摩，希望能够对读者有所帮助。</p>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
  </entry>
  <entry>
    <title>matplotlib</title>
    <url>/2021/12/09/matplotlib/</url>
    <content><![CDATA[<h3 id="5-3-图表"><a href="#5-3-图表" class="headerlink" title="5.3　图表"></a>5.3　图表</h3><p>数据分析图表有很多种，但每一种图表的绝大组成部分是基本相同的，一张完整的图表一般包括画布、图表标题、绘图区、数据系列、坐标轴、坐标轴标题、图例、文本标签、网格线等，如图5.4所示。</p>
<p>01 import matplotlib.pyplot as plt<br>02 plt.plot([1, 2, 3, 4,5])</p>
<p>01 import matplotlib.pyplot as plt<br>02 plt.plot([1, 2, 3, 4,5], [2, 5, 8, 12,18], ‘ro’)</p>
<h3 id="5-5-图表的常用设置"><a href="#5-5-图表的常用设置" class="headerlink" title="5.5　图表的常用设置"></a>5.5　图表的常用设置</h3><p>本节主要介绍图表的常用设置，主要包括颜色设置、线条样式、标记样式、设置画布、坐标轴、添加文本标签、设置标题和图例、添加注释文本、调整图表与画布边缘间距，以及其他相关设置等。</p>
<h3 id="5-5-1-基本绘图plot-函数"><a href="#5-5-1-基本绘图plot-函数" class="headerlink" title="5.5.1　基本绘图plot()函数"></a>5.5.1　基本绘图plot()函数</h3><p>Matplotlib基本绘图主要使用plot()函数，语法如下：</p>
<p>matplotlib.pyplot.plot(x,y,format_string,**kwargs)<br>参数说明：　**</p>
<p>x：x轴数据。　</p>
<p>y：y轴数据。　</p>
<p>format_string：控制曲线格式的字符串，包括颜色、线条样式和标记样式。　</p>
<p>kwargs：键值参数，相当于一个字典，比如输入参数为(1,2,3,4,k,a=1,b=2,c=3)，*args=(1,2,3,4,k)，**kwargs={‘a’:’1,’b’:2,’c’:3}。</p>
<p>0～1的小数作为灰度值，例如0.5。　</p>
<p>{‘b’, ‘g’, ‘r’, ‘c’, ‘m’, ‘y’, ‘k’, ‘w’}，其中的一个颜色值。　</p>
<p>X11/CSS4规定中的颜色名称。　</p>
<p>Xkcd中指定的颜色名称，例如xkcd:sky blue。　</p>
<p>Tableau调色板中的颜色，例如{‘tab:blue’, ‘tab:orange’, ‘tab:green’, ‘tab:red’, ‘tab:purple’, ‘tab:brown’,’tab:pink’, ‘tab:gray’, ‘tab:olive’, ‘tab:cyan’}。　</p>
<p>CN格式的颜色循环，对应的颜色设置代码如下：</p>
<p>01  from cycler import cycler<br>02  colors=[‘#1f77b4’, ‘#ff7f0e’, ‘#2ca02c’, ‘#d62728’, ‘#9467bd’, ‘#8c564b’, ‘#e377c2’,’#7f7f7f’, ‘#bcbd22’, ‘#17becf’]<br>03  plt.rcParams[‘axes.prop_cycle’] = cycler(color=colors)</p>
<p>1    plt.rcParams[’axes.unicode_minus’] = False    字符显示<br>2    plt.rcParams[’font.sans-serif’] = ‘SimHei’    设置字体<br>线条样式：lines<br>3    plt.rcParams[’lines.linestyle’] = ‘-.’    线条样式<br>4    plt.rcParams[’lines.linewidth’] = 3    线条宽度<br>5    plt.rcParams[’lines.color’] = ‘blue’    线条颜色<br>6    plt.rcParams[’lines.marker’] = None    默认标记<br>7    plt.rcParams[’lines.markersize’] = 6    标记大小<br>8    plt.rcParams[’lines.markeredgewidth’] = 0.5    标记附近的线宽<br>横、纵轴：xtick、ytick<br>9    plt.rcParams[’xtick.labelsize’]    横轴字体大小<br>10    plt.rcParams[’ytick.labelsize’]    纵轴字体大小<br>11    plt.rcParams[’xtick.major.size’]    x轴最大刻度<br>12    plt.rcParams[’ytick.major.size’]    y轴最大刻度<br>figure中的子图：axes<br>13    plt.rcParams[’axes.titlesize’]    子图的标题大小<br>14    plt.rcParams[’axes.labelsize’]    子图的标签大小<br>图像、图片：figure、savefig<br>15    plt.rcParams[’figure.dpi’]    图像分辨率<br>16    plt.rcParams[’figure.figsize’]    图像显示大小<br>17    plt.rcParams[’savefig.dpi’]    图片像素</p>
<h4 id="2．线条样式"><a href="#2．线条样式" class="headerlink" title="2．线条样式"></a>2．线条样式</h4><p>linestyle可选参数可以设置线条的样式，设置值如下，设置后的效果如图5.23所示。　“-”：实线，默认值。　“–”：双画线　“-.”：点画线。　“:”：虚线。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th align="right">描述</th>
</tr>
</thead>
<tbody><tr>
<td>agg_filter</td>
<td align="right">a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array</td>
</tr>
<tr>
<td>alpha</td>
<td align="right">float or None</td>
</tr>
<tr>
<td>animated</td>
<td align="right">bool</td>
</tr>
<tr>
<td>antialiased or aa</td>
<td align="right">bool</td>
</tr>
<tr>
<td>clip_box</td>
<td align="right">Bbox</td>
</tr>
<tr>
<td>clip_on</td>
<td align="right">bool</td>
</tr>
<tr>
<td>clip_path</td>
<td align="right">Patch or (Path, Transform) or None</td>
</tr>
<tr>
<td>color or c</td>
<td align="right">color</td>
</tr>
<tr>
<td>contains</td>
<td align="right">unknown</td>
</tr>
<tr>
<td>dash_capstyle</td>
<td align="right">{‘butt’, ‘round’, ‘projecting’}</td>
</tr>
<tr>
<td>dash_joinstyle</td>
<td align="right">{‘miter’, ‘round’, ‘bevel’}</td>
</tr>
<tr>
<td>dashes</td>
<td align="right">sequence of floats (on/off ink in points) or (None, None)</td>
</tr>
<tr>
<td>data</td>
<td align="right">(2, N) array or two 1D arrays</td>
</tr>
<tr>
<td>drawstyle or ds</td>
<td align="right">{‘default’, ‘steps’, ‘steps-pre’, ‘steps-mid’, ‘steps-post’}, default: ‘default’</td>
</tr>
<tr>
<td>figure</td>
<td align="right">Figure</td>
</tr>
<tr>
<td>fillstyle</td>
<td align="right">{‘full’, ‘left’, ‘right’, ‘bottom’, ‘top’, ‘none’}</td>
</tr>
<tr>
<td>gid</td>
<td align="right">str</td>
</tr>
<tr>
<td>in_layout</td>
<td align="right">bool</td>
</tr>
<tr>
<td>label</td>
<td align="right">object</td>
</tr>
<tr>
<td>linestyle or ls</td>
<td align="right">{’-’, ‘–’, ‘-.’, ‘:’, ‘’, (offset, on-off-seq), …}</td>
</tr>
<tr>
<td>linewidth or lw</td>
<td align="right">float</td>
</tr>
<tr>
<td>marker</td>
<td align="right">marker style string, Path or MarkerStyle</td>
</tr>
<tr>
<td>markeredgecolor or mec</td>
<td align="right">color</td>
</tr>
<tr>
<td>markeredgewidth or mew</td>
<td align="right">float</td>
</tr>
<tr>
<td>markerfacecolor or mfc</td>
<td align="right">color</td>
</tr>
<tr>
<td>markerfacecoloralt or mfcalt</td>
<td align="right">color</td>
</tr>
<tr>
<td>markersize or ms</td>
<td align="right">float</td>
</tr>
<tr>
<td>markevery</td>
<td align="right">None or int or (int, int) or slice or List[int] or float or (float, float) or List[bool]</td>
</tr>
<tr>
<td>path_effects</td>
<td align="right">AbstractPathEffect</td>
</tr>
<tr>
<td>picker</td>
<td align="right">unknown</td>
</tr>
<tr>
<td>pickradius</td>
<td align="right">float</td>
</tr>
<tr>
<td>rasterized</td>
<td align="right">bool or None</td>
</tr>
<tr>
<td>sketch_params</td>
<td align="right">(scale: float, length: float, randomness: float)</td>
</tr>
<tr>
<td>snap</td>
<td align="right">bool or None</td>
</tr>
<tr>
<td>solid_capstyle</td>
<td align="right">{‘butt’, ‘round’, ‘projecting’}</td>
</tr>
<tr>
<td>solid_joinstyle</td>
<td align="right">{‘miter’, ‘round’, ‘bevel’}</td>
</tr>
<tr>
<td>transform</td>
<td align="right">matplotlib.transforms.Transform</td>
</tr>
<tr>
<td>url</td>
<td align="right">str</td>
</tr>
<tr>
<td>visible</td>
<td align="right">bool</td>
</tr>
<tr>
<td>xdata</td>
<td align="right">1D array</td>
</tr>
<tr>
<td>ydata</td>
<td align="right">1D array</td>
</tr>
<tr>
<td>zorder</td>
<td align="right">float</td>
</tr>
</tbody></table>
<h4 id="3．标记样式"><a href="#3．标记样式" class="headerlink" title="3．标记样式"></a>3．标记样式</h4><p>marker可选参数可以设置标记样式，设置值如表5.2所示。</p>
<p>plt.plot(x,y,color=’m’,linestyle=’-‘,marker=’o’,mfc=’w’)</p>
<p>markerfacecolor or mfc：填充颜色</p>
<h3 id><a href="#" class="headerlink" title></a></h3><p>matpoltlib.pyplot.figure(num=None, figsize=None, dpi=None, facecolor=None, edgecolor=None, frameon=True)<br>参数说明：　</p>
<p>num：图像编号或名称，数字为编号，字符串为名称，可以通过该参数激活不同的画布。　</p>
<p>figsize：指定画布的宽和高，单位为英寸。　</p>
<p>dpi：指定绘图对象的分辨率，即每英寸多少个像素，默认值为80。像素越大画布越大。　</p>
<p>facecolor：背景颜色。　</p>
<p>edgecolor：边框颜色。</p>
<p>frameon：是否显示边框，默认值为True，绘制边框；如果为False，则不绘制边框。</p>
<p>【示例05】　自定义画布。（示例位置：资源包\MR\Code\05\05）<br>自定义一个5×3的黄色画布，主要代码如下：</p>
<p>01 import matplotlib.pyplot as plt<br>02 fig=plt.figure(figsize=(5,3),facecolor=’yellow’)<br>运行程序，输出结果如图5.25所示。</p>
<p>figsize=(5,3)，因为实际画布大小是500×300，所以这里不要输入太大的数字。</p>
<h4 id="1．x轴、y轴标题"><a href="#1．x轴、y轴标题" class="headerlink" title="1．x轴、y轴标题"></a>1．x轴、y轴标题</h4><p>设置x轴和y轴标题主要使用xlabel()函数和ylabel()函数。</p>
<p>（1）解决中文乱码问题，代码如下：</p>
<p>plt.rcParams[‘font.sans-serif’]=[‘SimHei’]        #解决中文乱码</p>
<p>（2）解决负号不显示问题，代码如下：</p>
<p>plt.rcParams[‘axes.unicode_minus’] = False       #解决负号不显示</p>
<h4 id="2．坐标轴刻度"><a href="#2．坐标轴刻度" class="headerlink" title="2．坐标轴刻度"></a>2．坐标轴刻度</h4><p>用matplotlib画二维图像时，默认情况下的横坐标（x轴）和纵坐标（y轴）显示的值有时可能达不到我们的需求，需要借助xticks()函数和yticks()函数分别对x轴和y轴的值进行设置。<br>xticks()函数的语法如下：</p>
<p>xticks(locs, [labels], **kwargs)<br>参数说明：　</p>
<p>locs：数组，表示x轴上的刻度。例如，在“学生英语成绩分布图”中，x轴的刻度是2～14的偶数，如果想改变这个值，就可以通过locs参数设置。　</p>
<p>labels：也是数组，默认值和locs相同。locs表示位置，而labels则决定该位置上的标签，如果赋予labels空值，则x轴将只有刻度而不显示任何值。</p>
<p>plt.xticks(range(1,15,1))</p>
<p>运行程序，对比效果如图5.27和图5.28所示。<br>接下来，设置y轴刻度，主要使用yticks()函数。例如，设置体温为35.4～38，主要代码如下：</p>
<p>plt.yticks([35.4,35.6,35.8,36,36.2,36.4,36.6,36.8,37,37.2,37.4,37.6,37.8,38])</p>
<h4 id="3．坐标轴范围"><a href="#3．坐标轴范围" class="headerlink" title="3．坐标轴范围"></a>3．坐标轴范围</h4><p>坐标轴范围是指x轴和y轴的取值范围。设置坐标轴范围主要使用xlim()函数和ylim()函数。</p>
<p>【示例09】　为折线图设置坐标范围。（示例位置：资源包\MR\Code\05\09）<br>设置x轴（日期）范围为1～14，y轴（基础体温）范围为35～45，主要代码如下：</p>
<p>01  plt.xlim(1,14)<br>02  plt.ylim(35,45)</p>
<h4 id="4．网格线"><a href="#4．网格线" class="headerlink" title="4．网格线"></a>4．网格线</h4><p>plt.grid(color=’0.5’,linestyle=’–’,linewidth=1)</p>
<h3 id="5-5-4-添加文本标签"><a href="#5-5-4-添加文本标签" class="headerlink" title="5.5.4　添加文本标签"></a>5.5.4　添加文本标签</h3><p>绘图过程中，为了能够更清晰、直观地看到数据，有时需要给图表中指定的数据点添加文本标签。下面介绍细节之二——文本标签，主要使用**text()**函数，语法如下：</p>
<p>matplotlib.pyplot.text(x, y, s, fontdict=None, withdash=False, **kwargs)<br>参数说明：　**</p>
<p>x：x坐标轴的值。　</p>
<p>y：y坐标轴的值。　</p>
<p>s：字符串，注释内容。　</p>
<p>fontdict：字典，可选参数，默认值为None。用于重写默认文本属性。　</p>
<p>withdash：布尔型，默认值为False，创建一个TexWithDash实例，而不是Text实例。　</p>
<p>kwargs：关键字参数。这里指通用的绘图参数，如字体大小fontsize=12、垂直对齐方式horizontalalignment=’center’（或简写为ha=’center’）、水平对齐方式verticalalignment=’center’（或简写为va=’center’）。</p>
<p>01  for a,b  in zip(x,y):<br>02      plt.text(a,b+3,’%.1f’%b,ha = ‘center’,va = ‘bottom’,fontsize=9)</p>
<p>​                                                                                     图5.31　带文本标签的折线图<br>在本示例代码中，首先，x、y是x轴和y轴的值，它代表了折线图在坐标中的位置，通过for循环找到每一个x、y值相对应的坐标赋值给a、b，再使用plt.text在对应的数据点上添加文本标签，而for循环也保证了折线图中每一个数据点都有文本标签。其中，a,b+3表示每一个数据点（x值对应y值加3）的位置处添加文本标签；%.1f’%b是对y值进行的格式化处理，保留小数点1位；ha=’center’、va=’bottom’代表水平对齐、垂直对齐的方式，fontsize则是字体大小。</p>
<h3 id="5-5-5-设置标题和图例"><a href="#5-5-5-设置标题和图例" class="headerlink" title="5.5.5　设置标题和图例"></a>5.5.5　设置标题和图例</h3><h4 id="1．图表标题"><a href="#1．图表标题" class="headerlink" title="1．图表标题"></a>1．图表标题</h4><p>为图表设置标题主要使用title()函数，语法如下：</p>
<p>matplotlib.pyplot.title(label, fontdict=None, loc=’center’, pad=None, **kwargs)<br>参数说明：　</p>
<p>label：字符串，表示图表标题文本。　</p>
<p>fontdict：字典，用来设置标题字体的样式。如{‘fontsize’: 20,’fontweight’:20,’va’: ‘bottom’,’ha’:’center’}。　</p>
<p>loc：字符串，表示标题水平位置，参数值为center、left或right，分别表示水平居中、水平居左和水平居右，默认为水平居中。　</p>
<p>pad：浮点型，表示标题离图表顶部的距离，默认值为None。</p>
<p>**kwargs：关键字参数，可以设置一些其他文本属性。<br>例如，设置图表标题为“14天基础体温曲线图”，主要代码如下：</p>
<p>plt.title(‘14天基础体温曲线图’,fontsize=’18’)</p>
<h4 id="2．图表图例"><a href="#2．图表图例" class="headerlink" title="2．图表图例"></a>2．图表图例</h4><h5 id="（1）自动显示图例"><a href="#（1）自动显示图例" class="headerlink" title="（1）自动显示图例"></a>（1）自动显示图例</h5><p>plt.legend()<br>（2）手动添加图例</p>
<p>plt.legend(‘基础体温’)</p>
<p>注意<br>当手动添加图例时，有时会出现文本显示不全，解决方法是在文本后面加一个逗号（,），主要代码如下：</p>
<p><strong>plt.legend((‘基础体温’,))</strong><br>（3）设置图例显示位置<br>通过loc参数可以设置图例的显示位置，如在左下方显示，主要代码如下：</p>
<p>plt.legend((‘基础体温’,),loc=’upper right’,fontsize=10)<br>具体图例显示位置的设置如表5.3所示。</p>
<p>plt.legend(bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0)<br>下面来看下设置标题和图例后的“14天基础体温曲线图”，效果如图5.32所示。</p>
<h3 id="5-5-6-添加注释"><a href="#5-5-6-添加注释" class="headerlink" title="5.5.6　添加注释"></a>5.5.6　添加注释</h3><p>01 plt.annotate(‘最高体温’, xy=(9,37.1), xytext=(10.5,37.1),</p>
<p>02               xycoords=’data’,<br>03               arrowprops=dict(facecolor=’r’, shrink=0.05))<br>下面介绍一下本示例中用到的几个主要参数。　</p>
<p>xy：被注释的坐标点，二维元组，如(x,y)。　</p>
<p>xytext：注释文本的坐标点（也就是本示例中箭头的位置），也是二维元组，默认与xy相同。　</p>
<p>xycoords：是被注释点的坐标系属性，设置值如表5.4所示。</p>
<h3 id="5-5-8-其他设置"><a href="#5-5-8-其他设置" class="headerlink" title="5.5.8　其他设置"></a>5.5.8　其他设置</h3><h4 id="1．坐标轴的刻度线"><a href="#1．坐标轴的刻度线" class="headerlink" title="1．坐标轴的刻度线"></a>1．坐标轴的刻度线</h4><p>（1）设置4个方向的坐标轴上的刻度线是否显示，主要代码如下：</p>
<p>plt.tick_params(bottom=False,left=True,right=True,top=True)<br>（2）设置x轴和y轴的刻度线显示方向，其中in表示向内，out表示向外，inout表示在中间，默认刻度线向外，主要代码如下：</p>
<p>plt.rcParams[‘xtick.direction’] = ‘in’         #x轴的刻度线向内显示<br>plt.rcParams[‘ytick.direction’] = ‘in’         #y轴的刻度线向内显示</p>
<h4 id="2．坐标轴相关属性设置"><a href="#2．坐标轴相关属性设置" class="headerlink" title="2．坐标轴相关属性设置"></a>2．坐标轴相关属性设置</h4><p>axis()：返回当前axes范围。　</p>
<p>axis(v)：通过输入v = [xmin, xmax, ymin, ymax]，设置x、y轴的取值范围。　</p>
<p>axis(‘off’)：关闭坐标轴轴线及坐标轴标签。　</p>
<p>axis(‘equal’)：使x、y轴长度一致。　</p>
<p>axis(‘scaled’)：调整图框的尺寸（而不是改变坐标轴取值范围），使x、y轴长度一致。　</p>
<p>axis(‘tight’)：改变x轴和y轴的限制，使所有数据被展示。如果所有的数据已经显示，它将移动到图形的中心而不修改（xmax～xmin）或（ymax～ymin）。　</p>
<p>axis(‘image’)：缩放axis范围（limits），等同于对data缩放范围。　</p>
<p>axis(‘auto’)：自动缩放。　</p>
<p>axis(‘normal’)：不推荐使用。恢复默认状态，轴限的自动缩放以使数据显示在图表中。</p>
<p>​                                                                                               图5.36　多折线图<br>上述举例，用到了几个参数，下面进行说明。</p>
<p>mfc：标记的颜色。　</p>
<p>ms：标记的大小。　</p>
<p>mec：标记边框的颜色。　</p>
<p>alpha：透明度，设置该参数可以改变颜色的深浅。</p>
<h3 id="5-6-2-绘制柱形图"><a href="#5-6-2-绘制柱形图" class="headerlink" title="5.6.2　绘制柱形图"></a>5.6.2　绘制柱形图</h3><p>matplotlib.pyplot.bar(x,height,width,bottom=None,*,align=’center’,data=None,**kwargs)<br>参数说明：　**</p>
<p>x：x轴数据。　</p>
<p>height：柱子的高度，也就是y轴数据。　</p>
<p>width：浮点型，柱子的宽度，默认值为0.8，可以指定固定值。　</p>
<p>bottom：标量或数组，可选参数，柱形图的y坐标，默认值为None。　</p>
<p>*：星号本身不是参数。星号表示其后面的参数为命名关键字参数，命名关键字参数必须传入参数名；否则程序会出现错误。　</p>
<p>align：对齐方式，如center（居中）和edge（边缘），默认值为center。　</p>
<p>data：data关键字参数。如果给定一个数据参数，所有位置和关键字参数将被替换。　</p>
<p>kwargs：关键字参数，其他可选参数，如color（颜色）、alpha（透明度）、label（每个柱子显示的标签）等。</p>
<p>01 import matplotlib.pyplot as plt<br>02 x=[1,2,3,4,5,6]</p>
<p>03 height=[10,20,30,40,50,60]<br>04 plt.bar(x,height)<br>运行程序，输出结果如图5.37所示。</p>
<p>bar()函数可以绘制出各种类型的柱形图，如基本柱形图、多柱形图、堆叠柱形图，只要将bar()函数的主要参数理解透彻，就会达到意想不到的效果。下面介绍几种常见的柱形图。</p>
<h3 id="5-6-3-绘制直方图"><a href="#5-6-3-绘制直方图" class="headerlink" title="5.6.3　绘制直方图"></a>5.6.3　绘制直方图</h3><p>直方图，又称质量分布图，由一系列高度不等的纵向条纹或线段表示数据分布的情况。一般用横轴表示数据类型，纵轴表示分布情况。直方图是数值数据分布的精确图形表示，是一个连续变量（定量变量）的概率分布的估计。<br>绘制直方图主要使用hist()函数，语法如下：</p>
<p>matplotlib.pyplot.hist(x,bins=None,range=None, density=None, bottom=None, histtype=’bar’, align=’mid’, log=<br>False, color=None, label=None, stacked=False, normed=None)<br>参数说明：　</p>
<p>x：数据集，最终的直方图将对数据集进行统计。　</p>
<p>bins：统计数据的区间分布。　</p>
<p>range：元组类型，显示的区间。　</p>
<p>density：布尔型，显示频率统计结果，默认值为None。设置值为False，不显示频率统计结果；设置值为True，则显示频率统计结果。需要注意，频率统计结果=区间数目/(总数×区间宽度)。　</p>
<p>histtype：可选参数，设置值为bar、barstacked、step或stepfilled，默认值为bar，推荐使用默认配置，其中step使用的是梯状，stepfilled则会对梯状内部进行填充，效果与bar类似。　</p>
<p>align：可选参数，控制柱状图的水平分布，设置值为left、mid或right，默认值为mid，其中，left或者right会有部分空白区域，推荐使用默认值。　</p>
<p>log：布尔型，默认值为False，即y坐标轴是否选择指数刻度。</p>
<p>stacked：布尔型，默认值为False，是否为堆积柱状图。</p>
<p>【示例16】　绘制简单直方图。（示例位置：资源包\MR\Code\05\16）<br>绘制简单直方图，程序代码如下：</p>
<p>01 import matplotlib.pyplot as plt<br>02 x=[22,87,5,43,56,73,55,54,11,20,51,5,79,31,27]<br>03 plt.hist(x, bins = [0,25,50,75,100])<br>运行程序，输出结果如图5.40所示。</p>
<h3 id="5-6-4-绘制饼形图"><a href="#5-6-4-绘制饼形图" class="headerlink" title="5.6.4　绘制饼形图"></a>5.6.4　绘制饼形图</h3><p>饼形图常用来显示各个部分在整体中所占的比例。例如，在工作中如果遇到需要计算总费用或金额的各个部分构成比例的情况，一般通过各个部分与总额相除来计算，而且这种比例表示方法很抽象，而通过饼形图将直接显示各个组成部分所占比例，一目了然。<br>Matplotlib绘制饼形图主要使用pie()函数，语法如下：</p>
<p>matplotlib.pyplot.pie(x,explode=None,labels=None,colors=None,autopct=None,pctdistance=0.6,shadow=False,<br>labeldistance=1.1,startangle=None,radius=None,counterclock=True,wedgeprops=None,textprops=None,center=<br>(0, 0), frame=False, rotatelabels=False, hold=None, data=None)<br>参数说明：　</p>
<p>x：每一块饼图的比例，如果sum(x)&gt;1会使用sum(x)归一化。　</p>
<p>explode：每一块饼图离中心的距离。　</p>
<p>labels：每一块饼图外侧显示的说明文字。　</p>
<p>autopct：设置饼图百分比，可以使用格式化字符串或format()函数。如’%1.1f ‘保留小数点前后1位。　</p>
<p>pctdistance：类似于labeldistance参数，指定百分比的位置刻度，默认值为0.6。　</p>
<p>shadow：在饼图下面画一个阴影，默认值为False，即不画阴影。　</p>
<p>labeldistance：标记的绘制位置，相对于半径的比例，默认值为1.1，如&lt;1则绘制在饼图内侧。　</p>
<p>startangle：起始绘制角度，默认是从x轴正方向逆时针画起，如设置值为90则从y轴正方向画起。　</p>
<p>radius：饼图半径，默认值为1。　</p>
<p>counterclock：指定指针方向，布尔型，可选参数。默认值为True，表示逆时针；如果值为False，则表示顺时针。　</p>
<p>wedgeprops：字典类型，可选参数，默认值为None。字典传递给wedge对象，用来画一个饼图。例如wedgeprops={‘linewidth’:2}设置wedge线宽为2。　</p>
<p>textprops：设置标签和比例文字的格式，字典类型，可选参数，默认值为None。传递给text对象的字典参数。　</p>
<p>center：浮点类型的列表，可选参数，默认值为(0,0)，表示图表中心位置。　</p>
<p>frame：布尔型，可选参数，默认值为False，不显示轴框架（也就是网格）；如果值为True，则显示轴框架，与grid()函数配合使用。实际应用中建议使用默认设置，因为显示轴框架会干扰饼形图效果。　</p>
<p>rotatelabels：布尔型，可选参数，默认值为False；如果值为True，则旋转每个标签到指定的角度。</p>
<p>01 import matplotlib.pyplot as plt<br>02 x = [2,5,12,70,2,9]<br>03 plt.pie(x,autopct=’%1.1f%%’)<br>运行程序，输出结果如图5.42所示。</p>
<h4 id="-1"><a href="#-1" class="headerlink" title></a></h4><p>​                                                                                               图5.44　分裂饼形图<br>分裂饼形图主要通过设置explode参数实现，该参数用于设置饼图距中心的距离，我们需要将哪块饼图分裂出来，就设置它与中心的距离即可。例如，图5.43中有10块饼图，我们将占比最多的“广东省”分裂出来，如图5.44（a）所示。广东省在第一位，那么就设置第一位距中心的距离为0.1，其他为0，关键代码如下：</p>
<p>explode = (0.1,0,0,0,0,0,0,0,0,0)</p>
<h4 id="3．立体感带阴影的饼形图"><a href="#3．立体感带阴影的饼形图" class="headerlink" title="3．立体感带阴影的饼形图"></a>3．立体感带阴影的饼形图</h4><p>立体感带阴影的饼形图看起来更美观，效果如图5.45所示。<br>立体感带阴影的饼形图主要通过shadow参数实现，设置该参数值为True即可，主要代码如下：</p>
<p>shadow=True</p>
<h4 id="4．环形图"><a href="#4．环形图" class="headerlink" title="4．环形图"></a>4．环形图</h4><p>​                                                                                                              图5.46　环形图<br>这里还是通过pie()函数实现，一个关键参数wedgeprops，字典类型，用于设置饼形图内、外边界的属性，如环的宽度，环边界颜色和宽度，主要代码如下：</p>
<p>wedgeprops = {‘width’: 0.4, ‘edgecolor’: ‘k’}</p>
<h4 id="5．内嵌"><a href="#5．内嵌" class="headerlink" title="5．内嵌"></a>5．内嵌</h4><p>​                                                                                             图5.47　内嵌环形图<br>绘制内嵌环形图需要注意以下3点。<br>（1）连续使用两次pie()函数。<br>（2）通过wedgeprops参数设置环形边界。<br>（3）通过radius参数设置不同的半径。<br>另外，由于图例内容比较长，为了使图例能够正常显示，图例代码中引入了两个主要参数，即frameon和bbox_to_anchor。其中，frameon参数设置图例有无边框；bbox_to_anchor参数设置图例位置，主要代码如下：</p>
<p><img src="/2021/12/09/matplotlib/image-20211022044933255.png" alt="image-20211022044933255"></p>
<h3 id="5-6-5-散点图"><a href="#5-6-5-散点图" class="headerlink" title="5.6.5　散点图"></a>5.6.5　散点图</h3><p>散点图主要用来查看数据的分布情况或相关性，一般用在线性回归分析中，查看数据点在坐标系平面上的分布情况。散点图表示因变量随自变量而变化的大致趋势，据此可以选择合适的函数对数据点进行拟合。<br>散点图与折线图类似，也是一个个点构成的。但不同之处在于，散点图的各点之间不会按照前后关系以线条连接起来。<br>Matplotlib绘制散点图使用plot()函数和scatter()函数都可以实现，本节使用scatter()函数绘制散点图，scatter()函数专门用于绘制散点图，使用方式和plot()函数类似，区别在于前者具有更高的灵活性，可以单独控制每个散点与数据匹配，并让每个散点具有不同的属性。scatter()函数的语法如下：</p>
<p>matplotlib.pyplot.scatter(x,y,s=None,c=None,marker=None,cmap=None,norm=None,vmin=None,vmax=None,<br>alpha=None,linewidths=None,verts=None,edgecolors=None,data=None, **kwargs)<br>参数说明：　</p>
<p>x，y：数据。　</p>
<p>s：标记大小，以平方磅为单位的标记面积，设置值如下。　</p>
<p>​        数值标量：以相同的大小绘制所有标记。　</p>
<p>​        行或列向量：使每个标记具有不同的大小。x、y和sz中的相应元素确定每个标记的位置和面积。sz的长度必须等于x和y的长度。　</p>
<p>​        []：使用36平方磅的默认面积。　</p>
<p>c：标记颜色，可选参数，默认标记颜色为蓝色。　</p>
<p>marker：标记样式，可选参数，默认值为’o’。　</p>
<p>cmap：颜色地图，可选参数，默认值为None。</p>
<p>norm：可选参数，默认值为None</p>
<p>vmin，vmax：标量，可选，默认值为None　</p>
<p>alpha：透明度，可选参数，0～1的数，表示透明度，默认值为None。　</p>
<p>linewidths：线宽，标记边缘的宽度，可选参数，默认值为None。　</p>
<p>verts：(x,y)的序列，可选参数，如果参数marker为None，这些顶点将用于构建标记。标记的中心位置为(0,0)。　</p>
<p>edgecolors：轮廓颜色，与参数c类似，可选参数，默认值为None。　</p>
<p>data：data关键字参数。如果给定一个数据参数，所有位置和关键字参数将被替换。　</p>
<p>**kwargs：关键字参数，其他可选参数。</p>
<p>01 import matplotlib.pyplot as plt<br>02 x=[1,2,3,4,5,6]<br>03 y=[19,24,37,43,55,68]<br>04 plt.scatter(x, y)<br>运行程序，输出结果如图5.48所示。</p>
<p>​                                                                              图5.49　销售收入与广告费散点图</p>
<h3 id="5-6-6-绘制面积图"><a href="#5-6-6-绘制面积图" class="headerlink" title="5.6.6　绘制面积图"></a>5.6.6　绘制面积图</h3><p>面积图用于体现数量随时间而变化的程度，也可用于引起人们对总值趋势的注意。例如，表示随时间而变化的利润的数据可以绘制在面积图中，以强调总利润。<br>Matplotlib绘制面积图主要使用stackplot()函数，语法如下：</p>
<p>matplotlib.pyplot.stackplot(x,*args,data=None,**kwargs)<br>参数说明：　**</p>
<p>x：x轴数据。　</p>
<p><em>args：当传入的参数个数未知时使用</em>args。这里指y轴数据可以传入多个y轴。　</p>
<p>data：data关键字参数。如果给定一个数据参数，所有位置和关键字参数将被替换。　</p>
<p>kwargs：关键字参数，其他可选参数，如color（颜色）、alpha（透明度）等。</p>
<h3 id="5-6-7-绘制热力图"><a href="#5-6-7-绘制热力图" class="headerlink" title="5.6.7　绘制热力图"></a>5.6.7　绘制热力图</h3><p>热力图是通过密度函数进行可视化用于表示地图中点的密度的热图。它使人们能够独立于缩放因子感知点的密度。热力图可以显示不可点击区域发生的事情。利用热力图可以看数据表里多个特征两两的相似度。例如，以特殊高亮的形式显示访客热衷的页面区域和访客所在的地理区域的图示。热力图在网页分析、业务数据分析等其他领域也有较为广泛的应用。</p>
<p>【示例28】　绘制简单热力图。（示例位置：资源包\MR\Code\05\28）<br>热力图是数据分析的常用方法，通过色差、亮度来展示数据的差异，易于理解。下面绘制简单热力图，程序代码如下：</p>
<p>01 import matplotlib.pyplot as plt<br>02 X = [[1,2],[3,4],[5,6],[7,8],[9,10]]<br>03 plt.imshow(X)<br>运行程序，输出结果如图5.53所示。</p>
<p>​                                                                                              图5.53　简单热力图</p>
<p>上述代码中，plt.imshow(X)中传入的数组X=[[1,2],[3,4],[5,6],[7,8],[9,10]]为颜色的对应值，按照矩阵X进行颜色分布，如左上角颜色为深蓝，其对应值为1，右下角颜色为黄色，其对应值为10，具体如下：</p>
<p>[1,2]  [深蓝,蓝色]<br>[3,4]  [蓝绿,深绿]<br>[5,6]  [海藻绿,春绿色]<br>[7,8]  [绿色,浅绿色]<br>[9,10] [草绿色,黄色]</p>
<h3 id="5-6-8-箱形图"><a href="#5-6-8-箱形图" class="headerlink" title="5.6.8　箱形图"></a>5.6.8　箱形图</h3><p>箱形图又称箱线图、盒须图或盒式图，它是一种用作显示一组数据分散情况下的资料的统计图。因形状像箱子而得名。箱形图最大的优点<strong>就是不受异常值的影响（异常值也称为离群值</strong>），可以以一种相对稳定的方式描述数据的离散分布情况，因此在各种领域也经常被使用。另外，箱形图也常用于异常值的识别。Matplotlib绘制箱形图主要使用boxplot()函数，语法如下：</p>
<p>matplotlib.pyplot.boxplot(x,notch=None,sym=None,vert=None,whis=None,positions=None,widths=None,patch_<br>artist=None,meanline=None,showmeans=None,showcaps=None,showbox=None,showfliers=None,boxprops=None,<br>labels=None,flierprops=None,medianprops=None,meanprops=None,capprops=None,whiskerprops=None)<br>参数说明：　</p>
<p>x：指定要绘制箱形图的数据。　</p>
<p>notch：是否以凹口的形式展现箱形图，默认非凹口。　</p>
<p>sym：指定异常点的形状，默认为加号（+）显示。　</p>
<p>vert：是否需要将箱形图垂直摆放，默认垂直摆放。　</p>
<p>whis：指定上下限与上下四分位的距离，默认为1.5倍的四分位差。　</p>
<p>positions：指定箱形图的位置，默认为[0,1,2,…]。　</p>
<p>widths：指定箱形图的宽度，默认为0.5。　</p>
<p>patch_artist：是否填充箱体的颜色。　</p>
<p>meanline：是否用线的形式表示均值，默认用点来表示。　</p>
<p>showmeans：是否显示均值，默认不显示。　</p>
<p>showcaps：是否显示箱形图顶端和末端的两条线，默认显示。　</p>
<p>showbox：是否显示箱形图的箱体，默认显示。　</p>
<p>showfliers：是否显示异常值，默认显示。　</p>
<p>boxprops：设置箱体的属性，如边框色、填充色等。　</p>
<p>labels：为箱形图添加标签，类似于图例的作用。　</p>
<p>filerprops：设置异常值的属性，如异常点的形状、大小、填充色等。　</p>
<p>medianprops：设置中位数的属性，如线的类型、粗细等。　meanprops：设置均值的属性，如点的大小、颜色等。</p>
<p>capprops：设置箱形图顶端和末端线条的属性，如颜色、粗细等。　</p>
<p>whiskerprops：设置须的属性，如颜色、粗细、线的类型等。</p>
<p>【示例30】　绘制简单箱形图。（示例位置：资源包\MR\Code\05\30）<br>绘制简单箱形图，程序代码如下：</p>
<p>01  import matplotlib.pyplot as plt<br>02  x=[1,2,3,5,7,9]<br>03  plt.boxplot(x)<br>运行程序，输出结果如图5.55所示。</p>
<p>01 import matplotlib.pyplot as plt<br>02 x1=[1,2,3,5,7,9]<br>03 x2=[10,22,13,15,8,19]<br>04 x3=[18,31,18,19,14,29]<br>05 plt.boxplot([x1,x2,x3])<br>运行程序，输出结果如图5.56所示。</p>
<p>下四分位<br>        图5.57中的下四分位数指的是数据的25%分位点所对应的值（Q1）。计算分位数可以使用Pandas的quantile()函数。例如，Q1 = df[‘总消费’].quantile(q = 0.25)。　</p>
<p>中位数<br>        中位数即为数据的50%分位点所对应的值（Q2）。　</p>
<p>上四分位数<br>        上四分位数则为数据的75%分位点所对应的值（Q3）。　</p>
<p>上限<br>        <strong>上限的计算公式为Q3+1.5(Q3-Q1)。</strong>　</p>
<p>下限<br>        下限的计算公式为Q1-1.5(Q3-Q1)。其中，Q3-Q1表示四分位差。如果使用箱形图识别异常值，其判断标准是，当变量的数据值大于箱形图的上限或者小于箱线图的下限时，就可以将这样的数据判定为异常值。</p>
<p>​                                                                                          图5.60　异常值</p>
<p>​                                              </p>
<h3 id="-2"><a href="#-2" class="headerlink" title></a></h3><p>Matplotlib可以实现在一张图上绘制多个子图表。Matplotlib提供了3种方法：一是subplot()函数；二是subplots()函数；三是add_subplot()函数，下面分别介绍。</p>
<h4 id="1．subplot-函数"><a href="#1．subplot-函数" class="headerlink" title="1．subplot()函数"></a>1．subplot()函数</h4><p>subplot()函数直接指定划分方式和位置，它可以将一个绘图区域划分为n个子图，每个subplot()函数只能绘制一个子图。语法如下：</p>
<p>matplotlib.pyplot.subplot(*args,**kwargs)<br>参数说明：　**</p>
<p><em>args：当传入的参数个数未知时使用</em>args。　</p>
<p>kwargs：关键字参数，其他可选参数。<br>例如，绘制一个2×3的区域，subplot(2,3,3)，将画布分成2行3列在第3个区域中绘制，用坐标表示如下：</p>
<p>(1,1),(1,2),(1,3)</p>
<p>(2,1),(2,2),(2,3)<br>如果行列的值都小于10，那么可以把它们缩写为一个整数，如subplot(233)。<br>另外，subplot()函数在指定的区域中创建一个轴对象，如果新创建的轴和之前所创建的轴重叠，那么，之前的轴将被删除。</p>
<p>上述举例，以下两个关键点一定要掌握。<br><strong>（1）每绘制一个子图表都要调用一次subplot()函数。</strong><br><strong>（2）绘图区域位置编号</strong>。<br>subplot()函数的前面两个参数指定的是一个画布被分割成的行数和列数，后面一个参数则指的是当前绘制区域位置编号，编号规则是行优先。<br>例如，图5.64中有3个子图表，第1个子图表subplot(2,2,1)，即将画布分成2行2列，在第1个子图中绘制折线图；第2个子图表subplot(2,2,2)，将画布分成2行2列，在第2个子图中绘制散点图；第3个子图表subplot(2,1,2)，将画布分成2行1列，由于第1行已经占用了，所以在第2行也就是第3个子图中绘制柱形图。示意图如图5.65所示。</p>
<p>​                                                                                               图5.65　多个子图示意图<br>subplot()函数在画布中绘图时，每次都要调用它指定绘图区域非常麻烦，而subplots()函数则更直接，它会事先把画布区域分割好。下面介绍subplots()函数。</p>
<h4 id="2．subplots-函数"><a href="#2．subplots-函数" class="headerlink" title="2．subplots()函数"></a>2．subplots()函数</h4><p>subplots()函数用于创建画布和子图，语法如下：</p>
<p>matplotlib.pyplot.subplots(nrows,ncols,sharex,sharey,squeeze,subplot_kw,gridspec_kw,**fig_kw)<br>参数说明：　</p>
<p>nrows和ncols：表示将画布分割成几行几列，例如，nrows=2、ncols=2表示将画布分割为2行2列，起始值均为0。当调用画布中的坐标轴时，ax[0,0]表示调用左上角的坐标，ax[1,1]表示调用右下角的坐标。　</p>
<p>sharex和sharey：布尔值或者值为“none”“all”“row”“col”，默认值为False。用于控制x或y轴之间的属性共享。具体参数值说明如下。　    </p>
<p>​        True或者“all”：表示x或y轴属性在所有子图中共享。　</p>
<p>​        False或者“none”：表示每个子图的x或y轴都是独立的部分。　</p>
<p>​        “row”：表示每个子图在一个x或y轴上共享行（row）。　</p>
<p>​        “col”：表示每个子图在一个x或y轴上共享列（column）　</p>
<p>squeeze：布尔值，默认值为True，额外的维度从返回的axes（轴）对象中挤出，对于n×1或1×n个子图，返回一个一维数组，对于n×m，n&gt;1和m&gt;1返回一个二维数组；如果值为False，则表示不进行挤压操作，返回一个元素为Axes实例的二维数组，即使它最终是1×1。　</p>
<p>subplot_kw：字典类型，可选参数。把字典的关键字传递给add_subplot()函数来创建每个子图。　</p>
<p>gridspec_kw：字典类型，可选参数。把字典的关键字传递给GridSpec()构造函数创建网格区域，然后将子图放在网格（grid）里。　**fig_kw：把所有详细的关键字参数传递给figure。</p>
<p>【示例37】　使用subplots()函数绘制多子图的空图表。（示例位置：资源包\MR\Code\05\37）<br>绘制一个2×3包含6个子图的空图表，使用subplots()函数只需3行代码。</p>
<p>01 import matplotlib.pyplot as plt<br>02 figure,axes=plt.subplots(2,3)<br>03 plt.show()<br>上述代码中，figure和axes是两个关键点。　</p>
<p>figure：绘制图表的画布。　</p>
<p>axes：坐标轴对象，可以理解为在figure（画布）上绘制坐标轴对象，它帮我们规划出了一个个科学作图的坐标轴系统。</p>
<h4 id="3．add-subplot-函数"><a href="#3．add-subplot-函数" class="headerlink" title="3．add_subplot()函数"></a>3．add_subplot()函数</h4><p>【示例39】　使用add_subplot()函数绘制多子图图表。（示例位置：资源包\MR\Code\05\39）<br>add_subplot()函数也可以实现在一张图上绘制多个子图表，用法与subplot()函数基本相同，先来看下列一段代码：</p>
<p>01 import matplotlib.pyplot as plt<br>02 fig = plt.figure()</p>
<p>03 ax1 = fig.add_subplot(2,3,1)<br>04 ax2 = fig.add_subplot(2,3,2)<br>05 ax3 = fig.add_subplot(2,3,3)<br>06 ax4 = fig.add_subplot(2,3,4)<br>07 ax5 = fig.add_subplot(2,3,5)<br>08 ax6 = fig.add_subplot(2,3,6)<br>上述代码同样是绘制一个2×3包含6个子图的空图表。首先创建figure实例（画布），然后通过ax1 =fig.add_subplot(2,3,1)创建第1个子图表，返回Axes实例（坐标轴对象），第1个参数为行数，第2个参数为列数，第3个参数为子图表的位置。<br>以上用3种方法实现了在一张图上绘制多个子图表，3种方法各有所长。subplot()函数和add_subplot()函数比较灵活，定制化效果比较好，可以实现子图表在图中的各种布局（如一张图上可以随意摆放3个或5个图表）；而subplots()函数较为不灵活，但它可以用较少的代码实现绘制多个子图表。</p>
<h3 id="5-6-11-图表的保存"><a href="#5-6-11-图表的保存" class="headerlink" title="5.6.11　图表的保存"></a>5.6.11　图表的保存</h3><p>实际工作中，有时需要将绘制的图表保存为图片放置到报告中。Matplotlib的savefig()函数可以实现这一功能，将图表保存为JPEG、TIFF或PNG格式的图片。<br>例如，保存之前绘制的折线图，主要代码如下：</p>
<p>plt.savefig(‘image.png’)<br>需要注意的一个关键问题：保存代码必须在图表预览前，也就是plt.show()代码前；否则保存后的图片是白色，图表无法保存。<br>运行程序，图表被保存在程序所在路径下，名为image.png，如图5.68所示。</p>
<p>​                                                                                             图5.68　保存后的图表</p>
<h2 id="5-7-综合应用"><a href="#5-7-综合应用" class="headerlink" title="5.7　综合应用"></a>5.7　综合应用</h2><h3 id="5-7-1-案例1：双y轴可视化数据分析图表的实现"><a href="#5-7-1-案例1：双y轴可视化数据分析图表的实现" class="headerlink" title="5.7.1　案例1：双y轴可视化数据分析图表的实现"></a>5.7.1　案例1：双y轴可视化数据分析图表的实现</h3><p>案例位置：资源包\MR\Code\05\example\01<br>双y轴顾名思义就是两个y轴，其特点是通过双y轴可以看出发展情况的同时还可以看到其增长速度。对于产品而言，通过此图可以看到产品销量的同时还可以看到产品增长率，效果如图5.69所示。</p>
<p>​                                                                           图5.69　双y轴可视化数据分析图表<br>双y轴可视化数据分析图表的实现主要使用add_suplot()函数和twinx()函数。twinx()函数表示共享x轴，那么也就是一个x轴、两个y轴，程序代码如下：</p>
]]></content>
      <categories>
        <category>数据分析文档</category>
      </categories>
  </entry>
  <entry>
    <title>图解数组计算模块NumPy</title>
    <url>/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/</url>
    <content><![CDATA[<h1 id="第8章图解数组计算模块NumPy"><a href="#第8章图解数组计算模块NumPy" class="headerlink" title="第8章图解数组计算模块NumPy"></a>第8章图解数组计算模块NumPy</h1><p>NumPy为数据分析三剑客之一，主要用于数组计算、矩阵运算和科学计算。对于本章的学习，建议初学者灵活学习，重点掌握数组创建、数组的简单操作和计算即可。<br>为了便于理解，本章运用了大量的示意图，用例简单，力求使您能够轻松地融入NumPy的学习中。通过典型案例，让您充分理解NumPy、应用NumPy。<br>下面让我们揭开NumPy神秘的面纱，开启NumPy之旅。</p>
<h1 id="8-1初识NumPy"><a href="#8-1初识NumPy" class="headerlink" title="8.1初识NumPy"></a>8.1初识NumPy</h1><h2 id="8-1-1NumPy概述"><a href="#8-1-1NumPy概述" class="headerlink" title="8.1.1NumPy概述"></a>8.1.1NumPy概述</h2><p>NumPy（见图8.1），更像是一个魔方（见图8.2），它是Python数组计算、矩阵运算和科学计算的核心库，NumPy这个词来源于Numerical和Python两个单词。NumPy提供了一个高性能的数组对象，让我们轻松创建一维数组、二维数组和多维数组，以及大量的函数和方法，帮助我们轻松地进行数组计算，从而广泛地应用于数据分析、机器学习、图像处理和计算机图形学、数学任务等领域当中。</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211025110157989.png" alt="image-20211025110157989"></p>
<p>​                                                                                                            图8.1　NumPy</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211025110220048.png" alt="image-20211025110220048"></p>
<p>​                                                                                                             图8.2　魔方<br>NumPy的用途是以数组的形式对数据进行操作。机器学习中充斥了大量的数组运算，而NumPy使得这些操作变得简单！由于NumPy是C语言实现的，所以其运算速度非常快。具体功能如下。　</p>
<p>有一个强大的n维数组对象ndarray。　</p>
<p>广播功能函数。　</p>
<p>线性代数、傅立叶变换、随机数生成、图形操作等功能。</p>
<p>整合C/C++/Fortran代码的工具。</p>
<h2 id="8-1-2-安装NumPy模块"><a href="#8-1-2-安装NumPy模块" class="headerlink" title="8.1.2　安装NumPy模块"></a>8.1.2　安装NumPy模块</h2><p>安装NumPy有两种方法。</p>
<h3 id="1．使用pip安装"><a href="#1．使用pip安装" class="headerlink" title="1．使用pip安装"></a>1．使用pip安装</h3><p>安装NumPy最简单的方法是使用pip工具，安装命令如下：</p>
<p>pip install pip</p>
<h3 id="2．在PyCharm开发环境中安装"><a href="#2．在PyCharm开发环境中安装" class="headerlink" title="2．在PyCharm开发环境中安装"></a>2．在PyCharm开发环境中安装</h3><p>（1）运行PyCharm，选择File→Settings命令，打开Settings对话框，选择Project Interpreter选项，然后单击添加模块的按钮，如图8.3所示。</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211025110322698.png" alt="image-20211025110322698"></p>
<p>​                                                                                    图8.3　单击添加模块的按钮<br>（2）在搜索栏中输入需要添加的模块名称为numpy，然后选择需要安装的模块，如图8.4所示。单击Install Package按钮即可安装NumPy模块。</p>
<h3 id="3．安装验证"><a href="#3．安装验证" class="headerlink" title="3．安装验证"></a>3．安装验证</h3><p>测试是否安装成功，程序代码如下：</p>
<p>01  from numpy import *   #导入numpy库<br>02  print(eye(4))          #生成对角矩阵<br>运行程序，输出结果如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211025110347905.png" alt="image-20211025110347905"></p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211025111116413.png" alt="image-20211025111116413"></p>
<p>图8.4　在PyCharm开发环境中安装NumPy模块</p>
<h2 id="8-1-3-数组相关概念"><a href="#8-1-3-数组相关概念" class="headerlink" title="8.1.3　数组相关概念"></a>8.1.3　数组相关概念</h2><p>学习NumPy前，我们先了解一下数组相关概念。数组可分为一维数组、二维数组、三维数组，其中三维数组是常见的多维数组，如图8.5所示。</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211025112546228.png" alt="image-20211025112546228"></p>
<p>​                                                                                                 图8.5　数组示意图<br>1．一维数组<br>一维数组很简单，基本和Python列表一样，区别在于数组切片针对的是原始数组（这就意味着，如果对数组进行修改，原始数组也会跟着更改）。<br>2．二维数组<br>二维数组本质是以数组作为数组元素的数组。二维数组包括行和列，类似于表格形状，又称为矩阵。<br>3．三维数组<br>三维数组是指维数为3的数组结构，也称矩阵列表。三维数组是最常见的多维数组，由于其可以用来描述三维空间中的位置或状态而被广泛使用。<br>4．轴的概念</p>
<p>轴是NumPy里的axis，指定某个axis，就是沿着这个axis做相关操作，其中二维数组中两个axis的指向如图8.6所示。<br>对于一维数组，情况有点特殊，它不像二维数组从上向下的操作，而是水平的，因此一维数组其axis=0指向如图8.7所示。</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211025112732987.png" alt="image-20211025112732987"></p>
<p>​                                                                                      图8.6　二维数组两个轴</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211025112750397.png" alt="image-20211025112750397"></p>
<p>​                                                                                     图8.7　一维数组一个轴</p>
<h1 id="8-2-创建数组"><a href="#8-2-创建数组" class="headerlink" title="8.2　创建数组"></a>8.2　创建数组</h1><h2 id="8-2-1-创建简单的数组"><a href="#8-2-1-创建简单的数组" class="headerlink" title="8.2.1　创建简单的数组"></a>8.2.1　创建简单的数组</h2><p>NumPy创建简单的数组主要使用array()函数，语法如下：</p>
<p>numpy.array(object,dtype=None,copy=True,order=’K’,subok=False,ndmin=0)<br>参数说明：　</p>
<p>object：任何具有数组接口方法的对象。　</p>
<p>dtype：数据类型。　</p>
<p>copy：布尔型，可选参数，默认值为True，则object对象被复制；否则，只有当__array__返回副本，object参数为嵌套序列，或者需要副本满足数据类型和顺序要求时，才会生成副本。　</p>
<p>order：元素在内存中的出现顺序，值为K、A、C、F。如果object参数不是数组，则新创建的数组将按行排列（C），如果值为F，则按列排列；如果object参数是一个数组，则C（按行）、F（按列）、A（原顺序）、K（元素在内存中的出现顺序）成立。　</p>
<p>subok：布尔型。如果值为True，则将传递子类；否则返回的数组将强制为基类数组（默认值）。　</p>
<p>ndmin：指定生成数组的最小维数。</p>
<p>【示例01】　演示如何创建数组。（示例位置：资源包\MR\Code\08\01）<br>创建几个简单的数组，效果如图8.8所示。</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211025113205539.png" alt="image-20211025113205539"></p>
<p>​                                                                                                          图8.8　简单数组<br>程序代码如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211025113400111.png" alt="image-20211025113400111"></p>
<h3 id="1．为数组指定数据类型"><a href="#1．为数组指定数据类型" class="headerlink" title="1．为数组指定数据类型"></a>1．为数组指定数据类型</h3><p>【示例02】　为数组指定数据类型。（示例位置：资源包\MR\Code\08\02）<br>NumPy支持比Python更多种类的数据类型，通过dtype参数可以指定数组的数据类型，程序代码如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211025113422663.png" alt="image-20211025113422663"></p>
<p>运行程序，输出结果如下：</p>
<p>[1. 2. 3.]<br>float64<br>&lt;class ‘numpy.float64’&gt;</p>
<h3 id="2．数组的复制"><a href="#2．数组的复制" class="headerlink" title="2．数组的复制"></a>2．数组的复制</h3><p>【示例03】　复制数组。（示例位置：资源包\MR\Code\08\03）<br>当运算和处理数组时，为了不影响到原数组，就需要对原数组进行复制，而对复制后的数组进行修改删除等操作都不会影响到原数组。数组的复制可以通过copy参数实现，程序代码如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211025113521420.png" alt="image-20211025113521420"></p>
<p>运行程序，输出结果如下：</p>
<p>[1 2 3]<br>[3 2 1]<br>数组n2是数组n1的副本，从运行结果得知：虽然修改了数组n2，但是数组n1没有发生变化。</p>
<h3 id="3．通过ndmin参数控制最小维数"><a href="#3．通过ndmin参数控制最小维数" class="headerlink" title="3．通过ndmin参数控制最小维数"></a>3．通过ndmin参数控制最小维数</h3><p>数组可分为一维数组、二维数组和多维数组，通过ndmin参数可以控制数组的最小维数。无论给出的数据的维数是多少，ndmin参数都会根据最小维数创建指定维数的数组。</p>
<p>【示例04】　修改数组的维数。（示例位置：资源包\MR\Code\08\04）<br>ndmin=3，虽然给出的数组是一维的，但是同样会创建一个三维数组，程序代码如下：<br>运行程序，输出结果如下：</p>
<p>[[[1 2 3]]]</p>
<h2 id="8-2-2-不同方式创建数组"><a href="#8-2-2-不同方式创建数组" class="headerlink" title="8.2.2　不同方式创建数组"></a>8.2.2　不同方式创建数组</h2><h3 id="1．创建指定维度和数据类型未初始化的数组"><a href="#1．创建指定维度和数据类型未初始化的数组" class="headerlink" title="1．创建指定维度和数据类型未初始化的数组"></a>1．创建指定维度和数据类型未初始化的数组</h3><p>【示例05】　创建指定维度和未初始化的数组。（示例位置：资源包\MR\Code\08\05）<br>创建指定维度和数据类型未初始化的数组主要使用empty()函数，程序代码如下：</p>
<p>01 import numpy as np<br>02 n = np.empty([2,3])<br>03 print(n)<br>运行程序，输出结果如下：</p>
<p>[[2.22519099e-307 2.33647355e-307 1.23077925e-312]<br>[2.33645827e-307 2.67023123e-307 1.69117157e-306]]<br>这里，数组元素为随机值，因为它们未被初始化。如果要改变数组类型，可以使用dtype参数，如整型，dtype=int。</p>
<h3 id="2．创建指定维度（以0填充）的数组"><a href="#2．创建指定维度（以0填充）的数组" class="headerlink" title="2．创建指定维度（以0填充）的数组"></a>2．创建指定维度（以0填充）的数组</h3><p>【示例06】　创建指定维度（以0填充）的数组。（示例位置：资源包\MR\Code\08\06）<br>创建指定维度并以0填充的数组，主要使用zeros()函数，程序代码如下：</p>
<p>01  import numpy as np<br>02  n = np.zeros(3)<br>03  print(n)<br>运行程序，输出结果如下：</p>
<p>[0. 0. 0.]<br>输出结果默认是浮点型（float）。</p>
<h3 id="3．创建指定维度（以1填充）的数组"><a href="#3．创建指定维度（以1填充）的数组" class="headerlink" title="3．创建指定维度（以1填充）的数组"></a>3．创建指定维度（以1填充）的数组</h3><p>【示例07】　创建指定维度并以1填充的数组。（示例位置：资源包\MR\Code\08\07）<br>创建指定维度并以1填充的数组，主要使用ones()函数，程序代码如下：</p>
<p>01 import numpy as np<br>02 n = np.ones(3)<br>03 print(n)</p>
<p>运行程序，输出结果如下：</p>
<p>[1. 1. 1.]<br>4．创建指定维度和类型的数组并以指定值填充【示例08】　创建以指定值填充的数组。（示例位置：资源包\MR\Code\08\08）<br>创建指定维度和类型的数组并以指定值填充，主要使用full()函数，程序代码如下：</p>
<p>01  import numpy as np<br>02  n = np.full((3,3), 8)<br>03  print(n)<br>运行程序，输出结果如下：</p>
<p>[[8 8 8]<br> [8 8 8]<br> [8 8 8]]</p>
<h2 id="8-2-3-从数值范围创建数组"><a href="#8-2-3-从数值范围创建数组" class="headerlink" title="8.2.3　从数值范围创建数组"></a>8.2.3　从数值范围创建数组</h2><h3 id="1．通过arange-函数创建数组"><a href="#1．通过arange-函数创建数组" class="headerlink" title="1．通过arange()函数创建数组"></a>1．通过arange()函数创建数组</h3><p>arange()函数同Python内置range()函数相似，区别在于返回值，arange()函数返回值是数组，而range()函数返回值是列表。arange()函数的语法如下：</p>
<p>arange([start,] stop[, step,], dtype=None)<br>参数说明：　</p>
<p>start：起始值，默认值为0。　</p>
<p>stop：终止值（不包含）。　</p>
<p>step：步长，默认值为1。　</p>
<p>dtype：创建数组的数据类型，如果不设置数据类型，则使用输入数据的数据类型。</p>
<p>【示例09】　通过数值范围创建数组。（示例位置：资源包\MR\Code\08\09）<br>使用arange()函数通过数值范围创建数组，程序代码如下：</p>
<p>01 import numpy as np<br>02 n=np.arange(1,12,2)<br>03 print(n)<br>运行程序，输出结果如下：</p>
<p>[ 1  3  5  7  9 11]</p>
<h3 id="2．使用linspace-函数创建等差数列"><a href="#2．使用linspace-函数创建等差数列" class="headerlink" title="2．使用linspace()函数创建等差数列"></a>2．使用linspace()函数创建等差数列</h3><p>首先简单了解一下等差数列，等差数列是指如果一个数列从第二项起，每一项与它的前一项的差等于同一个常数，那么这个数列就叫作等差数列。<br>例如，一般成年男鞋的各种尺码，如图8.9所示。</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211025113910259.png" alt="image-20211025113910259"></p>
<p>​                                                                                         图8.9　男鞋尺码对照表</p>
<p>马拉松赛前训练，一周每天的训练量（单位：m），如图8.10所示。</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211025113928239.png" alt="image-20211025113928239"></p>
<p>​                                                                                        图8.10　训练计划<br>在Python中创建等差数列可以使用NumPy的linspace()函数，该函数用于创建一个一维的等差数列的数组，它与arange()函数不同，arange()函数是从开始值到结束值的左闭右开区间（即包括开始值不包括结束值），第三个参数（如果存在）是步长；而linspace()函数是从开始值到结束值的闭区间（可以通过参数endpoint=False，使结束值不是闭区间），并且第三个参数是值的个数。</p>
<p>知识胶囊<br>本文经常会提到诸如“左闭右开区间”“左开右闭区间”“闭区间”等，这里简单介绍一下。“</p>
<p>左闭右开区间”是指包括起始值但不包括终止值的一个数值区间；</p>
<p>“左开右闭区间”是指不包括起始值但包括终止值的一个个数值区间；</p>
<p>“闭区间”是指既包括起始值又包括终止值的一个数值区间。</p>
<p>linspace()函数语法如下：</p>
<p>linspace(start,stop,num=50,endpoint=True,retstep=False,dtype=None)<br>参数说明：　</p>
<p>start：序列的起始值。　</p>
<p>stop：序列的终止值，如果endpoint参数的值为True，则该值包含于数列中。　</p>
<p>num：要生成的等步长的样本数量，默认值为50。　</p>
<p>endpoint：如果值为True，数列中包含stop参数的值；反之则不包含。默认值为True。　</p>
<p>retstep：如果值为True，则生成的数组中会显示间距；反之则不显示。　</p>
<p>dtype：数组的数据类型。</p>
<p>【示例10】　创建马拉松赛前训练等差数列数组。（示例位置：资源包\MR\Code\08\10）<br>创建马拉松赛前训练等差数列数组，程序代码如下：</p>
<p>01 import numpy as np<br>02 n1 = np.linspace(7500,10000,6)<br>03 print(n1)<br>运行程序，输出结果如下：</p>
<p>[ 7500.  8000.  8500.  9000.  9500. 10000.]</p>
<h3 id="3．使用logspace-函数创建等比数列"><a href="#3．使用logspace-函数创建等比数列" class="headerlink" title="3．使用logspace()函数创建等比数列"></a>3．使用logspace()函数创建等比数列</h3><p>首先了解一下等比数列，等比数列是指从第二项起，每一项与它的前一项的比值等于同一个常数的一种数列。<br>例如，在古印度，国王要重赏发明国际象棋的大臣，对他说：我可以满足你的任何要求，大臣说：请给我的棋盘的64个格子都放上小麦，第1个格子放1粒小麦，第2个格子放2粒小麦，第3个格子放4粒小麦，第4个格子放8粒小麦，如图8.11所示。后面每个格子里放的小麦数都是前一个格子里所放小麦数的2倍，直到第64个格子。<br>在Python中创建等比数列可以使用NumPy的logspace()函数，语法如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211025114247449.png" alt="image-20211025114247449"></p>
<p>​                                                                                                            图8.11　棋盘</p>
<p>numpy.logspace(start, stop, num=50, endpoint=True, base=10.0, dtype=None)<br>参数说明：　</p>
<p>start：序列的起始值。　</p>
<p>stop：序列的终止值。如果endpoint参数值为True，则该值包含于数列中。　</p>
<p>num：要生成的等步长的数据样本数量，默认值为50。　</p>
<p>endpoint：如果值为True，则数列中包含stop参数值；反之则不包含。默认值为True。　</p>
<p>base：对数log的底数。　</p>
<p>dtype：数组的数据类型。</p>
<p>【示例11】　通过logspace()函数解决棋盘放置小麦的问题。（示例位置：资源包\MR\Code\08\11）<br>通过logspace()函数计算棋盘中每个格子里放的小麦数是前一个格子里的2倍，直到第64个格子，每个格子里放多少小麦，程序代码如下：</p>
<p>01  import numpy as np<br>02  n = np.logspace(0,63,64,base=2,dtype=’int’)<br>03  print(n)<br>运行程序，输出结果如图8.12所示。</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211025114355783.png" alt="image-20211025114355783"></p>
<p>​                                                                                  图8.12　每个格子里放的小麦数</p>
<p>上述举例出现一个问题：后面大数出现负数，而且都是一样的，这是由于程序中指定的数据类型是int，是32位的，数据范围为-2147483648～2147483647，而我们计算后的数据远远超出了这个范围，因此便出现了溢出现象。解决这一问题，需要指定数据类型为uint64（无符号整数，数据范围为0～18446744073709551615），关键代码如下：</p>
<p>n = np.logspace(0,63,64,base=2,dtype=’uint64’)<br>运行程序，输出结果如图8.13所示。</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211025114438288.png" alt="image-20211025114438288"></p>
<p>​                                                                                     图8.13　每个格子里放的小麦数<br>以上就是每个格子里需要放的小麦数，可见发明国际象棋的大臣是多么聪明。说明<br>关于NumPy数据类型的详细介绍可参见8.3.1节。</p>
<h2 id="8-2-4-生成随机数组"><a href="#8-2-4-生成随机数组" class="headerlink" title="8.2.4　生成随机数组"></a>8.2.4　生成随机数组</h2><p>随机数组的生成主要使用NumPy的random模块，下面介绍几种常用的随机生成数组的函数。</p>
<h3 id="1．rand-函数"><a href="#1．rand-函数" class="headerlink" title="1．rand()函数"></a>1．rand()函数</h3><p>rand()函数用于生成(0,1)之间的随机数组，传入一个值随机生成一维数组，传入一对值则随机生成二维数组，语法如下：</p>
<p>numpy.random.rand(d0,d1,d2,d3,…,dn)<br>参数d0，d1，…，dn为整数，表示维度，可以为空。</p>
<p>【示例12】　随机生成0～1的数组。（示例位置：资源包\MR\Code\08\12）<br>随机生成一维数组和二维数组，代码如下：<br>运行程序，输出结果如下：</p>
<h3 id="2．randn-函数"><a href="#2．randn-函数" class="headerlink" title="2．randn()函数"></a>2．randn()函数</h3><p>randn()函数用于从正态分布中返回随机生成的数组，语法如下：</p>
<p>numpy.random.randn(d0,d1,d2,d3,…,dn)<br>参数d0，d1，…，dn为整数，表示维度，可以为空。</p>
<p>【示例13】　随机生成满足正态分布的数组。（示例位置：资源包\MR\Code\08\13）<br>随机生成满足正态分布的数组，程序代码如下：<br>运行程序，输出结果如下：</p>
<h3 id="3．randint-函数"><a href="#3．randint-函数" class="headerlink" title="3．randint()函数"></a>3．randint()函数</h3><p>randint()函数与NumPy的arange()函数类似。randint()函数用于生成一定范围内的随机数组，左闭右开区间，语法如下：</p>
<p>numpy.random.randint(low,high=None,size=None)</p>
<p>参数说明：　</p>
<p>low：低值（起始值），整数，且当参数high不为空时，参数low应小于参数high；否则程序会出现错误。　</p>
<p>high：高值（终止值），整数。</p>
<p>size：数组维数，整数或者元组，整数表示一维数组，元组表示多维数组。默认值为空，如果为空，则仅返回一个整数。</p>
<p>【示例14】　生成一定范围内的随机数组。（示例位置：资源包\MR\Code\08\14）<br>生成一定范围内的随机数组，程序代码如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211025114630842.png" alt="image-20211025114630842"></p>
<p>运行程序，输出结果如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211025114646241.png" alt="image-20211025114646241"></p>
<h3 id="4．normal-函数"><a href="#4．normal-函数" class="headerlink" title="4．normal()函数"></a>4．normal()函数</h3><p>normal()函数用于生成正态分布的随机数，语法如下：</p>
<p>numpy.random.normal(loc,scale,size)<br>参数说明：　</p>
<p>loc：正态分布的均值，对应正态分布的中心。loc=0说明是一个以y轴为对称轴的正态分布。　</p>
<p>scale：正态分布的标准差，对应正态分布的宽度，scale值越大，正态分布的曲线越“矮胖”；scale值越小，曲线越“高瘦”。　</p>
<p>size：表示数组维数。</p>
<p>【示例15】　生成正态分布的随机数组。（示例位置：资源包\MR\Code\08\15）<br>生成正态分布的随机数组，程序代码如下：</p>
<p>01 import numpy as np<br>02 n = np.random.normal(0, 0.1, 10)<br>03 print(n)<br>运行程序，输出结果如下：</p>
<p>[ 0.08530096  0.0404147  -0.00358281  0.05405901 -0.01677737 -0.02448481<br> 0.13410224 -0.09780364  0.06095256 -0.0431846 ]</p>
<h2 id="8-2-5-从已有的数组中创建数组"><a href="#8-2-5-从已有的数组中创建数组" class="headerlink" title="8.2.5　从已有的数组中创建数组"></a>8.2.5　从已有的数组中创建数组</h2><h3 id="1．asarray-函数"><a href="#1．asarray-函数" class="headerlink" title="1．asarray()函数"></a>1．asarray()函数</h3><p>asarray()函数用于创建数组，其与array()函数类似，语法如下：</p>
<p>numpy.asarray(a,dtype=None,order=None)<br>参数说明：　</p>
<p>a：可以是列表、列表的元组、元组、元组的元组、元组的列表或多维数组。　</p>
<p>dtype：数组的数据类型。　</p>
<p>order：值为C和F，分别代表按行排列和按列排列，即数组元素在内存中的出现顺序。</p>
<p>【示例16】　使用asarray()函数创建数组。（示例位置：资源包\MR\Code\08\16）<br>使用asarray()函数创建数组，程序代码如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211025114735631.png" alt="image-20211025114735631"></p>
<p>运行程序，输出结果如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211025114829679.png" alt="image-20211025114829679"></p>
<h3 id="2．frombuffer-函数"><a href="#2．frombuffer-函数" class="headerlink" title="2．frombuffer()函数"></a>2．frombuffer()函数</h3><p>NumPy的ndarray()数组对象不能像Python列表一样动态地改变其大小，在做数据采集时很不方便。下面介绍如何通过frombuffer()函数实现动态数组。frombuffer()函数接受buffer输入参数，以流的形式将读入的数据转换为数组。frombuffer()函数语法如下：</p>
<p>numpy.frombuffer(buffer,dtype=float,count=-1,offset=0)<br>参数说明：　</p>
<p>buffer：实现了__buffer__方法的对象。　</p>
<p>dtype：数组的数据类型。　</p>
<p>count：读取的数据数量，默认值为-1，表示读取所有数据。　</p>
<p>offset：读取的起始位置，默认值为0。</p>
<p>【示例17】　将字符串“mingrisoft”转换为数组。（示例位置：资源包\MR\Code\08\17）<br>将字符串“mingrisoft”转换为数组，程序代码如下：</p>
<p>01 import numpy as np<br>02 n=np.frombuffer(b’mingrisoft’,dtype=’S1’)<br>03 print(n)<br>关键代码解析：当buffer参数值为字符串时，Python 3默认字符串是Unicode类型，所以要转成Byte string类型，需要在原字符串前加上b。</p>
<h3 id="3．fromiter-函数"><a href="#3．fromiter-函数" class="headerlink" title="3．fromiter()函数"></a>3．fromiter()函数</h3><p>fromiter()函数用于从可迭代对象中建立数组对象，语法如下：</p>
<p>numpy.fromiter(iterable,dtype,count=-1)</p>
<p>参数说明：　</p>
<p>iterable：可迭代对象。　</p>
<p>dtype：数组的数据类型。　</p>
<p>count：读取的数据数量，默认值为-1，表示读取所有数据。</p>
<p>【示例18】　通过可迭代对象创建数组。（示例位置：资源包\MR\Code\08\18）<br>通过可迭代对象创建数组，程序代码如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211025114943273.png" alt="image-20211025114943273"></p>
<p>运行程序，输出结果如下：</p>
<p>[0 2 4 6 8]</p>
<h3 id="4．empty-like-函数"><a href="#4．empty-like-函数" class="headerlink" title="4．empty_like()函数"></a>4．empty_like()函数</h3><p>empty_like()函数用于创建一个与给定数组具有相同维度和数据类型且未初始化的数组，语法如下：</p>
<p>numpy.empty_like(prototype,dtype=None,order=’K’,subok=True)<br>参数说明：　</p>
<p>prototype：给定的数组。　</p>
<p>dtype：覆盖结果的数据类型。　</p>
<p>order：指定数组的内存布局。其中C（按行）、F（按列）、A（原顺序）、K（数据元素在内存中的出现顺序）。　</p>
<p>subok：默认情况下，返回的数组被强制为基类数组。如果值为True，则返回子类。</p>
<p>【示例19】　创建未初始化的数组。（示例位置：资源包\MR\Code\08\19）<br>下面使用empty_like()函数创建一个与给定数组具有相同维数、数据类型以及未初始化的数组，程序代码如下：</p>
<p>01 import numpy as np</p>
<p>02 n = np.empty_like([[1, 2], [3, 4]])<br>03 print(n)<br>运行程序，输出结果如下：</p>
<p>[[0 0]<br> [0 0]]</p>
<h3 id="5．zeros-like-函数"><a href="#5．zeros-like-函数" class="headerlink" title="5．zeros_like()函数"></a>5．zeros_like()函数</h3><p>【示例20】　创建以0填充的数组。（示例位置：资源包\MR\Code\08\20）<br>zeros_like()函数用于创建一个与给定数组维度和数据类型相同，并以0填充的数组，程序代码如下：</p>
<p>01 import numpy as np<br>02 n = np.zeros_like([[0.1,0.2,0.3], [0.4,0.5,0.6]])<br>03 print(n)<br>运行程序，输出结果如下：</p>
<p>[[0. 0. 0.]<br> [0. 0. 0.]]说明<br>参数说明请参见empty_like()函数。</p>
<h3 id="6．ones-like-函数"><a href="#6．ones-like-函数" class="headerlink" title="6．ones_like()函数"></a>6．ones_like()函数</h3><p>【示例21】　创建以1填充的数组。（示例位置：资源包\MR\Code\08\21）<br>ones_like()函数用于创建一个与给定数组维度和数据类型相同，并以1填充的数组，程序代码如下：</p>
<p>01 import numpy as np<br>02 n = np.ones_like([[0.1,0.2,0.3], [0.4,0.5,0.6]])</p>
<p>03 print(n)<br>运行程序，输出结果如下：</p>
<p>[[1. 1. 1.]<br>[1. 1. 1.]]说明<br>参数说明请参见empty_like()函数。</p>
<h3 id="7．full-like-函数"><a href="#7．full-like-函数" class="headerlink" title="7．full_like()函数"></a>7．full_like()函数</h3><p>full_like()函数用于创建一个与给定数组维度和数据类型相同，并以指定值填充的数组，语法如下：</p>
<p>numpy.full_like(a, fill_value, dtype=None, order=’K’, subok=True)<br>参数说明：　</p>
<p>a：给定的数组。　</p>
<p>fill_value：填充值。　</p>
<p>dtype：数组的数据类型，默认值为None，则使用给定数组的数据类型。　</p>
<p>order：指定数组的内存布局。其中C（按行）、F（按列）、A（原顺序）、K（数组元素在内存中的出现顺序）。　</p>
<p>subok：默认情况下，返回的数组被强制为基类数组。如果值为True，则返回子类。</p>
<p>【示例22】　创建以指定值“0.2”填充的数组。（示例位置：资源包\MR\Code\08\22）<br>创建一个与给定数组维度和数据类型相同，并以指定值“0.2”填充的数组，程序代码如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211025115141215.png" alt="image-20211025115141215"></p>
<p>运行程序，输出结果如下：</p>
<p>[1 1 1 1 1 1]<br>[0 0 0 0 0 0]<br>[0.2 0.2 0.2 0.2 0.2 0.2]</p>
<h1 id="8-3-数组的基本操作"><a href="#8-3-数组的基本操作" class="headerlink" title="8.3　数组的基本操作"></a>8.3　数组的基本操作</h1><h3 id="8-3-1-数据类型"><a href="#8-3-1-数据类型" class="headerlink" title="8.3.1　数据类型"></a>8.3.1　数据类型</h3><p>在对数组进行基本操作前，首先了解一下NumPy的数据类型。NumPy的数据类型比Python数据类型增加了更多种类的数值类型，如表8.1所示。为了区别Python数据类型，像bool、int、float、complex、str等数据类型的名称末尾都加了短下画线“_”。</p>
<p>​                                                                                            表8.1　NumPy数据类型表</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211025115201641.png" alt="image-20211025115201641"></p>
<p>每一种数据类型都有相应的数据转换函数。举例如下：</p>
<p>np.int8(3.141)</p>
<p>结果为3。</p>
<p>np.float64(8)<br>结果为8.0。</p>
<p>np.float(True)<br>结果为1.0。</p>
<p>bool(1)<br>结果为True。<br>在创建ndarray数组时，可以直接指定数值类型，关键代码如下：</p>
<p>a = np.arange(8, dtype=float)<br>结果为[0. 1. 2. 3. 4. 5. 6. 7.]。</p>
<p>注意<br>复数不能转换成为整数类型或者浮点数，例如以下的代码会出现错误提示：</p>
<p>float(8+ 1j)</p>
<h3 id="8-3-2-数组运算"><a href="#8-3-2-数组运算" class="headerlink" title="8.3.2　数组运算"></a>8.3.2　数组运算</h3><p>不用编写循环即可对数据执行批量运算，这就是NumPy数组运算的特点，NumPy称之为矢量化。大小相等的数组之间的任何算术运算NumPy都可以实现。本节主要介绍简单的数组运算，如加、减、乘、除、幂运算等。下面创建两个简单的NumPy数组，即n1和n2，数组n1包括元素1和2，数组n2包括元素3和4，如图8.14所示。接下来实现这两个数组的运算。</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211025115248732.png" alt="image-20211025115248732"></p>
<p>​                                                                                                              图8.14　数组示意图</p>
<h4 id="1．加法运算"><a href="#1．加法运算" class="headerlink" title="1．加法运算"></a>1．加法运算</h4><p>例如，加法运算是数组中对应位置的元素相加（即每行对应相加），如图8.15所示。</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211025115350997.png" alt="image-20211025115350997"></p>
<p>​                                                                              图8.15　数组加法运算示意图</p>
<p>【示例23】　数组加法运算。（示例位置：资源包\MR\Code\08\23）<br>在程序中直接将两个数组相加即可，即n1+n2，程序代码如下：<br>运行程序，输出结果如下：</p>
<p>[4 6]</p>
<h4 id="2．减法、乘法和除法运算"><a href="#2．减法、乘法和除法运算" class="headerlink" title="2．减法、乘法和除法运算"></a>2．减法、乘法和除法运算</h4><p>除了加法运算，还可以实现数组的减法、乘法和除法，如图8.16所示。</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211025115411699.png" alt="image-20211025115411699"></p>
<p>​                                                                  图8.16　数组的减法、乘法和除法运算示意图</p>
<p>【示例24】　数组的减法、乘法和除法运算。（示例位置：资源包\MR\Code\06\24）<br>同样，在程序中直接将两个数组相减、相乘或相除即可，程序代码如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211025115431957.png" alt="image-20211025115431957"></p>
<p>运行程序，输出结果如下：</p>
<p>[-2 -2]<br>[3 8]<br>[0.33333333 0.5  ]</p>
<h4 id="3．幂运算"><a href="#3．幂运算" class="headerlink" title="3．幂运算"></a>3．幂运算</h4><p>幂是数组中对应位置元素的幂运算，用两个“*”表示，如图8.17所示。</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211025115515999.png" alt="image-20211025115515999"></p>
<p>​                                                                                   图8.17　数组幂运算示意图</p>
<p>【示例25】　数组的幂运算。（示例位置：资源包\MR\Code\08\25）<br>从图8.17中得知：数组n1的元素1和数组n2的元素3，通过幂运算得到的是1的3次幂；数组n1的元素2和数组n2的元素4，通过幂运算得到的是2的4次幂，程序代码如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211025115559819.png" alt="image-20211025115559819"></p>
<p>运行程序，输出结果如下：</p>
<p>[ 1 16]</p>
<h4 id="4．比较运算"><a href="#4．比较运算" class="headerlink" title="4．比较运算"></a>4．比较运算</h4><p>【示例26】　数组的比较运算。（示例位置：资源包\MR\Code\08\26）<br>数组的比较运算是数组中对应位置元素的比较运算，比较后的结果是布尔值数组，程序代码如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211025115614452.png" alt="image-20211025115614452"></p>
<p>运行程序，输出结果如下：</p>
<p>[False False]<br>[False False]</p>
<p>[ True  True]<br>[ True  True]</p>
<h4 id="5．数组的标量运算"><a href="#5．数组的标量运算" class="headerlink" title="5．数组的标量运算"></a>5．数组的标量运算</h4><p>首先了解两个概念，即标量和向量。标量其实就是一个单独的数；而向量是一组数，这组数是顺序排列的，这里我们理解为数组。那么，数组的标量运算也可以理解为是向量与标量之间的运算。<br>例如，马拉松赛前训练，一周里每天的训练量以“米”（m）为单位，下面将其转换为以“千米”为单位，如图8.18所示。</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211025115659337.png" alt="image-20211025115659337"></p>
<p>​                                                                                             图8.18　数组的标量运算示意图</p>
<p>【示例27】　数组的标量运算。（示例位置：资源包\MR\Code\08\27）<br>在程序中，米转换为千米直接输入n1/1000即可，程序代码如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211025115723224.png" alt="image-20211025115723224"></p>
<p>运行程序，输出结果如下：</p>
<p>[ 7500  8000  8500  9000  9500 10000]<br>[ 7.5  8.   8.5  9.   9.5 10. ]<br>上述运算过程，在NumPy中叫作“广播机制”，它是一个非常有用的功能。</p>
<h3 id="8-3-3-数组的索引和切片"><a href="#8-3-3-数组的索引和切片" class="headerlink" title="8.3.3　数组的索引和切片"></a>8.3.3　数组的索引和切片</h3><p>NumPy数组元素是通过数组的索引和切片来访问和修改的，因此索引和切片是NumPy中最重要、最常用的操作。</p>
<h4 id="1．索引"><a href="#1．索引" class="headerlink" title="1．索引"></a>1．索引</h4><p>所谓数组的索引，即用于标记数组中对应元素的唯一数字，从0开始，即数组中的第一个元素的索引是0，以此类推。NumPy数组可以使用标准Python语法x[obj]的语法对数组进行索引，其中x是数组，obj是索引。</p>
<p>【示例28】　获取一维数组中的元素。（示例位置：资源包\MR\Code\08\28）<br>获取一维数组n1中索引为0的元素，程序代码如下：</p>
<p>01  import numpy as np<br>02  n1=np.array([1,2,3])   #创建一维数组<br>03  print(n1[0])           #输出一维数组的第一个元素<br>运行程序，输出结果如下：</p>
<p>1</p>
<p>【示例29】　获取二维数组中的元素。（示例位置：资源包\MR\Code\08\29）<br>再举一个例子，通过索引获取二维数组中的元素，程序代码如下：</p>
<p>01  import numpy as np<br>02  n1=np.array([[1,2,3],[4,5,6]])   #创建二维数组<br>03  print(n1[1] [2])                  #输出二维数组中第2行第3列的元素<br>运行程序，输出结果如下：</p>
<p>6</p>
<h4 id="2．切片式索引"><a href="#2．切片式索引" class="headerlink" title="2．切片式索引"></a>2．切片式索引</h4><p>数组的切片可以理解为对数组的分割，按照等分或者不等分，将一个数组切割为多个片段，它与Python中列表的切片操作一样。NumPy中的切片用冒号分隔切片参数来进行切片操作，语法如下：</p>
<p>[start:stop:step]<br>参数说明：　</p>
<p>start：起始索引。</p>
<p>stop：终止索引。　</p>
<p>step：步长。</p>
<p>【示例30】　实现简单的数组切片操作。（示例位置：资源包\MR\Code\08\30）<br>实现简单的切片操作，对数组n1进行切片式索引操作，如图8.19所示。</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026163649468.png" alt="image-20211026163649468"></p>
<p>​                                                                                  图8.19　切片式索引示意图<br>程序代码如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026163739258.png" alt="image-20211026163739258"></p>
<p>运行程序，输出结果如下：</p>
<p>1<br>2<br>[1 2]<br>[2 3]<br>[1 2]<br>切片式索引操作需要注意以下几点。<br>（1）索引是左闭右开区间，如上述代码中的n1[0:2]，只能取到索引从0～1的元素，而取不到索引为2的元素。<br>（2）当没有start参数时，代表从索引0开始取数，如上述代码中的n1[:2]。<br>（3）start、stop和step这3个参数都可以是负数，代表反向索引。以step参数为例，如图8.20所示。</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026163851780.png" alt="image-20211026163851780"></p>
<p>​                                                                                        图8.20　反向索引示意图</p>
<p>【示例31】　常用的切片式索引操作。（示例位置：资源包\MR\Code\08\31）<br>常用的切片式索引操作，程序代码如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026163919986.png" alt="image-20211026163919986"></p>
<p>运行程序，输出结果如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026163946683.png" alt="image-20211026163946683"></p>
<h4 id="3．二维数组索引"><a href="#3．二维数组索引" class="headerlink" title="3．二维数组索引"></a>3．二维数组索引</h4><p>二维数组索引可以使用array[n,m]的方式，以逗号分隔，表示第n个数组的，第m个元素。</p>
<p>【示例32】　二维数组的简单索引操作。（示例位置：资源包\MR\Code\08\32）<br>创建一个3行4列的二维数组，实现简单的索引操作，效果如图8.21所示。</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026164056410.png" alt="image-20211026164056410"></p>
<p>​                                                                                                图8.21　二维数组索引示意图<br>程序代码如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026164124849.png" alt="image-20211026164124849"></p>
<p>运行程序，输出结果如下：</p>
<p>[4 5 6 7]<br>6<br>[ 8  9 10 11]<br>上述代码中，n[1]表示第2个数组，n[1,2]表示第2个数组第3个元素，它等同于n[1][2]，表示数组n中第2行第3列的值，实际上n[1] [2]是先索引第一个维度得到一个数组，然后在此基础上再索引。</p>
<h4 id="4．二维数组切片式索引"><a href="#4．二维数组切片式索引" class="headerlink" title="4．二维数组切片式索引"></a>4．二维数组切片式索引</h4><p>【示例33】　二维数组的切片操作。（示例位置：资源包\MR\Code\08\33）<br>创建一个二维数组，实现各种切片式索引操作，效果如图8.22所示。</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026164351235.png" alt="image-20211026164351235"></p>
<p>​                                                                            图8.22　二维数组切片式索引示意图</p>
<p>程序代码如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026164653494.png" alt="image-20211026164653494"></p>
<p>运行程序，输出结果如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026164710619.png" alt="image-20211026164710619"></p>
<h3 id="8-3-4-数组重塑"><a href="#8-3-4-数组重塑" class="headerlink" title="8.3.4　数组重塑"></a>8.3.4　数组重塑</h3><p>数组重塑实际是更改数组的形状，例如，将原来2行3列的数组重塑为3行4列的数组。在NumPy中主要使用reshape()方法，该方法用于改变数组的形状。</p>
<h4 id="1．一维数组重塑"><a href="#1．一维数组重塑" class="headerlink" title="1．一维数组重塑"></a>1．一维数组重塑</h4><p>一维数组重塑就是将数组重塑为多行多列的数组。</p>
<p>【示例34】　将一维数组重塑为二维数组。（示例位置：资源包\MR\Code\08\34）<br>创建一个一维数组，然后通过reshape()方法将其改为2行3列的二维数组，程序代码如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026164736044.png" alt="image-20211026164736044"></p>
<p>运行程序，输出结果如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026164756364.png" alt="image-20211026164756364"></p>
<p>需要注意的是，数组重塑是基于数组元素不发生改变的情况，重塑后的数组所包含的元素个数必须与原数组元素个数相同，如果数组元素发生改变，程序就会报错。</p>
<p>【示例35】　将一行古诗转换为4行5列的二维数组。（示例位置：资源包\MR\Code\08\35）<br>将一行20列的数据转换为4行5列的二维数组，效果如图8.23所示。</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026164923273.png" alt="image-20211026164923273"></p>
<p>​                                                                                                 图8.23　数组重塑示意图<br>程序代码如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026164947021.png" alt="image-20211026164947021"></p>
<p>运行程序，输出结果如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026165004423.png" alt="image-20211026165004423"></p>
<h4 id="2．多维数组重塑"><a href="#2．多维数组重塑" class="headerlink" title="2．多维数组重塑"></a>2．多维数组重塑</h4><p>多维数组重塑同样使用reshape()方法。</p>
<p>【示例36】　将2行3列的数组重塑为3行2列的数组。（示例位置：资源包\MR\Code\08\36）<br>将2行3列的二维数组重塑为3行2列的二维数组，程序代码如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026165037961.png" alt="image-20211026165037961"></p>
<p>运行程序，输出结果如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026165053942.png" alt="image-20211026165053942"></p>
<h4 id="3．数组转置"><a href="#3．数组转置" class="headerlink" title="3．数组转置"></a>3．数组转置</h4><p>数组转置是指数组的行列转换，可以通过数组的T属性和transpose()函数实现。</p>
<p>【示例37】　将二维数组中的行列转置。（示例位置：资源包\MR\Code\08\37）<br>通过T属性将4行6列的二维数组中的行变成列，列变成行，程序代码如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026165138211.png" alt="image-20211026165138211"></p>
<p>运行程序，输出结果如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026165155864.png" alt="image-20211026165155864"></p>
<p>【示例38】　转换客户销售数据。（示例位置：资源包\MR\Code\08\38）<br>上述举例可能不太直观，下面再举一个例子，转换客户销售数据，对比效果如图8.24所示。</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026165234909.png" alt="image-20211026165234909"></p>
<p>​                                                                     图8.24　客户销售数据转换对比示意图<br>程序代码如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026165254710.png" alt="image-20211026165254710"></p>
<p>运行程序，输出结果如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026165309989.png" alt="image-20211026165309989"></p>
<p>transpose()函数也可以实现数组转置。例如，上述举例用transpose()函数实现，关键代码如下：</p>
<p>01  n = np.array([[‘A’,100],[‘B’,200],[‘C’,300],[‘D’,400],[‘E’,500]])<br>02  print(n.transpose())                           #transpose()函数行列转置<br>运行程序，输出结果如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026165407591.png" alt="image-20211026165407591"></p>
<h3 id="8-3-5-数组的增、删、改、查"><a href="#8-3-5-数组的增、删、改、查" class="headerlink" title="8.3.5　数组的增、删、改、查"></a>8.3.5　数组的增、删、改、查</h3><p>数组增、删、改、查的方法有很多种，下面介绍几种常用的方法。</p>
<h4 id="1．数组的增加"><a href="#1．数组的增加" class="headerlink" title="1．数组的增加"></a>1．数组的增加</h4><p>数组数据的增加可以按照水平方向增加数据，也可以按照垂直方向增加数据。水平方向增加数据主要使用hstack()函数，垂直方向增加数据主要使用vstack()函数。</p>
<p>【示例39】　为数组增加数据。（示例位置：资源包\MR\Code\08\39）<br>创建两个二维数组，然后实现数组数据的增加，程序代码如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026165507946.png" alt="image-20211026165507946"></p>
<p>运行程序，输出结果如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026165522416.png" alt="image-20211026165522416"></p>
<h4 id="2．数组的删除"><a href="#2．数组的删除" class="headerlink" title="2．数组的删除"></a>2．数组的删除</h4><p>数组的删除主要使用delete()方法。</p>
<p>【示例40】　删除指定的数组。（示例位置：资源包\MR\Code\08\40）<br>删除指定的数组，程序代码如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026165543012.png" alt="image-20211026165543012"></p>
<p>运行程序，输出结果如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026165601688.png" alt="image-20211026165601688"></p>
<p>那么，对于不想要的数组或数组元素还可以通过索引和切片方法只选取需要的数组或数组元素。</p>
<h4 id="3．数组的修改"><a href="#3．数组的修改" class="headerlink" title="3．数组的修改"></a>3．数组的修改</h4><p>修改数组或数组元素时，直接为数组或数组元素赋值即可。</p>
<p>【示例41】　修改指定的数组。（示例位置：资源包\MR\Code\08\41）<br>修改指定的数组，程序代码如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026165836901.png" alt="image-20211026165836901"></p>
<p>运行程序，输出结果如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026165851666.png" alt="image-20211026165851666"></p>
<h4 id="4．数组的查询"><a href="#4．数组的查询" class="headerlink" title="4．数组的查询"></a>4．数组的查询</h4><p>数组的查询同样可以使用索引和切片方法来获取指定范围的数组或数组元素，还可以通过where()函数查询符合条件的数组或数组元素。where()函数语法如下：</p>
<p>numpy.where(condition,x,y)<br>上述语法，第一个参数为一个布尔数组，第二个参数和第三个参数可以是标量也可以是数组。满足条件（参数condition），输出参数x，不满足条件输出参数y。</p>
<p>【示例42】　按指定条件查询数组。（示例位置：资源包\MR\Code\08\42）<br>数组查询，大于5输出2，不大于5输出0，程序代码如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026165929414.png" alt="image-20211026165929414"></p>
<p>运行程序，输出结果如下：</p>
<p>[0 1 2 3 4 5 6 7 8 9]<br>[0 0 0 0 0 0 2 2 2 2]<br>如果不指定参数x和y，则输出满足条件的数组元素的坐</p>
<p>标。例如，上述举例不指定参数x和y，关键代码如下：</p>
<p>01  n2=n1[np.where(n1&gt;5)]<br>02  print(n2)<br>运行程序，输出结果如下：</p>
<p>[6 7 8 9]</p>
<h1 id="8-4-NumPy矩阵的基本操作"><a href="#8-4-NumPy矩阵的基本操作" class="headerlink" title="8.4　NumPy矩阵的基本操作"></a>8.4　NumPy矩阵的基本操作</h1><p>在数学中经常会看到矩阵，而在程序中常用的是数组，可以简单地理解为，矩阵是数学的概念，而数组是计算机程序设计领域的概念。在NumPy中，矩阵是数组的分支，数组和矩阵有些时候是通用的，二维数组也称矩阵。下面简单介绍矩阵的基本操作。</p>
<h2 id="8-4-1-创建矩阵"><a href="#8-4-1-创建矩阵" class="headerlink" title="8.4.1　创建矩阵"></a>8.4.1　创建矩阵</h2><p>NumPy函数库中存在两种不同的数据类型（矩阵matrix和数组array），它们都可以用于处理行列表示的数组元素，虽然它们看起来很相似，但是在这两种数据类型上执行相同的数学运算，可能得到不同的结果。<br>在NumPy中，矩阵应用十分广泛。例如，每个图像可以被看作像素值矩阵。假设一个像素值仅为0和1，那么5×5大小的图像就是一个5×5的矩阵，如图8.25所示；而3×3大小的图像就是一个3×3的矩阵，如图8.26所示。</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026170015304.png" alt="image-20211026170015304"></p>
<p>​                                                                                             图8.25　5×5矩阵示意图</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026170035799.png" alt="image-20211026170035799"></p>
<p>​                                                                                                图8.26　3×3矩阵示意图<br>关于矩阵就简单了解到这里，下面介绍如何在NumPy中创建矩阵。</p>
<p>【示例43】　创建简单矩阵。（示例位置：资源包\MR\Code\08\43）<br>使用mat()函数创建矩阵，程序代码如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026170127022.png" alt="image-20211026170127022"></p>
<p>运行程序，输出结果如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026170143985.png" alt="image-20211026170143985"></p>
<p>从运行结果得知：mat()函数创建的是矩阵类型，array()函数创建的是数组类型，而用mat()函数创建的矩阵才能进行一些线性代数的操作。</p>
<p>【示例44】　使用mat()函数创建常见的矩阵。（示例位置：资源包\MR\Code\08\44）<br>下面使用mat()函数创建常见的矩阵。<br>（1）创建一个3×3的0（零）矩阵，程序代码如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026170213383.png" alt="image-20211026170213383"></p>
<p>运行程序，输出结果如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026170242743.png" alt="image-20211026170242743"></p>
<p>（2）创建一个2×4的1矩阵，程序代码如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026170348020.png" alt="image-20211026170348020"></p>
<p>运行程序，输出结果如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026170431915.png" alt="image-20211026170431915"></p>
<p>（3）使用random模块的rand()函数创建一个3×3为0～1随机产生的二维数组，并将其转换为矩阵，程序代码如下：</p>
<p>01  import numpy as np</p>
<p>02  data1 = np.mat(np.random.rand(3,3))<br>03  print(data1)<br>运行程序，输出结果如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026170511819.png" alt="image-20211026170511819"></p>
<p>（4）创建一个1～8的随机整数矩阵，程序代码如下：</p>
<p>01 import numpy as np<br>02 data1 = np.mat(np.random.randint(1,8,size=(3,5)))<br>03 print(data1)<br>运行程序，输出结果如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026170540232.png" alt="image-20211026170540232"></p>
<p>（5）创建对角矩阵，程序代码如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026170625799.png" alt="image-20211026170625799"></p>
<p>运行程序，输出结果如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026170642474.png" alt="image-20211026170642474"></p>
<p>（6）创建对角线矩阵，程序代码如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026170716487.png" alt="image-20211026170716487"></p>
<p>运行程序，输出结果如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026170742422.png" alt="image-20211026170742422"></p>
<p>说明<br>mat()函数只适用于二维矩阵，维数超过2以后，mat()</p>
<p>函数就不适用了，从这一点来看array()函数更具通用性。</p>
<h2 id="8-4-2-矩阵运算"><a href="#8-4-2-矩阵运算" class="headerlink" title="8.4.2　矩阵运算"></a>8.4.2　矩阵运算</h2><p>如果两个矩阵大小相同，我们可以使用算术运算符“+”“-”“*”“/”对矩阵进行加、减、乘、除的运算。</p>
<p>【示例45】　矩阵加法运算。（示例位置：资源包\MR\Code\08\45）<br>创建两个矩阵data1和data2，实现矩阵的加法运算，效果如图8.27所示。</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026170836683.png" alt="image-20211026170836683"></p>
<p>​                                                                  图8.27　矩阵的加法运算示意图<br>程序代码如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026170917227.png" alt="image-20211026170917227"></p>
<p>运行程序，输出结果如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026170933858.png" alt="image-20211026170933858"></p>
<p>【示例46】　矩阵减法、乘法和除法运算。（示例位置：资源包\MR\Code\08\46）<br>除了加法运算，还可以实现矩阵的减法、乘法和除法运算。接下来实现上述矩阵的减法和除法运算，程序代码如下：<br>运行程序，输出结果如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026170952257.png" alt="image-20211026170952257"></p>
<p>当对上述矩阵实现乘法运算时，程序出现了错误，原因是矩阵的乘法运算，要求左边矩阵的列和右边矩阵的行数要一致。由于上述矩阵data2只有一行，所以导致程序出错。</p>
<p>【示例47】　修改矩阵并进行乘法运算。（示例位置：资源包\MR\Code\08\47）</p>
<p>将矩阵data2改为2×2矩阵，再进行矩阵的乘法运算，程序代码如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026171103706.png" alt="image-20211026171103706"></p>
<p>运行程序，输出结果如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026171125494.png" alt="image-20211026171125494"></p>
<p>上述举例，是两个矩阵直接相乘，称之为矩阵相乘。矩阵相乘是第一个矩阵中与该元素行号相同的元素与第二个矩阵中与该元素列号相同的元素，两两相乘后再求和，运算过程如图8.28所示。例如，1×1+2×3=7，是第一个矩阵第1行元素与第二个矩阵第1列元素，两两相乘求和得到的。</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026171144696.png" alt="image-20211026171144696"></p>
<p>​                                                                         图8.28　矩阵相乘运算过程示意图<br>数组运算和矩阵运算的一个关键区别是矩阵相乘使用的是点乘。点乘，也称点积，是数组中元素对应位置一一相乘之后求和的操作，在NumPy中专门提供了点乘方法，即dot()方法，该方法返回的是两个数组的点积。</p>
<p>【示例48】　数组相乘与数组点乘比较。（示例位置：资源包\MR\Code\08\48）<br>数组相乘与数组点乘运算，程序代码如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026171207973.png" alt="image-20211026171207973"></p>
<p>运行程序，输出结果如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026171222686.png" alt="image-20211026171222686"></p>
<p>【示例49】　矩阵元素之间的相乘运算。（示例位置：资源包\MR\Code\08\49）<br>要实现矩阵对应元素之间的相乘可以使用multiply()函数，程序代码如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026171240997.png" alt="image-20211026171240997"></p>
<p>运行程序，输出结果如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026173555512.png" alt="image-20211026173555512"></p>
<h2 id="8-4-3-矩阵转换"><a href="#8-4-3-矩阵转换" class="headerlink" title="8.4.3　矩阵转换"></a>8.4.3　矩阵转换</h2><h3 id="1．矩阵转置"><a href="#1．矩阵转置" class="headerlink" title="1．矩阵转置"></a>1．矩阵转置</h3><p>【示例50】　使用T属性实现矩阵转置。（示例位置：资源包\MR\Code\08\50）<br>矩阵转置与数组转置一样使用T属性，程序代码如下：</p>
<p>01  import numpy as np<br>02  n1 = np.mat(‘1 3 3;4 5 6;7 12 9’)            #创建矩阵，使用分号隔开数据<br>03  print(‘矩阵转置结果为：\n’,n1.T)             #矩阵转置<br>运行程序，输出结果如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026173620078.png" alt="image-20211026173620078"></p>
<h3 id="2．矩阵求逆"><a href="#2．矩阵求逆" class="headerlink" title="2．矩阵求逆"></a>2．矩阵求逆</h3><p>【示例51】　实现矩阵逆运算。（示例位置：资源包\MR\Code\08\51）<br>矩阵要可逆，否则意味着该矩阵为奇异矩阵（即矩阵的行列式的值为0）。矩阵求逆主要使用I属性，程序代码如下：</p>
<p>01  import numpy as np<br>02  n1 = np.mat(‘1 3 3;4 5 6;7 12 9’)       #创建矩阵，使用分号隔开数据<br>03  print(‘矩阵的逆矩阵结果为：\n’,n1.I)    #逆矩阵<br>运行程序，输出结果如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026173645127.png" alt="image-20211026173645127"></p>
<h1 id="8-5-NumPy常用统计分析函数"><a href="#8-5-NumPy常用统计分析函数" class="headerlink" title="8.5　NumPy常用统计分析函数"></a>8.5　NumPy常用统计分析函数</h1><h2 id="8-5-1-数学运算函数"><a href="#8-5-1-数学运算函数" class="headerlink" title="8.5.1　数学运算函数"></a>8.5.1　数学运算函数</h2><p>NumPy包含大量的数学运算的函数，包括三角函数、算术运算函数、复数处理函数等，如表8.2所示。</p>
<p>​                                                                                        表8.2　数学运算函数</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026173754018.png" alt="image-20211026173754018"></p>
<p>下面介绍几个常用的数学运算函数。</p>
<h3 id="1．算术函数"><a href="#1．算术函数" class="headerlink" title="1．算术函数"></a>1．算术函数</h3><h3 id="（1）加、减、乘、除"><a href="#（1）加、减、乘、除" class="headerlink" title="（1）加、减、乘、除"></a>（1）加、减、乘、除</h3><p>NumPy算术函数包含简单的加、减、乘、除运算，如add()函数、subtract()函数、multiply()函数和divide()函数。这里要注意的是，数组必须具有相同的形状或符合数组广播规则。</p>
<p>【示例52】　数组加、减、乘、除运算。（示例位置：资源包\MR\Code\08\52）<br>数组加、减、乘、除运算，程序代码如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026173820639.png" alt="image-20211026173820639"></p>
<p>运行程序，输出结果如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026173836746.png" alt="image-20211026173836746"></p>
<h3 id="（2）倒数"><a href="#（2）倒数" class="headerlink" title="（2）倒数"></a>（2）倒数</h3><p>reciprocal()函数用于返回数组中各元素的倒数。如4/3的倒数是3/4。</p>
<p>【示例53】　计算数组元素的倒数。（示例位置：资源包\MR\Code\08\53）<br>计算数组元素的倒数，程序代码如下：</p>
<p>01 import numpy as np<br>02 a = np.array([0.25, 1.75, 2, 100])<br>03 print(np.reciprocal(a))<br>运行程序，输出结果如下：</p>
<p>[4.  0.57142857 0.5  0.01  ]</p>
<h3 id="（3）求幂"><a href="#（3）求幂" class="headerlink" title="（3）求幂"></a>（3）求幂</h3><p>power()函数将第一个数组中的元素作为底数，计算它与第二个数组中相应元素的幂。</p>
<p>【示例54】　数组元素的幂运算。（示例位置：资源包\MR\Code\08\54）<br>对数组元素幂运算，程序代码如下：</p>
<p>01 import numpy as np<br>02 n1 = np.array([10, 100, 1000])<br>03 print(np.power(n1, 3))<br>04 n2= np.array([1, 2, 3])<br>05 print(np.power(n1, n2))<br>运行程序，输出结果如下：</p>
<p>[  1000  1000000 1000000000]<br>[    10    10000 1000000000]</p>
<h3 id="（4）取余"><a href="#（4）取余" class="headerlink" title="（4）取余"></a>（4）取余</h3><p>mod()函数用于计算数组之间相应元素相除后的余数。</p>
<p>【示例55】　对数组元素取余。（示例位置：资源包\MR\Code\08\55）<br>对数组元素取余，程序代码如下：</p>
<p>01  import numpy as np<br>02  n1 = np.array([10, 20, 30])<br>03  n2 = np.array([4, 5, -8])<br>04  print(np.mod(n1, n2))<br>运行程序，输出结果如下：</p>
<p>[ 2  0 -2]</p>
<p>知识胶囊<br>下面重点介绍NumPy负数取余的算法，公式如下：<br>r=a-n*[a//n]<br>其中r为余数，a是被除数，n是除数，“//”为运算取商时保留整数的下界，即偏向于较小的整数。根据负数取余的3种情况，举例如下：<br>r=30-(-8)<em>(30//(-8))=30-(-8)</em>(-4)=30-32=-2<br>r=-30-(-8)<em>(-30//(-8))=-30-(-8)</em>(3)=-30-24=-6<br>r=-30-(8)<em>(-30//(8))=-30-(8)</em>(-4)=-30+32=2</p>
<h3 id="2．舍入函数"><a href="#2．舍入函数" class="headerlink" title="2．舍入函数"></a>2．舍入函数</h3><h3 id="（1）四舍五入around-函数"><a href="#（1）四舍五入around-函数" class="headerlink" title="（1）四舍五入around()函数"></a>（1）四舍五入around()函数</h3><p>四舍五入在NumPy中应用比较多，主要使用around()函数，该函数返回指定小数位数的四舍五入值，语法如下：</p>
<p>numpy.around(a,decimals)<br>参数说明：　</p>
<p>a：数组。　</p>
<p>decimals：舍入的小数位数，默认值为0，如果为负，整数将四舍五入到小数点左侧的位置。</p>
<p>【示例56】　将数组中的一组数字四舍五入。（示例位置：资源包\MR\Code\08\56）<br>将数组中的一组数字四舍五入，程序代码如下：<br>运行程序，输出结果如下：</p>
<p>[  2.   7. 100.   0.  3.  -2.]<br>[  1.55   6.82 100.    0.12   3.14  -2.35]<br>[  0.  10. 100.   0.  0.  -0.]</p>
<h3 id="（2）向上取整ceil-函数"><a href="#（2）向上取整ceil-函数" class="headerlink" title="（2）向上取整ceil()函数"></a>（2）向上取整ceil()函数</h3><p>ceil()函数用于返回大于或者等于指定表达式的最小整数，即向上取整。</p>
<p>【示例57】　对数组元素向上取整。（示例位置：资源包\MR\Code\08\57）<br>对数组元素向上取整，程序代码如下：<br>运行程序，输出结果如下：</p>
<p>[-1.  2. -0.  1. 15.]</p>
<h3 id="（3）向下取整floor-函数"><a href="#（3）向下取整floor-函数" class="headerlink" title="（3）向下取整floor()函数"></a>（3）向下取整floor()函数</h3><p>floor()函数用于返回小于或者等于指定表达式的最大整数，即向下取整。</p>
<p>【示例58】　对数组元素向下取整。（示例位置：资源包\MR\Code\08\58）</p>
<p>对数组元素向下取整，程序代码如下：</p>
<p>01  import numpy as np<br>02  n = np.array([-1.8, 1.66, -0.2, 0.888, 15])     #创建数组<br>03  print(np.floor(n))                              #向下取整<br>运行程序，输出结果如下：</p>
<p>[-2.  1. -1.  0. 15.]</p>
<h3 id="3．三角函数"><a href="#3．三角函数" class="headerlink" title="3．三角函数"></a>3．三角函数</h3><p>NumPy提供了标准的三角函数，即sin()函数、cos()函数和tan()函数。</p>
<p>【示例59】　计算数组的正弦值、余弦值和正切值。（示例位置：资源包\MR\Code\08\59）<br>计算数组元素的正弦值、余弦值和正切值，程序代码如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026174155746.png" alt="image-20211026174155746"></p>
<p>运行程序，输出结果如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026174212800.png" alt="image-20211026174212800"></p>
<p>arcsin()函数、arccos()函数和arctan()函数用于返回给定角度的sin、cos和tan的反三角函数。这些函数的结果可以通过degrees()函数将弧度转换为角度。</p>
<p>【示例60】　将弧度转换为角度。（示例位置：资源包\MR\Code\08\60）<br>首先计算不同角度的正弦值，然后使用arcsin()函数计算角度的反正弦，返回值以弧度为单位，最后使用degrees()函数将弧度转换为角度来验证结果，程序代码如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026174231238.png" alt="image-20211026174231238"></p>
<p>运行程序，输出结果如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026174311391.png" alt="image-20211026174311391"></p>
<p>arccos()函数和arctan()函数的用法与arcsin()函数的用法差不多，这里不再举例。</p>
<h2 id="8-5-2-统计分析函数"><a href="#8-5-2-统计分析函数" class="headerlink" title="8.5.2　统计分析函数"></a>8.5.2　统计分析函数</h2><p>统计分析函数是对整个NumPy数组或某条轴的数据进行统计运算，函数介绍如表8.3所示。</p>
<p>​                                                                                           表8.3　统计分析函数</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026174357030.png" alt="image-20211026174357030"></p>
<p>下面介绍几个常用的统计函数。首先创建一个数组，如图8.29所示。</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026174437338.png" alt="image-20211026174437338"></p>
<p>​                                                                                          图8.29　数组示意图</p>
<h3 id="1．求和sum-函数"><a href="#1．求和sum-函数" class="headerlink" title="1．求和sum()函数"></a>1．求和sum()函数</h3><p>【示例61】　对数组元素求和。（示例位置：资源包\MR\Code\08\61）<br>对数组元素求和、对数组元素按行和按列求和，程序代码如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026174535205.png" alt="image-20211026174535205"></p>
<p>运行程序，输出结果如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026174553779.png" alt="image-20211026174553779"></p>
<h3 id="2．求平均值mean-函数"><a href="#2．求平均值mean-函数" class="headerlink" title="2．求平均值mean()函数"></a>2．求平均值mean()函数</h3><p>【示例62】　对数组元素求平均值。（示例位置：资源包\MR\Code\08\62）<br>对数组元素求平均值、对数组元素按行求平均值和按列求平均值，关键代码如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026174622127.png" alt="image-20211026174622127"></p>
<p>运行程序，输出结果如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026174644781.png" alt="image-20211026174644781"></p>
<h3 id="3．求最大值max-函数和最小值min-函数"><a href="#3．求最大值max-函数和最小值min-函数" class="headerlink" title="3．求最大值max()函数和最小值min()函数"></a>3．求最大值max()函数和最小值min()函数</h3><p>【示例63】　对数组元素求最大值和最小值。（示例位置：资源包\MR\Code\08\63）<br>对数组元素求最大值和最小值，关键代码如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026174704524.png" alt="image-20211026174704524"></p>
<p>运行程序，输出结果如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026174733324.png" alt="image-20211026174733324"></p>
<p>对二维数组求最大值在实际应用中非常广泛。例如，统计销售冠军。</p>
<h3 id="4．求加权平均average-函数"><a href="#4．求加权平均average-函数" class="headerlink" title="4．求加权平均average()函数"></a>4．求加权平均average()函数</h3><p>在日常生活中，常用平均数表示一组数据的“平均水平”。在一组数据里，一个数据出现的次数称为权。将一组数据与出现的次数相乘再平均就是“加权平均”。加权平均能够反映一组数据中各个数据的重要程度，以及对整体趋势的影响。加权平均在日常生活应用非常广泛，如考试成绩、股票价格、竞技比赛等。</p>
<p>【示例64】　计算电商各活动销售的加权平均价。（示例位置：资源包\MR\Code\08\64）<br>某电商在开学季、6.18、双十一、双十二等活动价格均不同，下面计算加权平均价，程序代码如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026174836425.png" alt="image-20211026174836425"></p>
<p>运行程序，输出结果如下：</p>
<p>加权平均价：<br>34.84920634920635</p>
<h3 id="5．中位数median-函数"><a href="#5．中位数median-函数" class="headerlink" title="5．中位数median()函数"></a>5．中位数median()函数</h3><p>中位数用来衡量数据取值的中等水平或一般水平，可以避免极端值的影响。在数据处理过程中，当数据中存在少量异常值时，它不受其影响，基于这一特点，一般使用中位数来评价分析结果。<br>那么，什么是中位数？将各个变量值按大小顺序排列起来，形成一个数列，居于数列中间位置的那个数即为中位数。例如，1、2、3、4、5这5个数，中位数就是中间的数字3，而1、2、3、4、5、6这6个数，中位数则是中间两个数的平均值，即3.5。</p>
<p>知识胶囊<br>中位数与平均数不同，它不受异常值的影响。例如，将1、2、3、4、5、6改为1、2、3、4、5、288，中位数依然是3.5。</p>
<p>【示例65】　计算电商活动价格的中位数。（示例位置：资源包\MR\Code\08\65）<br>计算电商在开学季、6.18、双十一、双十二等活动价格的中位数，程序代码如下：<br>运行程序，输出结果如下：</p>
<p>数组排序：<br>[33.6 34.5 36. 37.8 39. 39.8]数组中位数为：<br>36.9</p>
<h3 id="6．方差、标准差"><a href="#6．方差、标准差" class="headerlink" title="6．方差、标准差"></a>6．方差、标准差</h3><p>方差、标准差的定义在第4章已经介绍过了，这里不再赘述，直接进入主题。</p>
<p>【示例66】　求数组的方差和标准差。（示例位置：资源包\MR\Code\08\66）<br>在NumPy中实现方差和标准差，程序代码如下：<br>运行程序，输出结果如下：</p>
<p>数组方差：<br>5.168055555555551数组标准差：<br>2.2733357771247853</p>
<h2 id="8-5-3-数组的排序"><a href="#8-5-3-数组的排序" class="headerlink" title="8.5.3　数组的排序"></a>8.5.3　数组的排序</h2><p>数组的排序是对数组元素进行排序。</p>
<h3 id="1．sort-函数"><a href="#1．sort-函数" class="headerlink" title="1．sort()函数"></a>1．sort()函数</h3><p>使用sort()函数进行排序，直接改变原数组，参数axis指定按行排序还是按列排序。</p>
<p>【示例67】　对数组元素按行和列排序。（示例位置：资源包\MR\Code\08\67）<br>对数组元素排序，程序代码如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026175022606.png" alt="image-20211026175022606"></p>
<p>运行程序，输出结果如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026175038158.png" alt="image-20211026175038158"></p>
<h3 id="2．argsort-函数"><a href="#2．argsort-函数" class="headerlink" title="2．argsort()函数"></a>2．argsort()函数</h3><p>使用argsort()函数对数组进行排序，返回升序排序之后数组值从小到大的索引值。</p>
<p>【示例68】　对数组元素升序排序。（示例位置：资源包\MR\Code\08\68）<br>对数组元素排序，程序代码如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026175100199.png" alt="image-20211026175100199"></p>
<p>运行程序，输出结果如下：</p>
<p>升序排序后的索引值：<br>[6 3 2 0 5 8 1 4 7]<br>排序后的顺序重构原数组：<br>[1 2 3 4 5 6 7 8 9]</p>
<h3 id="3．lexsort-函数"><a href="#3．lexsort-函数" class="headerlink" title="3．lexsort()函数"></a>3．lexsort()函数</h3><p>lexsort()函数用于对多个序列进行排序。可以把它当作是对电子表格进行排序，每一列代表一个序列，排序时优先照顾靠后的列。</p>
<p>【示例69】　通过排序解决成绩相同学生的录取问题。（示例位置：资源包\MR\Code\08\69）<br>某重点高中，精英班录取学生按照总成绩录取。由于名额有限，因此当总成绩相同时，数学成绩高的优先录取；当总成绩和数学成绩都相同时，按照英语成绩高的优先录取。下面使用lexsort()函数对学生成绩进行排序，程序代码如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026175145965.png" alt="image-20211026175145965"></p>
<p>运行程序，输出结果如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026175200074.png" alt="image-20211026175200074"></p>
<p>上述举例，按照数学、英语和总分进行升序排序，总成绩620分的两名同学，按照数学成绩高的优先录取原则进行第一轮排序，总分615分的两名同学，同时他们的数学成绩也相同，则按照英语成绩高的优先录取原则进行第二轮排序。</p>
<h1 id="8-6-综合应用"><a href="#8-6-综合应用" class="headerlink" title="8.6　综合应用"></a>8.6　综合应用</h1><h2 id="8-6-1-案例1：NumPy实现正态分布"><a href="#8-6-1-案例1：NumPy实现正态分布" class="headerlink" title="8.6.1　案例1：NumPy实现正态分布"></a>8.6.1　案例1：NumPy实现正态分布</h2><p>案例位置：资源包\MR\Code\08\example\01<br>首先简单了解一下什么是正态分布。正态分布，也称“常态分布”，又名高斯分布，它在数据分析的许多方面有着重大的影响力。<br>正态分布是应用最广泛、最常见的一种数据分布形式。正态分布像一只倒扣的钟，两头低，中间高，左右对称，大部分数据集中在平均值附近，小部分在两端。例如，学生成绩的分布，高分和低分的成绩一般是少数，分布在两端，而大部分成绩集中在中间，如图8.30所示。<br>下面使用NumPy生成均值为0，标准差为0.1的一维正态分布样本1000个，并用图表显示出来，效果如图8.31所示。</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026175247307.png" alt="image-20211026175247307"></p>
<p>​                                                                             图8.30　学生成绩正态分布示意图</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026175307086.png" alt="image-20211026175307086"></p>
<p>​                                                                                               图8.31　正态分布图</p>
<p>程序代码如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026175329461.png" alt="image-20211026175329461"></p>
<h2 id="8-6-2-案例2：NumPy用于图像灰度处理"><a href="#8-6-2-案例2：NumPy用于图像灰度处理" class="headerlink" title="8.6.2　案例2：NumPy用于图像灰度处理"></a>8.6.2　案例2：NumPy用于图像灰度处理</h2><p>案例位置：资源包\MR\Code\08\example\02<br>首先了解一下图像，图像其实是由若干像素组成，每一个像素都有明确的位置和被分配的颜色值，因此一张图像也就构成了一个像素矩阵。例如，一张灰度图片的像素块，如图8.32所示。</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026175347296.png" alt="image-20211026175347296"></p>
<p>​                                                                                      图8.32　灰度图片像素矩阵示意图<br>从图8.32得知：灰度图的数据是一个二维数组，颜色取值为0～255，其中，0为黑色，255为白色。从0～255逐渐由暗色变为亮色。由此可见，图像灰度处理是不是就可以通过数组计算来实现呢？<br>接下来，了解一个公式，RGB转换成灰度图像的常用公式：</p>
<p>Gray = R<em>0.299 + G</em>0.587 + B*0.114<br>其中，Gray表示灰度值，R、G、B表示红、绿、蓝颜色值，0.299、0.587、0.114表示灰度公式的固定值。</p>
<p>下面使用NumPy结合Matplotlib实现图像的灰度处理，程序代码如下：</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026175446668.png" alt="image-20211026175446668"></p>
<p>上述代码，显示灰度图时，需要在imshow()函数中设置参数cmap=”gray”。<br>运行程序，对比效果如图8.33和图8.34所示。</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026175502299.png" alt="image-20211026175502299"></p>
<p>​                                                                                                    图8.33　原图</p>
<p><img src="/2021/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/image-20211026175527183.png" alt="image-20211026175527183"></p>
<p>​                                                                                                          图8.34　灰度图像</p>
<h1 id="8-7-小结"><a href="#8-7-小结" class="headerlink" title="8.7　小结"></a>8.7　小结</h1><p>通过本章的学习，能够掌握NumPy的常用操作，即从数组创建到数组的基本操作和运算。对于数据统计分析来说，这些内容已经足够了；而对于人工智能、机器学习，还需要更加深入地学习NumPy相关知识。另外，当数据量非常大时，NumPy可以带来百倍以上的速度提升。</p>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
  </entry>
  <entry>
    <title>Python数据分析从入门到精通</title>
    <url>/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/</url>
    <content><![CDATA[<h1 id="Python数据分析从入门到精通"><a href="#Python数据分析从入门到精通" class="headerlink" title="Python数据分析从入门到精通"></a>Python数据分析从入门到精通</h1><h1 id="课程简介"><a href="#课程简介" class="headerlink" title="课程简介"></a>课程简介</h1><h2 id="自然智能"><a href="#自然智能" class="headerlink" title="自然智能"></a>自然智能</h2><p>自然智能（Natural Intelligence，NI），指人通过大脑的运算和决策产生有价值的行为。这些行为包括了人的大脑思考及决策、耳朵听力及判断、眼睛视觉及判断、鼻子嗅觉及判断、皮肤触觉及判断等，体现在人行为的方方面面。</p>
<h2 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p> 百度百科：它是<a href="https://baike.baidu.com/item/%E7%A0%94%E7%A9%B6/1883844">研究</a>、<a href="https://baike.baidu.com/item/%E5%BC%80%E5%8F%91/9400971">开发</a>用于<a href="https://baike.baidu.com/item/%E6%A8%A1%E6%8B%9F/7698898">模拟</a>、<a href="https://baike.baidu.com/item/%E5%BB%B6%E4%BC%B8/7834264">延伸</a>和扩展人的<a href="https://baike.baidu.com/item/%E6%99%BA%E8%83%BD/66637">智能</a>的理论、方法、技术及应用系统的一门新的技术科学。</p>
<p>人工智能（Artificial intelligence）简称AI。人工智能是计算机科学的一个分支，它企图了解智能的本质，并生产出一种新的能以人类智能相似的方式做出反应的智能机器，是研究、开发用于模拟、延伸和扩展人的智能的理论、方法、技术及应用系统的一门新的技术科学。</p>
<p>借用《计算机科学导论》作者贝赫鲁兹·佛罗赞（Behrouz Forouzan）的说法，人工智能是对程序系统的研究，该程序系统在一定程度上能模仿人类的活动，如感知，思考，学习和反应。</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>人工智能目前分为弱人工智能和强人工智能和超人工智能。</p>
<ol>
<li>弱人工智能：弱人工智能（Artificial Narrow Intelligence /ANI),只专注于完成某个特定的任务，例如语音识别、图象识别和翻译等，是擅长于单个方面的人工智能。它们只是用于解决特定的具体类的任务问题而存在，大都是统计数据，以此从中归纳出模型。由于弱人工智能智能处理较为单一的问题，且发展程度并没有达到模拟人脑思维的程度，所以弱人工智能仍然属于“工具”的范畴，与传统的“产品”在本质上并无区别。</li>
</ol>
<ol start="2">
<li> 强人工智能：强人工智能（Artificial General Intelligence  /AGI),属于人类级别的人工智能，在各方面都能和人类比肩，它能够进行思考、计划、解决问题、抽象思维、理解复杂理念、快速学习和从经验中学习等操作，并且和人类一样得心应手。</li>
<li> 超人工智能：超人工智能（Artificial Super intelligence/ASI），在几乎所有领域都比最聪明的人类大脑都聪明许多，包括科学创新、通识和社交技能。在超人工智能阶段，人工智能已经跨过“奇点”，其计算和思维能力已经远超人脑。此时的人工智能已经不是人类可以理解和想象。人工智能将打破人脑受到的维度限制，其所观察和思考的内容，人脑已经无法理解，人工智能将形成一个新的社会。</li>
</ol>
<p>我们现阶段还处于若人工智能阶段。</p>
<h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><p><strong>机器学习（MachineLearning）简称ML</strong>。机器学习属于人工智能的一个分支，也是人工智能的和核心。机器学习理论主要是设计和分析一些让计算机可以自动”学习“的算法。</p>
<h2 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h2><p>深度学习（Deep Learning）简称DL。最初的深度学习是利用深度神经网络来解决特征表达的一种学习过程。深度神经网络本身并不是一个全新的概念，可大致理解为包含多个隐含层的神经网络结构。为了提高深层神经网络的训练效果，人们对神经元的连接方法和激活函数等方面做出相应的调整。深度学习是机器学习研究中的一个新的领域，其动机在于建立、模拟人脑进行分析学习的神经网络，它模仿人脑的机制来解释数据，如图象、声音、文本。</p>
<h2 id="区别与联系"><a href="#区别与联系" class="headerlink" title="区别与联系"></a>区别与联系</h2><p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/Users\123\AppData\Roaming\Typora\typora-user-images\image-20211018014131909.png" alt="image-20211018014131909"></p>
<h2 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h2><p>机器学习是强大的数据分析工具</p>
<h3 id="数据分析行业前景"><a href="#数据分析行业前景" class="headerlink" title="数据分析行业前景"></a>数据分析行业前景</h3><p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/Users\123\AppData\Roaming\Typora\typora-user-images\image-20211018014409539.png" alt="image-20211018014409539"></p>
<h3 id="就业岗位"><a href="#就业岗位" class="headerlink" title="就业岗位"></a>就业岗位</h3><p>成为数据分析师</p>
<p>机器学习开发工程师</p>
<p>科学计算的科学家</p>
<h2 id="学习重点"><a href="#学习重点" class="headerlink" title="学习重点"></a>学习重点</h2><p>Numpy、Pandas、Matplotlib, Scipy、Scikit-learn、pyecharts</p>
<p>Numpy库和</p>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>anaconda 的下载和安装</p>
<p>官网：<a href="https://www.anaconda.com/products/individual">https://www.anaconda.com/products/individual</a></p>
<p>百度网盘：链接：<a href="https://pan.baidu.com/s/1VVwv3-AIr7c3S7juGpp8mQ">https://pan.baidu.com/s/1VVwv3-AIr7c3S7juGpp8mQ</a><br>提取码：v2bh </p>
<p>安装成功验证：</p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018024458282.png" alt="image-20211018024458282"></p>
<p>查看已经安装的安装包：</p>
<p>pip list</p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018022738296.png" alt="image-20211018022738296"></p>
<p>anaconda 安装工具包方法：</p>
<p>pip install</p>
<p>pip install 安装包名称 -i <a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a>  </p>
<h2 id="jupyter-notebook"><a href="#jupyter-notebook" class="headerlink" title="jupyter notebook"></a>jupyter notebook</h2><p>Jupyter Notebook将代码、说明文本、数学方程式、数据可视化图表等内容全部组合到一起显示在一个共享的文档中，可以实现一边写代码一边记录，而这些功能是Python自带的IDLE和集成开发环境PyCharm无法比拟的。</p>
<p>快捷键</p>
<ul>
<li><strong>Enter</strong> : 转入编辑模式</li>
<li><strong>Shift-Enter</strong> : 运行本单元，选中下个单元</li>
<li><strong>Ctrl-Enter</strong> : 运行本单元</li>
<li><strong>Alt-Enter</strong> : 运行本单元，在其下插入新单元</li>
<li><strong>Y</strong> : 单元转入代码状态</li>
<li><strong>M</strong> :单元转入markdown状态</li>
<li><strong>R</strong> : 单元转入raw状态</li>
<li><strong>1</strong> : 设定 1 级标题</li>
<li><strong>2</strong> : 设定 2 级标题</li>
<li><strong>3</strong> : 设定 3 级标题</li>
<li><strong>4</strong> : 设定 4 级标题</li>
<li><strong>5</strong> : 设定 5 级标题</li>
<li><strong>6</strong> : 设定 6 级标题</li>
<li><strong>Up</strong> : 选中上方单元</li>
<li><strong>K</strong> : 选中上方单元</li>
<li><strong>Down</strong> : 选中下方单元</li>
<li><strong>J</strong> : 选中下方单元</li>
<li><strong>Shift-K</strong> : 扩大选中上方单元</li>
<li><strong>Shift-J</strong> : 扩大选中下方单元</li>
<li><strong>A</strong> : 在上方插入新单元</li>
<li><strong>B</strong> : 在下方插入新单元</li>
<li><strong>X</strong> : 剪切选中的单元</li>
<li><strong>C</strong> : 复制选中的单元</li>
<li><strong>Shift-V</strong> : 粘贴到上方单元</li>
<li><strong>V</strong> : 粘贴到下方单元</li>
<li><strong>Z</strong> : 恢复删除的最后一个单元</li>
<li><strong>D,D</strong> : 删除选中的单元</li>
<li><strong>Shift-M</strong> : 合并选中的单元</li>
<li><strong>Ctrl-S</strong> : 文件存盘</li>
<li><strong>S</strong> : 文件存盘</li>
<li><strong>L</strong> : 转换行号</li>
<li><strong>O</strong> : 转换输出</li>
<li><strong>Shift-O</strong> : 转换输出滚动</li>
<li><strong>Esc</strong> : 关闭页面</li>
<li><strong>Q</strong> : 关闭页面</li>
<li><strong>H</strong> : 显示快捷键帮助</li>
<li><strong>I,I</strong> : 中断Notebook内核</li>
<li><strong>0,0</strong> : 重启Notebook内核</li>
<li><strong>Shift</strong> : 忽略</li>
<li><strong>Shift-Space</strong> : 向上滚动</li>
<li><strong>Space</strong> : 向下滚动</li>
</ul>
<h2 id="spyder"><a href="#spyder" class="headerlink" title="spyder"></a>spyder</h2><p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018024534693.png" alt="image-20211018024534693"></p>
<p>变量浏览器窗口</p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018024612097.png" alt="image-20211018024612097"></p>
<p>创建项目</p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018024700511.png" alt="image-20211018024700511"></p>
<h2 id="pycharm"><a href="#pycharm" class="headerlink" title="pycharm"></a>pycharm</h2><h2 id="开发工具比较"><a href="#开发工具比较" class="headerlink" title="开发工具比较"></a>开发工具比较</h2><p>PyCharm、Jupyter Notebook和Spyder这3种开发工具，各有特点。</p>
<p>a.数据分析，建议使用Spyder和Jupyter Notebook</p>
<p>b.复杂、大型项目，建议使用PyCharm</p>
<p>c. 数据分析、复杂和大型项目，建议三者可以结合使用</p>
<h1 id="第一章-了解数据分析"><a href="#第一章-了解数据分析" class="headerlink" title="第一章 了解数据分析"></a>第一章 了解数据分析</h1><h2 id="一-数据分析流程"><a href="#一-数据分析流程" class="headerlink" title="一. 数据分析流程"></a>一. 数据分析流程</h2><p>熟悉工具-明确目的-获取数据-数据处理-数据分析-验证结果-结果呈现-数据应用</p>
<h3 id="1-熟悉工具"><a href="#1-熟悉工具" class="headerlink" title="1.熟悉工具"></a>1.熟悉工具</h3><h3 id="2-明确目的"><a href="#2-明确目的" class="headerlink" title="2.明确目的"></a>2.明确目的</h3><p>在数据分析方面，首先要花一些时间搞清楚为什么要做数据分析、分析什么、想要达到什么效果。例如，为了评估产品改版后的效果比之前是否有所提升，或通过数据分析找到产品迭代的方向等。只有明确了分析目的，才能够找到适合的分析方法，也才能够有效地进行数据处理、数据分析和预测等后续工作。</p>
<h3 id="3-获取数据"><a href="#3-获取数据" class="headerlink" title="3.获取数据"></a>3.获取数据</h3><p>数据的来源有很多，像我们熟悉的Excel数据、数据库中的数据、网站数据以及公开的数据集等。那么，获取数据之前首先要知道需要什么时间段的数据，哪张表中的数据，以及如何获得，是下载、复制还是爬取等。</p>
<h3 id="4-数据处理"><a href="#4-数据处理" class="headerlink" title="4.数据处理"></a>4.数据处理</h3><p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018031333159.png" alt="image-20211018031333159"></p>
<p>数据规约：在接近或保持原始数据完整性的同时将数据集规模减小，以提高数据处理的速度。例如，一张Excel表中包含近3年的几十万条数据，由于我们只分析近一年的数据，因此要一年的数据即可，这样做的目的就是减小数据规模，提高数据处理速度。</p>
<p>数据清洗：在获取到原始数据后，可能其中的很多数据都不符合数据分析的要求，那么就需要按照如下步骤进行处理。</p>
<p>​        a.数据探索分析：分析数据的规律，通过一定的方法统计数据，通过统计结果判断数据是否存在缺失、异常等情况。例如，通过最小值判断数量、金额是否包含缺失数据，如果最小值为0，那么这部分数据就是缺失数据，以及通过判断数据是否存在空值来判断数据是否缺失。</p>
<p>​        b.重复数据处理：对于重复的数据删除即可。</p>
<p>​        c.缺失数据处理：对于缺失的数据，如果比例高于30%可以选择放弃这个指标，删除即可；如果低于30%可以将这部分缺失数据进行填充，以0或均值填充。</p>
<p>​        d.异常数据处理：异常数据需要对具体业务进行具体分析和处理，对于不符合常理的数据可进行删除。例如，性别男或女，但是数据中存在其他值，以及年龄超出正常年龄范围，这些都属于异常数据。</p>
<p>数据加工：包括数据抽取、数据计算、数据分组和数据转换。</p>
<p>​        a.数据抽取：是指选取数据中的部分内容。　</p>
<p>​        b.数据计算：是进行各种算术和逻辑运算，以便得到进一步的信息。　</p>
<p>​        c.数据分组：是按照有关信息进行有效的分组。　</p>
<p>​        d.数据转换：是指数据标准化处理，以适应数据分析算法的需要，常用的有z-score标准化，“最小、最大标准化”和“按小数定标标准化”等。经过上述标准化处理后，数据中各指标值将会处在同一个数量级别上，以便更好地对数据进行综合测评和分析。</p>
<h3 id="5-数据分析"><a href="#5-数据分析" class="headerlink" title="5.数据分析"></a>5.数据分析</h3><p>数据分析过程中，选择适合的分析方法和工具很重要，所选择的分析方法应兼具准确性、可操作性、可理解性和可应用性。但对于业务人员（如产品经理或运营）来说，数据分析最重要的是数据分析思维。</p>
<h3 id="6-验证结果"><a href="#6-验证结果" class="headerlink" title="6.验证结果"></a>6.验证结果</h3><p>通过数据分析我们会得到一些结果，但是这些结果只是数据的主观结果的体现，有些时候不一定完全准确，所以必须要进行验证。</p>
<p>例如，数据分析结果显示某产品点击率非常高，但实际下载量平平，那么这种情况，不要轻易定论，这种产品受欢迎，而要进一步验证，找到真正影响点击率的原因，这样才能做出更好的决策。</p>
<h3 id="7-结果呈现"><a href="#7-结果呈现" class="headerlink" title="7.结果呈现"></a>7.结果呈现</h3><p>现如今，企业越来越重视数据分析给业务决策带来的有效应用，而可视化是数据分析结果呈现的重要步骤。可视化是以图表方式呈现数据分析结果，这样的结果更清晰、更直观、更容易理解。</p>
<h3 id="8-数据应用"><a href="#8-数据应用" class="headerlink" title="8.数据应用"></a>8.数据应用</h3><p>数据分析的结果并不仅仅是把数据呈现出来，而更应该关注的是通过分析这些数据，后面可以做什么？如何将数据分析结果应用到实际业务中才是学习数据分析的重点。<br>数据分析结果的应用是数据产生实际价值的直接体现，而这个过程需要具有数据沟通能力、业务推动能力和项目工作能力。如果看了数据分析结果后并不知道做什么，那么这个数据分析就是失败的。</p>
<h2 id="二-数据分析常用的工具"><a href="#二-数据分析常用的工具" class="headerlink" title="二.数据分析常用的工具"></a>二.数据分析常用的工具</h2><p>excel  或者 python</p>
<ol>
<li><p>excel</p>
<p>Excel具备多种强大功能，例如创建表格、数据透视表、VBA等，Excel的系统如此庞大，确保了大家可以根据自己的需求分析数据。<br>但是在今天，大数据、人工智能时代，数据量很大的情况下Excel已经无法胜任，不仅处理起来很麻烦而且处理速度也会变慢。从数据分析的层面，Excel也只是停留在描述性分析，如对比分析、趋势分析、结构分析等。</p>
</li>
<li><p>python</p>
<p>虽然Excel已尽最大努力考虑到数据分析的大多数应用场景，但由于它是定制软件，很多东西都固化了，不能自由地修改。而Python非常的强大和灵活，可以编写代码来执行所需的任何操作，从专业和方便的角度来看，它比Excel更加强大。另外，Python可以实现Excel难以实现的应用场景。</p>
<p>a．专业的统计分析<br>例如，正态分布、使用算法对聚类进行分类和回归分析等。这种分析就像用数据做实验一样。它可以帮助我们回答下面的问题。<br>数据的分布是正态分布、三角分布还是其他类型的分布？离散情况如何？它是否在我们想要达到的统计可控范围内？不同参数对结果的影响是多少？<br>b．预测分析<br>例如，我们打算预测消费者的行为。他会在我们的商店停留多长时间？他会花多少钱？我们可以找出他的个人信用情况，并根据他的在线消费记录确定贷款金额。或者，我们可以根据他在网页上的浏览历史推送不同的产品。这也涉及当前流行的机器学习和人工智能概念。</p>
</li>
</ol>
<p>综上所述，Python作为数据分析工具的首选，具有以下优势。　Python语言简单易学、数据处理简单高效，对于初学者来说更加容易上手。　Python第三方扩展库不断更新，可用范围越来越广。　在科学计算、数据分析、数学建模和数据挖掘方面占据越来越重要的地位。　可以和其他语言进行对接，兼容性稳定。<br>当然，如果您既会Excel又会Python，那么绝对是职场的加分项！</p>
<h1 id="第二章-Pandas统计分析"><a href="#第二章-Pandas统计分析" class="headerlink" title="第二章 Pandas统计分析"></a>第二章 Pandas统计分析</h1><p>Pandas是Python的核心数据分析支持库，它提供了大量能使我们快速便捷地处理数据的函数和方法。<br>由于Pandas相关知识非常多，本书将Pandas分为上、下两章进行讲解。本章开始Pandas入门内容，从安装开始，逐步介绍Pandas相关的入门知识，包括两个主要的数据结构，即Series对象和DataFrame对象，也包括如何导入外部数据、数据抽取，以及数据的增加、修改和删除，还包括数据清洗、索引设置、数据排序与排名等相关基础知识，这些都是在为后期数据处理和数据分析打下良好的基础。</p>
<h2 id="一-Pandas概述"><a href="#一-Pandas概述" class="headerlink" title="一. Pandas概述"></a>一. Pandas概述</h2><p>Pandas是数据分析三大剑客之一，是Python的核心数据分析库，它提供了快速、灵活、明确的数据结构，能够简单、直观、快速地处理各种类型的数据，具体介绍如下所示。</p>
<p>Pandas能够处理以下类型的数据。　</p>
<p>1.与SQL或Excel表类似的数据。　</p>
<p>2.有序和无序（非固定频率）的时间序列数据。　</p>
<p>3.带行、列标签的矩阵数据。</p>
<p>4.任意其他形式的观测、统计数据集。</p>
<p>Pandas提供的两个主要数据结构Series（一维数组结构）与DataFrame（二维数组结构），可以处理金融、统计、社会科学、工程等领域里的大多数典型案例，并且Pandas是基于NumPy开发的，可以与其他第三方科学计算库完美集成。<br>Pandas的功能很多，它的优势如下。　</p>
<p>1.处理浮点与非浮点数据里的缺失数据，表示为NaN。　</p>
<p>2.大小可变，例如插入或删除DataFrame等多维对象的列。</p>
<p>3.自动、显式数据对齐，显式地将对象与一组标签对齐，也可以忽略标签，在Series、DataFrame计算时自动与数据对齐。　</p>
<p>4.强大、灵活的分组统计（groupby）功能，即数据聚合、数据转换。　</p>
<p>5.把Python和NumPy数据结构里不规则、不同索引的数据轻松地转换为DataFrame对象。　</p>
<p>6.智能标签，对大型数据集进行切片、花式索引、子集分解等操作。　</p>
<p>7.直观地合并（merge）、连接（join）数据集。　灵活地重塑（reshape）、透视（pivot）数据集。</p>
<p>8.成熟的导入、导出工具，导入文本文件（CSV等支持分隔符的文件）、Excel文件、数据库等来源的数据，导出Excel文件、文本文件等，利用超快的HDF5格式保存或加载数据。　</p>
<p>9.时间序列：支持日期范围生成、频率转换、移动窗口统计、移动窗口线性回归、日期位移等时间序列功能。</p>
<p>例1.读取excel数据</p>
<p>01 import pandas as pd               #导入pandas 模块<br>02 df=pd.read_excel(‘data.xlsx’)      #读取Excel 文件<br>03 df1=df.head()                      #显示前5 条数据</p>
<h2 id="二-seires-对象"><a href="#二-seires-对象" class="headerlink" title="二. seires 对象"></a>二. seires 对象</h2><p>Pandas是Python数据分析重要的库，而Series和DataFrame是Pandas库中两个重要的对象，也是Pandas中两个重要的数据结构，如图所示。</p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018035610974.png" alt="image-20211018035610974"><br>本节将主要介绍Series对象。</p>
<h3 id="2-1-图解Series对象"><a href="#2-1-图解Series对象" class="headerlink" title="2.1　图解Series对象"></a>2.1　图解Series对象</h3><p>Series是Python的Pandas库中的一种数据结构，它类似一维数组，由一组数据以及与这组数据相关的标签（即索引)组成，或者仅有一组数据没有索引也可以创建一个简单的Series。Series可以存储整数、浮点数、字符串、Python对象等多种类型的数据。<br>例如，在成绩表（见图3)中包含了Series对象和DataFrame对象，其中“语文”“数学”“英语”3列中的每一列均是一个Series对象，而“语文”“数学”“英语”3列组成了一个DataFrame对象，如图4所示。</p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018035821898.png" alt="image-20211018035821898"></p>
<p>​                                                                                           图3</p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018035900680.png" alt="image-20211018035900680"></p>
<p>​                                                                                         图4</p>
<h3 id="2-2-创建一个series对象"><a href="#2-2-创建一个series对象" class="headerlink" title="2.2 创建一个series对象"></a>2.2 创建一个series对象</h3><p>创建Series对象主要使用Pandas的Series()方法，语法如下：</p>
<p>s=pd.Series(data,index=index)</p>
<p>参数说明：　</p>
<p>data：表示数据，支持Python字典、多维数组、标量值（即只有大小，没有方向的量。也就是说，只是一个数值，如s=pd.Series(5)）。　index：表示行标签（索引）。　</p>
<p>返回值：Series对象。</p>
<p>说明<br>当data参数是多维数组时，index长度必须与data长度一致。如果没有指定index参数，则自动创建数值型索引（从0～data数据长度-1）。</p>
<p>【示例02】　在成绩表添加一列“物理”成绩。（示例位置：资源包\MR\Code\03\02）创建一个Series对象，在成绩表中添加一列“物理”成绩。程序代码如下：</p>
<p>01 import pandas as pd<br>02 s1=pd.Series([88,60,75])<br>03 print(s1)</p>
<p>上述举例，如果通过Pandas模块引入Series对象，那么就可以直接在程序中使用Series对象了。主要代码如下：</p>
<p>01 from pandas import Series<br>02 s1=Series([88,60,75])</p>
<h3 id="2-3-手动设置series索引"><a href="#2-3-手动设置series索引" class="headerlink" title="2.3 手动设置series索引"></a>2.3 手动设置series索引</h3><p>创建Series对象时会自动生成整数索引，默认值从0开始至数据长度减1。例如，3.2.1节举例中使用的就是默认索引，如0、1、2。除了使用默认索引，还可以通过index参数手动设置索引。</p>
<p>【示例03】　手动设置索引。（示例位置：资源包\MR\Code\03\03）<br>下面手动设置索引，将3.2.1节添加的“物理”成绩的索引设置为1、2、3，也可以是“明日同学”“高同学”“七月流火”。</p>
<p>程序代码如下：</p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018040816095.png" alt="image-20211018040816095"></p>
<p>运行程序，控制台输出结果如下：</p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018040836315.png" alt="image-20211018040836315"></p>
<p>说明<br>上述结果中输出的dtype是DataFrame数据的数据类型，int为整型，后面的数字表示位数。</p>
<h3 id="2-4-series-位置索引"><a href="#2-4-series-位置索引" class="headerlink" title="2.4 series 位置索引"></a>2.4 series 位置索引</h3><h4 id="2-4-1-series位置索引"><a href="#2-4-1-series位置索引" class="headerlink" title="2.4.1 series位置索引"></a>2.4.1 series位置索引</h4><p>位置索引是从0开始数，[0]是Series第一个数，[1]是Series第二个数，以此类推。</p>
<p>【示例04】　通过位置索引获取学生物理成绩。（示例位置：资源包\MR\Code\03\04）获取第一个学生的物理成绩。程序代码如下：</p>
<p>01 import pandas as pd<br>02 s1=pd.Series([88,60,75])<br>03 print(s1[0])<br>运行程序，控制台输出结果如下：</p>
<p>88</p>
<p>注意<br>Series不能使用[-1]定位索引。</p>
<h4 id="2-4-2-series-标签索引"><a href="#2-4-2-series-标签索引" class="headerlink" title="2.4.2 series 标签索引"></a>2.4.2 series 标签索引</h4><p>Series标签索引与位置索引方法类似，用[ ]表示，里面是索引名称，注意index的数据类型是字符串，如果需要获取多个标签索引值，用[[ ]]表示（相当于[ ]中包含一个列表）。</p>
<p>【示例05】　通过标签索引获取学生物理成绩。（示例位置：资源包\MR\Code\03\05）通过标签索引“明日同学”和“七月流火”获取物理成绩，程序代码如下：</p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018041305145.png" alt="image-20211018041305145"></p>
<h4 id="2-4-3-series-切片索引"><a href="#2-4-3-series-切片索引" class="headerlink" title="2.4.3 series 切片索引"></a>2.4.3 series 切片索引</h4><p>用标签索引做切片，包头包尾（即包含索引开始位置的数据，也包含索引结束位置的数据）。</p>
<p>【示例06】　通过切片获取数据。（示例位置：资源包\MR\Code\03\06）通过标签切片索引“明日同学”至“七月流火”获取数据。程序代码如下：</p>
<p>print(s1[‘明日同学’:’七月流火’])     #通过切片获取索引值</p>
<p>用位置索引做切片，和list列表用法一样，包头不包尾（即包含索引开始位置的数据，不包含索引结束位置的数据）。</p>
<p>【示例07】　通过位置切片获取数据。（示例位置：资源包\MR\Code\03\07）通过位置切片1～4获取数据，程序代码如下：</p>
<p>01  s2=pd.Series([88,60,75,34,68])<br>02  print(s2[1:4])<br>运行程序，控制台输出结果如下：</p>
<p>1  60<br>2  75<br>3  34</p>
<h4 id="2-4-5-获取series索引和值"><a href="#2-4-5-获取series索引和值" class="headerlink" title="2.4.5 获取series索引和值"></a>2.4.5 获取series索引和值</h4><p>获取Series索引和值主要使用Series的index和values方法。</p>
<p>【示例08】　获取物理成绩的索引和值。（示例位置：资源包\MR\Code\03\08）下面使用Series的index和values方法获取物理成绩的索引和值，程序代码如下：</p>
<p>01 import pandas as pd<br>02 s1=pd.Series([88,60,75])<br>03 print(s1.index)<br>04 print(s1.values)<br>运行程序，控制台输出结果如下：</p>
<p>RangeIndex(start=0, stop=3, step=1)<br>[88 60 75]</p>
<h2 id="三-DataFrame对象"><a href="#三-DataFrame对象" class="headerlink" title="三. DataFrame对象"></a>三. DataFrame对象</h2><p>DataFrame是Pandas库中的一种数据结构，它是由多种类型的列组成的二维表数据结构，类似于Excel、SQL或Series对象构成的字典。DataFrame是最常用的Pandas对象，它与Series对象一样支持多种类型的数据。</p>
<h3 id="3-1-图解DataFrame对象"><a href="#3-1-图解DataFrame对象" class="headerlink" title="3.1　图解DataFrame对象"></a>3.1　图解DataFrame对象</h3><p>DataFrame是一个二维表数据结构，由行、列数据组成的表格。DataFrame既有行索引也有列索引，它可以看作是由Series对象组成的字典，不过这些Series对象共用一个索引，如图3.11所示。</p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018042136168.png" alt="image-20211018042136168"></p>
<p>图3.11　DataFrame结构<br>处理DataFrame表格数据时，用index表示行或用columns表示列更直观。用这种方式迭代DataFrame的列，代码更易读懂。</p>
<p>【示例09】　遍历DataFrame数据。（示例位置：资源包\MR\Code\03\09）遍历DataFrame数据，输出成绩表的每一列数据，程序代码如下：</p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018042332305.png" alt="image-20211018042332305"></p>
<p>运行程序，控制台输出结果如下：</p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018042319399.png" alt="image-20211018042319399"></p>
<p>从运行结果得知，上述代码返回的其实是Series，如图3.12所示。Pandas之所以提供多种数据结构，其目的就是为了代码易读、操作更加方便。</p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018042510540.png" alt="image-20211018042510540"></p>
<h3 id="3-2-创建一个DataFrame对象"><a href="#3-2-创建一个DataFrame对象" class="headerlink" title="3.2 创建一个DataFrame对象"></a>3.2 创建一个DataFrame对象</h3><p>创建DataFrame主要使用Pandas的DataFrame()方法，语法如下：</p>
<p>pandas.DataFrame(data,index,columns,dtype,copy)<br>参数说明：　</p>
<p>data：表示数据，可以是ndarray数组、Series对象、列表、字典等。　</p>
<p>index：表示行标签（索引）。</p>
<p>columns：列标签（索引）。　</p>
<p>dtype：每一列数据的数据类型，其与Python数据类型有所不同，如object数据类型对应的是Python的字符型。</p>
<p>表3.1为Pandas数据类型与Python数据类型的对应表。</p>
<p>​                                                                                          表3.1　数据类型对应表　</p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018042916094.png" alt="image-20211018042916094"></p>
<p>copy：用于复制数据。　</p>
<p>返回值：DataFrame。<br>下面通过两种方法来创建DataFrame，即通过二维数组创建和通过字典创建。</p>
<p>1．通过二维数组创建DataFrame【示例10】　通过二维数组创建成绩表。（示例位置：资源包\MR\Code\03\10）<br>通过二维数组创建成绩表，包括语文、数学和英语，程序代码如下：</p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018043105059.png" alt="image-20211018043105059"></p>
<p>运行程序，控制台输出结果如下：</p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018043117683.png" alt="image-20211018043117683"></p>
<p>2．通过字典创建DataFrame<br>通过字典创建DataFrame，需要注意：字典中的value值只能是一维数组或单个的简单数据类型，如果是数组，要求所有数组长度一致；如果是单个数据，则每行都添加相同数据。</p>
<p>【示例11】　通过字典创建成绩表。（示例位置：资源包\MR\Code\03\11）通过字典创建成绩表，包括语文、数学、英语和班级，程序代码如下：</p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018043238790.png" alt="image-20211018043238790"></p>
<p>运行程序，控制台输出结果如下：</p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018043309599.png" alt="image-20211018043309599"></p>
<p>上述代码中，“班级”的value值是一个单个数据，所以每一行都添加了相同的数据“高一7班”。</p>
<h3 id="3-3-DataFrame重要属性和函数"><a href="#3-3-DataFrame重要属性和函数" class="headerlink" title="3.3 DataFrame重要属性和函数"></a>3.3 DataFrame重要属性和函数</h3><p>DataFrame是Pandas一个重要的对象，它的属性和函数很多，下面先简单了解DataFrame的几个重要属性和函数。重要属性介绍如表3.2所示，重要函数介绍如表3.3所示。</p>
<p>​                                                                                               表3.2　重要属性</p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018043520943.png" alt="image-20211018043520943"></p>
<p>​                                                                                                  表3.3　重要函数</p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018043534263.png" alt="image-20211018043534263"></p>
<h3 id="3-4-导入外部数据"><a href="#3-4-导入外部数据" class="headerlink" title="3.4 导入外部数据"></a>3.4 导入外部数据</h3><p>数据分析首先就要有数据。那么，数据类型有多种，本节介绍如何导入不同类型的外部数据。</p>
<h4 id="3-4-1-导入-xls或-xlsx文件"><a href="#3-4-1-导入-xls或-xlsx文件" class="headerlink" title="3.4.1　导入.xls或.xlsx文件"></a>3.4.1　导入.xls或.xlsx文件</h4><p>导入.xls或.xlsx文件主要使用Pandas的read_excel()方法，语法如下：</p>
<p>pandas.read_excel(io,sheet_name=0,header=0,names=None,index_col=None,usecols=None,squeeze=False,<br>dtype=None,engine=None,converters=None,true_values=None,false_values=None,skiprows=None,nrow=None,<br>na_values=None,keep_default_na=True,verbose=False,parse_dates=False,date_parser=None,thousands=None,<br>comment=None,skipfooter=0,conver_float=True,mangle_dupe_cols=True,**kwds)<br>常用参数说明：　</p>
<p>io：字符串，.xls或.xlsx文件路径或类文件对象。　</p>
<p>sheet_name：None、字符串、整数、字符串列表或整数列表，默认值为0。字符串用于工作表名称，整数为索引表示工作表位置，字符串列表或整数列表用于请求多个工作表，为None时获取所有工作表。参数值如表3.4所示。</p>
<p>​                                                                                     表3.4　sheet_name参数值　</p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018043941426.png" alt="image-20211018043941426"></p>
<p>header：指定作为列名的行，默认值为0，即取第一行的值为列名。数据为除列名以外的数据；若数据不包含列名，则设置header=None。　</p>
<p>names：默认值为None，要使用的列名列表。　</p>
<p>index_col：指定列为索引列，默认值为None，索引0是DataFrame的行标签。</p>
<p>usecols：int、list列表或字符串，默认值为None。　如果为None，则解析所有列。　如果为int，则解析最后一列。　如果为list列表，则解析列号列表的列。　如果为字符串，则表示以逗号分隔的Excel列字母和列范围列表（例如“A:E”或“A,C,E:F”）。范围包括双方。　squeeze：布尔值，默认值为False，如果解析的数据只包含一列，则返回一个Series。　</p>
<p>dtype：列的数据类型名称或字典，默认值为None。例如{‘a’:np.float64,’b’:np.int32}。　</p>
<p>skiprows：省略指定行数的数据，从第一行开始。　</p>
<p>skipfooter：省略指定行数的数据，从尾部数的行开始。</p>
<p>下面通过示例，详细介绍如何导入.xlsx文件。</p>
<h5 id="1．常规导入导入Excel文件。"><a href="#1．常规导入导入Excel文件。" class="headerlink" title="1．常规导入导入Excel文件。"></a>1．常规导入导入Excel文件。</h5><p>【示例12】　（示例位置：资源包\MR\Code\03\12）导入“1月.xlsx”Excel文件，程序代码如下：</p>
<p>01 import pandas as pd<br>02 df=pd.read_excel(‘1 月.xlsx’)<br>03 df1=df.head()          #输出前5 条数据<br>运行程序，输出前5条数据，结果如图3.13所示。<br>图3.13　1月淘宝销售数据（前5条数据）</p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018044223025.png" alt="image-20211018044223025"></p>
<p>知识胶囊<br>导入外部数据，必然要涉及路径问题，下面来了解一下相对路径和绝对路径。　</p>
<p><strong>相对路径</strong>：相对路径就是以当前文件为基准进行一级级目录指向被引用的资源文件。以下是常用的表示当前目录和当前目录的父级目录的标识符。　../：表示当前文件所在目录的上一级目录。　./：表示当前文件所在的目录（可以省略）。　/：表示当前文件的根目录（域名映射或硬盘目录）。　如果使用系统默认文件路径\，那么，在Python中则需要在路径最前面加一个r，以避免路径里面的\被转义。　</p>
<p><strong>绝对路径</strong>：绝对路径是文件真正存在的路径，是指从硬盘的根目录（盘符）开始，进行一级级目录指向文件。</p>
<h5 id="2．导入指定的Sheet页"><a href="#2．导入指定的Sheet页" class="headerlink" title="2．导入指定的Sheet页"></a>2．导入指定的Sheet页</h5><p>一个Excel文件包含多个Sheet页，通过设置sheet_name参数就可以导入指定Sheet页的数据。</p>
<p>【示例13】　导入指定Sheet页的数据。（示例位置：资源包\MR\Code\03\13）一个Excel文件包含多家店铺的销售数据，导入其中一家店铺（莫寒）的销售数据，如图3.14所示。<br>图3.14　原始数据</p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018044701218.png" alt="image-20211018044701218"></p>
<p>程序代码如下：</p>
<p>01 import pandas as pd<br>02 df=pd.read_excel(‘1 月.xlsx’,sheet_name=’莫寒’)<br>03 df1=df.head()          #输出前5条数据<br>运行程序，输出前5条数据，结果如图3.15所示。<br>除了指定Sheet页的名字，还可以指定Sheet页的顺序，从0开始。例如，sheet_name=0表示导入第一个Sheet页的数据，sheet_name=1表示导入第二个Sheet页的数据，以此类推。<br>如果不指定sheet_name参数，则默认导入第一个Sheet页的数据。</p>
<h5 id="3．通过行、列索引导入指定行、列数据"><a href="#3．通过行、列索引导入指定行、列数据" class="headerlink" title="3．通过行、列索引导入指定行、列数据"></a>3．通过行、列索引导入指定行、列数据</h5><p>DataFrame是二维数据结构，因此它既有行索引又有列索引。当导入Excel数据时，行索引会自动生成，如0、1、2；而列索引则默认将第0行作为列索引（如A,B,…,J）。DataFrame行、列索引的示意图如图3.16所示。</p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018044837800.png" alt="image-20211018044837800"></p>
<p>​                                                  </p>
<p>​                                                                            图3.15　导入指定的Sheet页（前5条数据） </p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018044932996.png" alt="image-20211018044932996"></p>
<p>​                                                                                图3.16　DataFrame行、列索引示意图</p>
<p>【示例14】　指定行索引导入Excel数据。（示例位置：资源包\MR\Code\03\14）<br>如果通过指定行索引导入Excel数据，则需要设置index_col参数。下面将“买家会员名”作为行索引（位于第0列），导入Excel数据，程序代码如下：</p>
<p>01 import pandas as pd<br>02 df1=pd.read_excel(‘1 月.xlsx’,index_col=0)     #“买家会员名”为行索引<br>03 df1=df1.head()                                 #输出前5条数据<br>运行程序，输出结果如图3.17所示。</p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018045103681.png" alt="image-20211018045103681"></p>
<p>图3.17　通过指定行索引导入Excel数据<br>如果通过指定列索引导入Excel数据，则需要设置header参数，主要代码如下：</p>
<p>df2=pd.read_excel(‘1月.xlsx’,header=1)        #设置第1行为列索引</p>
<p>运行程序，输出结果如图3.18所示。<br>如果将数字作为列索引，可以设置header参数为None，主要代码如下：</p>
<p>df3=pd.read_excel(‘1月.xlsx’,header=None)    #列索引为数字</p>
<p>运行程序，输出结果如图3.19所示。</p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018045218250.png" alt="image-20211018045218250"></p>
<p>图3.18　通过指定列索引导入Excel数据</p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018045231796.png" alt="image-20211018045231796"></p>
<p>图3.19　指定列索引<br>那么，为什么要指定索引呢？因为通过索引可以快速地检索数据，例如df3[0]，就可以快速检索到“买家会员名”这一列数据。</p>
<h5 id="4-导入指定列数据"><a href="#4-导入指定列数据" class="headerlink" title="4.导入指定列数据"></a>4.导入指定列数据</h5><p>一个Excel往往包含多列数据，如果只需要其中的几列，可以通过usecols参数指定需要的列，从0开始（表示第1列，以此类推）。</p>
<p>【示例15】　导入第1列数据。（示例位置：资源包\MR\Code\03\15）下面导入第1列数据（索引为0），程序代码如下：</p>
<p>01 import pandas as pd<br>02 df1=pd.read_excel(‘1 月.xlsx’,usecols=[0])       #导入第1列<br>03 df1.head()<br>运行程序，输出结果如图3.20所示。<br>如果导入多列，可以在列表中指定多个值。例如，导入第1列和第4列，主要代码如下：</p>
<p>df2=pd.read_excel(‘1月.xlsx’,usecols=[0,3])<br>也可以指定列名称，主要代码如下：</p>
<p>df3=pd.read_excel(‘1月.xlsx’,usecols=[‘买家会员名’,’宝贝标题’])<br>运行程序，输出结果如图3.21所示。</p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018045614397.png" alt="image-20211018045614397"></p>
<p>​                                                                                               图3.20　导入第1列</p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018045541729.png" alt="image-20211018045541729"></p>
<p>​                                                                                     图3.21　导入第1列和第4列数据</p>
<h4 id="3-4-2-导入-csv文件"><a href="#3-4-2-导入-csv文件" class="headerlink" title="3.4.2　导入.csv文件"></a>3.4.2　导入.csv文件</h4><p>导入.csv文件主要使用Pandas的read_csv()方法，语法如下：</p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018045855117.png" alt="image-20211018045855117">常用参数说明：　</p>
<p>filepath_or_buffer：字符串，文件路径，也可以是URL链接。　</p>
<p>sep、delimiter：字符串，分隔符。</p>
<p>header：指定作为列名的行，默认值为0，即取第1行的值为列名。数据为除列名以外的数据；若数据不包含列名，则设置header=None。　</p>
<p>names：默认值为None，要使用的列名列表。　</p>
<p>index_col：指定列为索引列，默认值为None，索引0是DataFrame的行标签。　</p>
<p>usecols：int、list列表或字符串，默认值为None。　如果为None，则解析所有列。　如果为int，则解析最后一列。　如果为list列表，则解析列号列表的列。　如果为字符串，则表示以逗号分隔的Excel列字母和列范围列表（例如“A:E”或“A,C,E:F”）。范围包括双方。　dtype：列的数据类型名称或字典，默认值为None。例如{‘a’:np.float64,’b’:np.int32}。　</p>
<p>parse_dates：布尔类型值、int类型值的列表、列表或字典，默认值为False。可以通过parse_dates参数直接将某列转换成datetime64日期类型。例如，df1=pd.read_csv(‘1月.csv’, parse_dates=[‘订单付款时间’])。　</p>
<p>​        parse_dates为True时，尝试解析索引。　</p>
<p>​        parse_dates为int类型值组成的列表时，如[1,2,3]，则解析1、2、3列的值作为独立的日期列。　</p>
<p>​        parse_date为列表组成的列表，如[[1,3]]，则将1、3列合并，作为一个日期列使用。　</p>
<p>​        parse_date为字典时，如{‘总计’：[1, 3]}，则将1、3列合并，合并后的列名为“总计”。　</p>
<p>encoding：字符串，默认值为None，文件的编码格式。Python常用的编码格式是UTF-8。　返回值：返回一个DataFrame。</p>
<p>【示例16】　导入.csv文件。（示例位置：资源包\MR\Code\03\16）导入.csv文件，程序代码如下：</p>
<p>01 import pandas as pd<br>02 df1=pd.read_csv(‘1月.csv’,encoding=’gbk’)        #导入.csv文件，并指定编码格式<br>03 df1=df1.head()                                   #输出前5条数据<br>运行程序，输出结果如图3.22所示。</p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018050346464.png" alt="image-20211018050346464">                                                  </p>
<p>​                                                                                            图3.22　导入.csv文件</p>
<p>注意<br>上述代码中指定了编码格式，即encoding=’gbk’。Python常用的编码格式是UTF-8和gbk，默认编码格式为UTF-8。导入.csv文件时，需要通过encoding参数指定编码格式。当将Excel文件另存为.csv文件时，默认编码格式为gbk，此时当编写代码导入.csv文件时，就需要设置编码格式为gbk，与源文件编码格式保持一致；否则会提示错误。</p>
<h4 id="3-4-3-导入-txt文本文件"><a href="#3-4-3-导入-txt文本文件" class="headerlink" title="3.4.3　导入.txt文本文件"></a>3.4.3　导入.txt文本文件</h4><p>导入.txt文件同样使用Pandas的read_csv()方法，不同的是需要指定sep参数（如制表符\t）。read_csv()方法读取.txt文件返回一个DataFrame，像表格一样的二维数据结构，如图3.23所示。</p>
<p>【示例17】　导入.txt文件。（示例位置：资源包\MR\Code\03\17）<br>下面使用read_csv()方法导入1月.txt文件，主要代码如下：</p>
<p>01 import pandas as pd<br>02 df1=pd.read_csv(‘1月.txt’,sep=’\t’,encoding=’gbk’)<br>03 print(df1.head())<br>运行程序，输出结果如图3.24所示。</p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018050613488-16345047782181.png" alt="image-20211018050613488"></p>
<p>​                                                                                                        图3.23　.txt文件形式</p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018050642828.png" alt="image-20211018050642828"></p>
<p>​                                                                                                         图3.24　导入.txt文本</p>
<h4 id="3-4-4-导入HTML网页"><a href="#3-4-4-导入HTML网页" class="headerlink" title="3.4.4　导入HTML网页"></a>3.4.4　导入HTML网页</h4><p>导入HTML网页数据主要使用Pandas的read_html()方法，该方法用于导入带有table标签的网页表格数据，语法如下：</p>
<p>pandas.read_html(io,match=’.+’,flavor=None,header=None,index_col=None,skiprows=None,attrs=None,parse_<br>dates=False,thousands=’,’,encoding=None,decimal=’.’,converters=None,na_values=None,keep_default_na=True,<br>displayed_only=True)<br>常用参数说明：　</p>
<p>io：字符串，文件路径，也可以是URL链接。网址不接受https，可以尝试去掉https中的s后爬取，如<a href="http://www.mingribook.com./">http://www.mingribook.com。</a></p>
<p>match：正则表达式，返回与正则表达式匹配的表格。　</p>
<p>flavor：解析器默认为lxml。　</p>
<p>header：指定列标题所在的行，列表list为多重索引。　</p>
<p>index_col：指定行标题对应的列，列表list为多重索引。　</p>
<p>encoding：字符串，默认为None，文件的编码格式。　</p>
<p>返回值：返回一个DataFrame。<br>使用read_html()方法前，首先要确定网页表格是否为table类型。例如，NBA球员薪资网页（<a href="http://www.espn.com/nba/salaries%EF%BC%89%EF%BC%8C%E5%8F%B3%E5%87%BB%E8%AF%A5%E7%BD%91%E9%A1%B5%E4%B8%AD%E7%9A%84%E8%A1%A8%E6%A0%BC%EF%BC%8C%E5%9C%A8%E5%BC%B9%E5%87%BA%E7%9A%84%E5%BF%AB%E6%8D%B7%E8%8F%9C%E5%8D%95%E4%B8%AD%E9%80%89%E6%8B%A9%E2%80%9C%E6%A3%80%E6%9F%A5%E5%85%83%E7%B4%A0%E2%80%9D%E5%91%BD%E4%BB%A4%EF%BC%8C%E6%9F%A5%E7%9C%8B%E4%BB%A3%E7%A0%81%E4%B8%AD%E6%98%AF%E5%90%A6%E5%90%AB%E6%9C%89%E8%A1%A8%E6%A0%BC%E6%A0%87%E7%AD%BE">http://www.espn.com/nba/salaries），右击该网页中的表格，在弹出的快捷菜单中选择“检查元素”命令，查看代码中是否含有表格标签</a><table>…</table>的字样，如图3.25所示。确定后才可以使用read_html()方法。</p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018051003748.png" alt="image-20211018051003748"></p>
<p>​                                                                            图3.25　<table>…</table>表格标签</p>
<p>【示例18】　导入NBA球员薪资数据。（示例位置：资源包\MR\Code\03\18）<br>下面使用read_html()方法导入NBA球员薪资数据，程序代码如下：</p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018051015470.png" alt="image-20211018051015470"></p>
<p>运行程序，输出结果如图3.26所示。</p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018051117577.png" alt="image-20211018051117577"></p>
<p>​                                                                                              图3.26　导入网页数据注意<br>运行程序，如果出现ImportError: lxml not found, please install it错误提示信息，则需要安装lxml模块。</p>
<h3 id="3-5-数据抽取"><a href="#3-5-数据抽取" class="headerlink" title="3.5　数据抽取"></a>3.5　数据抽取</h3><p>数据分析过程中，并不是所有的数据都是我们想要的，此时可以抽取部分数据，主要使用DataFrame对象的loc属性和iloc属性，示意图如图3.27所示。</p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018051225461.png" alt="image-20211018051225461">          </p>
<pre><code>                                                                                     图3.27　loc属性和iloc属性示意图
</code></pre>
<p>对象的loc属性和iloc属性都可以抽取数据，区别如下。　</p>
<p>loc属性：以列名（columns）和行名（index）作为参数，当只有一个参数时，默认是行名，即抽取整行数据，包括所有列，如df.loc[‘A’]。　</p>
<p>iloc属性：以行和列位置索引（即0，1，2，…)作为参数，0表示第1行，1表示第2行，以此类推。当只有一个参数时，默认是行索引，即抽取整行数据，包括所有列。如抽取第1行数据，df.iloc[0]。</p>
<h4 id="3-5-1-抽取一行数据"><a href="#3-5-1-抽取一行数据" class="headerlink" title="3.5.1　抽取一行数据"></a>3.5.1　抽取一行数据</h4><p>抽取一行数据主要使用loc属性。【</p>
<p>示例19】　抽取一行考试成绩数据。（示例位置：资源包\MR\Code\03\19）抽取一行名为“明日”的考试成绩数据（包括所有列），程序代码如下：</p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018051358694.png" alt="image-20211018051358694">运行程序，输出结果如图3.28所示。<br>使用iloc属性抽取第1行数据，指定行索引即可，如df.iloc[0]，输出结果同图3.28一样。</p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018051441548.png" alt="image-20211018051441548"></p>
<p>​                                                                                                                图3.28　抽取一行数据</p>
<h4 id="3-5-2-抽取多行数据"><a href="#3-5-2-抽取多行数据" class="headerlink" title="3.5.2　抽取多行数据"></a>3.5.2　抽取多行数据</h4><p>1．抽取任意多行数据<br>通过loc属性和iloc属性指定行名和行索引即可实现抽取任意多行数据。</p>
<p>【示例20】　抽取多行考试成绩数据。（示例位置：资源包\MR\Code\03\20）抽取行名为“明日”和“高袁圆”（即第1行和第3行数据）的考试成绩数据，可以使用loc属性，也可以使用iloc属性，其输出结果都是一样的，主要代码如下：</p>
<p>01 df1=df.loc[[‘明日’,’高袁圆’]]<br>02 df1=df.iloc[[0,2]]<br>运行程序，输出结果如图3.29所示。</p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018051606515.png" alt="image-20211018051606515"></p>
<p>​                                                                                                图3.29　抽取多行数据<br>2．抽取连续任意多行数据<br>在loc属性和iloc属性中合理地使用冒号（:），即可抽取连续任意多行数据。</p>
<p>【示例21】　抽取连续几个学生的考试成绩。（示例位置：资源包\MR\Code\03\21）抽取连续几个学生的考试成绩，主要代码如下：</p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018051735968.png" alt="image-20211018051735968"></p>
<p>运行程序，控制台输出结果如图3.30所示。</p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018051746750.png" alt="image-20211018051746750"></p>
<p>​                                                                                 图3.30　抽取连续任意多行数据</p>
<h4 id="3-5-3-抽取指定列数据"><a href="#3-5-3-抽取指定列数据" class="headerlink" title="3.5.3　抽取指定列数据"></a>3.5.3　抽取指定列数据</h4><p>抽取指定列数据，可以直接使用列名，也可以使用loc属性和iloc属性。<br>1．直接使用列名【示例22】　抽取“语文”和“数学”的考试成绩。（示例位置：资源包\MR\Code\03\22）<br>抽取列名为“语文”和“数学”的考试成绩数据，程序代码如下：</p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018051846594.png" alt="image-20211018051846594"></p>
<p>运行程序，输出结果如图3.31所示。</p>
<p>2．使用loc属性和iloc属性<br>前面介绍loc属性和iloc属性均有两个参数：第一个参数代表行；第二个参数代表列。那么这里抽取指定列数据时，行参数不能省略。</p>
<p>【示例23】　抽取指定学科的考试成绩。（示例位置：资源包\MR\Code\03\23）<br>下面使用loc属性和iloc属性抽取指定列数据，主要代码如下：</p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018052009426.png" alt="image-20211018052009426"></p>
<p>运行程序，控制台输出结果如图3.32所示。</p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018052021825.png" alt="image-20211018052021825"></p>
<p>​                                                                                      图3.31　直接使用列名</p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018052041459.png" alt="image-20211018052041459"></p>
<p>​                                                                                          图3.32　loc属性和iloc属性</p>
<h4 id="3-5-4-抽取指定行、列数据"><a href="#3-5-4-抽取指定行、列数据" class="headerlink" title="3.5.4　抽取指定行、列数据"></a>3.5.4　抽取指定行、列数据</h4><p>抽取指定行、列数据主要使用loc属性和iloc属性，这两个方法的两个参数都指定就可以实现指定行、列数据的抽取。</p>
<p>【示例24】　抽取指定学科和指定学生的考试成绩。（示例位置：资源包\MR\Code\03\24）使用loc属性和iloc属性抽取指定行、列数据，程序代码如下：</p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018052200474.png" alt="image-20211018052200474"></p>
<p>运行程序，控制台输出结果如图3.33所示。</p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018052214525.png" alt="image-20211018052214525"></p>
<pre><code>                                                                               图3.33　抽取指定行、列数据
</code></pre>
<p>在上述结果中，第一个输出结果是一个数，不是数据，是由于“df.loc[‘七月流火’,’英语’]”没有使用方括号[]，导致输出的数据不是DataFrame类型。</p>
<h4 id="3-5-5-按指定条件抽取数据"><a href="#3-5-5-按指定条件抽取数据" class="headerlink" title="3.5.5　按指定条件抽取数据"></a>3.5.5　按指定条件抽取数据</h4><p>DataFrame对象实现数据查询有以下3种方式。　取其中的一个元素.iat[x,x]。　基于位置的查询，如.iloc[]、iloc[2,1]。　基于行、列名称的查询，如.loc[x]。</p>
<p>【示例25】　抽取指定学科和指定分数的数据。（示例位置：资源包\MR\Code\03\25）抽取语文成绩大于105，数学成绩大于88的数据，程序代码如下：</p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018052322850.png" alt="image-20211018052322850"></p>
<p>运行程序，输出结果如图3.34所示。</p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018052523463.png" alt="image-20211018052523463">   </p>
<p>​                                                                                             图3.34　按指定条件抽取数据</p>
<h3 id="3-6-数据的增加、修改和删除"><a href="#3-6-数据的增加、修改和删除" class="headerlink" title="3.6　数据的增加、修改和删除"></a>3.6　数据的增加、修改和删除</h3><p>本节主要介绍如何操纵DataFrame对象中的各种数据。例如，数据的增加、修改和删除。</p>
<h4 id="3-6-1-增加数据"><a href="#3-6-1-增加数据" class="headerlink" title="3.6.1　增加数据"></a>3.6.1　增加数据</h4><p>DataFrame对象增加数据主要包括列数据增加和行数据增加。首先看一下原始数据，如图3.35所示。</p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018052637063.png" alt="image-20211018052637063"></p>
<p>图3.35　原始数据</p>
<h5 id="1．按列增加数据"><a href="#1．按列增加数据" class="headerlink" title="1．按列增加数据"></a>1．按列增加数据</h5><p>按列增加数据，可以通过以下3种方式实现。<br>（1）直接为DataFrame对象赋值</p>
<p>【示例26】　增加一列“物理”成绩。（示例位置：资源包\MR\Code\03\26）<br>增加一列“物理”成绩，程序代码如下：</p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018052702267.png" alt="image-20211018052702267"></p>
<p>运行程序，输出结果如图3.36所示。</p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018052756371.png" alt="image-20211018052756371"></p>
<p>​                                                                                   图3.36　按列增加数据<br>（2）使用loc属性在DataFrame对象的最后增加一列</p>
<p>【示例27】　使用loc属性增加一列“物理”成绩。（示例位置：资源包\MR\Code\03\27）使用loc属性在DataFrame对象的最后增加一列。例如，增加“物理”一列，主要代码如下：</p>
<p>df.loc[:,’物理’] = [88,79,60,50]<br>在DataFrame对象最后增加一列“物理”，其值为等号右边数据。</p>
<p>（3）在指定位置插入一列<br>在指定位置插入一列，主要使用insert()方法。</p>
<p>【示例28】　在第1列后面插入“物理”成绩。（示例位置：资源包\MR\Code\03\28）<br>例如，在第1列后面插入“物理”，其值为wl的数值，主要代码如下：</p>
<p>01 wl =[88,79,60,50]<br>02 df.insert(1,’物理’,wl)<br>运行程序，输出结果如图3.37所示。</p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018052920670.png" alt="image-20211018052920670"></p>
<p>​                                                                                                图3.37　使用insert()方法增加一列</p>
<h5 id="2．按行增加数据"><a href="#2．按行增加数据" class="headerlink" title="2．按行增加数据"></a>2．按行增加数据</h5><p>按行增加数据，可以通过以下两种方式实现。<br>（1）增加一行数据<br>增加一行数据主要使用loc属性实现。</p>
<p>【示例29】　在成绩表中增加一行数据。（示例位置：资源包\MR\Code\03\29）在成绩表中增加一行数据，即“钱多多”同学的成绩，主要代码如下：</p>
<p>df.loc[‘钱多多’] = [100,120,99]<br>（2）增加多行数据</p>
<p>增加多行数据主要使用字典结合append()方法实现。</p>
<p>【示例30】　在原有数据中增加几名同学的考试成绩。（示例位置：资源包\MR\Code\03\30）在原有数据中增加“钱多多”“童年”“无名”同学的考试成绩，主要代码如下：</p>
<p>01 df_insert=pd.DataFrame({‘语文’:[100,123,138],’数学’:[99,142,60],’英语’:[98,139,99]},index = [‘钱多多’,’童年’,’无名’])<br>02 df1 = df.append(df_insert)<br>运行程序，输出结果分别如图3.38和图3.39所示。</p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018053145141.png" alt="image-20211018053145141"></p>
<p>​                                                                                       图3.38　增加一行数据</p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018053204251.png" alt="image-20211018053204251"></p>
<p>​                                                                                        图3.39　增加多行数据</p>
<h4 id="3-6-2-修改数据"><a href="#3-6-2-修改数据" class="headerlink" title="3.6.2　修改数据"></a>3.6.2　修改数据</h4><p>修改数据包括行、列标题和数据的修改，首先看一下原始数据，如图3.40所示。</p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018053230905.png" alt="image-20211018053230905"></p>
<p>​                                                                                               图3.40　原始数据</p>
<h5 id="1．修改列标题"><a href="#1．修改列标题" class="headerlink" title="1．修改列标题"></a>1．修改列标题</h5><p>修改列标题主要使用DataFrame对象的cloumns属性，直接赋值即可。</p>
<p>【示例31】　修改“数学”的列名。（示例位置：资源包\MR\Code\03\31）将“数学”修改为“数学（上）”，主要代码如下：</p>
<p>df.columns=[‘语文’,’数学（上）’,’英语’]</p>
<p>上述代码中，即使只修改“数学”为“数学（上）”，但是也要将所有列的标题全部写上；否则将报错。<br>下面再介绍一种方法，使用DataFrame对象的rename()方法修改列标题。</p>
<p>【示例32】　修改多个学科的列名。（示例位置：资源包\MR\Code\03\32）将“语文”修改为“语文（上）”、“数学”修改为“数学（上）”、“英语”修改为“英语（上）”，主要代码如下：</p>
<p>df.rename(columns = {‘语文’:’语文（上）’,’数学’:’数学（上）’,’英语’:’英语（上）’},inplace = True)</p>
<p>上述代码中，参数inplace为True，表示直接修改df；否则，不修改df，只返回修改后的数据。<br>运行程序，输出结果分别如图3.41和图3.42所示。</p>
<h5 id="2．修改行标题"><a href="#2．修改行标题" class="headerlink" title="2．修改行标题"></a>2．修改行标题</h5><p>修改行标题主要使用DataFrame对象的index属性，直接赋值即可。【示例33】　将行标题统一修改为数字编号。（示例位置：资源包\MR\Code\03\33）<br>将行标题统一修改为数字编号，主要代码如下：</p>
<p>df.index=list(‘1234’)</p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018053500036.png" alt="image-20211018053500036"></p>
<p>​                                                                                         图3.41　修改列标题1</p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018053517247.png" alt="image-20211018053517247"></p>
<p>​                                                                                                 图3.42　修改列标题2</p>
<p>使用DataFrame对象的rename()方法也可以修改行标题。例如，将行标题统一修改为数字编号，主要代码如下：</p>
<p>df.rename({‘明日’:1,’七月流火’:2,’高袁圆’:3,’二月二’:4},axis=0,inplace = True)</p>
<h5 id="3．修改数据"><a href="#3．修改数据" class="headerlink" title="3．修改数据"></a>3．修改数据</h5><p>修改数据主要使用DataFrame对象的loc属性和iloc属性。</p>
<p>【示例34】　修改学生成绩数据。（示例位置：资源包\MR\Code\03\34）<br>（1）修改整行数据<br>例如，修改“明日”同学的各科成绩，主要代码如下：</p>
<p>df.loc[‘明日’]=[120,115,109]<br>如果各科成绩均加10分，可以直接在原有值上加10，主要代码如下：</p>
<p>df.loc[‘明日’]=df.loc[‘明日’]+10<br>（2）修改整列数据<br>例如，修改所有同学的“语文”成绩，主要代码如下：</p>
<p>df.loc[:,’语文’]=[115,108,112,118]<br>（3）修改某一数据</p>
<p>例如，修改“明日”同学的“语文”成绩，主要代码如下：</p>
<p>df.loc[‘明日’,’语文’]=115<br>（4）使用iloc属性修改数据<br>通过iloc属性指定行、列位置实现修改数据，主要代码如下：</p>
<p>01 df.iloc[0,0]=115                        #修改某一数据<br>02 df.iloc[:,0]=[115,108,112,118]          #修改整列数据<br>03 df.iloc[0,:]=[120,115,109]              #修改整行数据</p>
<h4 id="3-6-3-删除数据"><a href="#3-6-3-删除数据" class="headerlink" title="3.6.3　删除数据"></a>3.6.3　删除数据</h4><p>删除数据主要使用DataFrame对象的drop()方法。语法如下：</p>
<p>DataFrame.drop(labels=None, axis=0, index=None, columns=None, level=None, inplace=False, errors=’raise’)<br>参数说明：　</p>
<p>labels：表示行标签或列标签。　</p>
<p>axis：axis = 0，表示按行删除；</p>
<p>​            axis = 1，表示按列删除。默认值为0，即按行删除。　</p>
<p>index：删除行，默认值为None。　</p>
<p>columns：删除列，默认值为None。</p>
<p>level：针对有两级索引的数据。level = 0，表示按第1级索引删除整行；level = 1表示按第2级索引删除整行，默认值为None。　inplace：可选参数，对原数组做出修改并返回一个新数组。默认值为False，如果值为True，那么原数组直接就被替换。　</p>
<p>errors：参数值为ignore或raise，默认值为raise，如果值为ignore（忽略），则取消错误。</p>
<h5 id="1．删除行、列数据"><a href="#1．删除行、列数据" class="headerlink" title="1．删除行、列数据"></a>1．删除行、列数据</h5><p>【示例35】　删除学生成绩数据。（示例位置：资源包\MR\Code\03\35）<br>删除指定的学生成绩数据，主要代码如下：</p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018054027938.png" alt="image-20211018054027938"></p>
<h5 id="2．删除特定条件的行"><a href="#2．删除特定条件的行" class="headerlink" title="2．删除特定条件的行"></a>2．删除特定条件的行</h5><p>删除满足特定条件的行，首先找到满足该条件的行索引，然后再使用drop()方法将其删除。</p>
<p>【示例36】　删除符合条件的学生成绩数据。（示例位置：资源包\MR\Code\03\36）<br>删除“数学”成绩中包含88的行、“语文”成绩中小于110的行，主要代码如下：</p>
<p>01 df.drop(index=df[df[‘数学’].isin([88])].index[0],inplace=True)      #删除“数学”成绩中包含88的行<br>02 df.drop(index=df[df[‘语文’]&lt;110].index[0],inplace=True)             #删除“语文”成绩中小于110的行说明<br>以上代码中的方法都可以实现删除指定的行、列数据，读者选择一种即可。</p>
<h3 id="3-7-数据清洗"><a href="#3-7-数据清洗" class="headerlink" title="3.7　数据清洗"></a>3.7　数据清洗</h3><h4 id="3-7-1-缺失值查看与处理"><a href="#3-7-1-缺失值查看与处理" class="headerlink" title="3.7.1　缺失值查看与处理"></a>3.7.1　缺失值查看与处理</h4><p>缺失值是指由于某种原因导致数据为空，这种情况一般有不处理、删除、填充／替换、插值（以均值／中位数／众数等填补）这4种处理方式。</p>
<h5 id="1．缺失值查看"><a href="#1．缺失值查看" class="headerlink" title="1．缺失值查看"></a>1．缺失值查看</h5><p>首先需要找到缺失值，主要使用DataFrame对象的info()方法。</p>
<p>【示例37】　查看数据概况。（示例位置：资源包\MR\Code\03\37）以淘宝销售数据为例，首先输出数据，然后使用info()方法查看数据，程序代码如下：</p>
<p>01 import pandas as pd<br>02 df=pd.read_excel(‘TB2018.xls’)<br>03 print(df)<br>04 print(df.info())</p>
<p>运行程序，控制台输出结果如图3.43所示。</p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018054304916.png" alt="image-20211018054304916"></p>
<p>图3.43　缺失值查看<br>在Python中，缺失值一般用NaN表示，如图3.43所示。通过info()方法可看到“买家会员名”“买家实际支付金额”“宝贝标题”“订单付款时间”的非空数量是10，而“宝贝总数量”和“类别”的非空数量是8，那么说明这两项存在空值。</p>
<p>【示例38】　判断数据是否存在缺失值。（示例位置：资源包\MR\Code\03\38）<br>接下来，判断数据是否存在缺失值还可以使用isnull()方法和notnull()方法，主要代码如下：</p>
<p>01  print(df.isnull())<br>02  print(df.notnull())<br>运行程序，控制台输出结果如图3.44所示。</p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018054406384.png" alt="image-20211018054406384"></p>
<p>​                                                                                              图3.44　判断缺失值<br>使用isnull()方法缺失值返回True，非缺失值返回False；而notnull()方法与isnull()方法正好相反，缺失值返回False，非缺失值返回True。<br>如果使用df[df.isnull() == False]，</p>
<p>则会将所有非缺失值的数据找出来，只针对Series对象。</p>
<h5 id="2．缺失值删除处理"><a href="#2．缺失值删除处理" class="headerlink" title="2．缺失值删除处理"></a>2．缺失值删除处理</h5><p>通过前面的判断得知数据缺失情况，下面将缺失值删除，主要使用dropna()方法，该方法用于删除含有缺失值的行，主要代码如下：</p>
<p>df1=df.dropna()<br>运行程序，输出结果如图3.45所示。说明<br>有些时候数据可能存在整行为空的情况，此时可以在dropna()方法中指定参数how=’all’，删除所有空行。</p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018054531853.png" alt="image-20211018054531853"></p>
<p>​                                                                                   图3.45　缺失值删除处理1<br>从运行结果得知：dropna()方法将所有包含缺失值的数据全部删除了。那么，此时如果我们认为有些数据虽然存在缺失值，但是不影响数据分析，那么可以使用以下方法处理。例如，上述数据中只保留“宝贝总数量”不存在缺失值的数据，而类别是否缺失不关注，则可以使用notnull()方法判断，主要代码如下：</p>
<p>df2=df[df[‘宝贝总数量’].notnull()]<br>运行程序，输出结果如图3.46所示。</p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018054627170.png" alt="image-20211018054627170"></p>
<p>图3.46　缺失值删除处理2</p>
<h5 id="3．缺失值填充处理"><a href="#3．缺失值填充处理" class="headerlink" title="3．缺失值填充处理"></a>3．缺失值填充处理</h5><p>对于缺失数据，如果比例高于30%可以选择放弃这个指标，做删除处理；低于30%尽量不要删除，而是选择将这部分数据填充，一般以0、均值、众数（大多数）填充。DataFrame对象中的fillna()函数可以实现填充缺失数据，pad/ffill表示用前一个非缺失值去填充该缺失值；backfill/bfill表示用下一个非缺失值填充该缺失值；None用于指定一个值去替换缺失值。</p>
<p>【示例39】　将NaN填充为0。（示例位置：资源包\MR\Code\03\39）对于用于计算的数值型数据如果为空，可以选择用0填充。例如，将“宝贝总数量”为空的数据填充为0，主要代码如下：</p>
<p>df[‘宝贝总数量’] = df[‘宝贝总数量’].fillna(0)<br>运行程序，输出结果如图3.47所示。</p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018054749852.png" alt="image-20211018054749852"></p>
<h1 id="replace"><a href="#replace" class="headerlink" title="replace()"></a>replace()</h1><p>既可以替换某列，也可以替换某行，还可以全表替换</p>
<p>df.replace() 或者 df[col]replace()</p>
<pre><code>#参数如下：
df.replace(to_replace=None, value=None, inplace=False, limit=None, regex=False, method=&#39;pad&#39;,)
</code></pre>
<h1 id="参数说明："><a href="#参数说明：" class="headerlink" title="参数说明："></a>参数说明：</h1><ul>
<li>to_replace：被替换的值</li>
<li>value：替换后的值</li>
<li>inplace：是否要改变原数据，False是不改变，True是改变，默认是False</li>
<li>limit：控制填充次数</li>
<li>regex：是否使用正则,False是不使用，True是使用，默认是False</li>
<li>method：填充方式，pad,ffill,bfill分别是向前、向前、向后填充</li>
</ul>
<p>​                                                                                           图3.47　缺失值填充处理</p>
<h4 id="3-7-2-重复值处理"><a href="#3-7-2-重复值处理" class="headerlink" title="3.7.2　重复值处理"></a>3.7.2　重复值处理</h4><p>对于数据中存在的重复数据，包括重复的行或者几行中某几列的值重复一般做删除处理，主要使用DataFrame对象的drop_duplicates()方法。</p>
<p>【示例40】　处理淘宝电商销售数据中的重复数据。（示例位置：资源包\MR\Code\03\40）下面以“1月.xlsx”淘宝销售数据为例，对其中的重复数据进行处理。<br>（1）判断每一行数据是否重复（完全相同），主要代码如下：</p>
<p>df1.duplicated()<br>如果返回值为False表示不重复，返回值为True表示重复。<br>（2）去除全部的重复数据，主要代码如下：</p>
<p>df1.drop_duplicates()<br>（3）去除指定列的重复数据，主要代码如下：</p>
<p>df1.drop_duplicates([‘买家会员名’])<br>（4）保留重复行中的最后一行，主要代码如下：</p>
<p>df1.drop_duplicates([‘买家会员名’],keep=’last’)说明<br>以上代码中参数keep的值有3个。当keep=’first’表示保留第一次出现的重复行，是默认值；当keep为另外两个取值，即last和False时，分别表示保留最后一次出现的重复行和去除所有重复行。<br>（5）直接删除，保留一个副本，主要代码如下：</p>
<p>df1.drop_duplicates([‘买家会员名’,’买家支付宝账号’],inplace=Fasle)<br>inplace=True表示直接在原来的DataFrame上删除重复项，而默认值False表示删除重复项后生成一个副本。</p>
<h4 id="3-7-3-异常值的检测与处理"><a href="#3-7-3-异常值的检测与处理" class="headerlink" title="3.7.3　异常值的检测与处理"></a>3.7.3　异常值的检测与处理</h4><p>首先了解一下什么是异常值。在数据分析中异常值是指超出或低于正常范围的值，如年龄大于200、身高大于3米、宝贝总数量为负数等类似数据。那么这些数据如何检测呢？主要有以下几种方法。<br>（1）根据给定的数据范围进行判断，不在范围内的数据视为异常值。<br>（2）均方差。<br>在统计学中，如果一个数据分布近似正态分布（数据分布的一种形式，正态分布的概率密度函数曲线呈钟形，两头低、中间高、左右对称，因此人们又经常称之为钟形曲线），那么大约68%的数据值会在均值的一个标准差范围内，大约95%会在两个标准差范围内，大约99.7%会在3个标准差范围内。<br>（3）箱形图。<br>箱形图是显示一组数据分散情况资料的统计图。它可以将数据通过四分位数的形式进行图形化描述。箱形图通过上限和下限作为数据分布的边界。任何高于上限或低于下限的数据都可以认为是异常值，如图3.48所示。</p>
<p><img src="/2021/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/image-20211018055103761.png" alt="image-20211018055103761"></p>
<p>​                                                                                            图3.48　箱形图说明<br>有关箱形图的介绍以及如何通过箱形图识别异常值可参见第6章。<br>了解了异常值的检测，接下来介绍如何处理异常值，主要包括以下几种处理方式。<br>（1）最常用的方式是删除。<br>（2）将异常值当缺失值处理，以某个值填充。<br>（3）将异常值当特殊情况进行分析，研究异常值出现的原因。</p>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
  </entry>
  <entry>
    <title>matplotlib可视化数据分析图表</title>
    <url>/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="第五章-matplotlib可视化数据分析图表"><a href="#第五章-matplotlib可视化数据分析图表" class="headerlink" title="第五章 matplotlib可视化数据分析图表"></a>第五章 matplotlib可视化数据分析图表</h1><h2 id="5-1数据分析图表的作用"><a href="#5-1数据分析图表的作用" class="headerlink" title="5.1数据分析图表的作用"></a>5.1数据分析图表的作用</h2><p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022031956908.png" alt="image-20211022031956908"></p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022032027076.png" alt="image-20211022032027076"></p>
<p>上述举例同是“月销量分析”结果的呈现，您更青睐哪一种？显然，数据分析图表（见图5.2）更加直观、生动和具体，它将复杂的统计数字变得简单化、通俗化、形象化，使人一目了然，便于理解和比较。数据分析图表直观地展示统计信息，使我们能够快速了解数据变化趋势、数据比较结果以及所占比例等，它对数据分析、数据挖掘起到了关键性的作用。</p>
<h2 id="5-2-如何选择适合的图表类型"><a href="#5-2-如何选择适合的图表类型" class="headerlink" title="5.2　如何选择适合的图表类型"></a>5.2　如何选择适合的图表类型</h2><p>数据分析图表的类型包括条形图、柱状图、折线图、饼图、散点图、面积图、环形图、雷达图等。此外，通过图表的相互叠加还可以生成复合型图表。<br>不同类型的图表适用不同的场景，可以按使用目的选择合适的图表类型。下面通过一张框架图来说明，如图5.3所示。</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022032233461.png" alt="image-20211022032233461"></p>
<p>​                                                                                                    图5.3　图表分类框架图</p>
<h2 id="5-3-图表的基本组成"><a href="#5-3-图表的基本组成" class="headerlink" title="5.3　图表的基本组成"></a>5.3　图表的基本组成</h2><p>数据分析图表有很多种，但每一种图表的绝大组成部分是基本相同的，一张完整的图表一般包括画布、图表标题、绘图区、数据系列、坐标轴、坐标轴标题、图例、文本标签、网格线等，如图5.4所示。</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022032427628.png" alt="image-20211022032427628"></p>
<p>​                                                                                  图5.4　图表的基本组成部分<br>下面详细介绍各个组成部分的功能。<br>（1）画布：图中最大的白色区域，作为其他图表元素的容器。<br>（2）图表标题：用来概况图表内容的文字，常用的功能有设置字体、字号及字体颜色等。<br>（3）绘图区：画布中的一部分，即显示图形的矩形区域，可改变填充颜色、位置，以便图表展示更好的图形效果。<br>（4）数据系列：在数据区域中，同一列（或同一行）数值数据的集合构成一组数据系列，也就是图表中相关数据点的集合。图表中可以有一组到多组数据系列，多组数据系列之间通常采用不同的图案、颜色或符号来区分。图5.4中，销售额就是数据系列。<br>（5）坐标轴及坐标轴标题：坐标轴是标识数值大小及分类的垂直线和水平线，上面有标定数据值的标志（刻度）。一般情况下，水平轴（x轴）表示数据的分类；坐标轴标题用来说明坐标轴的分类及内容，分为水平坐标轴和垂直坐标轴。图5.4中，x轴的标题是“年份”，y轴的标题是“线上销售额（元）”。<br>（6）图例：是指示图表中系列区域的符号、颜色或形状定义数据系列所代表的内容。图例由两部分构成，即图例标示和图例项。其中，图例标示，代表数据系列的图案，即不同颜色的小方块；图例项，与图例标示对应的数据系列名称。一种图例标示只能对应一种图例项。<br>（7）文本标签：用于为数据系列添加说明文字。<br>（8）网格线：贯穿绘图区的线条，类似标尺可以衡量数据系列数值的标准。常用的功能有设置网格线宽度、样式、颜色、坐标轴等。</p>
<h2 id="5-4-Matplotlib概述"><a href="#5-4-Matplotlib概述" class="headerlink" title="5.4　Matplotlib概述"></a>5.4　Matplotlib概述</h2><p>众所周知，Python绘图库有很多，各有特点，而Maplotlib是最基础的Python可视化库。学习Python数据可视化，应首先从Maplotlib学起，然后再学习其他库作为拓展。</p>
<h3 id="5-4-1-Matplotlib简介"><a href="#5-4-1-Matplotlib简介" class="headerlink" title="5.4.1　Matplotlib简介"></a>5.4.1　Matplotlib简介</h3><p>Matplotlib是一个Python 2D绘图库，常用于数据可视化。它能够以多种硬拷贝格式和跨平台的交互式环境生成出版物质量的图形。<br>Matplotlib非常强大，绘制各种各样的图表游刃有余，它将容易的事情变得更容易，困难的事情变得可能。只需几行代码就可以绘制折线图（见图5.5和图5.6）、柱形图（见图5.7）、直方图（见图5.8）、饼形图（见图5.9）、散点图（见图5.10）等。</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022032738449.png" alt="image-20211022032738449"></p>
<p>​                                                                                               图5.5　折线图</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022032809892.png" alt="image-20211022032809892"></p>
<p>​                                                                                                         图5.6　多折线图</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022032836058.png" alt="image-20211022032836058"></p>
<p>​                                                                                                           图5.7　柱形图</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022032942254.png" alt="image-20211022032942254"></p>
<p>​                                                                                                                图5.8　直方图</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022033015707.png" alt="image-20211022033015707"></p>
<p>​                                                                                                   图5.9　饼形图</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022033048337.png" alt="image-20211022033048337"></p>
<p>​                                                                                                                   图5.10　散点图</p>
<p>Matpoltlib不仅可以绘制以上最基础的图表，还可以绘制一些高级图表，如双y轴可视化数据分析图表（见图5.11）、堆叠柱形图（见图5.12）、渐变饼形图（见图5.13）、等高线图（见图5.14）。</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022033123470.png" alt="image-20211022033123470"></p>
<p>​                                                                               图5.11　双y轴可视化数据分析图表</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022033148927.png" alt="image-20211022033148927"></p>
<p>​                                                                                          图5.12　堆叠柱形图</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022033244197.png" alt="image-20211022033244197"></p>
<p>​                                                                                                图5.13　渐变饼形图</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022033309035.png" alt="image-20211022033309035"></p>
<p>​                                                                                                     图5.14　等高线图<br>不仅如此，Matplotlib还可以绘制3D图表。例如，三维柱形图（见图5.15）、三维曲面图（见图5.16）。</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022033338259.png" alt="image-20211022033338259"></p>
<p>​                                                                                           图5.15　三维柱形图</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022033408168.png" alt="image-20211022033408168"></p>
<p>​                                                                                                  图5.16　三维曲面图</p>
<p>综上所述，只要熟练地掌握Matplotlib的函数，以及各项参数就能够绘制出各种出乎意料的图表，满足数据分析的需求。</p>
<h3 id="5-4-2-安装Matplotlib"><a href="#5-4-2-安装Matplotlib" class="headerlink" title="5.4.2　安装Matplotlib"></a>5.4.2　安装Matplotlib</h3><p>pip install matplotlib</p>
<h3 id="5-4-3-Matplotlib图表之初体验"><a href="#5-4-3-Matplotlib图表之初体验" class="headerlink" title="5.4.3　Matplotlib图表之初体验"></a>5.4.3　Matplotlib图表之初体验</h3><p>创建Matplotlib图表简单的只需两步。下面将绘制第一张图表。</p>
<p>【示例01】　绘制第一张图表。（示例位置：资源包\MR\Code\05\01）<br>（1）引入pyplot模块。</p>
<p>（2）使用Matplotlib模块的plot()方法绘制图表。<br>（3）输出结果，如图5.19和图5.20所示。</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022034058362.png" alt="image-20211022034058362"></p>
<p>​                                                                                         图5.19　简单折线图</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022034122814.png" alt="image-20211022034122814"></p>
<p>​                                                                                             图5.20　简单散点图</p>
<p>程序代码如下：</p>
<p>01 import matplotlib.pyplot as plt<br>02 plt.plot([1, 2, 3, 4,5])</p>
<p>【示例02】　绘制散点图。（示例位置：资源包\MR\Code\05\02）<br>将示例01的代码稍作改动以绘制散点图，程序代码如下：</p>
<p>01 import matplotlib.pyplot as plt<br>02 plt.plot([1, 2, 3, 4,5], [2, 5, 8, 12,18], ‘ro’)</p>
<h2 id="5-5-图表的常用设置"><a href="#5-5-图表的常用设置" class="headerlink" title="5.5　图表的常用设置"></a>5.5　图表的常用设置</h2><p>本节主要介绍图表的常用设置，主要包括颜色设置、线条样式、标记样式、设置画布、坐标轴、添加文本标签、设置标题和图例、添加注释文本、调整图表与画布边缘间距，以及其他相关设置等。</p>
<h3 id="5-5-1-基本绘图plot-函数"><a href="#5-5-1-基本绘图plot-函数" class="headerlink" title="5.5.1　基本绘图plot()函数"></a>5.5.1　基本绘图plot()函数</h3><p>Matplotlib基本绘图主要使用plot()函数，语法如下：</p>
<p>matplotlib.pyplot.plot(x,y,format_string,**kwargs)<br>参数说明：　**</p>
<p>x：x轴数据。　</p>
<p>y：y轴数据。　</p>
<p>format_string：控制曲线格式的字符串，包括颜色、线条样式和标记样式。　</p>
<p>kwargs：键值参数，相当于一个字典，比如输入参数为(1,2,3,4,k,a=1,b=2,c=3)，*args=(1,2,3,4,k)，**kwargs={‘a’:’1,’b’:2,’c’:3}。</p>
<p>【示例03】　绘制简单折线图。（示例位置：资源包\MR\Code\05\03）<br>绘制简单的折线图，程序代码如下：</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022034804845.png" alt="image-20211022034804845"></p>
<p>运行程序，输出结果如图5.21所示。</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022034902494.png" alt="image-20211022034902494"></p>
<p>​                                                                                     图5.21　简单折线图</p>
<p>【示例04】　绘制体温折线图。（示例位置：资源包\MR\Code\05\04）<br>示例03中数据是通过range()函数随机创建的。下面导入Excel体温表，分析下14天基础体温情况，程序代码如下：</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022034830689.png" alt="image-20211022034830689"></p>
<p>运行程序，输出结果如图5.22所示。</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022034948585.png" alt="image-20211022034948585"></p>
<p>​                                                                                     图5.22　体温折线图<br>至此，您可能还是觉得图5.22中的图表不够完美，那么在接下来的学习中，我们将一步一步完善这张图表。下面介绍图表中线条颜色、线条样式和标记样式的设置。</p>
<h4 id="1．颜色设置"><a href="#1．颜色设置" class="headerlink" title="1．颜色设置"></a>1．颜色设置</h4><p>color参数可以设置线条颜色，通用颜色值如表5.1所示。</p>
<p>​                                                                                                表5.1　通用颜色</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022035138016.png" alt="image-20211022035138016"></p>
<p>其他颜色可以通过十六进制字符串指定，或者指定颜色名称，例如：　</p>
<p>浮点形式的RGB或RGBA元组，例如(0.1, 0.2, 0.5)或(0.1, 0.2, 0.5, 0.3)。　</p>
<p>十六进制的RGB或RGBA字符串，例如#0F0F0F或#0F0F0F0F。　</p>
<p>0～1的小数作为灰度值，例如0.5。　</p>
<p>{‘b’, ‘g’, ‘r’, ‘c’, ‘m’, ‘y’, ‘k’, ‘w’}，其中的一个颜色值。　</p>
<p>X11/CSS4规定中的颜色名称。　</p>
<p>Xkcd中指定的颜色名称，例如xkcd:sky blue。　</p>
<p>Tableau调色板中的颜色，例如{‘tab:blue’, ‘tab:orange’, ‘tab:green’, ‘tab:red’, ‘tab:purple’, ‘tab:brown’,’tab:pink’, ‘tab:gray’, ‘tab:olive’, ‘tab:cyan’}。　</p>
<p>CN格式的颜色循环，对应的颜色设置代码如下：</p>
<p>01  from cycler import cycler<br>02  colors=[‘#1f77b4’, ‘#ff7f0e’, ‘#2ca02c’, ‘#d62728’, ‘#9467bd’, ‘#8c564b’, ‘#e377c2’,’#7f7f7f’, ‘#bcbd22’, ‘#17becf’]<br>03  plt.rcParams[‘axes.prop_cycle’] = cycler(color=colors)</p>
<p>补充：</p>
<ol>
<li><p>matplotlib的依赖包cycler是matplotlib自主开发的属性组合包，功能与内置模块itertools很多函数非常相似，可用于创建特殊的迭代器。matpoltlib在属性设置底层中使用了cycler包，典型的案例就是在多数据系列绘图中循环使用颜色、线条等外观设置。使用cycler可以避免构造多重循环，更简便、灵活的组合属性。</p>
</li>
<li><p>plt（matplotlib.pyplot）使用rc配置文件来自定义图形的各种默认属性，称之为rc配置或rc参数。<br>通过rc参数可以修改默认的属性，包括窗体大小、每英寸的点数、线条宽度、颜色、样式、坐标轴、坐标和网络属性、文本、字体等。rc参数存储在字典变量中，通过字典的方式进行访问。</p>
<p>序号    属性    说明<br>1    plt.rcParams[’axes.unicode_minus’] = False    字符显示<br>2    plt.rcParams[’font.sans-serif’] = ‘SimHei’    设置字体<br>线条样式：lines<br>3    plt.rcParams[’lines.linestyle’] = ‘-.’    线条样式<br>4    plt.rcParams[’lines.linewidth’] = 3    线条宽度<br>5    plt.rcParams[’lines.color’] = ‘blue’    线条颜色<br>6    plt.rcParams[’lines.marker’] = None    默认标记<br>7    plt.rcParams[’lines.markersize’] = 6    标记大小<br>8    plt.rcParams[’lines.markeredgewidth’] = 0.5    标记附近的线宽<br>横、纵轴：xtick、ytick<br>9    plt.rcParams[’xtick.labelsize’]    横轴字体大小<br>10    plt.rcParams[’ytick.labelsize’]    纵轴字体大小<br>11    plt.rcParams[’xtick.major.size’]    x轴最大刻度<br>12    plt.rcParams[’ytick.major.size’]    y轴最大刻度<br>figure中的子图：axes<br>13    plt.rcParams[’axes.titlesize’]    子图的标题大小<br>14    plt.rcParams[’axes.labelsize’]    子图的标签大小<br>图像、图片：figure、savefig<br>15    plt.rcParams[’figure.dpi’]    图像分辨率<br>16    plt.rcParams[’figure.figsize’]    图像显示大小<br>17    plt.rcParams[’savefig.dpi’]    图片像素</p>
</li>
</ol>
<h4 id="2．线条样式"><a href="#2．线条样式" class="headerlink" title="2．线条样式"></a>2．线条样式</h4><p>linestyle可选参数可以设置线条的样式，设置值如下，设置后的效果如图5.23所示。　“-”：实线，默认值。　“–”：双画线　“-.”：点画线。　“:”：虚线。</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022041509943.png" alt="image-20211022041509943"></p>
<p>​                                                                                          图5.23　线条样式</p>
<p>线条属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th align="right">描述</th>
</tr>
</thead>
<tbody><tr>
<td>agg_filter</td>
<td align="right">a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array</td>
</tr>
<tr>
<td>alpha</td>
<td align="right">float or None</td>
</tr>
<tr>
<td>animated</td>
<td align="right">bool</td>
</tr>
<tr>
<td>antialiased or aa</td>
<td align="right">bool</td>
</tr>
<tr>
<td>clip_box</td>
<td align="right">Bbox</td>
</tr>
<tr>
<td>clip_on</td>
<td align="right">bool</td>
</tr>
<tr>
<td>clip_path</td>
<td align="right">Patch or (Path, Transform) or None</td>
</tr>
<tr>
<td>color or c</td>
<td align="right">color</td>
</tr>
<tr>
<td>contains</td>
<td align="right">unknown</td>
</tr>
<tr>
<td>dash_capstyle</td>
<td align="right">{‘butt’, ‘round’, ‘projecting’}</td>
</tr>
<tr>
<td>dash_joinstyle</td>
<td align="right">{‘miter’, ‘round’, ‘bevel’}</td>
</tr>
<tr>
<td>dashes</td>
<td align="right">sequence of floats (on/off ink in points) or (None, None)</td>
</tr>
<tr>
<td>data</td>
<td align="right">(2, N) array or two 1D arrays</td>
</tr>
<tr>
<td>drawstyle or ds</td>
<td align="right">{‘default’, ‘steps’, ‘steps-pre’, ‘steps-mid’, ‘steps-post’}, default: ‘default’</td>
</tr>
<tr>
<td>figure</td>
<td align="right">Figure</td>
</tr>
<tr>
<td>fillstyle</td>
<td align="right">{‘full’, ‘left’, ‘right’, ‘bottom’, ‘top’, ‘none’}</td>
</tr>
<tr>
<td>gid</td>
<td align="right">str</td>
</tr>
<tr>
<td>in_layout</td>
<td align="right">bool</td>
</tr>
<tr>
<td>label</td>
<td align="right">object</td>
</tr>
<tr>
<td>linestyle or ls</td>
<td align="right">{’-’, ‘–’, ‘-.’, ‘:’, ‘’, (offset, on-off-seq), …}</td>
</tr>
<tr>
<td>linewidth or lw</td>
<td align="right">float</td>
</tr>
<tr>
<td>marker</td>
<td align="right">marker style string, Path or MarkerStyle</td>
</tr>
<tr>
<td>markeredgecolor or mec</td>
<td align="right">color</td>
</tr>
<tr>
<td>markeredgewidth or mew</td>
<td align="right">float</td>
</tr>
<tr>
<td>markerfacecolor or mfc</td>
<td align="right">color</td>
</tr>
<tr>
<td>markerfacecoloralt or mfcalt</td>
<td align="right">color</td>
</tr>
<tr>
<td>markersize or ms</td>
<td align="right">float</td>
</tr>
<tr>
<td>markevery</td>
<td align="right">None or int or (int, int) or slice or List[int] or float or (float, float) or List[bool]</td>
</tr>
<tr>
<td>path_effects</td>
<td align="right">AbstractPathEffect</td>
</tr>
<tr>
<td>picker</td>
<td align="right">unknown</td>
</tr>
<tr>
<td>pickradius</td>
<td align="right">float</td>
</tr>
<tr>
<td>rasterized</td>
<td align="right">bool or None</td>
</tr>
<tr>
<td>sketch_params</td>
<td align="right">(scale: float, length: float, randomness: float)</td>
</tr>
<tr>
<td>snap</td>
<td align="right">bool or None</td>
</tr>
<tr>
<td>solid_capstyle</td>
<td align="right">{‘butt’, ‘round’, ‘projecting’}</td>
</tr>
<tr>
<td>solid_joinstyle</td>
<td align="right">{‘miter’, ‘round’, ‘bevel’}</td>
</tr>
<tr>
<td>transform</td>
<td align="right">matplotlib.transforms.Transform</td>
</tr>
<tr>
<td>url</td>
<td align="right">str</td>
</tr>
<tr>
<td>visible</td>
<td align="right">bool</td>
</tr>
<tr>
<td>xdata</td>
<td align="right">1D array</td>
</tr>
<tr>
<td>ydata</td>
<td align="right">1D array</td>
</tr>
<tr>
<td>zorder</td>
<td align="right">float</td>
</tr>
</tbody></table>
<h4 id="3．标记样式"><a href="#3．标记样式" class="headerlink" title="3．标记样式"></a>3．标记样式</h4><p>marker可选参数可以设置标记样式，设置值如表5.2所示。</p>
<p>​                                                                                                   表5.2　标记设置</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022041541636.png" alt="image-20211022041541636"></p>
<p>下面为“14天基础体温曲线图”设置颜色和样式，并在实际体温位置进行标记，主要代码如下：</p>
<p>plt.plot(x,y,color=’m’,linestyle=’-‘,marker=’o’,mfc=’w’)</p>
<p>markerfacecolor or mfc：填充颜色</p>
<p>运行程序，输出结果如图5.24所示。</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022041620444.png" alt="image-20211022041620444"></p>
<p>​                                                                                       图5.24　带标记的折线图</p>
<h3 id="5-5-2-设置画布"><a href="#5-5-2-设置画布" class="headerlink" title="5.5.2　设置画布"></a>5.5.2　设置画布</h3><p>画布就像我们画画的画板一样，在Matplotlib中可以使用figure()方法设置画布大小、分辨率、颜色和边框等，语法如下：</p>
<p>matpoltlib.pyplot.figure(num=None, figsize=None, dpi=None, facecolor=None, edgecolor=None, frameon=True)<br>参数说明：　</p>
<p>num：图像编号或名称，数字为编号，字符串为名称，可以通过该参数激活不同的画布。　</p>
<p>figsize：指定画布的宽和高，单位为英寸。　</p>
<p>dpi：指定绘图对象的分辨率，即每英寸多少个像素，默认值为80。像素越大画布越大。　</p>
<p>facecolor：背景颜色。　</p>
<p>edgecolor：边框颜色。　</p>
<p>frameon：是否显示边框，默认值为True，绘制边框；如果为False，则不绘制边框。</p>
<p>【示例05】　自定义画布。（示例位置：资源包\MR\Code\05\05）<br>自定义一个5×3的黄色画布，主要代码如下：</p>
<p>01 import matplotlib.pyplot as plt<br>02 fig=plt.figure(figsize=(5,3),facecolor=’yellow’)<br>运行程序，输出结果如图5.25所示。</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022041739742.png" alt="image-20211022041739742"></p>
<p>​                                                                                               图5.25　设置画布注意</p>
<p>注意</p>
<p>figsize=(5,3)，因为实际画布大小是500×300，所以这里不要输入太大的数字。</p>
<h3 id="5-5-3-设置坐标轴"><a href="#5-5-3-设置坐标轴" class="headerlink" title="5.5.3　设置坐标轴"></a>5.5.3　设置坐标轴</h3><p>一张精确的图表，其中不免要用到坐标轴，下面介绍Matplotlib中坐标轴的使用。</p>
<h4 id="1．x轴、y轴标题"><a href="#1．x轴、y轴标题" class="headerlink" title="1．x轴、y轴标题"></a>1．x轴、y轴标题</h4><p>设置x轴和y轴标题主要使用xlabel()函数和ylabel()函数。</p>
<p>【示例06】　为体温折线图设置标题。（示例位置：资源包\MR\Code\05\06）<br>设置x轴标题为“2020年2月”，y轴标题为“基础体温”，程序代码如下：</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022041923078.png" alt="image-20211022041923078"></p>
<p>运行程序，输出结果如图5.26所示。</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022041940811.png" alt="image-20211022041940811"></p>
<p>​                                                                                 图5.26　带坐标轴标题的折线图实用技巧<br>在本示例中，应注意两个问题，即中文乱码问题和符号不显示问题。它们在实际编程过程中经常出现。<br>（1）解决中文乱码问题，代码如下：</p>
<p>plt.rcParams[‘font.sans-serif’]=[‘SimHei’]        #解决中文乱码</p>
<p>（2）解决负号不显示问题，代码如下：</p>
<p>plt.rcParams[‘axes.unicode_minus’] = False       #解决负号不显示</p>
<h4 id="2．坐标轴刻度"><a href="#2．坐标轴刻度" class="headerlink" title="2．坐标轴刻度"></a>2．坐标轴刻度</h4><p>用matplotlib画二维图像时，默认情况下的横坐标（x轴）和纵坐标（y轴）显示的值有时可能达不到我们的需求，需要借助xticks()函数和yticks()函数分别对x轴和y轴的值进行设置。<br>xticks()函数的语法如下：</p>
<p>xticks(locs, [labels], **kwargs)<br>参数说明：　</p>
<p>locs：数组，表示x轴上的刻度。例如，在“学生英语成绩分布图”中，x轴的刻度是2～14的偶数，如果想改变这个值，就可以通过locs参数设置。　</p>
<p>labels：也是数组，默认值和locs相同。locs表示位置，而labels则决定该位置上的标签，如果赋予labels空值，则x轴将只有刻度而不显示任何值。</p>
<p>【示例07】　为折线图设置刻度1。（示例位置：资源包\MR\Code\05\07）<br>在“14天基础体温折线图”中，x轴是从2～14的偶数，但实际日期是从1～14的连续数字，下面使用xticks()函数来解决这个问题，将x轴的刻度设置为1～14的连续数字，主要代码如下：</p>
<p>plt.xticks(range(1,15,1))</p>
<p>【示例08】　为折线图设置刻度2。（示例位置：资源包\MR\Code\05\08）<br>在示例07中，日期看起来不是很直观。下面将x轴刻度标签直接改为日，主要代码如下：</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022042054424.png" alt="image-20211022042054424"></p>
<p>运行程序，对比效果如图5.27和图5.28所示。<br>接下来，设置y轴刻度，主要使用yticks()函数。例如，设置体温为35.4～38，主要代码如下：</p>
<p>plt.yticks([35.4,35.6,35.8,36,36.2,36.4,36.6,36.8,37,37.2,37.4,37.6,37.8,38])</p>
<h4 id="3．坐标轴范围"><a href="#3．坐标轴范围" class="headerlink" title="3．坐标轴范围"></a>3．坐标轴范围</h4><p>坐标轴范围是指x轴和y轴的取值范围。设置坐标轴范围主要使用xlim()函数和ylim()函数。</p>
<p>【示例09】　为折线图设置坐标范围。（示例位置：资源包\MR\Code\05\09）<br>设置x轴（日期）范围为1～14，y轴（基础体温）范围为35～45，主要代码如下：</p>
<p>01  plt.xlim(1,14)<br>02  plt.ylim(35,45)</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022042147156.png" alt="image-20211022042147156"></p>
<p>​                                                                                           图5.27　更改x轴刻度</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022042216153.png" alt="image-20211022042216153"></p>
<p>​                                                                                                图5.28　x轴刻度为日<br>运行程序，输出结果如图5.29所示。</p>
<h4 id="4．网格线"><a href="#4．网格线" class="headerlink" title="4．网格线"></a>4．网格线</h4><p>细节决定成败。很多时候为了图表的美观，不得不考虑细节。下面介绍图表细节之一——网格线，主要使用grid()函数，首先生成网格线，代码如下：</p>
<p>plt.grid()<br>grid()函数也有很多参数，如颜色、网格线的方向（参数axis=’x’隐藏x轴网格线，axis=’y’隐藏y轴网格线）、网格线样式和网格线宽度等。下面为图表设置网格线，主要代码如下：</p>
<p>plt.grid(color=’0.5’,linestyle=’–’,linewidth=1)<br>运行程序，输出结果如图5.30所示。</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022042305653.png" alt="image-20211022042305653"></p>
<p>​                                                                                              图5.29　坐标轴范围</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022042332316.png" alt="image-20211022042332316"></p>
<pre><code>                                                                                 图5.30　带网格线的折线图实用技巧
</code></pre>
<p>网格线对于饼形图来说，直接使用并不显示，需要与饼形图的frame参数配合使用，设置该参数值为True。详见饼形图。</p>
<h3 id="5-5-4-添加文本标签"><a href="#5-5-4-添加文本标签" class="headerlink" title="5.5.4　添加文本标签"></a>5.5.4　添加文本标签</h3><p>绘图过程中，为了能够更清晰、直观地看到数据，有时需要给图表中指定的数据点添加文本标签。下面介绍细节之二——文本标签，主要使用text()函数，语法如下：</p>
<p>matplotlib.pyplot.text(x, y, s, fontdict=None, withdash=False, **kwargs)<br>参数说明：　**</p>
<p>x：x坐标轴的值。　</p>
<p>y：y坐标轴的值。　</p>
<p>s：字符串，注释内容。　</p>
<p>ontdict：字典，可选参数，默认值为None。用于重写默认文本属性。　</p>
<p>withdash：布尔型，默认值为False，创建一个TexWithDash实例，而不是Text实例。　</p>
<p>kwargs：关键字参数。这里指通用的绘图参数，如字体大小fontsize=12、垂直对齐方式horizontalalignment=’center’（或简写为ha=’center’）、水平对齐方式verticalalignment=’center’（或简写为va=’center’）。</p>
<p>【示例10】　为折线图添加基础体温文本标签。（示例位置：资源包\MR\Code\05\10）<br>为图表中各个数据点添加文本标签，关键代码如下：</p>
<p>01  for a,b  in zip(x,y):<br>02      plt.text(a,b+3,’%.1f’%b,ha = ‘center’,va = ‘bottom’,fontsize=9)<br>运行程序，输出结果如图5.31所示。</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022042505594.png" alt="image-20211022042505594"></p>
<p>​                                                                                     图5.31　带文本标签的折线图<br>在本示例代码中，首先，x、y是x轴和y轴的值，它代表了折线图在坐标中的位置，通过for循环找到每一个x、y值相对应的坐标赋值给a、b，再使用plt.text在对应的数据点上添加文本标签，而for循环也保证了折线图中每一个数据点都有文本标签。其中，a,b+3表示每一个数据点（x值对应y值加3）的位置处添加文本标签；%.1f’%b是对y值进行的格式化处理，保留小数点1位；ha=’center’、va=’bottom’代表水平对齐、垂直对齐的方式，fontsize则是字体大小。</p>
<h3 id="5-5-5-设置标题和图例"><a href="#5-5-5-设置标题和图例" class="headerlink" title="5.5.5　设置标题和图例"></a>5.5.5　设置标题和图例</h3><p>数据是一个图表所要展示的内容，而有了标题和图例则可以帮助我们更好地理解这个图表的含义和想要传递的信息。下面介绍图表细节之三——标题和图例。</p>
<h4 id="1．图表标题"><a href="#1．图表标题" class="headerlink" title="1．图表标题"></a>1．图表标题</h4><p>为图表设置标题主要使用title()函数，语法如下：</p>
<p>matplotlib.pyplot.title(label, fontdict=None, loc=’center’, pad=None, **kwargs)<br>参数说明：　</p>
<p>label：字符串，表示图表标题文本。　</p>
<p>fontdict：字典，用来设置标题字体的样式。如{‘fontsize’: 20,’fontweight’:20,’va’: ‘bottom’,’ha’:’center’}。　</p>
<p>loc：字符串，表示标题水平位置，参数值为center、left或right，分别表示水平居中、水平居左和水平居右，默认为水平居中。　</p>
<p>pad：浮点型，表示标题离图表顶部的距离，默认值为None。</p>
<p>**kwargs：关键字参数，可以设置一些其他文本属性。<br>例如，设置图表标题为“14天基础体温曲线图”，主要代码如下：</p>
<p>plt.title(‘14天基础体温曲线图’,fontsize=’18’)</p>
<h4 id="2．图表图例"><a href="#2．图表图例" class="headerlink" title="2．图表图例"></a>2．图表图例</h4><p>为图表设置图例主要使用legend()函数。下面介绍图例相关的设置。<br>（1）自动显示图例</p>
<p>plt.legend()<br>（2）手动添加图例</p>
<p>plt.legend(‘基础体温’)注意<br>当手动添加图例时，有时会出现文本显示不全，解决方法是在文本后面加一个逗号（,），主要代码如下：</p>
<p>plt.legend((‘基础体温’,))<br>（3）设置图例显示位置<br>通过loc参数可以设置图例的显示位置，如在左下方显示，主要代码如下：</p>
<p>plt.legend((‘基础体温’,),loc=’upper right’,fontsize=10)<br>具体图例显示位置的设置如表5.3所示。</p>
<p>​                                                                                          表5.3　图例位置参数设置值</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022042646532.png" alt="image-20211022042646532"></p>
<p>上述参数可以设置大概的图例位置，如果这样可以满足需求，那么第二个参数不设置也可以。第二个参数bbox_to_anchor是元组类型，包括两个值：num1用于控制legend的左右移动，值越大越向右边移动；num2用于控制legend的上下移动，值越大，越向上移动。这两个值用于微调图例的位置。<br>另外，通过该参数还可以设置图例位于图表外面，主要代码如下：</p>
<p>plt.legend(bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0)<br>下面来看下设置标题和图例后的“14天基础体温曲线图”，效果如图5.32所示。</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022042736618.png" alt="image-20211022042736618"></p>
<p>​                                                                                   图5.32　14天基础体温曲线图</p>
<h3 id="5-5-6-添加注释"><a href="#5-5-6-添加注释" class="headerlink" title="5.5.6　添加注释"></a>5.5.6　添加注释</h3><p>annotate()函数用于在图表上给数据添加文本注释，而且支持带箭头的画线工具，方便我们在合适的位置添加描述信息。</p>
<p>【示例11】　为图表添加注释。（示例位置：资源包\MR\Code\05\11）<br>在“14天基础体温折线图”中用箭头指示最高体温，效果如图5.33所示。</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022042805728.png" alt="image-20211022042805728"></p>
<p>​                                                                                       图5.33　箭头指示最高体温<br>主要代码如下：</p>
<p>01 plt.annotate(‘最高体温’, xy=(9,37.1), xytext=(10.5,37.1),</p>
<p>02               xycoords=’data’,<br>03               arrowprops=dict(facecolor=’r’, shrink=0.05))<br>下面介绍一下本示例中用到的几个主要参数。　</p>
<p>xy：被注释的坐标点，二维元组，如(x,y)。　</p>
<p>xytext：注释文本的坐标点（也就是本示例中箭头的位置），也是二维元组，默认与xy相同。　</p>
<p>xycoords：是被注释点的坐标系属性，设置值如表5.4所示。</p>
<p>​                                                                                    表5.4　xycoords参数设置值　</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022042954410.png" alt="image-20211022042954410"></p>
<p>arrowprops：箭头的样式，dict（字典）型数据。如果该属性非空，则会在注释文本和被注释点之间画一个箭头。arrowprops参数设置值如表5.5所示。</p>
<p>​                                                                               表5.5　arrowprops参数设置值说明</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022043118148.png" alt="image-20211022043118148"></p>
<p>关于annotate()函数的内容还有很多，这里不再赘述，感兴趣的读者可以以上述举例为基础，尝试更多的属性和样式。</p>
<h3 id="5-5-7-调整图表与画布边缘间距"><a href="#5-5-7-调整图表与画布边缘间距" class="headerlink" title="5.5.7　调整图表与画布边缘间距"></a>5.5.7　调整图表与画布边缘间距</h3><p>很多时候发现绘制出的图表出现显示不全的情况，其原因在于，x轴、y轴标题与画布边缘距离太近，如图5.34所示。<br>这种情况可以使用subplots_adjust()函数来调整，该函数主要用于调整图表与画布的间距，也可以调整子图表的间距。语法如下：</p>
<p>subplots_adjust(left=None, bottom=None,right=None, top=None,wspace=None,hspace=None)<br>参数说明：　left、bottom、right和top：这4个参数是用来调整上、下、左、右的空白，如图5.35所示。注意这里是从画布的左下角开始标记，取值为0～1。left和bottom值越小，则空白越少；而right和top值越大，则空白越少。</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022043238508.png" alt="image-20211022043238508"></p>
<p>​                                                                                          图5.34　显示不全的情况</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022043308669.png" alt="image-20211022043308669"></p>
<p>​                                                                                      图5.35　调整间距示意图　</p>
<p>wspace和hspace：用于调整列间距和行间距。<br>举个简单的例子，调整图表上、下、左、右的空白，主要代码如下：</p>
<p>plt.subplots_adjust(left=0.2, right=0.9, top=0.9, bottom=0.2)<br>如果只显示图片，坐标轴及标题都不显示，可以使用如下代码：</p>
<p>plt.subplots_adjust(left=0, bottom=0, right=1, top=1,hspace=0.1,wspace=0.1)</p>
<h3 id="5-5-8-其他设置"><a href="#5-5-8-其他设置" class="headerlink" title="5.5.8　其他设置"></a>5.5.8　其他设置</h3><h4 id="1．坐标轴的刻度线"><a href="#1．坐标轴的刻度线" class="headerlink" title="1．坐标轴的刻度线"></a>1．坐标轴的刻度线</h4><p>（1）设置4个方向的坐标轴上的刻度线是否显示，主要代码如下：</p>
<p>plt.tick_params(bottom=False,left=True,right=True,top=True)<br>（2）设置x轴和y轴的刻度线显示方向，其中in表示向内，out表示向外，inout表示在中间，默认刻度线向外，主要代码如下：</p>
<p>plt.rcParams[‘xtick.direction’] = ‘in’         #x轴的刻度线向内显示<br>plt.rcParams[‘ytick.direction’] = ‘in’         #y轴的刻度线向内显示</p>
<h4 id="2．坐标轴相关属性设置"><a href="#2．坐标轴相关属性设置" class="headerlink" title="2．坐标轴相关属性设置"></a>2．坐标轴相关属性设置</h4><p>axis()：返回当前axes范围。　</p>
<p>axis(v)：通过输入v = [xmin, xmax, ymin, ymax]，设置x、y轴的取值范围。　</p>
<p>axis(‘off’)：关闭坐标轴轴线及坐标轴标签。　</p>
<p>axis(‘equal’)：使x、y轴长度一致。　</p>
<p>axis(‘scaled’)：调整图框的尺寸（而不是改变坐标轴取值范围），使x、y轴长度一致。　</p>
<p>axis(‘tight’)：改变x轴和y轴的限制，使所有数据被展示。如果所有的数据已经显示，它将移动到图形的中心而不修改（xmax～xmin）或（ymax～ymin）。　</p>
<p>axis(‘image’)：缩放axis范围（limits），等同于对data缩放范围。　</p>
<p>axis(‘auto’)：自动缩放。　</p>
<p>axis(‘normal’)：不推荐使用。恢复默认状态，轴限的自动缩放以使数据显示在图表中。</p>
<h2 id="5-6-常用图表的绘制"><a href="#5-6-常用图表的绘制" class="headerlink" title="5.6　常用图表的绘制"></a>5.6　常用图表的绘制</h2><p>本节介绍常用图表的绘制，主要包括绘制折线图、绘制柱形图、绘制直方图、绘制饼形图、绘制散点图、绘制面积图、绘制热力图、绘制箱形图、绘3D图表、绘制多个子图表以及图表的保存。对于常用的图表类型以绘制多种类型图表进行举例，以适应不同应用场景的需求。</p>
<h3 id="5-6-1-绘制折线图"><a href="#5-6-1-绘制折线图" class="headerlink" title="5.6.1　绘制折线图"></a>5.6.1　绘制折线图</h3><p>折线图可以显示随时间而变化的连续数据，因此非常适用于显示在相等时间间隔下数据的趋势。如基础体温曲线图、学生成绩走势图、股票月成交量走势图，月销售统计分析图、微博、公众号、网站访问量统计图等都可以用折线图体现。在折线图中，类别数据沿水平轴均匀分布，所有值数据沿垂直轴均匀分布。<br>Matplotlib绘制折线图主要使用plot()函数，相信通过前面的学习，您已经了解了plot()函数的基本用法，并能够绘制一些简单的折线图，下面尝试绘制多折线图。</p>
<p>【示例12】　绘制学生语数外各科成绩分析图。（示例位置：资源包\MR\Code\05\12）<br>使用plot()函数绘制多折线图。例如，绘制学生语数外各科成绩分析图，程序代码如下：</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022043506478.png" alt="image-20211022043506478"></p>
<p>运行程序，输出结果如图5.36所示。</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022043526985.png" alt="image-20211022043526985"></p>
<p>​                                                                                               图5.36　多折线图<br>上述举例，用到了几个参数，下面进行说明。</p>
<p>mfc：标记的颜色。　</p>
<p>ms：标记的大小。　</p>
<p>mec：标记边框的颜色。　</p>
<p>alpha：透明度，设置该参数可以改变颜色的深浅。</p>
<h3 id="5-6-2-绘制柱形图"><a href="#5-6-2-绘制柱形图" class="headerlink" title="5.6.2　绘制柱形图"></a>5.6.2　绘制柱形图</h3><p>柱形图，又称长条图、柱状图、条状图等，是一种以长方形的长度为变量的统计图表。柱形图用来比较两个或两个以上的数据（不同时间或者不同条件），只有一个变量，通常用于较小的数据集分析。<br>Matplotlib绘制柱形图主要使用bar()函数，语法如下：</p>
<p>matplotlib.pyplot.bar(x,height,width,bottom=None,*,align=’center’,data=None,**kwargs)<br>参数说明：　**</p>
<p>x：x轴数据。　</p>
<p>height：柱子的高度，也就是y轴数据。　</p>
<p>width：浮点型，柱子的宽度，默认值为0.8，可以指定固定值。　</p>
<p>bottom：标量或数组，可选参数，柱形图的y坐标，默认值为None。　</p>
<p>*：星号本身不是参数。星号表示其后面的参数为命名关键字参数，命名关键字参数必须传入参数名；否则程序会出现错误。　</p>
<p>align：对齐方式，如center（居中）和edge（边缘），默认值为center。　</p>
<p>data：data关键字参数。如果给定一个数据参数，所有位置和关键字参数将被替换。　</p>
<p>kwargs：关键字参数，其他可选参数，如color（颜色）、alpha（透明度）、label（每个柱子显示的标签）等。</p>
<p>【示例13】　4行代码绘制简单的柱形图。（示例位置：资源包\MR\Code\05\13）<br>4行代码绘制简单的柱形图，程序代码如下：</p>
<p>01 import matplotlib.pyplot as plt<br>02 x=[1,2,3,4,5,6]</p>
<p>03 height=[10,20,30,40,50,60]<br>04 plt.bar(x,height)<br>运行程序，输出结果如图5.37所示。</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022043752815.png" alt="image-20211022043752815"></p>
<p>​                                                                                     图5.37　简单柱形图<br>bar()函数可以绘制出各种类型的柱形图，如基本柱形图、多柱形图、堆叠柱形图，只要将bar()函数的主要参数理解透彻，就会达到意想不到的效果。下面介绍几种常见的柱形图。</p>
<h4 id="1．基本柱形图"><a href="#1．基本柱形图" class="headerlink" title="1．基本柱形图"></a>1．基本柱形图</h4><p>【示例14】　绘制2013—2019年线上图书销售额分析图。（示例位置：资源包\MR\Code\05\14）<br>使用bar()函数绘制“2013—2019年线上图书销售额分析图”，程序代码如下：</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022043825693.png" alt="image-20211022043825693"></p>
<p>运行程序，输出结果如图5.38所示。</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022043843723.png" alt="image-20211022043843723"></p>
<p>​                                                                                                 图5.38　基本柱形图</p>
<p>本示例应用了前面所学习的知识，例如标题、图例、文本标签和坐标轴标签等。</p>
<h4 id="2．多柱形图"><a href="#2．多柱形图" class="headerlink" title="2．多柱形图"></a>2．多柱形图</h4><p>【示例15】　绘制各平台图书销售额分析图。（示例位置：资源包\MR\Code\05\15）<br>对于线上图书销售额的统计，如果要统计各个平台的销售额，可以使用多柱形图，不同颜色的柱子代表不同的平台，如京东、天猫、自营等，程序代码如下：</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022043936078.png" alt="image-20211022043936078"></p>
<p>在本示例中，柱形图中若显示n个柱子，则柱子宽度值需小于1/n；否则柱子会出现重叠现象。<br>运行程序，输出结果如图5.39所示。</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022044011167.png" alt="image-20211022044011167"></p>
<p>​                                                                                                  图5.39　多柱形图</p>
<h3 id="5-6-3-绘制直方图"><a href="#5-6-3-绘制直方图" class="headerlink" title="5.6.3　绘制直方图"></a>5.6.3　绘制直方图</h3><p>直方图，又称质量分布图，由一系列高度不等的纵向条纹或线段表示数据分布的情况。一般用横轴表示数据类型，纵轴表示分布情况。直方图是数值数据分布的精确图形表示，是一个连续变量（定量变量）的概率分布的估计。<br>绘制直方图主要使用hist()函数，语法如下：</p>
<p>matplotlib.pyplot.hist(x,bins=None,range=None, density=None, bottom=None, histtype=’bar’, align=’mid’, log=<br>False, color=None, label=None, stacked=False, normed=None)<br>参数说明：　</p>
<p>x：数据集，最终的直方图将对数据集进行统计。　</p>
<p>bins：统计数据的区间分布。　</p>
<p>range：元组类型，显示的区间。　</p>
<p>density：布尔型，显示频率统计结果，默认值为None。设置值为False，不显示频率统计结果；设置值为True，则显示频率统计结果。需要注意，频率统计结果=区间数目/(总数×区间宽度)。　</p>
<p>histtype：可选参数，设置值为bar、barstacked、step或stepfilled，默认值为bar，推荐使用默认配置，其中step使用的是梯状，stepfilled则会对梯状内部进行填充，效果与bar类似。　</p>
<p>align：可选参数，控制柱状图的水平分布，设置值为left、mid或right，默认值为mid，其中，left或者right会有部分空白区域，推荐使用默认值。　</p>
<p>log：布尔型，默认值为False，即y坐标轴是否选择指数刻度。</p>
<p>stacked：布尔型，默认值为False，是否为堆积柱状图。</p>
<p>【示例16】　绘制简单直方图。（示例位置：资源包\MR\Code\05\16）<br>绘制简单直方图，程序代码如下：</p>
<p>01 import matplotlib.pyplot as plt<br>02 x=[22,87,5,43,56,73,55,54,11,20,51,5,79,31,27]<br>03 plt.hist(x, bins = [0,25,50,75,100])<br>运行程序，输出结果如图5.40所示。</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022044122751.png" alt="image-20211022044122751"></p>
<p>​                                                                                          图5.40　简单直方图</p>
<p>【示例17】　直方图分析学生数学成绩分布情况。（示例位置：资源包\MR\Code\05\17）<br>再举一个例子，通过直方图分析学生数学成绩分布情况，程序代码如下：</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022044146025.png" alt="image-20211022044146025"></p>
<p>运行程序，输出结果如图5.41所示。</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022044204373.png" alt="image-20211022044204373"></p>
<pre><code>                                                                            图5.41　数学成绩分布直方图
</code></pre>
<p>上述举例，通过直方图可以清晰地看到高一数学成绩分布情况。基本呈现正态分布，两边低中间高，高分段学生缺失，说明试卷有难度。那么，通过直方图还可以分析以下内容。<br>（1）对学生进行比较。呈正态分布的测验便于选拔优秀，甄别落后，通过直方图一目了然。<br>（2）确定人数和分数线。测验成绩符合正态分布可以帮助等级评定时确定人数和估计分数段内的人数，确定录取分数线、各学科的优生率等。<br>（3）测验试题难度。</p>
<h3 id="5-6-4-绘制饼形图"><a href="#5-6-4-绘制饼形图" class="headerlink" title="5.6.4　绘制饼形图"></a>5.6.4　绘制饼形图</h3><p>饼形图常用来显示各个部分在整体中所占的比例。例如，在工作中如果遇到需要计算总费用或金额的各个部分构成比例的情况，一般通过各个部分与总额相除来计算，而且这种比例表示方法很抽象，而通过饼形图将直接显示各个组成部分所占比例，一目了然。<br>Matplotlib绘制饼形图主要使用pie()函数，语法如下：</p>
<p>matplotlib.pyplot.pie(x,explode=None,labels=None,colors=None,autopct=None,pctdistance=0.6,shadow=False,<br>labeldistance=1.1,startangle=None,radius=None,counterclock=True,wedgeprops=None,textprops=None,center=<br>(0, 0), frame=False, rotatelabels=False, hold=None, data=None)<br>参数说明：　</p>
<p>x：每一块饼图的比例，如果sum(x)&gt;1会使用sum(x)归一化。　</p>
<p>explode：每一块饼图离中心的距离。　</p>
<p>labels：每一块饼图外侧显示的说明文字。　</p>
<p>autopct：设置饼图百分比，可以使用格式化字符串或format()函数。如’%1.1f ‘保留小数点前后1位。　</p>
<p>pctdistance：类似于labeldistance参数，指定百分比的位置刻度，默认值为0.6。　</p>
<p>shadow：在饼图下面画一个阴影，默认值为False，即不画阴影。　</p>
<p>labeldistance：标记的绘制位置，相对于半径的比例，默认值为1.1，如&lt;1则绘制在饼图内侧。　</p>
<p>startangle：起始绘制角度，默认是从x轴正方向逆时针画起，如设置值为90则从y轴正方向画起。　</p>
<p>radius：饼图半径，默认值为1。　</p>
<p>counterclock：指定指针方向，布尔型，可选参数。默认值为True，表示逆时针；如果值为False，则表示顺时针。　</p>
<p>wedgeprops：字典类型，可选参数，默认值为None。字典传递给wedge对象，用来画一个饼图。例如wedgeprops={‘linewidth’:2}设置wedge线宽为2。　</p>
<p>textprops：设置标签和比例文字的格式，字典类型，可选参数，默认值为None。传递给text对象的字典参数。　</p>
<p>center：浮点类型的列表，可选参数，默认值为(0,0)，表示图表中心位置。　</p>
<p>frame：布尔型，可选参数，默认值为False，不显示轴框架（也就是网格）；如果值为True，则显示轴框架，与grid()函数配合使用。实际应用中建议使用默认设置，因为显示轴框架会干扰饼形图效果。　</p>
<p>rotatelabels：布尔型，可选参数，默认值为False；如果值为True，则旋转每个标签到指定的角度。</p>
<p>【示例18】　绘制简单饼形图。（示例位置：资源包\MR\Code\05\18）<br>绘制简单饼形图，程序代码如下：</p>
<p>01 import matplotlib.pyplot as plt<br>02 x = [2,5,12,70,2,9]<br>03 plt.pie(x,autopct=’%1.1f%%’)<br>运行程序，输出结果如图5.42所示。<br>饼形图也存在各种类型，主要包括基础饼形图、分裂饼形图、立体感带阴影的饼形图、环形图等。下面分别进行介绍。</p>
<h4 id="1．基础饼形图"><a href="#1．基础饼形图" class="headerlink" title="1．基础饼形图"></a>1．基础饼形图</h4><p>【示例19】　通过饼形图分析各地区销量占比情况。（示例位置：资源包\MR\Code\05\19）<br>下面通过饼形图分析2020年1月各地区销量占比情况，程序代码如下：</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022044422975.png" alt="image-20211022044422975"></p>
<p>运行程序，输出结果如图5.43所示。</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022044438588.png" alt="image-20211022044438588"></p>
<p>​                                                                                              图5.42　简单饼形图</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022044506316.png" alt="image-20211022044506316"></p>
<p>​                                                                                                图5.43　基础饼形图</p>
<h4 id="2．分裂饼形图"><a href="#2．分裂饼形图" class="headerlink" title="2．分裂饼形图"></a>2．分裂饼形图</h4><p>分裂饼形图是将您认为主要的饼图部分分裂出来，以达到突出显示的目的。</p>
<p>【示例20】　绘制分裂饼形图。（示例位置：资源包\MR\Code\05\20）<br>将销量占比最多的广东省分裂显示，效果如图5.44（a）所示。分裂饼形图可以同时分裂多块，效果如图5.44（b）所示。</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022044615077.png" alt="image-20211022044615077"></p>
<p>​                                                                                               图5.44　分裂饼形图<br>分裂饼形图主要通过设置explode参数实现，该参数用于设置饼图距中心的距离，我们需要将哪块饼图分裂出来，就设置它与中心的距离即可。例如，图5.43中有10块饼图，我们将占比最多的“广东省”分裂出来，如图5.44（a）所示。广东省在第一位，那么就设置第一位距中心的距离为0.1，其他为0，关键代码如下：</p>
<p>explode = (0.1,0,0,0,0,0,0,0,0,0)</p>
<h4 id="3．立体感带阴影的饼形图"><a href="#3．立体感带阴影的饼形图" class="headerlink" title="3．立体感带阴影的饼形图"></a>3．立体感带阴影的饼形图</h4><p>立体感带阴影的饼形图看起来更美观，效果如图5.45所示。<br>立体感带阴影的饼形图主要通过shadow参数实现，设置该参数值为True即可，主要代码如下：</p>
<p>shadow=True</p>
<h4 id="4．环形图"><a href="#4．环形图" class="headerlink" title="4．环形图"></a>4．环形图</h4><p>【示例21】　环形图分析各地区销量占比情况。（示例位置：资源包\MR\Code\05\21）<br>环形图是由两个及两个以上大小不一的饼图叠在一起，挖去中间的部分所构成的图形，效果如图5.46所示。</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022044639552.png" alt="image-20211022044639552"></p>
<p>​                                                                                图5.45　立体感带阴影的饼形图</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022044721819.png" alt="image-20211022044721819"></p>
<p>​                                                                                                              图5.46　环形图<br>这里还是通过pie()函数实现，一个关键参数wedgeprops，字典类型，用于设置饼形图内、外边界的属性，如环的宽度，环边界颜色和宽度，主要代码如下：</p>
<p>wedgeprops = {‘width’: 0.4, ‘edgecolor’: ‘k’}</p>
<h4 id="5．内嵌环形图"><a href="#5．内嵌环形图" class="headerlink" title="5．内嵌环形图"></a>5．内嵌环形图</h4><p>【示例22】　内嵌环形图分析各地区销量占比情况。（示例位置：资源包\MR\Code\05\22）<br>内嵌环形图实际是双环形图，效果如图5.47所示。</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022044800617.png" alt="image-20211022044800617"></p>
<p>​                                                                                             图5.47　内嵌环形图<br>绘制内嵌环形图需要注意以下3点。<br>（1）连续使用两次pie()函数。<br>（2）通过wedgeprops参数设置环形边界。<br>（3）通过radius参数设置不同的半径。<br>另外，由于图例内容比较长，为了使图例能够正常显示，图例代码中引入了两个主要参数，即frameon和bbox_to_anchor。其中，frameon参数设置图例有无边框；bbox_to_anchor参数设置图例位置，主要代码如下：</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022044933255.png" alt="image-20211022044933255"></p>
<h3 id="5-6-5-绘制散点图"><a href="#5-6-5-绘制散点图" class="headerlink" title="5.6.5　绘制散点图"></a>5.6.5　绘制散点图</h3><p>散点图主要用来查看数据的分布情况或相关性，一般用在线性回归分析中，查看数据点在坐标系平面上的分布情况。散点图表示因变量随自变量而变化的大致趋势，据此可以选择合适的函数对数据点进行拟合。<br>散点图与折线图类似，也是一个个点构成的。但不同之处在于，散点图的各点之间不会按照前后关系以线条连接起来。<br>Matplotlib绘制散点图使用plot()函数和scatter()函数都可以实现，本节使用scatter()函数绘制散点图，scatter()函数专门用于绘制散点图，使用方式和plot()函数类似，区别在于前者具有更高的灵活性，可以单独控制每个散点与数据匹配，并让每个散点具有不同的属性。scatter()函数的语法如下：</p>
<p>matplotlib.pyplot.scatter(x,y,s=None,c=None,marker=None,cmap=None,norm=None,vmin=None,vmax=None,<br>alpha=None,linewidths=None,verts=None,edgecolors=None,data=None, **kwargs)<br>参数说明：　</p>
<p>x，y：数据。　</p>
<p>​        s：标记大小，以平方磅为单位的标记面积，设置值如下。　</p>
<p>​        数值标量：以相同的大小绘制所有标记。　</p>
<p>​        行或列向量：使每个标记具有不同的大小。x、y和sz中的相应元素确定每个标记的位置和面积。sz的长度必须等于x和y的长度。　</p>
<p>​        []：使用36平方磅的默认面积。　</p>
<p>c：标记颜色，可选参数，默认标记颜色为蓝色。　</p>
<p>marker：标记样式，可选参数，默认值为’o’。　</p>
<p>cmap：颜色地图，可选参数，默认值为None。　</p>
<p>norm：可选参数，默认值为None</p>
<p>vmin，vmax：标量，可选，默认值为None　alpha：透明度，可选参数，0～1的数，表示透明度，默认值为None。　</p>
<p>linewidths：线宽，标记边缘的宽度，可选参数，默认值为None。　</p>
<p>verts：(x,y)的序列，可选参数，如果参数marker为None，这些顶点将用于构建标记。标记的中心位置为(0,0)。　</p>
<p>edgecolors：轮廓颜色，与参数c类似，可选参数，默认值为None。　</p>
<p>data：data关键字参数。如果给定一个数据参数，所有位置和关键字参数将被替换。　</p>
<p>**kwargs：关键字参数，其他可选参数。</p>
<p>【示例23】　绘制简单散点图。（示例位置：资源包\MR\Code\05\23）<br>绘制简单散点图，程序代码如下：</p>
<p>01 import matplotlib.pyplot as plt<br>02 x=[1,2,3,4,5,6]<br>03 y=[19,24,37,43,55,68]<br>04 plt.scatter(x, y)<br>运行程序，输出结果如图5.48所示。</p>
<p>【示例24】　散点图分析销售收入与广告费的相关性。（示例位置：资源包\MR\Code\05\24）<br>接下来，绘制销售收入与广告费散点图，用以观察销售收入与广告费的相关性，主要代码如下：</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022045035911.png" alt="image-20211022045035911"></p>
<p>运行程序，输出结果如图5.49所示</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022045051433.png" alt="image-20211022045051433"></p>
<p>​                                                                                          图5.48　简单散点图</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022045135206.png" alt="image-20211022045135206"></p>
<p>​                                                                              图5.49　销售收入与广告费散点图</p>
<h3 id="5-6-6-绘制面积图"><a href="#5-6-6-绘制面积图" class="headerlink" title="5.6.6　绘制面积图"></a>5.6.6　绘制面积图</h3><p>面积图用于体现数量随时间而变化的程度，也可用于引起人们对总值趋势的注意。例如，表示随时间而变化的利润的数据可以绘制在面积图中，以强调总利润。<br>Matplotlib绘制面积图主要使用stackplot()函数，语法如下：</p>
<p>matplotlib.pyplot.stackplot(x,*args,data=None,**kwargs)<br>参数说明：　**</p>
<p>x：x轴数据。　</p>
<p><em>args：当传入的参数个数未知时使用</em>args。这里指y轴数据可以传入多个y轴。　</p>
<p>data：data关键字参数。如果给定一个数据参数，所有位置和关键字参数将被替换。　</p>
<p>kwargs：关键字参数，其他可选参数，如color（颜色）、alpha（透明度）等。</p>
<p>【示例25】　绘制简单面积图。（示例位置：资源包\MR\Code\05\25）<br>绘制简单面积图，程序代码如下：</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022045229225.png" alt="image-20211022045229225"></p>
<p>运行程序，输出结果如图5.50所示。<br>面积图也有很多种，如标准面积图、堆叠面积图和百分比堆叠面积图等。下面主要介绍标准面积图和堆叠面积图。</p>
<h4 id="1．标准面积图"><a href="#1．标准面积图" class="headerlink" title="1．标准面积图"></a>1．标准面积图</h4><p>【示例26】　面积图分析线上图书销售情况。（示例位置：资源包\MR\Code\05\26）<br>通过标准面积图分析2013—2019年线上图书销售情况，通过该图可以看出每一年线上图书销售的一个趋势，效果如图5.51所示。</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022045332684.png" alt="image-20211022045332684"></p>
<p>​                                                                                          图5.50　简单面积图</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022045356189.png" alt="image-20211022045356189"></p>
<p>​                                                                                           图5.51　标准面积图<br>程序代码如下：</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022045417324.png" alt="image-20211022045417324"></p>
<h4 id="2．堆叠面积图"><a href="#2．堆叠面积图" class="headerlink" title="2．堆叠面积图"></a>2．堆叠面积图</h4><p>【示例27】　堆叠面积图分析各平台图书销售情况。（示例位置：资源包\MR\Code\05\27）<br>通过堆叠面积图分析2013—2019年线上各平台图书销售情况。堆叠面积图不仅可以看到各平台每年销售变化趋势，通过将各平台数据堆叠到一起还可以看到整体的变化趋势，效果如图5.52所示。<br>实现堆叠面积图的关键在于增加y轴，通过增加多个y轴数据，形成堆叠面积图，主要代码如下：</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022045506121.png" alt="image-20211022045506121"></p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022045521071.png" alt="image-20211022045521071"></p>
<p>​                                                                                                  图5.52　堆叠面积图</p>
<h3 id="5-6-7-绘制热力图"><a href="#5-6-7-绘制热力图" class="headerlink" title="5.6.7　绘制热力图"></a>5.6.7　绘制热力图</h3><p>热力图是通过密度函数进行可视化用于表示地图中点的密度的热图。它使人们能够独立于缩放因子感知点的密度。热力图可以显示不可点击区域发生的事情。利用热力图可以看数据表里多个特征两两的相似度。例如，以特殊高亮的形式显示访客热衷的页面区域和访客所在的地理区域的图示。热力图在网页分析、业务数据分析等其他领域也有较为广泛的应用。</p>
<p>【示例28】　绘制简单热力图。（示例位置：资源包\MR\Code\05\28）<br>热力图是数据分析的常用方法，通过色差、亮度来展示数据的差异，易于理解。下面绘制简单热力图，程序代码如下：</p>
<p>01 import matplotlib.pyplot as plt<br>02 X = [[1,2],[3,4],[5,6],[7,8],[9,10]]<br>03 plt.imshow(X)<br>运行程序，输出结果如图5.53所示。</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022045548445.png" alt="image-20211022045548445"></p>
<p>​                                                                                              图5.53　简单热力图</p>
<p>上述代码中，plt.imshow(X)中传入的数组X=[[1,2],[3,4],[5,6],[7,8],[9,10]]为颜色的对应值，按照矩阵X进行颜色分布，如左上角颜色为深蓝，其对应值为1，右下角颜色为黄色，其对应值为10，具体如下：</p>
<p>[1,2]  [深蓝,蓝色]<br>[3,4]  [蓝绿,深绿]<br>[5,6]  [海藻绿,春绿色]<br>[7,8]  [绿色,浅绿色]<br>[9,10] [草绿色,黄色]</p>
<p>【示例29】　热力图对比分析学生各科成绩。（示例位置：资源包\MR\Code\05\29）<br>根据学生成绩统计数据绘制热力图，通过热力图可清晰直观地对比每名学生各科成绩的高低。程序代码如下：</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022045644366.png" alt="image-20211022045644366"></p>
<p>运行程序，输出结果如图5.54所示。</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022045702905.png" alt="image-20211022045702905"></p>
<p>​                                                                                        图5.54　学生成绩统计热力图<br>从图5.54中可以看到，颜色以高亮显示的，成绩越高；反之，成绩越低。</p>
<h3 id="5-6-8-绘制箱形图"><a href="#5-6-8-绘制箱形图" class="headerlink" title="5.6.8　绘制箱形图"></a>5.6.8　绘制箱形图</h3><p>箱形图又称箱线图、盒须图或盒式图，它是一种用作显示一组数据分散情况下的资料的统计图。因形状像箱子而得名。箱形图最大的优点就是不受异常值的影响（异常值也称为离群值），可以以一种相对稳定的方式描述数据的离散分布情况，因此在各种领域也经常被使用。另外，箱形图也常用于异常值的识别。Matplotlib绘制箱形图主要使用boxplot()函数，语法如下：</p>
<p>matplotlib.pyplot.boxplot(x,notch=None,sym=None,vert=None,whis=None,positions=None,widths=None,patch_<br>artist=None,meanline=None,showmeans=None,showcaps=None,showbox=None,showfliers=None,boxprops=None,<br>labels=None,flierprops=None,medianprops=None,meanprops=None,capprops=None,whiskerprops=None)<br>参数说明：　</p>
<p>x：指定要绘制箱形图的数据。　</p>
<p>notch：是否以凹口的形式展现箱形图，默认非凹口。　</p>
<p>sym：指定异常点的形状，默认为加号（+）显示。　</p>
<p>vert：是否需要将箱形图垂直摆放，默认垂直摆放。　</p>
<p>whis：指定上下限与上下四分位的距离，默认为1.5倍的四分位差。　</p>
<p>positions：指定箱形图的位置，默认为[0,1,2,…]。　</p>
<p>widths：指定箱形图的宽度，默认为0.5。　</p>
<p>patch_artist：是否填充箱体的颜色。　</p>
<p>meanline：是否用线的形式表示均值，默认用点来表示。　</p>
<p>showmeans：是否显示均值，默认不显示。　</p>
<p>showcaps：是否显示箱形图顶端和末端的两条线，默认显示。　</p>
<p>showbox：是否显示箱形图的箱体，默认显示。　</p>
<p>showfliers：是否显示异常值，默认显示。　</p>
<p>boxprops：设置箱体的属性，如边框色、填充色等。　</p>
<p>labels：为箱形图添加标签，类似于图例的作用。　</p>
<p>filerprops：设置异常值的属性，如异常点的形状、大小、填充色等。　</p>
<p>medianprops：设置中位数的属性，如线的类型、粗细等。　meanprops：设置均值的属性，如点的大小、颜色等。</p>
<p>capprops：设置箱形图顶端和末端线条的属性，如颜色、粗细等。　</p>
<p>whiskerprops：设置须的属性，如颜色、粗细、线的类型等。</p>
<p>【示例30】　绘制简单箱形图。（示例位置：资源包\MR\Code\05\30）<br>绘制简单箱形图，程序代码如下：</p>
<p>01  import matplotlib.pyplot as plt<br>02  x=[1,2,3,5,7,9]<br>03  plt.boxplot(x)<br>运行程序，输出结果如图5.55所示。</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022045845005.png" alt="image-20211022045845005"></p>
<p>​                                                                                              图5.55　简单箱形图</p>
<p>【示例31】　绘制多组数据的箱形图。（示例位置：资源包\MR\Code\05\31）<br>上述举例是一组数据的箱形图，还可以绘制多组数据的箱形图，需要指定多组数据。例如，为三组数据绘制箱形图，程序代码如下：</p>
<p>01 import matplotlib.pyplot as plt<br>02 x1=[1,2,3,5,7,9]<br>03 x2=[10,22,13,15,8,19]<br>04 x3=[18,31,18,19,14,29]<br>05 plt.boxplot([x1,x2,x3])<br>运行程序，输出结果如图5.56所示。</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022045922170.png" alt="image-20211022045922170"></p>
<p>​                                                                                       图5.56　多组数据的箱形图<br>箱形图将数据切割分离（实际上就是将数据分为4大部分），如图5.57所示。</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022050015245.png" alt="image-20211022050015245"></p>
<p>​                                                                               图5.57　箱形图组成<br>下面介绍箱形图每部分具体含义以及如何通过箱形图识别异常值。　</p>
<p>下四分位<br>        图5.57中的下四分位数指的是数据的25%分位点所对应的值（Q1）。计算分位数可以使用Pandas的quantile()函数。例如，Q1 = df[‘总消费’].quantile(q = 0.25)。　</p>
<p>中位数<br>        中位数即为数据的50%分位点所对应的值（Q2）。　</p>
<p>上四分位数<br>        上四分位数则为数据的75%分位点所对应的值（Q3）。　</p>
<p>上限<br>        上限的计算公式为Q3+1.5(Q3-Q1)。　</p>
<p>下限<br>        下限的计算公式为Q1-1.5(Q3-Q1)。其中，Q3-Q1表示四分位差。如果使用箱形图识别异常值，其判断标准是，当变量的数据值大于箱形图的上限或者小于箱线图的下限时，就可以将这样的数据判定为异常值。<br>下面了解一下判断异常值的算法，如图5.58所示。</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022050132143.png" alt="image-20211022050132143"></p>
<p>​                                                                                      图5.58　异常值判断标准</p>
<p>【示例32】　通过箱形图判断异常值。（示例位置：资源包\MR\Code\05\32）<br>通过箱形图查找客人总消费数据中存在的异常值，程序代码如下：</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022050217773.png" alt="image-20211022050217773"></p>
<p>运行程序，输出结果如图5.59和图5.60所示。</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022050241397.png" alt="image-20211022050241397"></p>
<p>​                                                                                                      图5.59　箱形图</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022050303942.png" alt="image-20211022050303942"></p>
<p>​                                                                                          图5.60　异常值</p>
<h3 id="5-6-9-绘制3D图表"><a href="#5-6-9-绘制3D图表" class="headerlink" title="5.6.9　绘制3D图表"></a>5.6.9　绘制3D图表</h3><p>3D图表有立体感也比较美观，看起来更加“高大上”。下面介绍两种3D图表，即三维柱形图和三维曲面图。</p>
<p>绘制3D图表，我们仍使用Matplotlib，但需要安装mpl_toolkits工具包，使用pip安装命令，语法如下：</p>
<p>pip install –upgrade matplotlib<br>安装好这个模块后，即可调用mpl_tookits下的mplot3d类进行3D图表的绘制。</p>
<h4 id="1．3D柱形图"><a href="#1．3D柱形图" class="headerlink" title="1．3D柱形图"></a>1．3D柱形图</h4><p>【示例33】　绘制3D柱形图。（示例位置：资源包\MR\Code\05\33）<br>绘制3D柱形图，程序代码如下：</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022050416166.png" alt="image-20211022050416166"></p>
<p>运行程序，输出结果如图5.61所示。</p>
<h4 id="2．3D曲面图"><a href="#2．3D曲面图" class="headerlink" title="2．3D曲面图"></a>2．3D曲面图</h4><p>【示例34】　绘制3D曲面图。（示例位置：资源包\MR\Code\05\34）<br>绘制3D曲面图，程序代码如下：</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022050435386.png" alt="image-20211022050435386"></p>
<p>运行程序，输出结果如图5.62所示。</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022050517722.png" alt="image-20211022050517722"></p>
<p>​                                                                                                图5.61　3D柱形图</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022050540268.png" alt="image-20211022050540268"></p>
<p>​                                                                                                图5.62　3D曲面图</p>
<h3 id="5-6-10-绘制多个子图表"><a href="#5-6-10-绘制多个子图表" class="headerlink" title="5.6.10　绘制多个子图表"></a>5.6.10　绘制多个子图表</h3><p>Matplotlib可以实现在一张图上绘制多个子图表。Matplotlib提供了3种方法：一是subplot()函数；二是subplots()函数；三是add_subplot()函数，下面分别介绍。</p>
<h4 id="1．subplot-函数"><a href="#1．subplot-函数" class="headerlink" title="1．subplot()函数"></a>1．subplot()函数</h4><p>subplot()函数直接指定划分方式和位置，它可以将一个绘图区域划分为n个子图，每个subplot()函数只能绘制一个子图。语法如下：</p>
<p>matplotlib.pyplot.subplot(*args,**kwargs)<br>参数说明：　**</p>
<p><em>args：当传入的参数个数未知时使用</em>args。　</p>
<p>kwargs：关键字参数，其他可选参数。<br>例如，绘制一个2×3的区域，subplot(2,3,3)，将画布分成2行3列在第3个区域中绘制，用坐标表示如下：</p>
<p>(1,1),(1,2),(1,3)</p>
<p>(2,1),(2,2),(2,3)<br>如果行列的值都小于10，那么可以把它们缩写为一个整数，如subplot(233)。<br>另外，subplot()函数在指定的区域中创建一个轴对象，如果新创建的轴和之前所创建的轴重叠，那么，之前的轴将被删除。</p>
<p>【示例35】　使用subplot()函数绘制多个子图的空图表。（示例位置：资源包\MR\Code\05\35）<br>绘制一个2×3包含6个子图的空图表，程序代码如下：</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022050641579.png" alt="image-20211022050641579"></p>
<p>运行程序，输出结果如图5.63所示。</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022050704636.png" alt="image-20211022050704636"></p>
<p>​                                                                                        图5.63　6个子图的空图表</p>
<p>【示例36】　绘制包含多个子图的图表。（示例位置：资源包\MR\Code\05\36）<br>通过上述举例了解了subplot()函数的基本用法，接下来将前面所学的简单图表整合到一张图表上，结果如图5.64所示。</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022050726379.png" alt="image-20211022050726379"></p>
<p>​                                                                                                图5.64　多个子图<br>程序代码如下：</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022050819496.png" alt="image-20211022050819496"></p>
<p>上述举例，以下两个关键点一定要掌握。<br>（1）每绘制一个子图表都要调用一次subplot()函数。<br>（2）绘图区域位置编号。<br>subplot()函数的前面两个参数指定的是一个画布被分割成的行数和列数，后面一个参数则指的是当前绘制区域位置编号，编号规则是行优先。<br>例如，图5.64中有3个子图表，第1个子图表subplot(2,2,1)，即将画布分成2行2列，在第1个子图中绘制折线图；第2个子图表subplot(2,2,2)，将画布分成2行2列，在第2个子图中绘制散点图；第3个子图表subplot(2,1,2)，将画布分成2行1列，由于第1行已经占用了，所以在第2行也就是第3个子图中绘制柱形图。示意图如图5.65所示。</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022050957651.png" alt="image-20211022050957651"></p>
<p>​                                                                                               图5.65　多个子图示意图<br>subplot()函数在画布中绘图时，每次都要调用它指定绘图区域非常麻烦，而subplots()函数则更直接，它会事先把画布区域分割好。下面介绍subplots()函数。</p>
<h4 id="2．subplots-函数"><a href="#2．subplots-函数" class="headerlink" title="2．subplots()函数"></a>2．subplots()函数</h4><p>subplots()函数用于创建画布和子图，语法如下：</p>
<p>matplotlib.pyplot.subplots(nrows,ncols,sharex,sharey,squeeze,subplot_kw,gridspec_kw,**fig_kw)<br>参数说明：　</p>
<p>nrows和ncols：表示将画布分割成几行几列，例如，nrows=2、ncols=2表示将画布分割为2行2列，起始值均为0。当调用画布中的坐标轴时，ax[0,0]表示调用左上角的坐标，ax[1,1]表示调用右下角的坐标。　</p>
<p>sharex和sharey：布尔值或者值为“none”“all”“row”“col”，默认值为False。用于控制x或y轴之间的属性共享。具体参数值说明如下。　    </p>
<p>​        True或者“all”：表示x或y轴属性在所有子图中共享。　</p>
<p>​        False或者“none”：表示每个子图的x或y轴都是独立的部分。　</p>
<p>​        “row”：表示每个子图在一个x或y轴上共享行（row）。　</p>
<p>​        “col”：表示每个子图在一个x或y轴上共享列（column）　</p>
<p>squeeze：布尔值，默认值为True，额外的维度从返回的axes（轴）对象中挤出，对于n×1或1×n个子图，返回一个一维数组，对于n×m，n&gt;1和m&gt;1返回一个二维数组；如果值为False，则表示不进行挤压操作，返回一个元素为Axes实例的二维数组，即使它最终是1×1。　</p>
<p>subplot_kw：字典类型，可选参数。把字典的关键字传递给add_subplot()函数来创建每个子图。　</p>
<p>gridspec_kw：字典类型，可选参数。把字典的关键字传递给GridSpec()构造函数创建网格区域，然后将子图放在网格（grid）里。　**fig_kw：把所有详细的关键字参数传递给figure。</p>
<p>【示例37】　使用subplots()函数绘制多子图的空图表。（示例位置：资源包\MR\Code\05\37）<br>绘制一个2×3包含6个子图的空图表，使用subplots()函数只需3行代码。</p>
<p>01 import matplotlib.pyplot as plt<br>02 figure,axes=plt.subplots(2,3)<br>03 plt.show()<br>上述代码中，figure和axes是两个关键点。　</p>
<p>figure：绘制图表的画布。　</p>
<p>axes：坐标轴对象，可以理解为在figure（画布）上绘制坐标轴对象，它帮我们规划出了一个个科学作图的坐标轴系统。<br>通过图5.66中的示意图可以明白，外面的是画布（figure），里面带坐标轴的是坐标轴对象（axes）。</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022051256063.png" alt="image-20211022051256063"></p>
<p>​                                                                                                 图5.66　坐标系统示意图</p>
<p>【示例38】　使用subplots()函数绘制多子图图表。（示例位置：资源包\MR\Code\05\38）<br>使用subplots()函数将前面所学的简单图表整合到一张图表上，结果如图5.67所示。<br>程序代码如下：</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022051345468.png" alt="image-20211022051345468"></p>
<p>​    <img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022051430897.png" alt="image-20211022051430897">                                                                                                    </p>
<p>​                                                                                                  图5.67　多子图图表</p>
<h4 id="3．add-subplot-函数"><a href="#3．add-subplot-函数" class="headerlink" title="3．add_subplot()函数"></a>3．add_subplot()函数</h4><p>【示例39】　使用add_subplot()函数绘制多子图图表。（示例位置：资源包\MR\Code\05\39）<br>add_subplot()函数也可以实现在一张图上绘制多个子图表，用法与subplot()函数基本相同，先来看下列一段代码：</p>
<p>01 import matplotlib.pyplot as plt<br>02 fig = plt.figure()</p>
<p>03 ax1 = fig.add_subplot(2,3,1)<br>04 ax2 = fig.add_subplot(2,3,2)<br>05 ax3 = fig.add_subplot(2,3,3)<br>06 ax4 = fig.add_subplot(2,3,4)<br>07 ax5 = fig.add_subplot(2,3,5)<br>08 ax6 = fig.add_subplot(2,3,6)<br>上述代码同样是绘制一个2×3包含6个子图的空图表。首先创建figure实例（画布），然后通过ax1 =fig.add_subplot(2,3,1)创建第1个子图表，返回Axes实例（坐标轴对象），第1个参数为行数，第2个参数为列数，第3个参数为子图表的位置。<br>以上用3种方法实现了在一张图上绘制多个子图表，3种方法各有所长。subplot()函数和add_subplot()函数比较灵活，定制化效果比较好，可以实现子图表在图中的各种布局（如一张图上可以随意摆放3个或5个图表）；而subplots()函数较为不灵活，但它可以用较少的代码实现绘制多个子图表。</p>
<h3 id="5-6-11-图表的保存"><a href="#5-6-11-图表的保存" class="headerlink" title="5.6.11　图表的保存"></a>5.6.11　图表的保存</h3><p>实际工作中，有时需要将绘制的图表保存为图片放置到报告中。Matplotlib的savefig()函数可以实现这一功能，将图表保存为JPEG、TIFF或PNG格式的图片。<br>例如，保存之前绘制的折线图，主要代码如下：</p>
<p>plt.savefig(‘image.png’)<br>需要注意的一个关键问题：保存代码必须在图表预览前，也就是plt.show()代码前；否则保存后的图片是白色，图表无法保存。<br>运行程序，图表被保存在程序所在路径下，名为image.png，如图5.68所示。</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022051548738.png" alt="image-20211022051548738"></p>
<p>​                                                                                             图5.68　保存后的图表</p>
<h2 id="5-7-综合应用"><a href="#5-7-综合应用" class="headerlink" title="5.7　综合应用"></a>5.7　综合应用</h2><h3 id="5-7-1-案例1：双y轴可视化数据分析图表的实现"><a href="#5-7-1-案例1：双y轴可视化数据分析图表的实现" class="headerlink" title="5.7.1　案例1：双y轴可视化数据分析图表的实现"></a>5.7.1　案例1：双y轴可视化数据分析图表的实现</h3><p>案例位置：资源包\MR\Code\05\example\01<br>双y轴顾名思义就是两个y轴，其特点是通过双y轴可以看出发展情况的同时还可以看到其增长速度。对于产品而言，通过此图可以看到产品销量的同时还可以看到产品增长率，效果如图5.69所示。</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022051701232.png" alt="image-20211022051701232"></p>
<p>​                                                                           图5.69　双y轴可视化数据分析图表<br>双y轴可视化数据分析图表的实现主要使用add_suplot()函数和twinx()函数。twinx()函数表示共享x轴，那么也就是一个x轴、两个y轴，程序代码如下：</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022051736548.png" alt="image-20211022051736548"></p>
<h3 id="5-7-2-案例2：颜色渐变饼形图的实现"><a href="#5-7-2-案例2：颜色渐变饼形图的实现" class="headerlink" title="5.7.2　案例2：颜色渐变饼形图的实现"></a>5.7.2　案例2：颜色渐变饼形图的实现</h3><p>案例位置：资源包\MR\Code\05\example\03<br>在绘制图表的过程中，每一次都苦于颜色设置问题，数据较多的情况下，不知道该如何配色，手动配色费时费力。下面绘制渐变颜色的饼形图，根据所占比例自动配置渐变色，占比越大颜色越深，占比越小颜色越浅，省去了手动配色的麻烦，而且占比情况一目了然，效果如图5.70所示。</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022051826217.png" alt="image-20211022051826217"></p>
<p>​                                                                                           图5.70　渐变色饼形图<br>颜色渐变主要使用了Matplotlib内置颜色地图模块cm，在该模块中指定一组数据可以生成多种颜色，由浅入深。例如，渐变蓝色，cmap=plt.cm.Blues。<br>下面来绘制颜色渐变的饼形图，程序代码如下：</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022051859149.png" alt="image-20211022051859149"></p>
<h3 id="5-7-3-案例3：等高线图的实现"><a href="#5-7-3-案例3：等高线图的实现" class="headerlink" title="5.7.3　案例3：等高线图的实现"></a>5.7.3　案例3：等高线图的实现</h3><p>案例位置：资源包\MR\Code\05\example\04<br>等高线图是在地理课中讲述山峰山谷时绘制的图形，在机器学习中也会被用在绘制梯度下降算法的图形中。等高线图实现结果如图5.71所示。</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022052019277.png" alt="image-20211022052019277"></p>
<p>程序代码如下：</p>
<p><img src="/2021/12/09/matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8/image-20211022052044728.png" alt="image-20211022052044728"></p>
<p>关键代码解析：</p>
<p>要画出等高线，核心函数是Matplotlib的contourf()函数，但该函数中参数x和y对应的值是二维数据，因此需要使用NumPy的meshgrid()函数将x和y值转换成二维数据，代码如下：</p>
<p>np.meshgrid(x, y)</p>
<h2 id="5-8-小结"><a href="#5-8-小结" class="headerlink" title="5.8　小结"></a>5.8　小结</h2><p>数据统计得再好都不如一张图表清晰、直观。本章用大量的举例详细地介绍了Matplotlib图表，其根本在于能够使读者全面透彻地了解和掌握最基础的图表，并应用到实际数据统计分析工作中，同时也为以后学习其他绘图库奠定坚实的基础。</p>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
  </entry>
  <entry>
    <title>pandas</title>
    <url>/2021/12/09/pandas/</url>
    <content><![CDATA[<p>一. 数据分析</p>
<p>熟悉工具-明确目的-获取数据-数据处理-数据分析-验证结果-结果呈现-数据应用</p>
<p>​                                                                                          表3.1　数据类型对应表　</p>
<h3 id="3-3-DataFrame重要属性和函数"><a href="#3-3-DataFrame重要属性和函数" class="headerlink" title="3.3 DataFrame重要属性和函数"></a>3.3 DataFrame重要属性和函数</h3><p>DataFrame是Pandas一个重要的对象，它的属性和函数很多，下面先简单了解DataFrame的几个重要属性和函数。重要属性介绍如表3.2所示，重要函数介绍如表3.3所示。</p>
<p>​                                                                                               表3.2　重要属性</p>
<p>​                                                                                                  表3.3　重要函数</p>
<h3 id="3-4-导入外部数据"><a href="#3-4-导入外部数据" class="headerlink" title="3.4 导入外部数据"></a>3.4 导入外部数据</h3><h4 id="3-4-1-导入-xls或-xlsx文件"><a href="#3-4-1-导入-xls或-xlsx文件" class="headerlink" title="3.4.1　导入.xls或.xlsx文件"></a>3.4.1　导入.xls或.xlsx文件</h4><p>导入.xls或.xlsx文件主要使用Pandas的read_excel()方法，语法如下：</p>
<p>pandas.read_excel(io,sheet_name=0,header=0,names=None,index_col=None,usecols=None,squeeze=False,<br>dtype=None,engine=None,converters=None,true_values=None,false_values=None,skiprows=None,nrow=None,<br>na_values=None,keep_default_na=True,verbose=False,parse_dates=False,date_parser=None,thousands=None,<br>comment=None,skipfooter=0,conver_float=True,mangle_dupe_cols=True,**kwds)<br>常用参数说明：　</p>
<p>io：字符串，.xls或.xlsx文件路径或类文件对象。　</p>
<p>sheet_name：None、字符串、整数、字符串列表或整数列表，默认值为0。字符串用于工作表名称，整数为索引表示工作表位置，字符串列表或整数列表用于请求多个工作表，为None时获取所有工作表。参数值如表3.4所示。</p>
<p>​                                                                                     表3.4　sheet_name参数值　</p>
<p>header：指定作为列名的行，默认值为0，即取第一行的值为列名。数据为除列名以外的数据；若数据不包含列名，则设置header=None。　</p>
<p>names：默认值为None，要使用的列名列表。　</p>
<p>index_col：指定列为行索引，默认值为None，索引0是DataFrame的行标签。</p>
<p>usecols：int、list列表或字符串，默认值为None。　如果为None，则解析所有列。　如果为int，则解析最后一列。　如果为list列表，则解析列号列表的列。　如果为字符串，则表示以逗号分隔的Excel列字母和列范围列表（例如“A:E”或“A,C,E:F”）。范围包括双方。　squeeze：布尔值，默认值为False，如果解析的数据只包含一列，则返回一个Series。　</p>
<p>dtype：列的数据类型名称或字典，默认值为None。例如{‘a’:np.float64,’b’:np.int32}。　</p>
<p>skiprows：省略指定行数的数据，从第一行开始。　</p>
<p>skipfooter：省略指定行数的数据，从尾部数的行开始。</p>
<p>下面通过示例，详细介绍如何导入.xlsx文件。</p>
<p>知识胶囊<br>导入外部数据，必然要涉及路径问题，下面来了解一下相对路径和绝对路径。　</p>
<p><strong>相对路径</strong>：相对路径就是以当前文件为基准进行一级级目录指向被引用的资源文件。以下是常用的表示当前目录和当前目录的父级目录的标识符。　../：表示当前文件所在目录的上一级目录。　./：表示当前文件所在的目录（可以省略）。　/：表示当前文件的根目录（域名映射或硬盘目录）。　如果使用系统默认文件路径\，那么，在Python中则需要在路径最前面加一个r，以避免路径里面的\被转义。　</p>
<p><strong>绝对路径</strong>：绝对路径是文件真正存在的路径，是指从硬盘的根目录（盘符）开始，进行一级级目录指向文件。</p>
<h5 id="2．导入指定的Sheet页"><a href="#2．导入指定的Sheet页" class="headerlink" title="2．导入指定的Sheet页"></a>2．导入指定的Sheet页</h5><p>一个Excel文件包含多个Sheet页，通过设置sheet_name参数就可以导入指定Sheet页的数据。</p>
<p>【示例13】　导入指定Sheet页的数据。 \03\13）一个Excel文件包含多家店铺的销售数据，导入其中一家店铺（莫寒）的销售数据，如图3.14所示。<br>图3.14　原始数据</p>
<p>程序代码如下：</p>
<p>01 import pandas as pd<br>02 df=pd.read_excel(‘1 月.xlsx’,sheet_name=’莫寒’)<br>03 df1=df.head()          #输出前5条数据<br>运行程序，输出前5条数据，结果如图3.15所示。<br>除了指定Sheet页的名字，还可以指定Sheet页的顺序，从0开始。例如，sheet_name=0表示导入第一个Sheet页的数据，sheet_name=1表示导入第二个Sheet页的数据，以此类推。<br>如果不指定sheet_name参数，则默认导入第一个Sheet页的数据。</p>
<h5 id="3．通过行、列索引导入指定行、列数据"><a href="#3．通过行、列索引导入指定行、列数据" class="headerlink" title="3．通过行、列索引导入指定行、列数据"></a>3．通过行、列索引导入指定行、列数据</h5><p>DataFrame是二维数据结构，因此它既有行索引又有列索引。当导入Excel数据时，行索引会自动生成，如0、1、2；而列索引则默认将第0行作为列索引（如A,B,…,J）。DataFrame行、列索引的示意图如图3.16所示。</p>
<p>​                                                  </p>
<p>​                                                                            图3.15　导入指定的Sheet页（前5条数据） </p>
<p>​                                                                                图3.16　DataFrame行、列索引示意图</p>
<p>【示例14】　指定行索引导入Excel数据。 \03\14）<br>如果通过指定行索引导入Excel数据，则需要设置index_col参数。下面将“买家会员名”作为行索引（位于第0列），导入Excel数据，程序代码如下：</p>
<p>01 import pandas as pd<br>02 df1=pd.read_excel(‘1 月.xlsx’,index_col=0)     #“买家会员名”为行索引<br>03 df1=df1.head()                                 #输出前5条数据<br>运行程序，输出结果如图3.17所示。</p>
<p>图3.17　通过指定行索引导入Excel数据<br>如果通过指定列索引导入Excel数据，则需要设置header参数，主要代码如下：</p>
<p>df2=pd.read_excel(‘1月.xlsx’,header=1)        #设置第1行为列索引</p>
<p>运行程序，输出结果如图3.18所示。<br>如果将数字作为列索引，可以设置header参数为None，主要代码如下：</p>
<p>df3=pd.read_excel(‘1月.xlsx’,header=None)    #列索引为数字</p>
<p>运行程序，输出结果如图3.19所示。</p>
<p>图3.19　指定列索引<br>那么，为什么要指定索引呢？因为通过索引可以快速地检索数据，例如df3[0]，就可以快速检索到“买家会员名”这一列数据。</p>
<h5 id="4-导入指定列数据"><a href="#4-导入指定列数据" class="headerlink" title="4.导入指定列数据"></a>4.导入指定列数据</h5><p>一个Excel往往包含多列数据，如果只需要其中的几列，可以通过usecols参数指定需要的列，从0开始（表示第1列，以此类推）。</p>
<p>【示例15】　导入第1列数据。 \03\15）下面导入第1列数据（索引为0），程序代码如下：</p>
<p>01 import pandas as pd<br>02 df1=pd.read_excel(‘1 月.xlsx’,usecols=[0])       #导入第1列<br>03 df1.head()<br>运行程序，输出结果如图3.20所示。<br>如果导入多列，可以在列表中指定多个值。例如，导入第1列和第4列，主要代码如下：</p>
<p>df2=pd.read_excel(‘1月.xlsx’,usecols=[0,3])<br>也可以指定列名称，主要代码如下：</p>
<p>df3=pd.read_excel(‘1月.xlsx’,usecols=[‘买家会员名’,’宝贝标题’])<br>运行程序，输出结果如图3.21所示。</p>
<p>​                                                                                     图3.21　导入第1列和第4列数据</p>
<h4 id="3-4-2-导入-csv文件"><a href="#3-4-2-导入-csv文件" class="headerlink" title="3.4.2　导入.csv文件"></a>3.4.2　导入.csv文件</h4><p>导入.csv文件主要使用Pandas的read_csv()方法，语法如下：</p>
<p>常用参数说明：　</p>
<p>filepath_or_buffer：字符串，文件路径，也可以是URL链接。　</p>
<p>sep、delimiter：字符串，分隔符。</p>
<p>header：指定作为列名的行，默认值为0，即取第1行的值为列名。数据为除列名以外的数据；若数据不包含列名，则设置header=None。　</p>
<p>names：默认值为None，要使用的列名列表。　</p>
<p>index_col：指定列为索引列，默认值为None，索引0是DataFrame的行标签。　</p>
<p>usecols：int、list列表或字符串，默认值为None。　如果为None，则解析所有列。　如果为int，则解析最后一列。　如果为list列表，则解析列号列表的列。　如果为字符串，则表示以逗号分隔的Excel列字母和列范围列表（例如“A:E”或“A,C,E:F”）。范围包括双方。　dtype：列的数据类型名称或字典，默认值为None。例如{‘a’:np.float64,’b’:np.int32}。　</p>
<p>parse_dates：布尔类型值、int类型值的列表、列表或字典，默认值为False。可以通过parse_dates参数直接将某列转换成datetime64日期类型。例如，df1=pd.read_csv(‘1月.csv’, parse_dates=[‘订单付款时间’])。　</p>
<p>​        parse_dates为True时，尝试解析索引。　</p>
<p>​        parse_dates为int类型值组成的列表时，如[1,2,3]，则解析1、2、3列的值作为独立的日期列。　</p>
<p>​        parse_date为列表组成的列表，如[[1,3]]，则将1、3列合并，作为一个日期列使用。　</p>
<p>​        parse_date为字典时，如{‘总计’：[1, 3]}，则将1、3列合并，合并后的列名为“总计”。　</p>
<p>encoding：字符串，默认值为None，文件的编码格式。Python常用的编码格式是UTF-8。　返回值：返回一个DataFrame。</p>
<p>【示例16】　导入.csv文件。 \03\16）导入.csv文件，程序代码如下：</p>
<p>01 import pandas as pd<br>02 df1=pd.read_csv(‘1月.csv’<strong>,encoding=</strong>‘gbk’)        #导入.csv文件，并指定编码格式<br>03 df1=df1.head()                                   #输出前5条数据<br>运行程序，输出结果如图3.22所示。                                                  </p>
<p>​                                                                                            图3.22　导入.csv文件</p>
<p>注意<br>上述代码中指定了编码格式，即encoding=’gbk’。Python常用的编码格式是UTF-8和gbk，默认编码格式为UTF-8。导入.csv文件时，需要通过encoding参数指定编码格式。当将Excel文件另存为.csv文件时，默认编码格式为gbk，此时当编写代码导入.csv文件时，就需要设置编码格式为gbk，与源文件编码格式保持一致；否则会提示错误。</p>
<h4 id="3-4-3-导入-txt文本文件"><a href="#3-4-3-导入-txt文本文件" class="headerlink" title="3.4.3　导入.txt文本文件"></a>3.4.3　导入.txt文本文件</h4><p>导入.txt文件同样使用Pandas的read_csv()方法，不同的是需要指定sep参数（如制表符\t）。read_csv()方法读取.txt文件返回一个DataFrame，像表格一样的二维数据结构，如图3.23所示。</p>
<p>【示例17】　导入.txt文件。 \03\17）<br>下面使用read_csv()方法导入1月.txt文件，主要代码如下：</p>
<p>01 import pandas as pd<br>02 df1=pd.read_csv(‘1月.txt’,sep=’\t’,encoding=’gbk’)<br>03 print(df1.head())<br>运行程序，输出结果如图3.24所示。</p>
<p>​                                                                                                         图3.24　导入.txt文本</p>
<h4 id="3-4-4-导入HTML网页"><a href="#3-4-4-导入HTML网页" class="headerlink" title="3.4.4　导入HTML网页"></a>3.4.4　导入HTML网页</h4><p>导入HTML网页数据主要使用Pandas的read_html()方法，该方法用于导入带有table标签的网页表格数据，语法如下：</p>
<p>pandas.read_html(io,match=’.+’,flavor=None,header=None,index_col=None,skiprows=None,attrs=None,parse_<br>dates=False,thousands=’,’,encoding=None,decimal=’.’,converters=None,na_values=None,keep_default_na=True,<br>displayed_only=True)<br>常用参数说明：　</p>
<p>io：字符串，文件路径，也可以是URL链接。网址不接受https，可以尝试去掉https中的s后爬取，如<a href="http://www.mingribook.com./">http://www.mingribook.com。</a></p>
<p>match：正则表达式，返回与正则表达式匹配的表格。　</p>
<p>flavor：解析器默认为lxml。　</p>
<p>header：指定列标题所在的行，列表list为多重索引。　</p>
<p>index_col：指定行标题对应的列，列表list为多重索引。　</p>
<p>encoding：字符串，默认为None，文件的编码格式。　</p>
<p>返回值：返回一个DataFrame。<br>使用read_html()方法前，首先要确定网页表格是否为table类型。例如，NBA球员薪资网页（<a href="http://www.espn.com/nba/salaries%EF%BC%89%EF%BC%8C%E5%8F%B3%E5%87%BB%E8%AF%A5%E7%BD%91%E9%A1%B5%E4%B8%AD%E7%9A%84%E8%A1%A8%E6%A0%BC%EF%BC%8C%E5%9C%A8%E5%BC%B9%E5%87%BA%E7%9A%84%E5%BF%AB%E6%8D%B7%E8%8F%9C%E5%8D%95%E4%B8%AD%E9%80%89%E6%8B%A9%E2%80%9C%E6%A3%80%E6%9F%A5%E5%85%83%E7%B4%A0%E2%80%9D%E5%91%BD%E4%BB%A4%EF%BC%8C%E6%9F%A5%E7%9C%8B%E4%BB%A3%E7%A0%81%E4%B8%AD%E6%98%AF%E5%90%A6%E5%90%AB%E6%9C%89%E8%A1%A8%E6%A0%BC%E6%A0%87%E7%AD%BE">http://www.espn.com/nba/salaries），右击该网页中的表格，在弹出的快捷菜单中选择“检查元素”命令，查看代码中是否含有表格标签</a><table>…</table>的字样，如图3.25所示。确定后才可以使用read_html()方法。</p>
<p>​                                                                            图3.25　<table>…</table>表格标签</p>
<p>【示例18】　导入NBA球员薪资数据。 \03\18）<br>下面使用read_html()方法导入NBA球员薪资数据，程序代码如下：</p>
<p>运行程序，输出结果如图3.26所示。</p>
<p>​                                                                                              图3.26　导入网页数据注意<br>运行程序，如果出现ImportError: lxml not found, please install it错误提示信息，则需要安装lxml模块。</p>
<h3 id="3-5-数据抽取"><a href="#3-5-数据抽取" class="headerlink" title="3.5　数据抽取"></a>3.5　数据抽取</h3><p>数据分析过程中，并不是所有的数据都是我们想要的，此时可以抽取部分数据，主要使用DataFrame对<strong>象的loc属性和iloc属性</strong>，示意图如图3.27所示。          </p>
<pre><code>                                                                                     图3.27　loc属性和iloc属性示意图
</code></pre>
<p>对象的loc属性和iloc属性都可以抽取数据，区别如下。　</p>
<p>loc属性：以列名（columns）和行名（index）作为参数，当只有一个参数时，默认是行名，即抽取整行数据，包括所有列，如df.loc[‘A’]。　</p>
<p>iloc属性：以行和列位置索引（即0，1，2，…)作为参数，0表示第1行，1表示第2行，以此类推。当只有一个参数时，默认是行索引，即抽取整行数据，包括所有列。如抽取第1行数据，df.iloc[0]。</p>
<h4 id="3-5-1-抽取一行数据"><a href="#3-5-1-抽取一行数据" class="headerlink" title="3.5.1　抽取一行数据"></a>3.5.1　抽取一行数据</h4><p>抽取一行数据主要使用loc属性。【</p>
<p>示例19】　抽取一行考试成绩数据。 \03\19）抽取一行名为“明日”的考试成绩数据（包括所有列），程序代码如下：运行程序，输出结果如图3.28所示。<br>使用iloc属性抽取第1行数据，指定行索引即可，如df.iloc[0]，输出结果同图3.28一样。</p>
<p>[1,2,2,3]</p>
<p>[[1,2,3,4]]</p>
<p>​                                                                                                                图3.28　抽取一行数据</p>
<h4 id="3-5-2-抽取多行数据"><a href="#3-5-2-抽取多行数据" class="headerlink" title="3.5.2　抽取多行数据"></a>3.5.2　抽取多行数据</h4><p>1．抽取任意多行数据<br><strong>通过loc属性和iloc属性指定行名和行索引即可实现抽取任意多行数据。</strong></p>
<p>【示例20】　抽取多行考试成绩数据。 \03\20）抽取行名为“明日”和“高袁圆”（即第1行和第3行数据）的考试成绩数据，可以使用loc属性，也可以使用iloc属性，其输出结果都是一样的，主要代码如下：</p>
<p>01 df1=df.loc[[‘明日’,’高袁圆’]]<br>02 df1=df.iloc[[0,2]]<br>运行程序，输出结果如图3.29所示。</p>
<p>​                                                                                                图3.29　抽取多行数据<br>2．抽取连续任意多行数据<br>在loc属性和iloc属性中合理地使用冒号（:），即可抽取连续任意多行数据。</p>
<p>【示例21】　抽取连续几个学生的考试成绩。 \03\21）抽取连续几个学生的考试成绩，主要代码如下：</p>
<p>运行程序，控制台输出结果如图3.30所示。</p>
<p>​                                                                                 图3.30　抽取连续任意多行数据</p>
<h4 id="3-5-3-抽取指定列数据"><a href="#3-5-3-抽取指定列数据" class="headerlink" title="3.5.3　抽取指定列数据"></a>3.5.3　抽取指定列数据</h4><p>抽取指定列数据，可以直接使用列名，也可以使用loc属性和iloc属性。<br>1．直接使用列名【示例22】　抽取“语文”和“数学”的考试成绩。 \03\22）<br>抽取列名为“语文”和“数学”的考试成绩数据，程序代码如下：</p>
<p>运行程序，输出结果如图3.31所示。</p>
<p>2．使用loc属性和iloc属性<br>前面介绍loc属性和iloc属性均有两个参数：第一个参数代表行；第二个参数代表列。那么这里抽取指定列数据时，行参数不能省略。</p>
<p>【示例23】　抽取指定学科的考试成绩。 \03\23）<br>下面使用loc属性和iloc属性抽取指定列数据，主要代码如下：</p>
<p>​                         </p>
<p>​                                                                                          图3.32　loc属性和iloc属性</p>
<h4 id="3-5-4-抽取指定行、列数据"><a href="#3-5-4-抽取指定行、列数据" class="headerlink" title="3.5.4　抽取指定行、列数据"></a>3.5.4　抽取指定行、列数据</h4><p>抽取指定行、列数据主要使用loc属性和iloc属性，这两个方法的两个参数都指定就可以实现指定行、列数据的抽取。</p>
<p>【示例24】　抽取指定学科和指定学生的考试成绩。 \03\24）使用loc属性和iloc属性抽取指定行、列数据，程序代码如下：</p>
<p>运行程序，控制台输出结果如图3.33所示。</p>
<pre><code>                                                                               图3.33　抽取指定行、列数据
</code></pre>
<p>在上述结果中，第一个输出结果是一个数，不是数据，是由于“df.loc[‘七月流火’,’英语’]”没有使用方括号[]，导致输出的数据不是DataFrame类型。</p>
<h4 id="3-5-5-按指定条件抽取数据"><a href="#3-5-5-按指定条件抽取数据" class="headerlink" title="3.5.5　按指定条件抽取数据"></a>3.5.5　按指定条件抽取数据</h4><p>DataFrame对象实现数据查询有以下3种方式。　取其中的一个元素.iat[x,x]。　基于位置的查询，如.iloc[]、iloc[2,1]。　基于行、列名称的查询，如.loc[x]。</p>
<p>【示例25】　抽取指定学科和指定分数的数据。 \03\25）抽取语文成绩大于105，数学成绩大于88的数据，程序代码如下：</p>
<p>​                                                                                             图3.34　按指定条件抽取数据</p>
<h3 id="3-6-数据的增加、修改和删除"><a href="#3-6-数据的增加、修改和删除" class="headerlink" title="3.6　数据的增加、修改和删除"></a>3.6　数据的增加、修改和删除</h3><h4 id="3-6-1-增加数据"><a href="#3-6-1-增加数据" class="headerlink" title="3.6.1　增加数据"></a>3.6.1　增加数据</h4><p>图3.35　原始数据</p>
<h5 id="1．按列增加数据"><a href="#1．按列增加数据" class="headerlink" title="1．按列增加数据"></a>1．按列增加数据</h5><p>按列增加数据，可以通过以下3种方式实现。<br>（1）直接为DataFrame对象赋值</p>
<p>【示例26】　增加一列“物理”成绩。 \03\26）<br>增加一列“物理”成绩，程序代码如下：</p>
<p>运行程序，输出结果如图3.36所示。</p>
<p>​                                                                                   图3.36　按列增加数据<br>（2）使用loc属性在DataFrame对象的最后增加一列</p>
<p>【示例27】　使用loc属性增加一列“物理”成绩。 \03\27）使用loc属性在DataFrame对象的最后增加一列。例如，增加“物理”一列，主要代码如下：</p>
<p>df.loc[:,’物理’] = [88,79,60,50]<br>在DataFrame对象最后增加一列“物理”，其值为等号右边数据。</p>
<p>（3）在指定位置插入一列<br>在指定位置插入一列，主要使用insert()方法。</p>
<p>【示例28】　在第1列后面插入“物理”成绩。 \03\28）<br>例如，在第1列后面插入“物理”，其值为wl的数值，主要代码如下：</p>
<p>01 wl =[88,79,60,50]<br>02 df.insert(1,’物理’,wl)<br>运行程序，输出结果如图3.37所示。</p>
<h5 id="2．按行增加数据"><a href="#2．按行增加数据" class="headerlink" title="2．按行增加数据"></a>2．按行增加数据</h5><p>按行增加数据，可以通过以下两种方式实现。<br>（1）增加一行数据<br>增加一行数据主要使用loc属性实现。</p>
<p>【示例29】　在成绩表中增加一行数据。 \03\29）在成绩表中增加一行数据，即“钱多多”同学的成绩，主要代码如下：</p>
<p>df.loc[‘钱多多’] = [100,120,99]<br>（2）增加多行数据</p>
<p>增加多行数据主要使用<strong>字典</strong>结合**append()**方法实现。</p>
<p>【示例30】　在原有数据中增加几名同学的考试成绩。 \03\30）在原有数据中增加“钱多多”“童年”“无名”同学的考试成绩，主要代码如下：</p>
<p>01 df_insert=pd.DataFrame({‘语文’:[100,123,138],’数学’:[99,142,60],’英语’:[98,139,99]},index = [‘钱多多’,’童年’,’无名’])<br>02 df1 = df.append(df_insert)</p>
<p>​                                              </p>
<p>​                                                    </p>
<h5 id="1．修改列标题"><a href="#1．修改列标题" class="headerlink" title="1．修改列标题"></a>1．修改列标题</h5><p>修改列标题主要使用DataFrame对象的cloumns属性，直接赋值即可。</p>
<p>【示例31】　修改“数学”的列名。 \03\31）将“数学”修改为“数学（上）”，主要代码如下：</p>
<p>df.columns=[‘语文’,’数学（上）’,’英语’]</p>
<p>上述代码中，即使只修改“数学”为“数学（上）”，但是也<strong>要将所有列的标题全部写上；</strong>否则将报错。<br>下面再介绍一种方法，使用DataFrame对象的rename()方法修改列标题。</p>
<p>【示例32】　修改多个学科的列名。 \03\32）将“语文”修改为“语文（上）”、“数学”修改为“数学（上）”、“英语”修改为“英语（上）”，主要代码如下：</p>
<p>df1=df.rename(columns = {‘语文’:’语文（上）’,’数学’:’数学（上）’,’英语’:’英语（上）’},inplace = True)</p>
<p>上述代码中，参数inplace为True，表示直接修改df；否则，不修改df，只返回修改后的数据。<br>运行程序，输出结果分别如图3.41和图3.42所示。</p>
<h5 id="2．修改行标题"><a href="#2．修改行标题" class="headerlink" title="2．修改行标题"></a>2．修改行标题</h5><p>修改行标题主要使用DataFrame对象的index属性，直接赋值即可。</p>
<p>【示例33】　将行标题统一修改为数字编号。 \03\33）<br>将行标题统一修改为数字编号，主要代码如下：</p>
<p>df.index=list(‘1234’)</p>
<p>使用DataFrame对象的rename()方法也可以修改行标题。例如，将行标题统一修改为数字编号，主要代码如下：</p>
<p>df.rename({‘明日’:1,’七月流火’:2,’高袁圆’:3,’二月二’:4},axis=0,inplace = True)</p>
<h5 id="3．修改数据"><a href="#3．修改数据" class="headerlink" title="3．修改数据"></a>3．修改数据</h5><p>修改数据主要使用DataFrame对象的loc属性和iloc属性。</p>
<p>【示例34】　修改学生成绩数据。 \03\34）<br>（1）修改整行数据<br>例如，修改“明日”同学的各科成绩，主要代码如下：</p>
<p>df.loc[‘明日’]=[120,115,109]<br>如果各科成绩均加10分，可以直接在原有值上加10，主要代码如下：</p>
<p>df.loc[‘明日’]=df.loc[‘明日’]+10<br>（2）修改整列数据<br>例如，修改所有同学的“语文”成绩，主要代码如下：</p>
<p>df.loc[:,’语文’]=[115,108,112,118]<br>（3）修改某一数据</p>
<p>例如，修改“明日”同学的“语文”成绩，主要代码如下：</p>
<p>df.loc[‘明日’,’语文’]=115<br>（4）使用iloc属性修改数据<br>通过iloc属性指定行、列位置实现修改数据，主要代码如下：</p>
<p>01 df.iloc[0,0]=115                        #修改某一数据<br>02 df.iloc[:,0]=[115,108,112,118]          #修改整列数据<br>03 df.iloc[0,:]=[120,115,109]              #修改整行数据</p>
<h4 id="3-6-3-删除数据"><a href="#3-6-3-删除数据" class="headerlink" title="3.6.3　删除数据"></a>3.6.3　删除数据</h4><p>删除数据主要使用DataFrame对象的drop()方法。语法如下：</p>
<p>DataFrame.drop(labels=None, axis=0, index=None, columns=None, level=None, inplace=False, errors=’raise’)<br>参数说明：　</p>
<p>labels：表示行标签或列标签。　</p>
<p>axis：axis = 0，表示按行删除；</p>
<p>​            axis = 1，表示按列删除。默认值为0，即按行删除。　</p>
<p>index：删除行，默认值为None。　</p>
<p>columns：删除列，默认值为None。</p>
<p>level：针对有两级索引的数据。level = 0，表示按第1级索引删除整行；level = 1表示按第2级索引删除整行，默认值为None。　inplace：可选参数，对原数组做出修改并返回一个新数组。默认值为False，如果值为True，那么原数组直接就被替换。　</p>
<p>errors：参数值为ignore或raise，默认值为raise，如果值为ignore（忽略），则取消错误。</p>
<h5 id="1．删除行、列数据"><a href="#1．删除行、列数据" class="headerlink" title="1．删除行、列数据"></a>1．删除行、列数据</h5><p>【示例35】　删除学生成绩数据。 \03\35）<br>删除指定的学生成绩数据，主要代码如下：</p>
<h5 id="2．删除特定条件的行"><a href="#2．删除特定条件的行" class="headerlink" title="2．删除特定条件的行"></a>2．删除特定条件的行</h5><p>删除满足特定条件的行，首先找到满足该条件的行索引，然后再使用drop()方法将其删除。</p>
<p>【示例36】　删除符合条件的学生成绩数据。 \03\36）<br>删除“数学”成绩中包含88的行、“语文”成绩中小于110的行，主要代码如下：</p>
<p>01 df.drop(index=df[df[‘数学’].<strong>isin</strong>([88])].index[0],inplace=True)      #删除“数学”成绩中包含88的行<br>02 df.drop(index=df[df[‘语文’]&lt;110].index[0],inplace=True)             #删除“语文”成绩中小于110的行说明<br>以上代码中的方法都可以实现删除指定的行、列数据，读者选择一种即可。</p>
<h3 id="3-7-数据清洗"><a href="#3-7-数据清洗" class="headerlink" title="3.7　数据清洗"></a>3.7　数据清洗</h3><h4 id="3-7-1-缺失值查看与处理"><a href="#3-7-1-缺失值查看与处理" class="headerlink" title="3.7.1　缺失值查看与处理"></a>3.7.1　缺失值查看与处理</h4><p>缺失值是指由于某种原因导致数据为空，这种情况一般有不处理、删除、填充／替换、插值（以均值／中位数／众数等填补）这4种处理方式。</p>
<h5 id="1．缺失值查看"><a href="#1．缺失值查看" class="headerlink" title="1．缺失值查看"></a>1．缺失值查看</h5><p>首先需要找到缺失值，主要使用DataFrame对象的info()方法。</p>
<p>【示例37】　查看数据概况。 \03\37）以淘宝销售数据为例，首先输出数据，然后使用info()方法查看数据，程序代码如下：</p>
<p>01 import pandas as pd<br>02 df=pd.read_excel(‘TB2018.xls’)<br>03 print(df)<br>04 print(df.info())</p>
<p>运行程序，控制台输出结果如图3.43所示。</p>
<p>图3.43　缺失值查看<br>在Python中，缺失值一般用NaN表示，如图3.43所示。通过info()方法可看到“买家会员名”“买家实际支付金额”“宝贝标题”“订单付款时间”的非空数量是10，而“宝贝总数量”和“类别”的非空数量是8，那么说明这两项存在空值。</p>
<p>【示例38】　判断数据是否存在缺失值。 \03\38）<br>接下来，判断数据是否存在缺失值还可以使用isnull()方法和notnull()方法，主要代码如下： </p>
<p>01  print(df.isnull())<br>02  print(df.notnull())</p>
<p>​                                                                                              图3.44　判断缺失值<br>使用isnull()方法缺失值返回True，非缺失值返回False；而notnull()方法与isnull()方法正好相反，缺失值返回False，非缺失值返回True。<br>如果使用df[df.isnull() == False]，</p>
<p>则会将所有非缺失值的数据找出来，只针对Series对象。</p>
<h5 id="2．缺失值删除处理"><a href="#2．缺失值删除处理" class="headerlink" title="2．缺失值删除处理"></a>2．缺失值删除处理</h5><p>通过前面的判断得知数据缺失情况，下面将缺失值删除，主要使用dropna()方法，该方法用于删除含有缺失值的行，主要代码如下：</p>
<p>df1=df.dropna()<br>运行程序，输出结果如图3.45所示。说明<br>有些时候数据可能存在整行为空的情况，此时可以在dropna()方法中指定参数how=’all’，删除所有空行。</p>
<p>​                                                                                   图3.45　缺失值删除处理1<br>从运行结果得知：dropna()方法将所有包含缺失值的数据全部删除了。那么，此时如果我们认为有些数据虽然存在缺失值，但是不影响数据分析，那么可以使用以下方法处理。例如，上述数据中只保留“宝贝总数量”不存在缺失值的数据，而类别是否缺失不关注，则可以使用notnull()方法判断，主要代码如下：</p>
<p>df2=df[df[‘宝贝总数量’].notnull()]<br>运行程序，输出结果如图3.46所示。</p>
<p>图3.46　缺失值删除处理2</p>
<h5 id="3．缺失值填充处理"><a href="#3．缺失值填充处理" class="headerlink" title="3．缺失值填充处理"></a>3．缺失值填充处理</h5><p>对于缺失数据，如果比例高于30%可以选择放弃这个指标，做删除处理；低于30%尽量不要删除，而是选择将这部分数据填充，一般以0、均值、众数（大多数）填充。DataFrame对象中的fillna()函数可以实现填充缺失数据，pad/ffill表示用前一个非缺失值去填充该缺失值；backfill/bfill表示用下一个非缺失值填充该缺失值；None用于指定一个值去替换缺失值。</p>
<p>【示例39】　将NaN填充为0。 \03\39）对于用于计算的数值型数据如果为空，可以选择用0填充。例如，将“宝贝总数量”为空的数据填充为0，主要代码如下：</p>
<p>运行程序，输出结果如图3.47所示。</p>
<p>​                                                                                                图3.47　缺失值填充处理</p>
<h4 id="3-7-2-重复值处理"><a href="#3-7-2-重复值处理" class="headerlink" title="3.7.2　重复值处理"></a>3.7.2　重复值处理</h4><p>对于数据中存在的重复数据，包括重复的行或者几行中某几列的值重复一般做删除处理，主要使用DataFrame对象的drop_duplicates()方法。</p>
<p>【示例40】　处理淘宝电商销售数据中的重复数据。 \03\40）下面以“1月.xlsx”淘宝销售数据为例，对其中的重复数据进行处理。<br>（1）判断每一行数据是否重复（完全相同），主要代码如下：</p>
<p>df1.duplicated()<br>如果返回值为False表示不重复，返回值为True表示重复。<br>（2）去除全部的重复数据，主要代码如下：</p>
<p>df1.drop_duplicates()#默认保留一行<br>（3）去除指定列的重复数据，主要代码如下：</p>
<p>df1.drop_duplicates([‘买家会员名’])<br>（4）保留重复行中的最后一行，主要代码如下：</p>
<p>df1.drop_duplicates([‘买家会员名’],keep=’last’)</p>
<p>说明<br>以上代码中参数keep的值有3个。当keep=’first’表示保留第一次出现的重复行，<strong>是默认值</strong>；当keep为另外两个取值，即last和False时，分别表示保留最后一次出现的重复行和去除所有重复行。<br>（5）直接删除，保留一个副本，主要代码如下：</p>
<p>df1.drop_duplicates([‘买家会员名’,’买家支付宝账号’],inplace=Fasle)<br>inplace=True表示直接在原来的DataFrame上删除重复项，而默认值False表示删除重复项后生成一个副本。</p>
<h4 id="3-7-3-异常值的检测与处理"><a href="#3-7-3-异常值的检测与处理" class="headerlink" title="3.7.3　异常值的检测与处理"></a>3.7.3　异常值的检测与处理</h4><p>首先了解一下什么是异常值。在数据分析中异常值是指超出或低于正常范围的值，如年龄大于200、身高大于3米、宝贝总数量为负数等类似数据。那么这些数据如何检测呢？主要有以下几种方法。<br>（1）根据给定的数据范围进行判断，不在范围内的数据视为异常值。<br>（2）均方差。<br>在统计学中，如果一个数据分布近似正态分布（数据分布的一种形式，正态分布的概率密度函数曲线呈钟形，两头低、中间高、左右对称，因此人们又经常称之为钟形曲线），那么大约68%的数据值会在均值的一个标准差范围内，大约95%会在两个标准差范围内，大约99.7%会在3个标准差范围内。<br>（3）箱形图。<br>箱形图是显示一组数据分散情况资料的统计图。它可以将数据通过四分位数的形式进行图形化描述。箱形图通过上限和下限作为数据分布的边界。任何高于上限或低于下限的数据都可以认为是异常值，如图3.48所示。</p>
<p>​                                                                                            图3.48　箱形图说明<br>有关箱形图的介绍以及如何通过箱形图识别异常值可参见第6章。<br>了解了异常值的检测，接下来介绍如何处理异常值，主要包括以下几种处理方式。<br>（1）最常用的方式是删除。<br>（2）将异常值当缺失值处理，以某个值填充。<br>（3）将异常值当特殊情况进行分析，研究异常值出现的原因。</p>
<p>缺失值替换</p>
<p>replace(to_repalce=None,value=None,inplace=False,limit=None,regex=False,method=’pad’)</p>
<p>to_repalce:指定需要替换的原值，可以是字符型，正则表达式，列表，series，整数，浮点数或None，例如{‘V1’:n1,’v2’:n2}表示使用n1,n2替换掉原来的v1,v2,这时的value必须为None</p>
<p>value：指定用于替换的新值</p>
<p>inplace：True修改原始数据，False仅修改视图</p>
<p>limit：限制向前，向后填充的最大个数</p>
<p>regex：默认False，若为True则to_palce必须为一个字符串。</p>
<p>pd.where(cond,value)</p>
<p>满足条件的保留，不满足条件的修改为value</p>
<h3 id="3-8-索引设置"><a href="#3-8-索引设置" class="headerlink" title="3.8 索引设置"></a>3.8 索引设置</h3><p>索引能够快速查询数据，本节主要介绍索引的作用以及索引的应用。</p>
<h4 id="3-8-1-索引的作用"><a href="#3-8-1-索引的作用" class="headerlink" title="3.8.1　索引的作用"></a>3.8.1　索引的作用</h4><p>索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。Pandas索引的作用如下。　</p>
<p>更方便查询数据。　</p>
<p>使用索引可以提升查询性能。　</p>
<p>如果索引是唯一的，Pandas会使用哈希表优化，查找数据的时间复杂度为O(1)。　</p>
<p>如果索引不是唯一的，但是有序，Pandas会使用二分查找算法，查找数据的时间复杂度为O(logN)。　</p>
<p>如果索引是完全随机的，那么每次查询都要扫描数据表，查找数据的时间复杂度为O(N)。　自动的数据对齐功能，示意图如图3.49所示。</p>
<p>​                                                                                    图3.49　自动数据对齐示意图<br>实现上述效果，程序代码如下：</p>
<p>01 import pandas as pd<br>02 s1 = pd.Series([10,20,30],index= list(“abc”))<br>03 s2 = pd.Series([2,3,4],index=list(“bcd”))<br>04 print(s1 + s2)　</p>
<p>强大的数据结构。　</p>
<p>基于分类数的索引，提升性能。　</p>
<p>多维索引，用于groupby多维聚合结果等。　</p>
<p>时间类型索引，强大的日期和时间的方法支持。</p>
<h4 id="3-8-2-重新设置索引"><a href="#3-8-2-重新设置索引" class="headerlink" title="3.8.2　重新设置索引"></a>3.8.2　重新设置索引</h4><p>Pandas有一个很重要的方法是reindex()，它的作用是创建一个适应新索引的新对象。语法如下：</p>
<p>DataFrame.reindex(labels = None,index = None,columns = None,axis = None,method = None,copy = True,level =<br>None,fill_value = nan,limit = None,tolerance = None)<br>常用参数说明：　</p>
<p>labels：标签，可以是数组，默认值为None（无）。　</p>
<p>index：行索引，默认值为None。　</p>
<p>columns：列索引，默认值为None。</p>
<p>axis：轴，axis=0表示行，axis=1表示列。默认值为None。　</p>
<p>method：默认值为None，重新设置索引时，选择插值（一种填充缺失数据的方法）方法，其值可以是None、bfill/backfill（向后填充）、ffill/pad（向前填充）等。　</p>
<p>fill_value：缺失值要填充的数据。如缺失值不用NaN填充，而用0填充，则设置fill_value=0即可。</p>
<h5 id="1．对Series对象重新设置索引"><a href="#1．对Series对象重新设置索引" class="headerlink" title="1．对Series对象重新设置索引"></a>1．对Series对象重新设置索引</h5><p>【示例41】　重新设置物理成绩的索引。 \03\41）<br>在3.2.3节已经建立了一组学生的物理成绩，下面重新设置索引，程序代码如下：</p>
<p>01 import pandas as pd<br>02 s1=pd.Series([88,60,75],index=[1,2,3])<br>03 print(s1)<br>04 print(s1.reindex([1,2,3,4,5]))</p>
<p>​                                                                                                 图3.51　重新设置索引<br>从运行结果得知：reindex()方法根据新索引进行了重新排序，并且对缺失值自动填充NaN。如果不想用NaN填充，则可以为fill_value参数指定值，如0，主要代码如下：</p>
<p>s1.reindex([1,2,3,4,5],fill_value=0)<br>而对于一些有一定顺序的数据，我们可能需要插值（插值是一种填充缺失数据的方法）来填充缺失的数据，可以使用method参数。</p>
<p>【示例42】　向前和向后填充数据。 \03\42）</p>
<p>向前填充（和前面数据一样）、向后填充（和后面数据一样），主要代码如下：</p>
<p>01 print(s1.reindex([1,2,3,4,5],method=’ffill’))   #向前填充<br>02 print(s1.reindex([1,2,3,4,5],method=’bfill’))   #向后填充</p>
<h5 id="2．对DataFrame对象重新设置索引"><a href="#2．对DataFrame对象重新设置索引" class="headerlink" title="2．对DataFrame对象重新设置索引"></a>2．对DataFrame对象重新设置索引</h5><p>对于DataFrame对象，reindex()方法用于修改行索引和列索引。</p>
<p>【示例43】　创建成绩表并重新设置索引。 \03\43）通过二维数组创建成绩表，程序代码如下：</p>
<p>df.reindex([‘mr001’,’mr002’,’mr003’,’mr004’,’mr005’])<br>通过reindex()方法重新设置列索引，主要代码如下：</p>
<p>df.reindex(columns=[‘语文’,’物理’,’数学’,’英语’])<br>通过reindex()方法重新设置行索引和列索引，主要代码如下：</p>
<p>df.reindex(index=[‘mr001’,’mr002’,’mr003’,’mr004’,’mr005’],columns=[‘语文’,’物理’,’数学’,’英语’])<br>运行程序，控制台输出结果分别为原始数据（见图3.52）、重新设置行索引（见图3.53）、重新设置列索引（见图3.54）、重新设置行、列索引（见图3.55）。</p>
<p>​                                                                                              </p>
<h4 id="3-8-3-设置某列为行索引"><a href="#3-8-3-设置某列为行索引" class="headerlink" title="3.8.3　设置某列为行索引"></a>3.8.3　设置某列为行索引</h4><p>设置某列为行索引主要使用set_index()方法。</p>
<p>【示例44】　设置“买家会员名”为行索引。 \03\44）<br>首先，导入“1月.xlsx”Excel文件，程序代码如下：</p>
<p>运行程序，输出结果如图3.56所示。<br>此时默认行索引为0、1、2、3、4，下面将“买家会员名”作为行索引，主要代码如下：</p>
<p>df2=df.set_index([‘买家会员名’])<br>运行程序，输出结果如图3.57所示。</p>
<p>​                                                                                                图3.56　1月淘宝销售数据（部分数据）</p>
<p>​                                                                                                       图3.57　设置“买家会员名”为索引<br>如果在set_index()方法中传入参数drop=True，则会删除“买家会员名”；如果传入drop=False，则会保留“买家会员名”。默认为False。</p>
<h4 id="3-8-4-数据清洗后重新设置连续的行索引"><a href="#3-8-4-数据清洗后重新设置连续的行索引" class="headerlink" title="3.8.4　数据清洗后重新设置连续的行索引"></a>3.8.4　数据清洗后重新设置连续的行索引</h4><p>在对Dataframe对象进行数据清洗后，例如去掉含NaN的行之后，发现行索引还是原来的行索引，对比效果如图3.58和图3.59所示。</p>
<p>​                                                                                            图3.58　原数据</p>
<p>​                                                                           图3.59　数据清洗后还是原来的索引</p>
<p>【示例45】　删除数据后重新设置索引。 \03\45）</p>
<p>如果要重新设置索引可以使用reset_index()方法，在删除缺失数据后重新设置索引，主要代码如下：</p>
<p>df2=df.dropna().reset_index(drop=True)<br>运行程序，输出结果如图3.60所示。</p>
<p>另外，对于分组统计后的数据，有时也需要重新设置连续的行索引，方法同上。</p>
<h3 id="3-9-数据排序与排名"><a href="#3-9-数据排序与排名" class="headerlink" title="3.9　数据排序与排名"></a>3.9　数据排序与排名</h3><p>本节主要介绍数据的各种排序和排名方法。</p>
<h4 id="3-9-1-数据排序"><a href="#3-9-1-数据排序" class="headerlink" title="3.9.1　数据排序"></a>3.9.1　数据排序</h4><p>DataFrame数据排序主要使用sort_values()方法，该方法类似于SQL中的ORDER BY。sort_values()方法可以根据指定行／列进行排序，语法如下：</p>
<p>DataFrame.sort_values(by,axis=0,ascending=True,inplace=False,kind=’quicksort’,na_position=’last’,ignore_<br>index=False)<br>参数说明：　</p>
<p>by：要排序的名称列表。</p>
<p>axis：轴，axis=0表示行，axis=1表示列。默认值为0，即按行排序。　</p>
<p>ascending：升序或降序排序，布尔值，指定多个排序可以使用布尔值列表。默认值为True。　</p>
<p>inplace：布尔值，默认值为False，如果值为True，则就地排序。　</p>
<p>kind：指定排序算法，值为quicksort（快速排序）、mergesort（混合排序）或heapsort（堆排），默认值为quicksort。　</p>
<p>na_position：空值（NaN）的位置，值为first空值在数据开头，值为last空值在数据最后，默认值为last。　</p>
<p>ignore_index：布尔值，是否忽略索引，值为True标记索引（从0开始按顺序的整数值），值为False则忽略索引。</p>
<h5 id="1．按一列数据排序"><a href="#1．按一列数据排序" class="headerlink" title="1．按一列数据排序"></a>1．按一列数据排序</h5><p>Spyder变量浏览窗口本身也支持数据排序，单击需要排序的列即可实现升序或降序排序。<br>程序代码如下：</p>
<h5 id="2．按多列数据排序"><a href="#2．按多列数据排序" class="headerlink" title="2．按多列数据排序"></a>2．按多列数据排序</h5><p>主要代码如下：</p>
<p>df1=df.sort_values(by=[‘图书名称’,’销量’])</p>
<h5 id="3．对统计结果排序"><a href="#3．对统计结果排序" class="headerlink" title="3．对统计结果排序"></a>3．对统计结果排序</h5><p>按“类别”分组统计销量并进行降序排序，统计排序后的效果如图3.64所示。</p>
<p>​                                                                                 图3.64　按“类别”分组统计销量并降序排序<br>主要代码如下：</p>
<p>01 df1=df.groupby([“类别”])[“销量”].sum().reset_index()</p>
<p>2 df2=df1.sort_values(by=’销量’,ascending=False)</p>
<h5 id="4．按行数据排序"><a href="#4．按行数据排序" class="headerlink" title="4．按行数据排序"></a>4．按行数据排序</h5><p>【示例49】　按行数据排序。 \03\49）<br>按行排序，主要代码如下：</p>
<p>df=dfrow.sort_values(by=0,ascending=True,axis=1)</p>
<p>注意<br><strong>按行排序的数据类型要一致</strong>，否则会出现错误提示。</p>
<h4 id="3-9-2-数据排名"><a href="#3-9-2-数据排名" class="headerlink" title="3.9.2　数据排名"></a>3.9.2　数据排名</h4><p>排名是根据Series对象或DataFrame的某几列的值进行排名的，主要使用rank()方法，语法如下：</p>
<p>DataFrame.rank(axis=0,method=’average’,numeric_only=None,na_option=’keep’,ascending=True,pct=False)<br>参数说明：　</p>
<p>axis：轴，axis=0表示行，axis=1表示列。默认值为0，即按行排序。　</p>
<p>method：表示在具有相同值的情况下所使用的排序方法。设置值如下。　</p>
<p>​    average：默认值，平均排名。</p>
<p>​    min：最小值排名。　</p>
<p>​    max：最大值排名。　</p>
<p>​    first：按值在原始数据中的出现顺序分配排名。　</p>
<p>​    dense：密集排名，类似最小值排名，但是排名每次只增加1，即排名相同的数据只占一个名次。　</p>
<p>numeric_only：对于DataFrame对象，如果设置值为True，则只对数字列进行排序。　</p>
<p>na_option：空值的排序方式，设置值如下。　</p>
<p>​    keep：保留，将空值等级赋值给NaN值。　</p>
<p>​    top：如果按升序排序，则将最小排名赋值给NaN值。　</p>
<p>​    bottom：如果按升序排序，则将最大排名赋值给NaN值。　</p>
<p>ascending：升序或降序排序，布尔值，指定多个排序可以使用布尔值列表。默认值为True。　</p>
<p>pct：布尔值，是否以百分比形式返回排名。默认值为False。</p>
<p>1．顺序排名</p>
<p>01 df[‘平均排名’]=df[‘销量’].rank(ascending=False)</p>
<p>02 df1=df[[‘图书名称’,’销量’,’平均排名’]]<br>程序运行结果如图3.66所示。<br>3．最小值排名<br>排名相同的，按顺序排名取最小值作为排名，主要代码如下：</p>
<p>df[‘最小值排名’]=df[‘销量’].rank(method=”min”,ascending=False)<br>4．最大值排名<br>排名相同的，按顺序排名取最大值作为排名，主要代码如下：</p>
<p>df[‘最大值排名’]=df[‘销量’]</p>
<p>rank(method=”max”,ascending=False)</p>
<h3 id="sum"><a href="#sum" class="headerlink" title="sum()"></a>sum()</h3><p>DataFrame.sum(axis=None, skipna=None, level=None, numeric_only=None, min_count=0, **kwargs)<br>参数说明：　</p>
<p>axis：axis=1表示行，axis=0表示列，默认值为None（无）。　skipna：布尔型，表示计算结果是否排除NaN/Null值，默认值为None。</p>
<p>level：表示索引层级，默认值为None。　</p>
<p>numeric_only：仅数字，布尔型，默认值为None。　</p>
<p>min_count：表示执行操作所需的数目，整型，默认值为0。　**kwargs：要传递给函数的附加关键字参数。　</p>
<p>返回值：返回Series对象或DataFrame对象。行或列求和数据。</p>
<p>【示例01】　计算语文、数学和英语三科的总成绩。 \04\01）<br>首先，创建一组DataFrame类型的数据，包括语文、数学和英语三科的成绩，如图4.1所示。<br>程序代码如下：</p>
<p>df[‘总成绩’]=df.sum(axis=1)</p>
<h3 id="mean"><a href="#mean" class="headerlink" title="mean()"></a>mean()</h3><p>DataFrame.mean(axis=None, skipna=None, level=None, numeric_only=None, kwargs)<br>参数说明：　</p>
<p>axis：axis=1表示行，axis=0表示列，默认值为None（无）。　</p>
<p>skipna：布尔型，表示计算结果是否排除NaN/Null值，默认值为None。　</p>
<p>level：表示索引层级，默认值为None。　</p>
<p>numeric_only：仅数字，布尔型，默认值为None。　</p>
<p>kwargs：要传递给函数的附加关键字参数。　</p>
<p>返回值：返回Series对象或DataFrame对象。行或列平均值数据。</p>
<h3 id="max"><a href="#max" class="headerlink" title="max()"></a>max()</h3><p>DataFrame.max(axis=None, skipna=None, level=None, numeric_only=None, **kwargs)<br>参数说明：　**</p>
<p>**axis：axis=1表示行，axis=0表示列，默认值为None（无）。　skipna：布尔型，表示计算结果是否排除NaN/Null值，默认值为None。　</p>
<p>**level：表示索引层级，默认值为None。　</p>
<p>**numeric_only：仅数字，布尔型，默认值为None。　</p>
<p>kwargs：要传递给函数的附加关键字参数。　</p>
<p>返回值：返回Series对象或DataFrame对象。行或列最大值数据。</p>
<h3 id="median"><a href="#median" class="headerlink" title="median()"></a>median()</h3><p>中位数又称中值，是统计学专有名词，是指按顺序排列的一组数据中位于中间位置的数，其不受异常值的影响。例如，年龄23、45、35、25、22、34、28这7个数，中位数就是排序后位于中间的数字，即28；而年龄23、45、35、25、22、34、28、27这8个数，中位数则是排序后位于中间两个数的平均值，即27.5。在Python中直接调用DataFrame对象的median()函数就可以轻松实现中位数的运算，语法如下：</p>
<p>DataFrame.median(axis=None,skipna=None,level=None,numeric_only=None,**kwargs)<br>参数说明：　**</p>
<p>**axis：axis=1表示行，axis=0表示列，默认值为None（无）。　skipna：布尔型，表示计算结果是否排除NaN/Null值，默认值为None。　</p>
<p>**level：表示索引层级，默认值为None。　</p>
<p>**numeric_only：仅数字，布尔型，默认值为None。　</p>
<p>kwargs：要传递给函数的附加关键字参数。　</p>
<p>返回值：返回Series对象或DataFrame对象。</p>
<h3 id="mode"><a href="#mode" class="headerlink" title="mode()"></a>mode()</h3><p>什么是众数？众数的众字有多的意思，顾名思义，众数就是一组数据中出现最多的数称为众数，它代表了数据的一般水平。<br>在Python中通过调用DataFrame对象的mode()函数可以实现众数运算，语法如下：</p>
<p>DataFrame.mode(axis=0,numeric_only=False,dropna=True)<br>参数说明：　</p>
<p>axis：axis=1表示行，axis=0表示列，默认值为0。　</p>
<p>numeric_only：仅数字，布尔型，默认值为False。如果值为True，则仅适用于数字列。　</p>
<p>dropna：是否删除缺失值，布尔型，默认值为True。　</p>
<p>返回值：返回Series对象或DataFrame对象。</p>
<h3 id="var"><a href="#var" class="headerlink" title="var()"></a>var()</h3><p>方差<br>接着来看一下总体波动（方差和），“小黑”的数据是73.2，“小白”的数据是949.2，很明显“小黑”的物理成绩波动较小，发挥更稳定，所以应该选“小黑”参加物理竞赛。<br>以上举例就是方差的意义。大数据时代，它能够帮助我们解决很多身边的问题、协助我们做出合理的决策。<br>在Python中通过调用DataFrame对象的var()函数可以实现方差运算，语法如下：</p>
<p><strong>DataFrame.var(axis=None,skipna=None,level=None,ddof=1,numeric_only=None,kwargs)</strong><br>参数说明：　</p>
<p>axis：axis=1表示行，axis=0表示列，默认值为None（无）。　skipna：布尔型，表示计算结果是否排除NaN/Null值，默认值为None。　</p>
<p>level：表示索引层级，默认值为None。　</p>
<p>ddof：整型，默认值为1。自由度，计算中使用的除数是N-ddof，其中N表示元素的数量。　</p>
<p>numeric_only：仅数字，布尔型，默认值为None。　</p>
<p>kwargs：要传递给函数的附加关键字参数。　</p>
<p>返回值：返回Series对象或DataFrame对象。</p>
<h3 id="std"><a href="#std" class="headerlink" title="std()"></a>std()</h3><p>标准差又称均方差，是方差的平方根，用来表示数据的离散程度。<br>在Python中通过调用DataFrame对象的std()函数求标准差，语法如下：</p>
<p>DataFrame.std(axis=None,skipna=None,level=None,ddof=1,numeric_only=None,**kwargs)<br>std()函数的参数与var()函数一样，这里不再赘述。</p>
<h3 id="4-1-9-求分位数（quantile-函数）"><a href="#4-1-9-求分位数（quantile-函数）" class="headerlink" title="4.1.9　求分位数（quantile()函数）"></a>4.1.9　求分位数（quantile()函数）</h3><p>分位数也称分位点，它以概率依据将数据分割为几个等份，常用的有中位数（即二分位数）、四分位数、百分位数等。分位数是数据分析中常用的一个统计量，经过抽样得到一个样本值。例如，经常会听老师说：“这次考试竟然有20%的同学不及格！”，那么这句话就体现了分位数的应用。在Python中通过调用DataFrame对象的quantile()函数求分位数，语法如下：</p>
<p><strong>DataFrame.quantile(q=0.5,axis=0,numeric_only=True, interpolation=’linear’)</strong><br>参数说明：　</p>
<p>q：浮点型或数组，默认为0.5（50%分位数），其值为0～1。　</p>
<p>axis：axis=1表示行，axis=0表示列。默认值为0。　</p>
<p>numeric_only：仅数字，布尔型，默认值为True。　</p>
<p>interpolation：内插值，可选参数[{‘linear’,‘lower’,‘higher’,‘midpoint’,‘nearest’}]用于指定要使用的插值方法，当期望的分位数为数据点i～j时。　</p>
<p>​    linear’：i+(j-i)×分数，其中分数是指数被i和j包围的小数部分。　</p>
<p>​    lower：i。　</p>
<p>​    higher：j。　 </p>
<p>​    nearest：i或j二者以最近者为准。　</p>
<p>​    midpoint：(i+j)/2。　</p>
<p>返回值：返回Series或DataFrame对象。</p>
<p>【示例10】　通过分位数确定被淘汰的35%的学生。 \04\10）<br>以学生成绩为例，数学成绩分别为120、89、98、78、65、102、112、56、79、45的10名同学，现根据分数淘汰35%的学生，该如何处理？首先使用quantile()函数计算35%的分位数，然后将学生成绩与分位数比较，筛选小于等于分位数的学生，程序代码如下：</p>
<h3 id="4-2-1-设置小数位数"><a href="#4-2-1-设置小数位数" class="headerlink" title="4.2.1　设置小数位数"></a>4.2.1　设置小数位数</h3><p>设置小数位数主要使用DataFrame对象的round()函数，该函数可以实现四舍五入，而它的decimals参数则用于设置保留小数的位数，设置后数据类型不会发生变化，依然是浮点型。语法如下：</p>
<p>DataFrame.round(decimals=0, *args, **kwargs)　**</p>
<p>decimals：每一列四舍五入的小数位数，整型、字典或Series对象。如果是整数，则将每一列四舍五入到相同的位置。否则，将字典和Series舍入到可变数目的位置；如果小数是类似于字典的，那么列名应该在键中；如果小数是级数，列名应该在索引中。没有包含在小数中的任何列都将保持原样。非输入列的小数元素将被忽略。　</p>
<p>args：附加的关键字参数。　</p>
<p>kwargs：附加的关键字参数。　</p>
<p>返回值：返回DataFrame对象。</p>
<p>当然，保留小数位数也可以用自定义函数，例如，为DataFrame对象中的各个浮点值保留两位小数，主要代码如下：</p>
<p>df.applymap(lambda x: ‘%.2f’%x)</p>
<h3 id="4-2-2-设置百分比"><a href="#4-2-2-设置百分比" class="headerlink" title="4.2.2　设置百分比"></a>4.2.2　设置百分比</h3><p>在数据分析过程中，有时需要百分比数据。那么，利用自定义函数将数据进行格式化处理，处理后的数据就可以从浮点型转换成带指定小数位数的百分比数据，主要使用apply()函数与format()函数。</p>
<p>【示例13】　将指定数据格式化为百分比数据。 \04\13）<br>将A1列的数据格式化为百分比数据，程序代码如下：</p>
<h3 id="4-2-3-设置千位分隔符"><a href="#4-2-3-设置千位分隔符" class="headerlink" title="4.2.3　设置千位分隔符"></a>4.2.3　设置千位分隔符</h3><p>由于业务需要，有时需要将数据格式化为带千位分隔符的数据。那么，处理后的数据将不再是浮点型而是对象型。</p>
<p>df[‘麻阳’]=df[‘妈呀’]。apply(lambda x:format(int(x),’,’))</p>
<h3 id="4-3-1-分组groupby"><a href="#4-3-1-分组groupby" class="headerlink" title="4.3.1　分组groupby()"></a>4.3.1　分组groupby()</h3><p><strong>DataFrame.groupby(by=None,axis=0,level=None,as_index=True,sort=True,group_keys=True,squeeze=False,observed=False)</strong></p>
<p>参数说明：　</p>
<p>by：映射、字典或Series对象、数组、标签或标签列表。如果by是一个函数，则对象索引的每个值都调用它；如果传递了一个字典或Series对象，则使用该字典或Series对象值来确定组；如果传递了数组ndarray，则按原样使用这些值来确定组。　</p>
<p>axis：axis=1表示行，axis=0表示列。默认值为0。　</p>
<p>level：表示索引层级，默认值为None（无）。　</p>
<p>as_index：布尔型，默认值为True，返回以组标签为索引的对象。　sort：对组进行排序，布尔型，默认值为True。　</p>
<p>group_keys：布尔型，默认值为True，调用apply()函数时，将分组的键添加到索引以标识片段。　</p>
<p>squeeze：布尔型，默认值为False。如果可能，减少返回类型的维度；否则返回一致类型。　</p>
<p>observed： <em>bool, default False</em> 布尔型, 观察者, 默认为False。当以石斑鱼为分类时，才会使用该参数。如果参数值为True，则仅显示分类石斑鱼的观测值；如果参数值为False，则显示分类石斑鱼的所有值。</p>
<p>返回值：返回DataFrameGroupBy，返回包含有关组的信息的groupby对象。</p>
<h4 id="1．按照一列分组统计"><a href="#1．按照一列分组统计" class="headerlink" title="1．按照一列分组统计"></a>1．按照一列分组统计</h4><p>【示例15】　根据“一级分类”统计订单数据。 \04\15）<br>按照图书“一级分类”对订单数据进行分组统计求和，程序代码如下：</p>
<p>​                                 图4.10　按照一列分组统计</p>
<h4 id="2．按照多列分组统计"><a href="#2．按照多列分组统计" class="headerlink" title="2．按照多列分组统计"></a>2．按照多列分组统计</h4><p>多列分组统计，以列表形式指定列。</p>
<p>【示例16】　根据两级分类统计订单数据。 \04\16）<br>按照图书“一级分类”和“二级分类”对订单数据进行分组统计求和，主要代码如下：</p>
<p>01 #抽取数据<br>02 df1=df[[‘一级分类’,’二级分类’,’7天点击量’,’订单预定’]]<br>03 df1=df1.groupby([‘一级分类’,’二级分类’]).sum()    #分组统计求和</p>
<h4 id="3．分组并按指定列进行数据计算"><a href="#3．分组并按指定列进行数据计算" class="headerlink" title="3．分组并按指定列进行数据计算"></a>3．分组并按指定列进行数据计算</h4><p>前面介绍的分组统计是按照所有列进行汇总计算的，那么如何按照指定列汇总计算呢？</p>
<p>【示例17】　统计各编程语言的7天点击量。 \04\17）<br>统计各编程语言的7天点击量，首先按“二级分类”分组，然后抽取“7天点击量”列并对该列进行求和运算，主要代码如下：</p>
<p>df1=df1.groupby(‘二级分类’)[‘7天点击量’].sum()</p>
<h3 id="4-3-3-对分组的某列或多列使用聚合函数（agg-函数）"><a href="#4-3-3-对分组的某列或多列使用聚合函数（agg-函数）" class="headerlink" title="4.3.3　对分组的某列或多列使用聚合函数（agg()函数）"></a>4.3.3　对分组的某列或多列使用聚合函数（agg()函数）</h3><p>Python也可以实现像SQL中的分组聚合运算操作，主要通过groupby()函数与agg()函数实现。【示例20】　对分组统计结果使用聚合函数。 \04\20）<br>按“一级分类”分组统计“7天点击量”“订单预定”的平均值和总和，主要代码如下：</p>
<p>print(df1.groupby(‘一级分类’).agg([‘mean’,’sum’]))<br>运行程序，控制台输出结果如图4.14所示。</p>
<p>【示例21】　针对不同的列使用不同的聚合函数。 \04\21）<br>在上述示例中，还可以针对不同的列使用不同的聚合函数。例如，按“一级分类”分组统计“7天点击量”的平均值和总和、“订单预定”的总和，主要代码如下：</p>
<p>print(df1.groupby(‘一级分类’).agg({‘7天点击量’:[‘mean’,’sum’], ‘订单预定’:[‘sum’]}))</p>
<p>​           图4.15　分组统计“7天点击量”的平均值和总和、“订单预定”的总和</p>
<p>【示例22】　通过自定义函数实现分组统计。 \04\22）<br>通过自定义函数也可以实现数据分组统计。例如，统计1月份销售数据中，购买次数最多的产品，主要代码如下：</p>
<h2 id="4-4-数据移位"><a href="#4-4-数据移位" class="headerlink" title="4.4　数据移位"></a>4.4　数据移位</h2><p>什么是数据移位？例如，分析数据时需要上一条数据怎么办？当然是移动至上一条，从而得到该条数据，这就是数据移位。在Pandas中，使用shift()方法可以获得上一条数据，该方法返回向下移位后的结果，从而得到上一条数据。例如，获取某学生上一次英语成绩，如图4.21所示。</p>
<p>DataFrame.shift(periods=1, freq=None, axis=0)<br>参数说明：　</p>
<p>periods：表示移动的幅度，可以是正数，也可以是负数，默认值是1，1表示移动一次。注意这里移动的都是数据，而索引是不移动的，移动之后是没有对应值的，赋值为NaN。　</p>
<p>freq：可选参数，默认值为None，只适用于时间序列，如果这个参数存在，那么会按照参数值移动时间索引，而数据值没有发生变化。　</p>
<p>axis：axis=1表示行，axis=0表示列。默认值为0。</p>
<h3 id="4-5-1-一列数据转换为多列数据"><a href="#4-5-1-一列数据转换为多列数据" class="headerlink" title="4.5.1　一列数据转换为多列数据"></a>4.5.1　一列数据转换为多列数据</h3><p>一列数据转换为多列数据的情况在日常工作中经常会用到，从各种系统中导出的订单号、名称、地址很多都是复合组成的（即由多项内容组成），那么，这些列在查找、统计、合并时就没办法使用，需要将它们拆分开。例如，地址信息由省市区街道门牌号等信息组成，如果按省、市或区统计数据，就需要将地址信息中的“省”“市”“区”拆分开，此时就应用到了一列数据转多列数据，通常使用以下方法。</p>
<h4 id="1．split-方法"><a href="#1．split-方法" class="headerlink" title="1．split()方法"></a>1．split()方法</h4><p>Pandas的DataFrame对象中的str.split()内置方法可以实现分割字符串，语法如下：</p>
<p>Series.str.split(pat=None, n=-1, expand=False)<br>参数说明：　</p>
<p>pat：字符串、符号或正则表达式，字符串分割的依据，默认以空格分割字符串。　</p>
<p>n：整型，分割次数，默认值是-1，0或-1都将返回所有拆分。　expand：布尔型，分割后的结果是否转换为DataFrame，默认值是False。　</p>
<p>返回值：系列、索引、DataFrame或多重索引。</p>
<h4 id="2．join-方法与split-方法结合"><a href="#2．join-方法与split-方法结合" class="headerlink" title="2．join()方法与split()方法结合"></a>2．join()方法与split()方法结合</h4><p>df = df.join(df[‘宝贝标题’].str.split(‘, ‘, expand=True))</p>
<p>【示例28】　对元组数据进行分隔。 \04\28）<br>首先，创建一组包含元组的数据，程序代码如下：</p>
<p>01  import pandas as pd<br>02  df = pd.DataFrame({‘a’:[1,2,3,4,5], ‘b’:[(1,2), (3,4),(5,6),(7,8),(9,10)]})<br>03  print(df)</p>
<p>然后，使用apply()函数对元组进行分隔，主要代码如下：</p>
<p>df[[‘b1’, ‘b2’]] = df[‘b’].apply(pd.Series)<br>或者使用join()方法结合apply()函数，主要代码如下：</p>
<p>df= df.join(df[‘b’].apply(pd.Series))</p>
<h4 id="3．pivot-方法"><a href="#3．pivot-方法" class="headerlink" title="3．pivot()方法"></a>3．pivot()方法</h4><p>pivot()方法针对列的值，即指定某列的值作为行索引，指定某列的值作为列索引，然后再指定哪些列作为索引对应的值。unstack()方法针对索引进行操作，pivot()方法针对值进行操作。但实际上，二者的功能往往可以互相实现。<br>pivot()方法的语法如下：</p>
<p>DataFrame.pivot(index=None, columns=None, values=None)<br>参数说明：　</p>
<p>index：字符串或对象，可选参数。列用于创建新DataFrame数据的索引。如果没有，则使用现有索引。　</p>
<p>columns：字符串或对象，列用于创建新DataFrame的列。　</p>
<p>values：列用于填充新DataFrame的值，如果未指定，则将使用所有剩余的列，结果将具有分层索引列。　</p>
<p>返回值：DataFrame对象或Series对象。</p>
<p>使用pivot()方法转换学生成绩表，主要代码如下：</p>
<p>01 df=pd.read_excel(‘grade.xls’,sheet_name=’英语3’)         #导入Excel文件<br>02 df1=df.pivot(index=’序号’,columns=’班级’,values=’得分’)</p>
<p>图4.33　使用pivot()方法转换学生成绩表</p>
<h3 id="4-5-3-DataFrame转换为字典"><a href="#4-5-3-DataFrame转换为字典" class="headerlink" title="4.5.3　DataFrame转换为字典"></a>4.5.3　DataFrame转换为字典</h3><p>DataFrame转换为字典主要使用DataFrame对象的to_dict()方法，以索引作为字典的键（key），以列作为字典的值（value）。例如，有一个DataFrame对象（索引为“类别”、列为“数量”），通过to_dict()方法就会生成一个字典，示意图如图4.34所示。如果DataFrame对象包含两列，那么to_dict()方法就会生成一个两层的字典（dict），第一层是列名作为字典的键（key），第二层以索引列的值作为字典的键（key），以列值作为字典的值（value）。</p>
<p>【示例32】　将Excel销售数据转换为字典。 \04\32）<br>使用to_dict()方法将按“宝贝标题”分组统计后的部分数据转换为字典，程序代码如下：</p>
<p>​                           图4.35　DataFrame转换为字典</p>
<h3 id="4-5-4-DataFrame转换为列表"><a href="#4-5-4-DataFrame转换为列表" class="headerlink" title="4.5.4　DataFrame转换为列表"></a>4.5.4　DataFrame转换为列表</h3><p>DataFrame转换为列表主要使用DataFrame对象的tolist()方法。</p>
<p>【示例33】　将电商数据转换为列表。 \04\33）</p>
<h3 id="4-5-5-DataFrame转换为元组"><a href="#4-5-5-DataFrame转换为元组" class="headerlink" title="4.5.5　DataFrame转换为元组"></a>4.5.5　DataFrame转换为元组</h3><p>DataFrame转换为元组，首先通过循环语句按行读取DataFrame数据，然后使用元组函数tuple()将其转换为元组。</p>
<p>【示例34】　将Excel数据转换为元组。 \04\34）<br>将Excel表中的人物关系部分数据转换成元组，程序代码如下：</p>
<p>​                            图4.37　DataFrame转换为元组</p>
<h3 id="4-5-6-Excel转换为HTML网页格式"><a href="#4-5-6-Excel转换为HTML网页格式" class="headerlink" title="4.5.6　Excel转换为HTML网页格式"></a>4.5.6　Excel转换为HTML网页格式</h3><p>日常工作中，有时会涉及财务数据的处理，而Excel应用最为广泛，但是对于展示数据来说，Excel并不友好，如果你想用其他格式的文件来向用户展示，那么，HTML网页格式是不错的选择。首先使用read_excel()方法导入Excel文件，然后使用to_html()方法将DataFrame数据导出为HTML格式，这样便实现了Excel转换为HTML格式。</p>
<p>程序代码如下：</p>
<p>01 import pandas as pd<br>02 df=pd.read_excel(‘mrbooks.xls’)<br>03 df.to_html(‘mrbook.html’,header = True,index = False)</p>
<h2 id="4-6-数据合并"><a href="#4-6-数据合并" class="headerlink" title="4.6　数据合并"></a>4.6　数据合并</h2><p>DataFrame数据合并主要使用merge()方法和concat()方法。</p>
<h3 id="4-6-1-数据合并（merge-方法）"><a href="#4-6-1-数据合并（merge-方法）" class="headerlink" title="4.6.1　数据合并（merge()方法）"></a>4.6.1　数据合并（merge()方法）</h3><p>Pandas模块的merge()方法是按照两个DataFrame对象列名相同的列进行连接合并，两个DataFrame对象必须具有同名的列。merge()方法的语法如下：</p>
<p>pandas.merge(right,how=’inner’,on=None,left_on=None,right_on=None,left_index=False,right_index=False,sort=<br>False,suffixes=(‘_x’,’_y’),copy=True,indicator=False,validate=None)<br>参数说明：　</p>
<p>right：合并对象，DataFrame对象或Series对象。　</p>
<p>how：合并类型，参数值可以是left（左合并）、right（右合并）、outer（外部合并）或inner（内部合并），默认值为inner。各个值的说明如下。　</p>
<p>​        left：只使用来自左数据集的键，类似于SQL左外部联接，保留键的顺序。　</p>
<p>​        right：只使用来自右数据集的键，类似于SQL右外部联接，保留键的顺序。　</p>
<p>​        outer：使用来自两个数据集的键，类似于SQL外部联接，按字典顺序对键进行排序。　</p>
<p>​        inner：使用来自两个数据集的键的交集，类似于SQL内部连接，保持左键的顺序。</p>
<p>on：标签、列表或数组，默认值为None。DataFrame对象连接的列或索引级别名称。也可以是DataFrame对象长度的数组或数组列表。</p>
<p>left_on：标签、列表或数组，默认值为None。要连接的左数据集的列或索引级名称，也可以是左数据集长度的数组或数组列表。　</p>
<p>right_on：标签、列表或数组，默认值为None。要连接的右数据集的列或索引级名称，也可以是右数据集长度的数组或数组列表。　left_index：布尔型，默认值为False。使用左数据集的索引作为连接键。如果是多重索引，则其他数据中的键数（索引或列数）必须匹配索引级别数。</p>
<p>right_index：布尔型，默认值为False，使用右数据集的索引作为连接键。　</p>
<p>sort：布尔型，默认值为False，在合并结果中按字典顺序对连接键进行排序。如果值为False，则连接键的顺序取决于连接类型how参数。　</p>
<p>suffixes：元组类型，默认值为(‘_x’,’_y’)。当左侧数据集和右侧数据集的列名相同时，数据合并后列名将带上“_x”和“_y”后缀。　</p>
<p>copy：是否复制数据，默认值为True。如果值为False，则不复制数据。　</p>
<p>indicator：布尔型或字符串，默认值为False。如果值为True，则添加一个列以输出名为_Merge的DataFrame对象，其中包含每一行的信息。如果是字符串，将向输出的DataFrame对象中添加包含每一行信息的列，并将列命名为字符型的值。　</p>
<p>validate：字符串，检查合并数据是否为指定类型。可选参数，其值说明如下。　one_to_one或“1:1”：检查合并键在左、右数据集中是否都是唯一的。　one_to_many或“1:m”：检查合并键在左数据集中是否唯一。　many_to_one或“m:1”：检查合并键在右数据集中是否唯一。　many_to_many或“m:m”：允许，但不检查。　</p>
<p>返回值：DataFrame对象，两个合并对象的数据集。</p>
<h4 id="1．常规合并"><a href="#1．常规合并" class="headerlink" title="1．常规合并"></a>1．常规合并</h4><p>运行程序，控制台输出结果如图4.40所示。</p>
<p>【示例37】　通过索引合并数据。 \04\37）<br>如果通过索引列合并，则需要设置right_index参数和left_index参数值为True。例如，上述举例，通过列索引合并，主要代码如下：</p>
<p>01 df_merge=pd.merge(df1,df2,right_index=True,left_index=True)<br>02 print(df_merge)<br>运行程序，控制台输出结果如图4.41所示。</p>
<p>【示例38】　对合并数据去重。 \04\38）<br>从图4.41中的运行结果得知：数据中存在重复列（如编号），如果不想要重复列，可以设置按指定列和列索引合并数据，主要代码如下：</p>
<p>df_merge=pd.merge(df1,df2,on=’编号’,left_index=True,right_index=True)</p>
<p>还可以通过how参数解决这一问题。例如，设置该参数值为left，就是让df1保留所有的行列数据，df2则根据df1的行列进行补全，主要代码如下：</p>
<p>df_merge=pd.merge(df1,df2,on=’编号’,how=’left’)<br>运行程序，控制台输出结果如图4.42所示。</p>
<h4 id="2．多对一的数据合并"><a href="#2．多对一的数据合并" class="headerlink" title="2．多对一的数据合并"></a>2．多对一的数据合并</h4><p>多对一是指两个数据集（df1、df2）的共有列中的数据不是一对一的关系，例如，df1中的“编号”是唯一的，而df2中的“编号”有重复的编号，类似这种就是多对一的关系，示意图如图4.43所示。【示例39】　根据共有列进行合并数据。 \04\39）<br>根据共有列中的数据进行合并，df2根据df1的行列进行补全，程序代码如下：</p>
<h3 id="4-6-2-数据合并（concat-方法）"><a href="#4-6-2-数据合并（concat-方法）" class="headerlink" title="4.6.2　数据合并（concat()方法）"></a>4.6.2　数据合并（concat()方法）</h3><p>concat()方法可以根据不同的方式将数据合并，语法如下：</p>
<p>pandas.concat(objs,axis=0,join=’outer’,ignore_index: bool = False, keys=None, levels=None, names=None,<br>verify_integrity: bool = False, sort: bool = False, copy: bool = True)<br>参数说明：　</p>
<p>objs：Series、DataFrame或Panel对象的序列或映射。如果传递一个字典，则排序的键将用作键参数。　</p>
<p>axis：axis=1表示行，axis=0表示列。默认值为0。　</p>
<p>join：值为inner（内连接）或outer（外连连接），处理其他轴上的索引方式。默认值为outer。　</p>
<p>ignore_index：布尔值，默认值为False，保留索引，索引值为0，…，n-1。如果值为True，则忽略索引。　</p>
<p>keys：序列，默认值为None。使用传递的键作为最外层构建层次索引。如果为多索引，应该使用元组。　</p>
<p>levels：序列列表，默认值为None。用于构建MultiIndex的特定级别（唯一值）；否则，它们将从键推断。　</p>
<p>names：list列表，默认值为None。结果层次索引中的级别的名称。　</p>
<p>verify_integrity：布尔值，默认值为False。检查新连接的轴是否包含重复项。　</p>
<p>sort：布尔值，默认值为True（1.0.0以后版本默认值为False，即不排序）。如果连接为外连接（join=’outer’），则对未对齐的非连接轴进行排序；如果连接为内连接（join=’inner’），则该参数不起作用。</p>
<p>copy：是否复制数据，默认值为True，如果值为False，则不复制数据。</p>
<p>下面介绍concat()方法不同的合并方式，其中dfs代表合并后的DataFrame对象，df1、df2等代表单个DataFrame对象，result代表合并后的结果（DataFrame对象）。</p>
<h4 id="1．相同字段的表首尾相接"><a href="#1．相同字段的表首尾相接" class="headerlink" title="1．相同字段的表首尾相接"></a>1．相同字段的表首尾相接</h4><p>表结构相同的数据将直接合并，表首尾相接，主要代码如下：</p>
<p>01  dfs= [df1, df2, df3]<br>02  result = pd.concat(dfs)<br>例如，表df1、df2和df3结构相同，如图4.47所示。合并后的效果如图4.48所示。如果想要在合并数据时标记源数据来自哪张表，则需要在代码中加入参数keys，例如表名分别为“1月”“2月”“3月”，合并后的效果如图4.49所示。</p>
<p>​                        图4.49　合并后带标记（月份）的效果<br>主要代码如下：</p>
<p>result = pd.concat(dfs, keys=[‘1月’, ‘2月’, ‘3月’])</p>
<h4 id="2．横向表合并（行对齐）"><a href="#2．横向表合并（行对齐）" class="headerlink" title="2．横向表合并（行对齐）"></a>2．横向表合并（行对齐）</h4><p>当合并的数据列名称不一致时，可以设置参数axis=1，concat()方法将按行对齐，然后将不同列名的两组数据进行合并，缺失的数据用NaN填充，df1和df4合并前后效果如图4.50和图4.51所示。</p>
<p>​                        图4.50　横向表合并前</p>
<p>​                            图4.51　横向表合并后<br>主要代码如下：</p>
<p>result = pd.concat([df1, df4], axis=1)</p>
<h4 id="3．交叉合并"><a href="#3．交叉合并" class="headerlink" title="3．交叉合并"></a>3．交叉合并</h4><p>交叉合并，需要在代码中加上join参数，如果值为inner，结果是两张表的交集；如果值为outer，结果是两张表的并集。例如两张表交集，表df1和df4合并前后的效果如图4.52和图4.53所示。</p>
<p>​                                       图4.53　交叉合并后<br>主要代码如下：</p>
<p>result = pd.concat([df1, df4], axis=1, join=’inner’)</p>
<h4 id="4．指定表对齐数据（行对齐）"><a href="#4．指定表对齐数据（行对齐）" class="headerlink" title="4．指定表对齐数据（行对齐）"></a>4．指定表对齐数据（行对齐）</h4><p>如果指定参数join_axes，就可以指定根据哪张表来对齐数据。例如，根据df4对齐数据，就会保留表df4的数据，然后将表df1的数据与之合并，行数不变，合并前后的效果与如图4.54和图4.55所示。</p>
<p>主要代码如下：</p>
<p>result = pd.concat([df1, df4], axis=1, join_axes=[df4.index])</p>
<h2 id="4-7-数据导出"><a href="#4-7-数据导出" class="headerlink" title="4.7　数据导出"></a>4.7　数据导出</h2><h3 id="4-7-1-导出为-xlsx文件"><a href="#4-7-1-导出为-xlsx文件" class="headerlink" title="4.7.1　导出为.xlsx文件"></a>4.7.1　导出为.xlsx文件</h3><p>导出数据为Excel，主要使用DataFrame对象的to_excel()方法，语法如下：</p>
<p>DataFrame.to_excel(excel_writer,sheet_name=’Sheet1’,na_rep=’’,float_format=None,columns=None,header=True,<br>index=True,index_label=None,startrow=0,startcol=0,engine=None,merge_cells=True, encoding=None, inf_rep=’inf’,<br>verbose=True, freeze_panes=None)<br>参数说明：　</p>
<p>excel_writer：字符串或ExcelWriter对象。　</p>
<p>sheet_name：字符串，默认值为Sheet1，包含DataFrame的表的名称。　</p>
<p>na_rep：字符串，默认值为’ ‘。缺失数据的表示方式。　</p>
<p>float_format：字符串，默认值为None，格式化浮点数的字符串。　</p>
<p>columns：序列，可选参数，要编辑的列。　</p>
<p>header：布尔型或字符串列表，默认值为True。列名称，如果给定字符串列表，则表示它是列名称的别名。　</p>
<p>index：布尔型，默认值为True，行名（索引）。　</p>
<p>index_label：字符串或序列，默认值为None。如果需要，可以使用索引列的列标签；如果没有给出，标题和索引为True，则使用索引名称；如果数据文件使用多索引，则需使用序列。</p>
<p>startrow：指定从哪一行开始写入数据。　</p>
<p>startcol：指定从哪一列开始写入数据。　</p>
<p>engine：字符串，默认值为None，指定要使用的写引擎，如openpyxl或xlsxwriter。也可以通过io.excel.xlsx.writer、io.excel.xls.writer和io.excel.xlsm.writer进行设置。　</p>
<p>merge_cells：布尔型，默认值为True。　</p>
<p>encoding：指定Excel文件的编码方式，默认值为None。　</p>
<p>inf_rep：字符串，默认值为“正”，表示无穷大。　</p>
<p>verbose：布尔型，默认值为True。在错误日志中显示更多信息。　freeze_panes：整数的元组，长度2，默认值为None。指定要冻结的行列。</p>
<p>【示例41】　将处理后的数据导出为Excel文件。 \04\41）<br>将数据合并后的结果导出为Excel文件，主要代码如下：</p>
<p>df_merge.to_excel(‘merge.xlsx’)<br>运行程序，数据将导出为Excel文件，如图4.56所示。</p>
<p>df1.to_excel(‘df1.xlsx’,sheet_name=’df1’)</p>
<h3 id="4-7-2-导出为-csv文件"><a href="#4-7-2-导出为-csv文件" class="headerlink" title="4.7.2　导出为.csv文件"></a>4.7.2　导出为.csv文件</h3><p>导出数据为.csv文件，主要使用DataFrame对象的to_csv()方法，语法如下：</p>
<p>path_or_buf：要保存的路径及文件名。　</p>
<p>sep：分隔符，默认值为”,”。　</p>
<p>na_rep：指定空值的输出方式，默认值为空字符串。　</p>
<p>float_format：浮点数的输出格式，要用双引号括起来。　</p>
<p>columns：指定要导出的列，用列名列表表示，默认值为None。　header：是否输出列名，默认值为True。　</p>
<p>index：是否输出索引，默认值为True。　</p>
<p>index_label：索引列的列名，默认值为None。　</p>
<p>mode：Python写入模式，默认值为w。　</p>
<p>encoding：编码方式，默认值为utf-8。　</p>
<p>compression：压缩模式，默认值为infer。　</p>
<p>quoting：导出.csv文件是否用引号，默认值为0，表示不加双引号；如果值为1，则每个字段都会加上引号，数值也会被当作字符串看待。</p>
<p>quotechar：引用字符，当quoting=1时可以指定引号字符为双引号（” “）或单引号（’ ‘）。　</p>
<p>line_terminator：换行符，默认值为\n。</p>
<p>chunksize：一次写入.csv文件的行数，当DataFrame对象数据特别大时需要分批写入。　</p>
<p>date_format：日期输出格式。　</p>
<p>doublequote：是否添加双引用符，默认值为True。　</p>
<p>escapechar：设置转义字符。　</p>
<p>decimal：可识别十进制分隔符的字符。　</p>
<p>errors：指定如何处理编码和解码错误，默认值为strict（严格的）。</p>
<p>【示例42】　将处理后的数据导出为.csv文件。 \04\42）<br>下面介绍to_csv()方法常用功能，举例如下，df为DataFrame对象。<br>（1）相对位置，保存在程序所在路径下，代码如下：</p>
<p>df.to_csv(‘Result.csv’)<br>（2）绝对位置，代码如下：</p>
<p>df.to_csv(‘d:\Result.csv’)<br>（3）分隔符。使用问号（？）分隔符分隔需要保存的数据，代码如下：</p>
<p>df.to_csv(‘Result.csv’,sep=’?’)``<br>（4）替换空值，缺失值保存为NA，代码如下：</p>
<p>df.to_csv(‘Result1.csv’,na_rep=’NA’)<br>（5）格式化数据，保留两位小数，代码如下：</p>
<p>df.to_csv(‘Result1.csv’,float_format=’%.2f’)<br>（6）保留某列数据，保存索引列和name列，代码如下：</p>
<p>df.to_csv(‘Result.csv’,columns=[‘name’])<br>（7）是否保留列名，不保留列名，代码如下：</p>
<p>df.to_csv(‘Result.csv’,header=False)<br>（8）是否保留行索引，不保留行索引，代码如下：</p>
<p>df.to_csv(‘Result.csv’,index=False)</p>
<h3 id="4-7-3-导出多个Sheet"><a href="#4-7-3-导出多个Sheet" class="headerlink" title="4.7.3　导出多个Sheet"></a>4.7.3　导出多个Sheet</h3><p>导出多个Sheet，应首先使用pd.ExcelWriter()方法打开一个Excel文件，然后再使用to_excel()方法导出指定的Sheet。</p>
<h2 id><a href="#" class="headerlink" title></a></h2><h3 id="4-8-1-DataFrame的日期数据转换"><a href="#4-8-1-DataFrame的日期数据转换" class="headerlink" title="4.8.1　DataFrame的日期数据转换"></a>4.8.1　DataFrame的日期数据转换</h3><p>日常工作中，有一个非常麻烦的事情就是日期的格式可以有很多种表达，我们看到同样是2020年2月14日，可以有很多种格式，如图4.57所示。那么，我们需要先将这些格式统一后才能进行后续的工作。Pandas提供了to_datetime()方法可以帮助我们解决这一问题。<br>to_datetime()方法可以用来批量处理日期数据转换，对于处理大数据非常实用和方便，它可以将日期数据转换成你需要的各种格式。例如，将2/14/20和14-2-2020转换为日期格式2020-02-14。to_datetime()方法的语法如下：</p>
<p>pandas.to_datetime(arg,errors=’ignore’,dayfirst=False,yearfirst=False,utc=None,box=True,format=None,exact=<br>True,unit=None,infer_datetime_format=False,origin=’unix’,cache=False)<br>参数说明：　</p>
<p>arg：字符串、日期时间、字符串数组。　</p>
<p>errors：值为ignore、raise或coerce，具体说明如下，默认值为ignore，即忽略错误。　</p>
<p>ignore：无效的解析将返回原值。　</p>
<p>raise：无效的解析将引发异常。　</p>
<p>coerce：无效的解析将被设置为NaT，即无法转换为日期的数据将被转换为NaT。　</p>
<p>dayfirst：第一个为天，布尔型，默认值为False。例如02/09/2020，如果值为True，则解析日期的第一个为天，即2020-09-02；如果值为False，则解析日期与原日期一致，即2020-02-09。　</p>
<p>yearfirst：第一个为年，布尔型，默认值为False。例如14-Feb-20，如果值为True，则解析日期的第一个为年，即2014-02-20；如果值为False，则解析日期与原日期一致，即2020-02-14。　</p>
<p>utc：默认值为None。返回utc即协调世界时间。　</p>
<p>box：布尔值，默认值为True，如果值为True，则返回DatetimeIndex；如果值为False，则返回ndarray。　</p>
<p>format：格式化显示时间的格式。字符串，默认值为None。　</p>
<p>exact：布尔值，默认值为True。如果为True，则要求格式完全匹配；如果为False，则允许格式与目标字符串中的任何位置匹配。　</p>
<p>unit：默认值为None，参数的单位（D、s、、ms、μs、ns）表示时间的单位。　</p>
<p>infer_datetime_format：默认值为False。如果没有格式，则尝试根据第一个日期时间字符串推断格式。　</p>
<p>origin：默认值为unix。定义参考日期。数值将被解析为单位数。　</p>
<p>cache：默认值为False。如果值为True，则使用唯一、转换日期的缓存应用日期时间转换。在解析重复日期字符串，特别是带有时区偏移的字符串时，可能会产生明显的加速。只有在至少有50个值时才使用缓存。越界值的存在将使缓存不可用，并可能减慢解析速度。　</p>
<p>返回值：日期时间。</p>
<p>​                                        图4.59　日期组合</p>
<h3 id="4-8-2-dt对象"><a href="#4-8-2-dt对象" class="headerlink" title="4.8.2　dt对象"></a>4.8.2　dt对象</h3><p>dt对象是Series对象中用于获取日期属性的一个访问器对象，通过它可以获取日期中的年、月、日、星期数、季节等，还可以判断日期是否处在年底。语法如下：</p>
<p>  Series.dt()<br>参数说明：　</p>
<p>返回值：返回与原始系列相同的索引系列。如果Series不包含类日期值，则引发错误。　</p>
<p>dt对象提供了year、month、day、dayofweek、dayofyear、is_leap_year、quarter、weekday_name等属性和方法。</p>
<p>例如，year可以获取“年”、month可以获取“月”、quarter可以直接得到每个日期分别是第几个季度，weekday_name可以直接得到每个日期对应的是周几。</p>
<p>【示例46】　获取日期中的年、月、日、星期数等。 \04\46）<br>使用dt对象获取日期中的年、月、日、星期数、季节等。<br>（1）获取年、月、日，代码如下：</p>
<p>df[‘年’],df[‘月’],df[‘日’]=df[‘日期’].dt.year,df[‘日期’].dt.month,df[‘日期’].dt.day<br>（2）从日期判断出所处星期数，代码如下：</p>
<p>df[‘星期几’]=df[‘日期’].dt.day_name()<br>（3）从日期判断所处季度，代码如下：</p>
<p>df[‘季度’]=df[‘日期’].dt.quarter<br>（4）从日期判断是否为年底最后一天，代码如下：</p>
<p>df[‘是否年底’]=df[‘日期’].dt.is_year_end<br>运行程序，控制台输出结果如图4.60所示。</p>
<p>​                               图4.60　dt对象日期转换</p>
<h3 id="4-8-3-获取日期区间的数据"><a href="#4-8-3-获取日期区间的数据" class="headerlink" title="4.8.3　获取日期区间的数据"></a>4.8.3　获取日期区间的数据</h3><p>获取日期区间的数据的方法是直接在DataFrame对象中输入日期或日期区间，但前提必须设置日期为索引，举例如下。　</p>
<p>获取2018年的数据。</p>
<p>df1[‘2018’]　</p>
<p>获取2017—2018年的数据。</p>
<p>df1[‘2017’:’2018’]　</p>
<p>获取某月（2018年7月）的数据。</p>
<p>df1[‘2018-07’]　</p>
<p>获取具体某天（2018年5月6日）的数据。</p>
<p>df1[‘2018-05-06’:’2018-05-06’]</p>
<h3 id="4-8-4-按不同时期统计并显示数据"><a href="#4-8-4-按不同时期统计并显示数据" class="headerlink" title="4.8.4　按不同时期统计并显示数据"></a>4.8.4　按不同时期统计并显示数据</h3><h4 id="1．按时期统计数据"><a href="#1．按时期统计数据" class="headerlink" title="1．按时期统计数据"></a>1．按时期统计数据</h4><p>按时期统计数据主要通过DataFrame对象的resample()方法结合数据计算函数实现。resample()方法主要应用于时间序列频率转换和重采样，它可以从日期中获取年、月、日、星期、季节等，结合数据计算函数就可以实现按年、月、日、星期或季度等不同时期统计数据。举例如下所示。<br>（1）按年统计数据，代码如下：</p>
<p>df1=df1.resample(‘AS’).sum()<br>（2）按季度统计数据，代码如下：</p>
<p>df2.resample(‘Q’).sum()<br>（3）按月度统计数据，代码如下：</p>
<p>df1.resample(‘M’).sum()<br>（4）按星期统计数据，代码如下：</p>
<p>df1.resample(‘W’).sum()<br>（5）按天统计数据，代码如下：</p>
<p>df1.resample(‘D’).sum()</p>
<p>完整错误描述：<br>TypeError: Only valid with DatetimeIndex, TimedeltaIndex or PeriodIndex, but got an instance of’Index’<br>出现上述错误，是由于<strong>resample()函数要求索引必须为日期型</strong>。<br>解决方法：将数据的索引转换为datetime类型，主要代码如下：</p>
<p>df1.index = pd.to_datetime(df1.index)</p>
<h4 id="2．按时期显示数据"><a href="#2．按时期显示数据" class="headerlink" title="2．按时期显示数据"></a>2．按时期显示数据</h4><p>DataFrame对象的to_period()方法可以将时间戳转换为时期，从而实现按时期显示数据，前提是日期必须设置为索引。语法如下：</p>
<p>DataFrame.to_period(freq=None, axis=0, copy=True)<br>参数说明：　</p>
<p>freq：字符串，周期索引的频率，默认值为None。　</p>
<p>axis：行列索引，axis=0表示行索引，axis=1表示列索引。默认值为0，即表示行索引。　</p>
<p>copy：是否复制数据，默认值为True，如果值为False，则不复制数据。　返回值：带周期索引的时间序列。</p>
<p>【示例48】　从日期中获取不同的时期。 \04\48）<br>从日期中获取不同的时期，主要代码如下：</p>
<p><img src="/2021/12/09/pandas/文档\第四章-Pandas统计分析.assets\image-20211020052452293.png" alt="image-20211020052452293"></p>
<h4 id="3．按时期统计并显示数据"><a href="#3．按时期统计并显示数据" class="headerlink" title="3．按时期统计并显示数据"></a>3．按时期统计并显示数据</h4><p>（1）按年统计并显示数据，代码如下：</p>
<p>df2.resample(‘AS’).sum().to_period(‘A’)<br>控制台输出结果如图4.63所示。<br>（2）按季度统计并显示数据，代码如下：</p>
<p>Q_df=df2.resample(‘Q’).sum().to_period(‘Q’)</p>
<p>（3）按月统计并显示数据，代码如下：</p>
<p>df2.resample(‘M’).sum().to_period(‘M’)<br>控制台输出结果如图4.65所示。<br>（4）按星期统计并显示数据（前5条数据），代码如下：</p>
<p>df2.resample(‘W’).sum().to_period(‘W’).head()</p>
<h2 id="4-9-时间序列"><a href="#4-9-时间序列" class="headerlink" title="4.9　时间序列"></a>4.9　时间序列</h2><h3 id="4-9-1-重采样（Resample-方法）"><a href="#4-9-1-重采样（Resample-方法）" class="headerlink" title="4.9.1　重采样（Resample()方法）"></a>4.9.1　重采样（Resample()方法）</h3><p>通过前面的学习，我们学会了如何生成不同频率的时间索引，按小时、按天、按周、按月等，如果想对数据做不同频率的转换，该怎么办？在Pandas中对时间序列的频率的调整称为重新采样，即将时间序列从一个频率转换到另一个频率的处理过程。例如，每天一个频率转换为每5天一个频率，如图4.67所示。</p>
<p>​                                       图4.67　时间频率<br>重采样主要使用resample()方法，该方法用于对常规时间序列重新采样和频率转换，包括降采样和升采样两种。首先了解下resample()方法，语法如下：</p>
<p>DataFrame.resample(rule,how=None,axis=0,fill_method=None,closed=None,label=None,convention=’start’,kind=<br>None,loffset=None,limit=None,base=0,on=None,level=None)<br>参数说明：　</p>
<p>rule：字符串，偏移量表示目标字符串或对象转换。　</p>
<p>how：用于产生聚合值的函数名或数组函数。例如mean、ohlc和np.max等，默认值为mean，其他常用的值为first、last、median、max和min。　</p>
<p>axis：整型，表示行列，axis=0表示列，axis=1表示行。默认值为0，即表示列。　fill_method：升采样时所使用的填充方法，ffill()方法（用前值填充）或bfill()方法（用后值填充），默认值为None。　</p>
<p>closed：降采样时，时间区间的开和闭，与数学里区间的概念一样，其值为right或left，right表示左开右闭（即左边值不包括在内），left表示左闭右开（即右边值不包括在内），默认值为right左开右闭。　</p>
<p>label：降采样时，如何设置聚合值的标签。例如，10:30—10:35会被标记成10:30还是10:35，默认值为None。　</p>
<p>convention：当重采样时，将低频率转换到高频率所采用的约定，其值为start或end，默认值为start。　</p>
<p>kind：聚合到时期（period）或时间戳（timestamp），默认聚合到时间序列的索引类型，默认值为None。　</p>
<p>loffset：聚合标签的时间校正值，默认值为None。例如，-1s或Second(-1)用于将聚合标签调早1秒。　</p>
<p>limit：向前或向后填充时，允许填充的最大时期数，默认值为None。</p>
<p>　base：整型，默认值为0。对于均匀细分1天的频率，聚合间隔的“原点”。例如，对于5min频率，base的范围可以是0～4。　on：字符串，可选参数，默认值为None。对DataFrame对象使用列代替索引进行重新采样。列必须与日期时间类似。　</p>
<p>level：字符串或整型，可选参数，默认值为None。用于多索引，重新采样的级别名称或级别编号，级别必须与日期时间类似。　</p>
<p>返回值：重新采样对象。</p>
<p>​                          图4.68　时间序列转换程序代码如下：</p>
<p>01  import pandas as pd<br>02  index = pd.date_range(‘02/02/2020’, periods=9, freq=’T’)</p>
<p>03  series = pd.Series(range(9), index=index)<br>04  print(series)<br>05  print(series.resample(‘3T’).sum())</p>
<h3 id="4-9-2-降采样处理"><a href="#4-9-2-降采样处理" class="headerlink" title="4.9.2　降采样处理"></a>4.9.2　降采样处理</h3><p>降采样是周期由高频率转向低频率。例如，将5min股票交易数据转换为日交易，按天统计的销售数据转换为按周统计。<br>数据降采样会涉及数据的聚合。例如，天数据变成周数据，那么就要对1周7天的数据进行聚合，聚合的方式主要包括求和、求均值等。例如，淘宝店铺每天销售数据（部分数据），如图4.69所示。</p>
<p>【示例50】　按周统计销售数据。 \04\50）<br>使用resample()方法来做降采样处理，频率为“周”，也就是将上述销售数据处理为每周（每7天）求和一次数据，程序代码如下：</p>
<p>01 import pandas as pd<br>02 df=pd.read_excel(‘time.xls’)<br>03 df1 = df.set_index(‘订单付款时间’)  #设置“订单付款时间”为索引<br>04 print(df1.resample(‘W’).sum().head())<br>运行程序，控制台输出结果如图4.70所示。<br>在参数说明中，我们列出了closed参数的解释，如果把closed参数值设置为left，结果如图4.71所示。</p>
<p>​              图4.69　淘宝店铺每天销售数据（部分数据）</p>
<p>​                                       图4.70　周数据统计1</p>
<p>​                              图4.71　周数据统计2</p>
<h3 id="4-9-3-升采样处理"><a href="#4-9-3-升采样处理" class="headerlink" title="4.9.3　升采样处理"></a>4.9.3　升采样处理</h3><p>​    升采样是周期由低频率转向高频率。将数据从低频率转换到高频率时，就不需要聚合了，将其重采样到日频率，默认会引入缺失值。<br>例如，原来是按周统计的数据，现在变成按天统计。升采样会涉及数据的填充，根据填充的方法不同，填充的数据也不同。下面介绍3种填充方法。　不填充。空值用NaN代替，使用asfreq()方法。　用前值填充。用前面的值填充空值，使用ffill()方法或者pad()方法。为了方便记忆，ffill()方法可以使用它的第一个字母“f”代替，代表forward，向前的意思。　用后值填充，使用bfill()方法，可以使用字母“b”代替，代表back，向后的意思。</p>
<p>【示例51】　每6小时统计一次数据。 \04\51）<br>下面创建一个时间序列，起始日期是2020-02-02，一共两天，每天对应的数值分别是1和2，通过升采样处理为每6小时统计一次数据，空值以不同的方式填充，程序代码如下：</p>
<p>01  import pandas as pd<br>02  import numpy as np<br>03  rng = pd.date_range(‘20200202’, periods=2)<br>05  s1_6h_asfreq = s1.resample(‘6H’).asfreq()</p>
<p>06  print(s1_6h_asfreq)<br>07  s1_6h_pad = s1.resample(‘6H’).pad()<br>08  print(s1_6h_pad)<br>09  s1_6h_ffill = s1.resample(‘6H’).ffill()<br>10  print(s1_6h_ffill)<br>11  s1_6h_bfill = s1.resample(‘6H’).bfill()<br>12  print(s1_6h_bfill)<br>运行程序，控制台输出结果如图4.72所示。</p>
<p>​                          图4.72　6小时数据统计</p>
<h3 id="4-9-4-时间序列数据汇总（ohlc-函数）"><a href="#4-9-4-时间序列数据汇总（ohlc-函数）" class="headerlink" title="4.9.4　时间序列数据汇总（ohlc()函数）"></a>4.9.4　时间序列数据汇总（ohlc()函数）</h3><p>在金融领域，经常会看到开盘（open）、收盘（close）、最高价（high）和最低价（low）数据，而在Pandas中经过重新采样的数据也可以实现这样的结果，通过调用ohlc()函数得到数据汇总结果，即开始值（open）、结束值（close）、最高值（high）和最低值（low）。ohlc()函数的语法如下：</p>
<p>resample.ohlc()<br>ohlc()函数返回DataFrame对象，每组数据的open（开）、high（高）、low（低）和close（关）值。</p>
<p>【示例52】　统计数据的open、high、low和close值。 \04\52）<br>下面是一组5分钟的时间序列，通过ohlc()函数获取该时间序列中每组时间的开始值、最高值、最低值和结束值，程序代码如下：</p>
<p>01  import pandas as pd<br>02  import numpy as np<br>03  rng = pd.date_range(‘2/2/2020’,periods=12,freq=’T’)<br>04  s1 = pd.Series(np.arange(12),index=rng)<br>05  print(s1.resample(‘5min’).ohlc())<br>运行程序，控制台输出结果如图4.73所示。</p>
<p>​                          图4.73　时间序列数据汇总</p>
<h3 id="4-9-5-移动窗口数据计算（rolling-函数）"><a href="#4-9-5-移动窗口数据计算（rolling-函数）" class="headerlink" title="4.9.5　移动窗口数据计算（rolling()函数）"></a>4.9.5　移动窗口数据计算（rolling()函数）</h3><p>通过重采样可以得到想要的任何频率的数据，但是这些数据也是一个时点的数据，那么就存在这样一个问题：时点的数据波动较大，某一点的数据就不能很好地表现它本身的特性，于是就有了“移动窗口”的概念，简单地说，为了提升数据的可靠性，将某个点的取值扩大到包含这个点的一段区间，用区间来进行判断，这个区间就是窗口。<br>下面举例说明，图4.74显示了移动窗口数据示意图，其中时间序列代表1号到15号每天的销量数据，接下来以3天为一个窗口，将该窗口从左至右依次移动，统计出3天的平均值作为这个点的值，如3号的销量是1号、2号和3号的平均值。</p>
<p>通过上述示意图相信您已经理解了移动窗口，在Pandas中可以通过rolling()函数实现移动窗口数据的计算，语法如下：</p>
<p>DataFrame.rolling(window, min_periods=None, center=False, win_type=None, on=None, axis=0, closed=None)</p>
<p>参数说明：　</p>
<p>window：时间窗口的大小，有两种形式，即int或offset。如果使用int，则数值表示计算统计量的观测值的数量，即向前几个数据；如果使用offset，则表示时间窗口的大小。　</p>
<p>min_periods：每个窗口最少包含的观测值数量，小于这个值的窗口结果为NA。值可以是int，默认值为None。offset情况下，默认值为1。</p>
<p>center：把窗口的标签设置为居中。布尔型，默认值为False，居右。</p>
<p>win_type：窗口的类型。截取窗的各种函数。字符串类型，默认值为None。　</p>
<p>on：可选参数。对于DataFrame对象，是指定要计算移动窗口的列，值为列名。　</p>
<p>axis：整型，axis=0表示列，axis=1表示行。默认值为0，即对列进行计算。　</p>
<p>closed：定义区间的开闭，支持int类型的窗口。对于offset类型默认是左开右闭（默认值为right）。可以根据情况指定left。　</p>
<p>返回值：为特定操作而生成的窗口或移动窗口子类。</p>
<p>【示例53】　创建淘宝每日销量数据。 \04\53）<br>首先创建一组淘宝每日销量数据，程序代码如下：</p>
<p>01  import pandas as pd<br>02  index=pd.date_range(‘20200201’,’20200215’)<br>03  data=[3,6,7,4,2,1,3,8,9,10,12,15,13,22,14]<br>04  s1_data=pd.Series(data,index=index)<br>05  print(s1_data)<br>运行程序，控制台输出结果如图4.75所示。</p>
<p>【示例54】　使用rolling()函数计算3天的均值。 \04\54）</p>
<p>下面使用rolling()函数计算2020-02-01至2020-02-15中每3天的均值，窗口个数为3，代码如下：</p>
<p>s1_data.rolling(3).mean()<br>运行程序，看下rolling()函数是如何计算的？在图4.76中，当窗口开始移动时，第一个时间点2020-02-01和第二个时间点2020-02-02的数值为空，这是因为窗口个数为3，它们前面有空数据，所以均值为空；而到第三个时间点2020-02-03时，它前面的数据是2020-02-01至</p>
<p>​                       图4.76　2020-02-01至2020-02-15移动窗口均值1</p>
<p>【示例55】　用当天的数据代表窗口数据。 \04\55）<br>在计算第一个时间点2020-02-01的窗口数据时，虽然数据不够窗口长度3，但是至少有当天的数据，那么能否用当天的数据代表窗口数据呢？答案是肯定的，通过设置min_periods参数即可，它表示窗口最少包含的观测值，小于这个值的窗口长度显示为空，等于或大于时都有值，主要代码如下：</p>
<p>s1_data.rolling(3,min_periods=1).mean()</p>
<p>运行程序，对比效果如图4.77所示。<br>上述举例，我们再扩展下，通过图表观察原始数据与移动窗口数据的平稳性，如图4.78所示。其中实线代表移动窗口数据，其走向更平稳，这也是学习移动窗口rolling()函数的原因。</p>
<h2 id="4-10-综合应用"><a href="#4-10-综合应用" class="headerlink" title="4.10　综合应用"></a>4.10　综合应用</h2><h3 id="4-10-1-案例1：Excel多表合并"><a href="#4-10-1-案例1：Excel多表合并" class="headerlink" title="4.10.1　案例1：Excel多表合并"></a>4.10.1　案例1：Excel多表合并</h3><p>案例位置：资源包\MR\Code\04\example\01<br>在日常工作中，几乎我们每天都有大量的数据需要处理，桌面上总是布满密密麻麻的Excel表，这样看上去非常凌乱，其实我们完全可以将其中类别相同的Excel表合并到一起，这样不但不会丢失数据，而且还可以有效地分析数据。下面使用concat()方法将指定文件夹内的所有Excel表合并，程序代码如下：</p>
<h3 id="4-10-2-案例2：股票行情数据分析"><a href="#4-10-2-案例2：股票行情数据分析" class="headerlink" title="4.10.2　案例2：股票行情数据分析"></a>4.10.2　案例2：股票行情数据分析</h3><p>案例位置：资源包\MR\Code\04\example\02<br>股票数据包括开盘价、收盘价、最高价、最低价、成交量等多个指标。其中，收盘价是当日行情的标准，也是下一个交易日开盘价的依据，可以预测未来证券市场行情，因此当投资者对行情分析时，一般采用收盘价作为计算依据。<br>下面使用rolling()函数计算某股票20天、50天和200天的收盘价均值并生成走势图（也称K线图），如图4.79所示。</p>
]]></content>
      <categories>
        <category>数据分析文档</category>
      </categories>
  </entry>
  <entry>
    <title>pandas统计分析</title>
    <url>/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>第四章 Pandas统计分析</p>
<h2 id="4-1-数据计算"><a href="#4-1-数据计算" class="headerlink" title="4.1 数据计算"></a>4.1 数据计算</h2><p>Pandas提供了大量的数据计算函数，可以实现求和、求均值、求最大值、求最小值、求中位数、求众数、求方差、标准差等，从而使得数据统计变得简单高效。</p>
<h3 id="4-1-1求和函数（sum"><a href="#4-1-1求和函数（sum" class="headerlink" title="4.1.1求和函数（sum())"></a>4.1.1求和函数（sum())</h3><p>DataFrame.sum(axis=None, skipna=None, level=None, numeric_only=None, min_count=0, **kwargs)<br>参数说明：　</p>
<p>axis：axis=1表示行，axis=0表示列，默认值为None（无）。　skipna：布尔型，表示计算结果是否排除NaN/Null值，默认值为None。</p>
<p>level：表示索引层级，默认值为None。　</p>
<p>numeric_only：仅数字，布尔型，默认值为None。　</p>
<p>min_count：表示执行操作所需的数目，整型，默认值为0。　**kwargs：要传递给函数的附加关键字参数。　</p>
<p>返回值：返回Series对象或DataFrame对象。行或列求和数据。</p>
<p>【示例01】　计算语文、数学和英语三科的总成绩。（示例位置：资源包\MR\Code\04\01）<br>首先，创建一组DataFrame类型的数据，包括语文、数学和英语三科的成绩，如图4.1所示。<br>程序代码如下：</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020032035450.png" alt="image-20211020032035450">下面使用sum()函数计算三科的总成绩，代码如下：</p>
<p>df[‘总成绩’]=df.sum(axis=1)</p>
<p>运行程序，输出结果如图4.2所示。</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020032210845.png" alt="image-20211020032210845"></p>
<p>​                                        图4.1　DataFrame数据</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020032230748.png" alt="image-20211020032230748"></p>
<p>​                                  图4.2　sum()函数计算三科的总成绩</p>
<h3 id="4-1-2-求均值（mean-函数）"><a href="#4-1-2-求均值（mean-函数）" class="headerlink" title="4.1.2　求均值（mean()函数）"></a>4.1.2　求均值（mean()函数）</h3><p>DataFrame.mean(axis=None, skipna=None, level=None, numeric_only=None, kwargs)<br>参数说明：　</p>
<p>axis：axis=1表示行，axis=0表示列，默认值为None（无）。　</p>
<p>skipna：布尔型，表示计算结果是否排除NaN/Null值，默认值为None。　</p>
<p>level：表示索引层级，默认值为None。　</p>
<p>numeric_only：仅数字，布尔型，默认值为None。　</p>
<p>kwargs：要传递给函数的附加关键字参数。　</p>
<p>返回值：返回Series对象或DataFrame对象。行或列平均值数据。</p>
<p>【示例02】　计算语文、数学和英语各科的平均分。（示例位置：资源包\MR\Code\04\02）<br>计算语文、数学和英语各科成绩的平均值，程序代码如下：</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020032641368.png" alt="image-20211020032641368"></p>
<p>运行程序，输出结果如图4.3所示。</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020032714762.png" alt="image-20211020032714762"></p>
<p>​                             图4.3　mean()函数计算三科成绩的平均值<br>从运行结果得知：语文平均分109，数学平均分107，英语平均分114.667。</p>
<h3 id="4-1-3-求最大值（max-函数）"><a href="#4-1-3-求最大值（max-函数）" class="headerlink" title="4.1.3　求最大值（max()函数）"></a>4.1.3　求最大值（max()函数）</h3><p>在Python中通过调用DataFrame对象的max()函数实现行／列数据最大值运算，语法如下：</p>
<p>DataFrame.max(axis=None, skipna=None, level=None, numeric_only=None, **kwargs)<br>参数说明：　**</p>
<p>**axis：axis=1表示行，axis=0表示列，默认值为None（无）。　skipna：布尔型，表示计算结果是否排除NaN/Null值，默认值为None。　</p>
<p>**level：表示索引层级，默认值为None。　</p>
<p>**numeric_only：仅数字，布尔型，默认值为None。　</p>
<p>kwargs：要传递给函数的附加关键字参数。　</p>
<p>返回值：返回Series对象或DataFrame对象。行或列最大值数据。</p>
<p>【示例03】　计算语文、数学和英语各科的最高分。（示例位置：资源包\MR\Code\04\03）<br>计算语文、数学和英语各科成绩的最大值，程序代码如下：</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020032850843.png" alt="image-20211020032850843"></p>
<p>运行程序，输出结果如图4.4所示。</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020033031795.png" alt="image-20211020033031795"></p>
<p>​                       图4.4　max()函数计算三科成绩的最大值</p>
<p>4.1.4　求最小值（min()函数）<br>在Python中通过调用DataFrame对象的min()函数实现行／列数据最小值运算，语法如下：</p>
<p>DataFrame.min(axis=None, skipna=None, level=None, numeric_only=None, **kwargs)<br>参数说明：　**</p>
<p>**axis：axis=1表示行，axis=0表示列，默认值为None（无）。　skipna：布尔型，表示计算结果是否排除NaN/Null值，默认值为None。　</p>
<p>**level：表示索引层级，默认值为None。　</p>
<p>**numeric_only：仅数字，布尔型，默认值为None。　</p>
<p>kwargs：要传递给函数的附加关键字参数。　</p>
<p>返回值：返回Series对象或DataFrame对象。行或列最小值数据。</p>
<p>【示例04】　计算语文、数学和英语各科的最低分。（示例位置：资源包\MR\Code\04\04）<br>计算语文、数学和英语各科成绩的最小值，程序代码如下：</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020033254349.png" alt="image-20211020033254349"></p>
<p>运行程序，输出结果如图4.5所示。</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020033314763.png" alt="image-20211020033314763"></p>
<h3 id="4-1-5-求中位数（median-函数）"><a href="#4-1-5-求中位数（median-函数）" class="headerlink" title="4.1.5　求中位数（median()函数）"></a>4.1.5　求中位数（median()函数）</h3><p>中位数又称中值，是统计学专有名词，是指按顺序排列的一组数据中位于中间位置的数，其不受异常值的影响。例如，年龄23、45、35、25、22、34、28这7个数，中位数就是排序后位于中间的数字，即28；而年龄23、45、35、25、22、34、28、27这8个数，中位数则是排序后位于中间两个数的平均值，即27.5。在Python中直接调用DataFrame对象的median()函数就可以轻松实现中位数的运算，语法如下：</p>
<p>DataFrame.median(axis=None,skipna=None,level=None,numeric_only=None,**kwargs)<br>参数说明：　**</p>
<p>**axis：axis=1表示行，axis=0表示列，默认值为None（无）。　skipna：布尔型，表示计算结果是否排除NaN/Null值，默认值为None。　</p>
<p>**level：表示索引层级，默认值为None。　</p>
<p>**numeric_only：仅数字，布尔型，默认值为None。　</p>
<p>kwargs：要传递给函数的附加关键字参数。　</p>
<p>返回值：返回Series对象或DataFrame对象。</p>
<p>【示例05】　计算学生各科成绩的中位数1。（示例位置：资源包\MR\Code\04\05）<br>下面给出一组数据（3条记录），然后使用median()函数计算语文、数学和英语各科成绩的中位数，程序代码如下：</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020033458773.png" alt="image-20211020033458773"></p>
<p>运行程序，控制台输出结果如下：</p>
<p>语文    130.0数学    120.0英语    130.0</p>
<p>【示例06】　计算学生各科成绩的中位数2。（示例位置：资源包\MR\Code\04\06）<br>下面再给出一组数据（4条记录），同样使用median()函数计算语文、数学和英语各科成绩的中位数，程序代码如下：</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020033625031.png" alt="image-20211020033625031"></p>
<p>运行程序，控制台输出结果如下：</p>
<p>语文    121.5数学    121.5英语    120.0</p>
<h3 id="4-1-6-求众数（mode-函数）"><a href="#4-1-6-求众数（mode-函数）" class="headerlink" title="4.1.6　求众数（mode()函数）"></a>4.1.6　求众数（mode()函数）</h3><p>什么是众数？众数的众字有多的意思，顾名思义，众数就是一组数据中出现最多的数称为众数，它代表了数据的一般水平。<br>在Python中通过调用DataFrame对象的mode()函数可以实现众数运算，语法如下：</p>
<p>DataFrame.mode(axis=0,numeric_only=False,dropna=True)<br>参数说明：　</p>
<p>axis：axis=1表示行，axis=0表示列，默认值为0。　</p>
<p>numeric_only：仅数字，布尔型，默认值为False。如果值为True，则仅适用于数字列。　</p>
<p>dropna：是否删除缺失值，布尔型，默认值为True。　</p>
<p>返回值：返回Series对象或DataFrame对象。<br>首先看一组原始数据，如图4.6所示。</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020033849240.png" alt="image-20211020033849240"></p>
<p>【示例07】　计算学生各科成绩的众数。（示例位置：资源包\MR\Code\04\07）<br>计算语文、数学和英语三科成绩的众数、每一行的众数和“数学”成绩的众数，程序代码如下：</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020034005721.png" alt="image-20211020034005721"></p>
<p>三科成绩的众数：<br>每一行的众数：</p>
<p>0  110<br>1  130<br>2  130<br>数学成绩的众数：</p>
<p>0  120</p>
<h3 id="4-1-7-求方差（var-函数）"><a href="#4-1-7-求方差（var-函数）" class="headerlink" title="4.1.7　求方差（var()函数）"></a>4.1.7　求方差（var()函数）</h3><p>方差用于衡量一组数据的离散程度，即各组数据与它们的平均数的差的平方，那么我们用这个结果来衡量这组数据的波动大小，并把它叫作这组数据的方差，方差越小越稳定。通过方差可以了解一个问题的波动性。下面简单介绍下方差的意义，相信通过一个简单的举例您就会了解。<br>例如，某校两名同学的物理成绩都很优秀，而参加物理竞赛的名额只有一个，那么选谁去获得名次的机率更大呢？于是根据历史数据计算出了两名同学的平均成绩，但结果是实力相当，平均成绩都是107.6，怎么办呢？这时让方差帮决定，看看谁的成绩更稳定。首先汇总物理成绩，如图4.7所示。</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020034219502.png" alt="image-20211020034219502"></p>
<p>​                                            图4.7　物理成绩<br>通过方差对比两名同学物理成绩的波动，如图4.8所示。</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020034235082.png" alt="image-20211020034235082"></p>
<p>​                                                   图4.8　方差<br>接着来看一下总体波动（方差和），“小黑”的数据是73.2，“小白”的数据是949.2，很明显“小黑”的物理成绩波动较小，发挥更稳定，所以应该选“小黑”参加物理竞赛。<br>以上举例就是方差的意义。大数据时代，它能够帮助我们解决很多身边的问题、协助我们做出合理的决策。<br>在Python中通过调用DataFrame对象的var()函数可以实现方差运算，语法如下：</p>
<p><strong>DataFrame.var(axis=None,skipna=None,level=None,ddof=1,numeric_only=None,kwargs)</strong><br>参数说明：　</p>
<p>axis：axis=1表示行，axis=0表示列，默认值为None（无）。　skipna：布尔型，表示计算结果是否排除NaN/Null值，默认值为None。　</p>
<p>level：表示索引层级，默认值为None。　</p>
<p>ddof：整型，默认值为1。自由度，计算中使用的除数是N-ddof，其中N表示元素的数量。　</p>
<p>numeric_only：仅数字，布尔型，默认值为None。　</p>
<p>kwargs：要传递给函数的附加关键字参数。　</p>
<p>返回值：返回Series对象或DataFrame对象。</p>
<p>【示例08】　通过方差判断谁的物理成绩更稳定。（示例位置：资源包\MR\Code\04\08）<br>计算“小黑”和“小白”物理成绩的方差，程序代码如下：</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020034435272.png" alt="image-20211020034435272"></p>
<p>运行程序，控制台输出结果如下：</p>
<p>小黑     18.3小白    237.3<br>从运行结果得知：“小黑”的物理成绩波动较小，发挥更稳定。这里需要注意的是，Pandas中计算的方差为无偏样本方差（即方差和／样本数-1），NumPy中计算的方差就是样本方差本身（即方差和／样本数）。</p>
<h3 id="4-1-8-标准差（数据标准化std-函数）"><a href="#4-1-8-标准差（数据标准化std-函数）" class="headerlink" title="4.1.8　标准差（数据标准化std()函数）"></a>4.1.8　标准差（数据标准化std()函数）</h3><p>标准差又称均方差，是方差的平方根，用来表示数据的离散程度。<br>在Python中通过调用DataFrame对象的std()函数求标准差，语法如下：</p>
<p>DataFrame.std(axis=None,skipna=None,level=None,ddof=1,numeric_only=None,**kwargs)<br>std()函数的参数与var()函数一样，这里不再赘述。</p>
<p>【示例09】　计算各科成绩的标准差。（示例位置：资源包\MR\Code\04\09）<br>使用std()函数计算标准差，程序代码如下：</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020034453875.png" alt="image-20211020034453875"></p>
<p>运行程序，控制台输出结果如下：</p>
<p>语文    11.547005数学     5.773503英语    11.5547005</p>
<h3 id="4-1-9-求分位数（quantile-函数）"><a href="#4-1-9-求分位数（quantile-函数）" class="headerlink" title="4.1.9　求分位数（quantile()函数）"></a>4.1.9　求分位数（quantile()函数）</h3><p>分位数也称分位点，它以概率依据将数据分割为几个等份，常用的有中位数（即二分位数）、四分位数、百分位数等。分位数是数据分析中常用的一个统计量，经过抽样得到一个样本值。例如，经常会听老师说：“这次考试竟然有20%的同学不及格！”，那么这句话就体现了分位数的应用。在Python中通过调用DataFrame对象的quantile()函数求分位数，语法如下：</p>
<p><strong>DataFrame.quantile(q=0.5,axis=0,numeric_only=True, interpolation=’linear’)</strong><br>参数说明：　</p>
<p>q：浮点型或数组，默认为0.5（50%分位数），其值为0～1。　</p>
<p>axis：axis=1表示行，axis=0表示列。默认值为0。　</p>
<p>numeric_only：仅数字，布尔型，默认值为True。　</p>
<p>interpolation：内插值，可选参数[{‘linear’,‘lower’,‘higher’,‘midpoint’,‘nearest’}]用于指定要使用的插值方法，当期望的分位数为数据点i～j时。　</p>
<p>​    linear’：i+(j-i)×分数，其中分数是指数被i和j包围的小数部分。　</p>
<p>​    lower：i。　</p>
<p>​    higher：j。　 </p>
<p>​    nearest：i或j二者以最近者为准。　</p>
<p>​    midpoint：(i+j)/2。　</p>
<p>返回值：返回Series或DataFrame对象。</p>
<p>【示例10】　通过分位数确定被淘汰的35%的学生。（示例位置：资源包\MR\Code\04\10）<br>以学生成绩为例，数学成绩分别为120、89、98、78、65、102、112、56、79、45的10名同学，现根据分数淘汰35%的学生，该如何处理？首先使用quantile()函数计算35%的分位数，然后将学生成绩与分位数比较，筛选小于等于分位数的学生，程序代码如下：</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020035437337.png" alt="image-20211020035437337"></p>
<p>运行程序，控制台输出结果如下：</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020035513992.png" alt="image-20211020035513992"></p>
<p>从运行结果得知：即将被淘汰的学生有4名，分数分别为78、65、56和45。</p>
<p>【示例11】　计算日期、时间和时间增量数据的分位数。（示例位置：资源包\MR\Code\04\11）<br>如果参数numeric_only=False，将计算日期、时间和时间增量数据的分位数，程序代码如下：<br>运行程序，控制台输出结果如下：</p>
<p>A                  1.5<br>B 2019-07-02 12:00:00<br>C          1 days 12:00:00<br>Name: 0.5, dtype: object</p>
<h2 id="4-2-数据格式化"><a href="#4-2-数据格式化" class="headerlink" title="4.2　数据格式化"></a>4.2　数据格式化</h2><p>在进行数据处理时，尤其是在数据计算中应用求均值（mean()函数）后，发现结果中的小数位数增加了许多。此时就需要对数据进行格式化，以增加数据的可读性。例如，保留小数点位数、百分号、千位分隔符等。首先来看一组数据，如图4.9所示。</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020035851798.png" alt="image-20211020035851798"></p>
<p>​                                         图4.9　原始数据</p>
<h3 id="4-2-1-设置小数位数"><a href="#4-2-1-设置小数位数" class="headerlink" title="4.2.1　设置小数位数"></a>4.2.1　设置小数位数</h3><p>设置小数位数主要使用DataFrame对象的round()函数，该函数可以实现四舍五入，而它的decimals参数则用于设置保留小数的位数，设置后数据类型不会发生变化，依然是浮点型。语法如下：</p>
<p>DataFrame.round(decimals=0, *args, **kwargs)　**</p>
<p>decimals：每一列四舍五入的小数位数，整型、字典或Series对象。如果是整数，则将每一列四舍五入到相同的位置。否则，将字典和Series舍入到可变数目的位置；如果小数是类似于字典的，那么列名应该在键中；如果小数是级数，列名应该在索引中。没有包含在小数中的任何列都将保持原样。非输入列的小数元素将被忽略。　</p>
<p>args：附加的关键字参数。　</p>
<p>kwargs：附加的关键字参数。　</p>
<p>返回值：返回DataFrame对象。</p>
<p>【示例12】　四舍五入保留指定的小数位数。（示例位置：资源包\MR\Code\04\12）<br>使用round()函数四舍五入保留小数位数，程序代码如下：</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020040002742.png" alt="image-20211020040002742"></p>
<p>运行程序，控制台输出结果如下：</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020040023289.png" alt="image-20211020040023289"></p>
<p>当然，保留小数位数也可以用自定义函数，例如，为DataFrame对象中的各个浮点值保留两位小数，主要代码如下：</p>
<p>df.applymap(lambda x: ‘%.2f’%x)</p>
<p>注意<br>经过自定义函数处理过的数据将不再是浮点型而是对象型，如果后续计算需要数据，则应先进行数据类型转换。</p>
<h3 id="4-2-2-设置百分比"><a href="#4-2-2-设置百分比" class="headerlink" title="4.2.2　设置百分比"></a>4.2.2　设置百分比</h3><p>在数据分析过程中，有时需要百分比数据。那么，利用自定义函数将数据进行格式化处理，处理后的数据就可以从浮点型转换成带指定小数位数的百分比数据，主要使用apply()函数与format()函数。</p>
<p>【示例13】　将指定数据格式化为百分比数据。（示例位置：资源包\MR\Code\04\13）<br>将A1列的数据格式化为百分比数据，程序代码如下：</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020040234891.png" alt="image-20211020040234891"></p>
<p>运行程序，控制台输出结果如下：</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020040335780.png" alt="image-20211020040335780"></p>
<h3 id="4-2-3-设置千位分隔符"><a href="#4-2-3-设置千位分隔符" class="headerlink" title="4.2.3　设置千位分隔符"></a>4.2.3　设置千位分隔符</h3><p>由于业务需要，有时需要将数据格式化为带千位分隔符的数据。那么，处理后的数据将不再是浮点型而是对象型。</p>
<p>【示例14】　将金额格式化为带千位分隔符的数据。（示例位置：资源包\MR\Code\04\14）<br>将图书销售码洋格式化为带千位分隔符的数据，程序代码如下：</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020040604750.png" alt="image-20211020040604750"></p>
<p>运行程序，控制台输出结果如下：</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020040623599.png" alt="image-20211020040623599"></p>
<p>注意<br>设置千位分隔符后，对于程序来说，这些数据将不再是数值型，而是数字和逗号组成的字符串，如果由于程序需要再变成数值型就会很麻烦，因此设置千位分隔符要慎重。</p>
<h2 id="4-3-数据分组统计"><a href="#4-3-数据分组统计" class="headerlink" title="4.3　数据分组统计"></a>4.3　数据分组统计</h2><p>本节主要介绍分组统计函数groupby()的各种应用。</p>
<h3 id="4-3-1-分组统计groupby-函数"><a href="#4-3-1-分组统计groupby-函数" class="headerlink" title="4.3.1　分组统计groupby()函数"></a>4.3.1　分组统计groupby()函数</h3><p>对数据进行分组统计，主要使用DataFrame对象的groupby()函数，其功能如下。<br>（1）根据给定的条件将数据拆分成组。</p>
<p>（2）每个组都可以独立应用函数（如求和函数sum()、求平均值函数mean()等）。</p>
<p>（3）将结果合并到一个数据结构中。</p>
<p>groupby()函数用于将数据按照一列或多列进行分组，一般与计算函数结合使用，实现数据的分组统计，语法如下：</p>
<p><strong>DataFrame.groupby(by=None,axis=0,level=None,as_index=True,sort=True,group_keys=True,squeeze=False,observed=False)</strong></p>
<p>参数说明：　</p>
<p>by：映射、字典或Series对象、数组、标签或标签列表。如果by是一个函数，则对象索引的每个值都调用它；如果传递了一个字典或Series对象，则使用该字典或Series对象值来确定组；如果传递了数组ndarray，则按原样使用这些值来确定组。　</p>
<p>axis：axis=1表示行，axis=0表示列。默认值为0。　</p>
<p>level：表示索引层级，默认值为None（无）。　</p>
<p>as_index：布尔型，默认值为True，返回以组标签为索引的对象。　sort：对组进行排序，布尔型，默认值为True。　</p>
<p>group_keys：布尔型，默认值为True，调用apply()函数时，将分组的键添加到索引以标识片段。　</p>
<p>squeeze：布尔型，默认值为False。如果可能，减少返回类型的维度；否则返回一致类型。　</p>
<p>observed： <em>bool, default False</em> 布尔型, 观察者, 默认为False。当以石斑鱼为分类时，才会使用该参数。如果参数值为True，则仅显示分类石斑鱼的观测值；如果参数值为False，则显示分类石斑鱼的所有值。</p>
<p>返回值：返回DataFrameGroupBy，返回包含有关组的信息的groupby对象。</p>
<h4 id="1．按照一列分组统计"><a href="#1．按照一列分组统计" class="headerlink" title="1．按照一列分组统计"></a>1．按照一列分组统计</h4><p>【示例15】　根据“一级分类”统计订单数据。（示例位置：资源包\MR\Code\04\15）<br>按照图书“一级分类”对订单数据进行分组统计求和，程序代码如下：</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020042705196.png" alt="image-20211020042705196"></p>
<p>运行程序，输出结果如图4.10所示。</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020042744863.png" alt="image-20211020042744863"></p>
<p>​                                 图4.10　按照一列分组统计</p>
<h4 id="2．按照多列分组统计"><a href="#2．按照多列分组统计" class="headerlink" title="2．按照多列分组统计"></a>2．按照多列分组统计</h4><p>多列分组统计，以列表形式指定列。</p>
<p>【示例16】　根据两级分类统计订单数据。（示例位置：资源包\MR\Code\04\16）<br>按照图书“一级分类”和“二级分类”对订单数据进行分组统计求和，主要代码如下：</p>
<p>01 #抽取数据<br>02 df1=df[[‘一级分类’,’二级分类’,’7天点击量’,’订单预定’]]<br>03 df1=df1.groupby([‘一级分类’,’二级分类’]).sum()    #分组统计求和</p>
<p>运行程序，输出结果如图4.11所示。</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020042906442.png" alt="image-20211020042906442"></p>
<p>​                                    图4.11　按照多列分组统计</p>
<h4 id="3．分组并按指定列进行数据计算"><a href="#3．分组并按指定列进行数据计算" class="headerlink" title="3．分组并按指定列进行数据计算"></a>3．分组并按指定列进行数据计算</h4><p>前面介绍的分组统计是按照所有列进行汇总计算的，那么如何按照指定列汇总计算呢？</p>
<p>【示例17】　统计各编程语言的7天点击量。（示例位置：资源包\MR\Code\04\17）<br>统计各编程语言的7天点击量，首先按“二级分类”分组，然后抽取“7天点击量”列并对该列进行求和运算，主要代码如下：</p>
<p>df1=df1.groupby(‘二级分类’)[‘7天点击量’].sum()<br>运行程序，输出结果如图4.12所示。</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020043023795.png" alt="image-20211020043023795"></p>
<p>图4.12　分组并按指定列进行数据计算</p>
<h3 id="4-3-2-对分组数据进行迭代"><a href="#4-3-2-对分组数据进行迭代" class="headerlink" title="4.3.2　对分组数据进行迭代"></a>4.3.2　对分组数据进行迭代</h3><p>通过for循环对分组统计数据进行迭代（遍历分组数据）。</p>
<p>【示例18】　迭代一级分类的订单数据。（示例位置：资源包\MR\Code\04\18）<br>按照“一级分类”分组，并输出每一分类中的订单数据，主要代码如下：</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020043149194.png" alt="image-20211020043149194"></p>
<p>运行程序，控制台输出结果如图4.13所示。<br>上述代码中，name是groupby()函数中“一级分类”的值，group是分组后的数据。如果groupby()函数对多列进行分组，那么需要在for循环中指定多列。</p>
<p>【示例19】　迭代两级分类的订单数据。（示例位置：资源包\MR\Code\04\19）<br>迭代“一级分类”和“二级分类”的订单数据，主要代码如下：</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020043219251.png" alt="image-20211020043219251"></p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020043328145.png" alt="image-20211020043328145"></p>
<p>​                          图4.13　对分组数据进行迭代</p>
<h3 id="4-3-3-对分组的某列或多列使用聚合函数（agg-函数）"><a href="#4-3-3-对分组的某列或多列使用聚合函数（agg-函数）" class="headerlink" title="4.3.3　对分组的某列或多列使用聚合函数（agg()函数）"></a>4.3.3　对分组的某列或多列使用聚合函数（agg()函数）</h3><p>Python也可以实现像SQL中的分组聚合运算操作，主要通过groupby()函数与agg()函数实现。【示例20】　对分组统计结果使用聚合函数。（示例位置：资源包\MR\Code\04\20）<br>按“一级分类”分组统计“7天点击量”“订单预定”的平均值和总和，主要代码如下：</p>
<p>print(df1.groupby(‘一级分类’).agg([‘mean’,’sum’]))<br>运行程序，控制台输出结果如图4.14所示。</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020043531227.png" alt="image-20211020043531227"></p>
<p>​                 图4.14　分组统计“7天点击量”“订单预定”的平均值和总和</p>
<p>【示例21】　针对不同的列使用不同的聚合函数。（示例位置：资源包\MR\Code\04\21）<br>在上述示例中，还可以针对不同的列使用不同的聚合函数。例如，按“一级分类”分组统计“7天点击量”的平均值和总和、“订单预定”的总和，主要代码如下：</p>
<p>print(df1.groupby(‘一级分类’).agg({‘7天点击量’:[‘mean’,’sum’], ‘订单预定’:[‘sum’]}))<br>运行程序，控制台输出结果如图4.15所示。</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020043554534.png" alt="image-20211020043554534"></p>
<p>​           图4.15　分组统计“7天点击量”的平均值和总和、“订单预定”的总和</p>
<p>【示例22】　通过自定义函数实现分组统计。（示例位置：资源包\MR\Code\04\22）<br>通过自定义函数也可以实现数据分组统计。例如，统计1月份销售数据中，购买次数最多的产品，主要代码如下：</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020043631773.png" alt="image-20211020043631773"></p>
<p>运行程序，控制台输出结果如图4.16所示。</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020043647886.png" alt="image-20211020043647886"></p>
<p>​                             图4.16　统计购买次数最多的产品</p>
<p>从运行结果得知：“零基础学Python”是用户购买次数最多的产品。实用技巧<br>在图4.16显示的输出结果中可以看到，lambda()函数名称<lambda>被输出出来，看上去不是很美观，那么如何去掉它？方法是使用__name__方法修改函数名称，主要代码如下：</lambda></p>
<p>max.<strong>name</strong> = “购买次数最多”<br>运行程序，控制台输出结果如图4.17所示。</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020043747160.png" alt="image-20211020043747160"></p>
<p>​                         图4.17　使用__name__方法修改函数名称</p>
<h3 id="4-3-4-通过字典和Series对象进行分组统计"><a href="#4-3-4-通过字典和Series对象进行分组统计" class="headerlink" title="4.3.4　通过字典和Series对象进行分组统计"></a>4.3.4　通过字典和Series对象进行分组统计</h3><h4 id="1．通过字典进行分组统计"><a href="#1．通过字典进行分组统计" class="headerlink" title="1．通过字典进行分组统计"></a>1．通过字典进行分组统计</h4><p>首先创建字典建立对应关系，然后将字典传递给groupby()函数从而实现数据分组统计。</p>
<p>【示例23】　通过字典分组统计“北上广”销量。（示例位置：资源包\MR\Code\04\23）<br>统计各地区销量，业务要求将“北京”“上海”“广州”3个一线城市放在一起统计。那么首先创建一个字典将“北京出库销量”“上海出库销量”“广州出库销量”都对应“北上广”；然后使用groupby()函数进行分组统计。主要代码如下：</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020043824543.png" alt="image-20211020043824543"></p>
<p>运行程序，控制台输出结果如图4.18所示。</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020043847244.png" alt="image-20211020043847244"></p>
<p>​                                 图4.18　通过字典进行分组统计</p>
<h4 id="2．通过Series对象进行分组统计"><a href="#2．通过Series对象进行分组统计" class="headerlink" title="2．通过Series对象进行分组统计"></a>2．通过Series对象进行分组统计</h4><p>通过Series对象进行分组统计与字典的方法类似。</p>
<p>【示例24】　通过Series对象分组统计“北上广”销量。（示例位置：资源包\MR\Code\04\24）<br>首先，创建一个Series对象，主要代码如下：</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020043933019.png" alt="image-20211020043933019"></p>
<p>运行程序，输出结果如图4.19所示。<br>然后，将Series对象传递给groupby()函数实现数据分组统计，主要代码如下：</p>
<p>01  df1=df.groupby(s1,axis=1).sum()<br>02  print(df1)<br>运行程序，控制台输出结果如图4.20所示。</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020043959963.png" alt="image-20211020043959963"></p>
<p>​                             图4.19　通过Series对象进行分组统计</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020044040014.png" alt="image-20211020044040014"></p>
<p>​                             图4.20　分组统计结果</p>
<h2 id="4-4-数据移位"><a href="#4-4-数据移位" class="headerlink" title="4.4　数据移位"></a>4.4　数据移位</h2><p>什么是数据移位？例如，分析数据时需要上一条数据怎么办？当然是移动至上一条，从而得到该条数据，这就是数据移位。在Pandas中，使用shift()方法可以获得上一条数据，该方法返回向下移位后的结果，从而得到上一条数据。例如，获取某学生上一次英语成绩，如图4.21所示。</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020044117875.png" alt="image-20211020044117875"></p>
<p>​                              图4.21　获取学生上一次英语成绩<br>shift()方法是一个非常有用的方法，用于数据位移与其他方法结合，能实现很多难以想象的功能，语法格式如下：</p>
<p>DataFrame.shift(periods=1, freq=None, axis=0)<br>参数说明：　</p>
<p>periods：表示移动的幅度，可以是正数，也可以是负数，默认值是1，1表示移动一次。注意这里移动的都是数据，而索引是不移动的，移动之后是没有对应值的，赋值为NaN。　</p>
<p>freq：可选参数，默认值为None，只适用于时间序列，如果这个参数存在，那么会按照参数值移动时间索引，而数据值没有发生变化。　</p>
<p>axis：axis=1表示行，axis=0表示列。默认值为0。</p>
<p>【示例25】　统计学生英语周测成绩的升降情况。（示例位置：资源包\MR\Code\04\25）<br>使用shift()方法统计学生每周英语测试成绩的升降情况，程序代码如下：</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020044313140.png" alt="image-20211020044313140"></p>
<p>运行程序，控制台输出结果如图4.22所示。<br>从运行结果得知：第2次比第1次下降5分，第3次比第2次下降6分，第4次比第3次提升21分，第5次比第4次下降5分。<br>这里再扩展下，通过10次周测来一看下学生整体英语成绩的升降情况，如图4.23和图4.24所示。</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020044330897.png" alt="image-20211020044330897"></p>
<p>​                                     图4.22　英语升降情况</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020044547566.png" alt="image-20211020044547566"></p>
<p>​                               图4.23　10次周测英语成绩升降情况</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020044603814.png" alt="image-20211020044603814"></p>
<p>​                     图4.24　图表展示英语成绩升降情况</p>
<p>说明</p>
<p>有关图表的知识将在第6章介绍，这里先简单了解。</p>
<p>shift()方法还有很多方面的应用。例如这样一个场景：分析股票数据，获取的股票数据中有股票的实时价格，也有每日的收盘价“close”，此时需要将实时价格和上一个工作日的收盘价进行对比，那么通过shift()方法就可以轻松解决。shift()方法还可以应用于时间序列，感兴趣的读者可以在学习完成后续章节进行尝试和探索。</p>
<h2 id="4-5-数据转换"><a href="#4-5-数据转换" class="headerlink" title="4.5　数据转换"></a>4.5　数据转换</h2><p>数据转换一般包括一列数据转换为多列数据、行列转换、DataFrame转换为字典、DataFrame转换为列表和DataFrame转换为元组等。</p>
<h3 id="4-5-1-一列数据转换为多列数据"><a href="#4-5-1-一列数据转换为多列数据" class="headerlink" title="4.5.1　一列数据转换为多列数据"></a>4.5.1　一列数据转换为多列数据</h3><p>一列数据转换为多列数据的情况在日常工作中经常会用到，从各种系统中导出的订单号、名称、地址很多都是复合组成的（即由多项内容组成），那么，这些列在查找、统计、合并时就没办法使用，需要将它们拆分开。例如，地址信息由省市区街道门牌号等信息组成，如果按省、市或区统计数据，就需要将地址信息中的“省”“市”“区”拆分开，此时就应用到了一列数据转多列数据，通常使用以下方法。</p>
<h4 id="1．split-方法"><a href="#1．split-方法" class="headerlink" title="1．split()方法"></a>1．split()方法</h4><p>Pandas的DataFrame对象中的str.split()内置方法可以实现分割字符串，语法如下：</p>
<p>Series.str.split(pat=None, n=-1, expand=False)<br>参数说明：　</p>
<p>pat：字符串、符号或正则表达式，字符串分割的依据，默认以空格分割字符串。　</p>
<p>n：整型，分割次数，默认值是-1，0或-1都将返回所有拆分。　expand：布尔型，分割后的结果是否转换为DataFrame，默认值是False。　</p>
<p>返回值：系列、索引、DataFrame或多重索引。<br>首先，我们来看一组淘宝销售订单数据（部分数据），如图4.25所示。</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020044753477.png" alt="image-20211020044753477"></p>
<p>图4.25　淘宝销售订单数据（部分数据）<br>从图4-25中数据得知：不仅“收货地址”是复合的，“宝贝标题”也是复合的，即由多种产品组成。</p>
<p>【示例26】　分割“收货地址”数据中的“省、市、区”。（示例位置：资源包\MR\Code\04\26）<br>使用split()方法先对“收货地址”进行分割，程序代码如下：</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020044817707.png" alt="image-20211020044817707"></p>
<p>运行程序，输出结果如图4.26所示。</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020044931041.png" alt="image-20211020044931041"></p>
<p>​                                  图4.26　分割后的收货地址</p>
<h4 id="2．join-方法与split-方法结合"><a href="#2．join-方法与split-方法结合" class="headerlink" title="2．join()方法与split()方法结合"></a>2．join()方法与split()方法结合</h4><p>【示例27】　以逗号分隔多种产品数据。（示例位置：资源包\MR\Code\04\27）<br>通过join()方法与split()方法结合，以逗号“,”分隔“宝贝标题”，主要代码如下：</p>
<p>df = df.join(df[‘宝贝标题’].str.split(‘, ‘, expand=True))</p>
<p>运行程序，输出结果如图4.27所示。</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020044959881.png" alt="image-20211020044959881"></p>
<p>​                                   图4.27　分隔后的“宝贝标题”<br>从运行结果得知：“宝贝标题”中含有多种产品的数据被拆分开，这样操作便于日后对每种产品的销量进行统计。<br>将DataFrame中的tuple（元组）类型数据分隔成多列</p>
<p>【示例28】　对元组数据进行分隔。（示例位置：资源包\MR\Code\04\28）<br>首先，创建一组包含元组的数据，程序代码如下：</p>
<p>01  import pandas as pd<br>02  df = pd.DataFrame({‘a’:[1,2,3,4,5], ‘b’:[(1,2), (3,4),(5,6),(7,8),(9,10)]})<br>03  print(df)</p>
<p>然后，使用apply()函数对元组进行分隔，主要代码如下：</p>
<p>df[[‘b1’, ‘b2’]] = df[‘b’].apply(pd.Series)<br>或者使用join()方法结合apply()函数，主要代码如下：</p>
<p>df= df.join(df[‘b’].apply(pd.Series))<br>运行程序，控制台输出原始数据如图4.28所示，结果如图4.29和图4.30所示。</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045110497.png" alt="image-20211020045110497"></p>
<p>​                                            图4.28　原始数据</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045122797.png" alt="image-20211020045122797"></p>
<p>​                             图4.29　apply()函数分隔元组</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045146968.png" alt="image-20211020045146968"></p>
<p>​                       图4.30　join()方法结合apply()函数分隔元组</p>
<h3 id="4-5-2-行列转换"><a href="#4-5-2-行列转换" class="headerlink" title="4.5.2　行列转换"></a>4.5.2　行列转换</h3><p>在Pandas处理数据过程中，有时需要对数据进行行列转换或重排，主要使用stack()方法、unstack()方法和pivot()方法，下面介绍这3种方法的应用。</p>
<h4 id="1．stack-方法"><a href="#1．stack-方法" class="headerlink" title="1．stack()方法"></a>1．stack()方法</h4><p>stack()方法用于将原来的<strong>列索引转换成最内层的行索引</strong>，转换效果对比示意图如图4.31所示。</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045215351.png" alt="image-20211020045215351"></p>
<p>​                               图4.31　转换效果对比示意图<br>stack()方法的语法如下：</p>
<p>DataFrame.stack(level=-1, dropna=True)<br>参数说明：　</p>
<p>level：索引层级，定义为一个索引或标签，或索引或标签列表，默认值是-1。　</p>
<p>dropna：布尔型，默认值是True，　</p>
<p>返回值：DataFrame对象或Series对象。</p>
<p>【示例29】　对英语成绩表进行行列转换。（示例位置：资源包\MR\Code\04\29）<br>将学生英语成绩表进行行列转换，程序代码如下：</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045321517.png" alt="image-20211020045321517"></p>
<h4 id="2．unstack-方法"><a href="#2．unstack-方法" class="headerlink" title="2．unstack()方法"></a>2．unstack()方法</h4><p>unstack()方法与stack()方法相反，它是stack()方法的逆操作，即将最内层的行索引转换成列索引，转换效果对比如图4.32所示。</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045341690.png" alt="image-20211020045341690"></p>
<p>​                   图4.32　unstack()方法转换数据示意图<br>unstack()方法的语法如下：</p>
<p>DataFrame.unstack(level=-1, fill_value=None)<br>参数说明：　</p>
<p>level：索引层级，定义为一个索引或标签，或索引或标签列表，默认值是-1。　</p>
<p>fill_value：整型、字符串或字典，如果unstack()方法产生丢失值，则用这个值替换NaN。　返回值：DataFrame对象或Series对象。</p>
<p>【示例30】　使用unstack()方法转换学生成绩表。（示例位置：资源包\MR\Code\04\30）<br>同样转换学生成绩表，主要代码如下：</p>
<p>01 df=pd.read_excel(‘grade.xls’,sheet_name=’英语2’)      #导入Excel文件<br>02 df = df.set_index([‘班级’,’序号’,’Unnamed: 2’])       #设置多级索引<br>03 print(df.unstack())<br>unstack()方法中有一个参数可以指定转换第几层索引，例如，unstack(0)就是把第一层行索引转换为列索引，默认是将最内层索引转换为列索引。</p>
<h4 id="3．pivot-方法"><a href="#3．pivot-方法" class="headerlink" title="3．pivot()方法"></a>3．pivot()方法</h4><p>pivot()方法针对列的值，即指定某列的值作为行索引，指定某列的值作为列索引，然后再指定哪些列作为索引对应的值。unstack()方法针对索引进行操作，pivot()方法针对值进行操作。但实际上，二者的功能往往可以互相实现。<br>pivot()方法的语法如下：</p>
<p>DataFrame.pivot(index=None, columns=None, values=None)<br>参数说明：　</p>
<p>index：字符串或对象，可选参数。列用于创建新DataFrame数据的索引。如果没有，则使用现有索引。　</p>
<p>columns：字符串或对象，列用于创建新DataFrame的列。　</p>
<p>values：列用于填充新DataFrame的值，如果未指定，则将使用所有剩余的列，结果将具有分层索引列。　</p>
<p>返回值：DataFrame对象或Series对象。</p>
<p>【示例31】　使用pivot()方法转换学生成绩表。（示例位置：资源包\MR\Code\04\31）<br>使用pivot()方法转换学生成绩表，主要代码如下：</p>
<p>01 df=pd.read_excel(‘grade.xls’,sheet_name=’英语3’)         #导入Excel文件<br>02 df1=df.pivot(index=’序号’,columns=’班级’,values=’得分’)<br>运行程序，输出结果如图4.33所示。</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045550818.png" alt="image-20211020045550818"></p>
<p>图4.33　使用pivot()方法转换学生成绩表</p>
<h3 id="4-5-3-DataFrame转换为字典"><a href="#4-5-3-DataFrame转换为字典" class="headerlink" title="4.5.3　DataFrame转换为字典"></a>4.5.3　DataFrame转换为字典</h3><p>DataFrame转换为字典主要使用DataFrame对象的to_dict()方法，以索引作为字典的键（key），以列作为字典的值（value）。例如，有一个DataFrame对象（索引为“类别”、列为“数量”），通过to_dict()方法就会生成一个字典，示意图如图4.34所示。如果DataFrame对象包含两列，那么to_dict()方法就会生成一个两层的字典（dict），第一层是列名作为字典的键（key），第二层以索引列的值作为字典的键（key），以列值作为字典的值（value）。</p>
<p>【示例32】　将Excel销售数据转换为字典。（示例位置：资源包\MR\Code\04\32）<br>使用to_dict()方法将按“宝贝标题”分组统计后的部分数据转换为字典，程序代码如下：</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045613721.png" alt="image-20211020045613721"></p>
<p>运行程序，控制台输出结果如图4.35所示。</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045643137.png" alt="image-20211020045643137"></p>
<p>​                       图4.34　DataFrame转换为字典示意图</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045702961.png" alt="image-20211020045702961"></p>
<p>​                           图4.35　DataFrame转换为字典</p>
<h3 id="4-5-4-DataFrame转换为列表"><a href="#4-5-4-DataFrame转换为列表" class="headerlink" title="4.5.4　DataFrame转换为列表"></a>4.5.4　DataFrame转换为列表</h3><p>DataFrame转换为列表主要使用DataFrame对象的tolist()方法。</p>
<p>【示例33】　将电商数据转换为列表。（示例位置：资源包\MR\Code\04\33）<br>将淘宝销售数据中的“买家会员名”转换为列表，程序代码如下：</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045737401.png" alt="image-20211020045737401"></p>
<p>运行程序，控制台输出结果如图4.36所示。</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045806297.png" alt="image-20211020045806297"></p>
<p>图4.36　DataFrame转换为列表</p>
<h3 id="4-5-5-DataFrame转换为元组"><a href="#4-5-5-DataFrame转换为元组" class="headerlink" title="4.5.5　DataFrame转换为元组"></a>4.5.5　DataFrame转换为元组</h3><p>DataFrame转换为元组，首先通过循环语句按行读取DataFrame数据，然后使用元组函数tuple()将其转换为元组。</p>
<p>【示例34】　将Excel数据转换为元组。（示例位置：资源包\MR\Code\04\34）<br>将Excel表中的人物关系部分数据转换成元组，程序代码如下：</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045832962.png" alt="image-20211020045832962"></p>
<p>运行程序，控制台输出结果如图4.37所示。</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045913740.png" alt="image-20211020045913740"></p>
<p>​                            图4.37　DataFrame转换为元组</p>
<h3 id="4-5-6-Excel转换为HTML网页格式"><a href="#4-5-6-Excel转换为HTML网页格式" class="headerlink" title="4.5.6　Excel转换为HTML网页格式"></a>4.5.6　Excel转换为HTML网页格式</h3><p>日常工作中，有时会涉及财务数据的处理，而Excel应用最为广泛，但是对于展示数据来说，Excel并不友好，如果你想用其他格式的文件来向用户展示，那么，HTML网页格式是不错的选择。首先使用read_excel()方法导入Excel文件，然后使用to_html()方法将DataFrame数据导出为HTML格式，这样便实现了Excel转换为HTML格式。</p>
<p>【示例35】　将Excel订单数据转换为HTML网页格式。（示例位置：资源包\MR\Code\04\35）<br>将淘宝部分订单数据转换为HTML网页格式，效果如图4.38所示。</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045939834.png" alt="image-20211020045939834"></p>
<p>​                              图4.38　Excel转换为HTML网页格式<br>程序代码如下：</p>
<p>01 import pandas as pd<br>02 df=pd.read_excel(‘mrbooks.xls’)<br>03 df.to_html(‘mrbook.html’,header = True,index = False)</p>
<h2 id="4-6-数据合并"><a href="#4-6-数据合并" class="headerlink" title="4.6　数据合并"></a>4.6　数据合并</h2><p>DataFrame数据合并主要使用merge()方法和concat()方法。</p>
<h3 id="4-6-1-数据合并（merge-方法）"><a href="#4-6-1-数据合并（merge-方法）" class="headerlink" title="4.6.1　数据合并（merge()方法）"></a>4.6.1　数据合并（merge()方法）</h3><p>Pandas模块的merge()方法是按照两个DataFrame对象列名相同的列进行连接合并，两个DataFrame对象必须具有同名的列。merge()方法的语法如下：</p>
<p>pandas.merge(right,how=’inner’,on=None,left_on=None,right_on=None,left_index=False,right_index=False,sort=<br>False,suffixes=(‘_x’,’_y’),copy=True,indicator=False,validate=None)<br>参数说明：　</p>
<p>right：合并对象，DataFrame对象或Series对象。　</p>
<p>how：合并类型，参数值可以是left（左合并）、right（右合并）、outer（外部合并）或inner（内部合并），默认值为inner。各个值的说明如下。　</p>
<p>​        left：只使用来自左数据集的键，类似于SQL左外部联接，保留键的顺序。　</p>
<p>​        right：只使用来自右数据集的键，类似于SQL右外部联接，保留键的顺序。　</p>
<p>​        outer：使用来自两个数据集的键，类似于SQL外部联接，按字典顺序对键进行排序。　</p>
<p>​        inner：使用来自两个数据集的键的交集，类似于SQL内部连接，保持左键的顺序。</p>
<p>on：标签、列表或数组，默认值为None。DataFrame对象连接的列或索引级别名称。也可以是DataFrame对象长度的数组或数组列表。</p>
<p>left_on：标签、列表或数组，默认值为None。要连接的左数据集的列或索引级名称，也可以是左数据集长度的数组或数组列表。　</p>
<p>right_on：标签、列表或数组，默认值为None。要连接的右数据集的列或索引级名称，也可以是右数据集长度的数组或数组列表。　left_index：布尔型，默认值为False。使用左数据集的索引作为连接键。如果是多重索引，则其他数据中的键数（索引或列数）必须匹配索引级别数。</p>
<p>right_index：布尔型，默认值为False，使用右数据集的索引作为连接键。　</p>
<p>sort：布尔型，默认值为False，在合并结果中按字典顺序对连接键进行排序。如果值为False，则连接键的顺序取决于连接类型how参数。　</p>
<p>suffixes：元组类型，默认值为(‘_x’,’_y’)。当左侧数据集和右侧数据集的列名相同时，数据合并后列名将带上“_x”和“_y”后缀。　</p>
<p>copy：是否复制数据，默认值为True。如果值为False，则不复制数据。　</p>
<p>indicator：布尔型或字符串，默认值为False。如果值为True，则添加一个列以输出名为_Merge的DataFrame对象，其中包含每一行的信息。如果是字符串，将向输出的DataFrame对象中添加包含每一行信息的列，并将列命名为字符型的值。　</p>
<p>validate：字符串，检查合并数据是否为指定类型。可选参数，其值说明如下。　one_to_one或“1:1”：检查合并键在左、右数据集中是否都是唯一的。　one_to_many或“1:m”：检查合并键在左数据集中是否唯一。　many_to_one或“m:1”：检查合并键在右数据集中是否唯一。　many_to_many或“m:m”：允许，但不检查。　</p>
<p>返回值：DataFrame对象，两个合并对象的数据集。</p>
<h4 id="1．常规合并"><a href="#1．常规合并" class="headerlink" title="1．常规合并"></a>1．常规合并</h4><p>【示例36】　合并学生成绩表。（示例位置：资源包\MR\Code\04\36）<br>假设一个DataFrame对象包含了学生的“语文”“数学”“英语”成绩，而另一个DataFrame对象则包含了学生的“体育”成绩，现在将它们合并，示意图如图4.39所示。</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020050304612.png" alt="image-20211020050304612"></p>
<p>​                 图4.39　数据合并效果对比示意图<br>程序代码如下：</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020050326358.png" alt="image-20211020050326358"></p>
<p>运行程序，控制台输出结果如图4.40所示。</p>
<p>【示例37】　通过索引合并数据。（示例位置：资源包\MR\Code\04\37）<br>如果通过索引列合并，则需要设置right_index参数和left_index参数值为True。例如，上述举例，通过列索引合并，主要代码如下：</p>
<p>01 df_merge=pd.merge(df1,df2,right_index=True,left_index=True)<br>02 print(df_merge)<br>运行程序，控制台输出结果如图4.41所示。</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020050352118.png" alt="image-20211020050352118"></p>
<p>​                           图4.40　合并结果</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020050412167.png" alt="image-20211020050412167"></p>
<p>​                            图4.41　通过索引列合并</p>
<p>【示例38】　对合并数据去重。（示例位置：资源包\MR\Code\04\38）<br>从图4.41中的运行结果得知：数据中存在重复列（如编号），如果不想要重复列，可以设置按指定列和列索引合并数据，主要代码如下：</p>
<p>df_merge=pd.merge(df1,df2,on=’编号’,left_index=True,right_index=True)</p>
<p>还可以通过how参数解决这一问题。例如，设置该参数值为left，就是让df1保留所有的行列数据，df2则根据df1的行列进行补全，主要代码如下：</p>
<p>df_merge=pd.merge(df1,df2,on=’编号’,how=’left’)<br>运行程序，控制台输出结果如图4.42所示。</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020050506047.png" alt="image-20211020050506047"></p>
<p>图4.42　合并结果</p>
<h4 id="2．多对一的数据合并"><a href="#2．多对一的数据合并" class="headerlink" title="2．多对一的数据合并"></a>2．多对一的数据合并</h4><p>多对一是指两个数据集（df1、df2）的共有列中的数据不是一对一的关系，例如，df1中的“编号”是唯一的，而df2中的“编号”有重复的编号，类似这种就是多对一的关系，示意图如图4.43所示。【示例39】　根据共有列进行合并数据。（示例位置：资源包\MR\Code\04\39）<br>根据共有列中的数据进行合并，df2根据df1的行列进行补全，程序代码如下：</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020050528714.png" alt="image-20211020050528714"></p>
<p>运行程序，控制台输出结果如图4.44所示。</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020050545631.png" alt="image-20211020050545631"></p>
<p>​                                     图4.43　多对一合并示意图</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020050604101.png" alt="image-20211020050604101"></p>
<p>​                                  图4.44　合并结果</p>
<h4 id="3．多对多的数据合并"><a href="#3．多对多的数据合并" class="headerlink" title="3．多对多的数据合并"></a>3．多对多的数据合并</h4><p>多对多是指两个数据集（df1、df2）的共有列中的数据不全是一对一的关系，都有重复数据，例如“编号”，示图如图4.45所示。</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020050702131.png" alt="image-20211020050702131"></p>
<p>​                                    图4.45　多对多示意图</p>
<p>【示例40】　合并数据并相互补全。（示例位置：资源包\MR\Code\04\40）<br>根据共有列中的数据进行合并，df2、df1相互补全，程序代码如下：</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020050733884.png" alt="image-20211020050733884"></p>
<p>运行程序，控制台输出结果如图4.46所示。</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020050749641.png" alt="image-20211020050749641"></p>
<p>​                                               图4.46　合并结果</p>
<h3 id="4-6-2-数据合并（concat-方法）"><a href="#4-6-2-数据合并（concat-方法）" class="headerlink" title="4.6.2　数据合并（concat()方法）"></a>4.6.2　数据合并（concat()方法）</h3><p>concat()方法可以根据不同的方式将数据合并，语法如下：</p>
<p>pandas.concat(objs,axis=0,join=’outer’,ignore_index: bool = False, keys=None, levels=None, names=None,<br>verify_integrity: bool = False, sort: bool = False, copy: bool = True)<br>参数说明：　</p>
<p>objs：Series、DataFrame或Panel对象的序列或映射。如果传递一个字典，则排序的键将用作键参数。　</p>
<p>axis：axis=1表示行，axis=0表示列。默认值为0。　</p>
<p>join：值为inner（内连接）或outer（外连连接），处理其他轴上的索引方式。默认值为outer。　</p>
<p>ignore_index：布尔值，默认值为False，保留索引，索引值为0，…，n-1。如果值为True，则忽略索引。　</p>
<p>keys：序列，默认值为None。使用传递的键作为最外层构建层次索引。如果为多索引，应该使用元组。　</p>
<p>levels：序列列表，默认值为None。用于构建MultiIndex的特定级别（唯一值）；否则，它们将从键推断。　</p>
<p>names：list列表，默认值为None。结果层次索引中的级别的名称。　</p>
<p>verify_integrity：布尔值，默认值为False。检查新连接的轴是否包含重复项。　</p>
<p>sort：布尔值，默认值为True（1.0.0以后版本默认值为False，即不排序）。如果连接为外连接（join=’outer’），则对未对齐的非连接轴进行排序；如果连接为内连接（join=’inner’），则该参数不起作用。</p>
<p>copy：是否复制数据，默认值为True，如果值为False，则不复制数据。</p>
<p>下面介绍concat()方法不同的合并方式，其中dfs代表合并后的DataFrame对象，df1、df2等代表单个DataFrame对象，result代表合并后的结果（DataFrame对象）。</p>
<h4 id="1．相同字段的表首尾相接"><a href="#1．相同字段的表首尾相接" class="headerlink" title="1．相同字段的表首尾相接"></a>1．相同字段的表首尾相接</h4><p>表结构相同的数据将直接合并，表首尾相接，主要代码如下：</p>
<p>01  dfs= [df1, df2, df3]<br>02  result = pd.concat(dfs)<br>例如，表df1、df2和df3结构相同，如图4.47所示。合并后的效果如图4.48所示。如果想要在合并数据时标记源数据来自哪张表，则需要在代码中加入参数keys，例如表名分别为“1月”“2月”“3月”，合并后的效果如图4.49所示。</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051001176.png" alt="image-20211020051001176"></p>
<p>​                          图4.47　3张相同字段的表</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051019220.png" alt="image-20211020051019220"></p>
<p>​                                     图4.48　首尾相接合并后的效果</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051035379.png" alt="image-20211020051035379"></p>
<p>​                        图4.49　合并后带标记（月份）的效果<br>主要代码如下：</p>
<p>result = pd.concat(dfs, keys=[‘1月’, ‘2月’, ‘3月’])</p>
<h4 id="2．横向表合并（行对齐）"><a href="#2．横向表合并（行对齐）" class="headerlink" title="2．横向表合并（行对齐）"></a>2．横向表合并（行对齐）</h4><p>当合并的数据列名称不一致时，可以设置参数axis=1，concat()方法将按行对齐，然后将不同列名的两组数据进行合并，缺失的数据用NaN填充，df1和df4合并前后效果如图4.50和图4.51所示。</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051057217.png" alt="image-20211020051057217"></p>
<p>​                        图4.50　横向表合并前</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051113896.png" alt="image-20211020051113896"></p>
<p>​                            图4.51　横向表合并后<br>主要代码如下：</p>
<p>result = pd.concat([df1, df4], axis=1)</p>
<h4 id="3．交叉合并"><a href="#3．交叉合并" class="headerlink" title="3．交叉合并"></a>3．交叉合并</h4><p>交叉合并，需要在代码中加上join参数，如果值为inner，结果是两张表的交集；如果值为outer，结果是两张表的并集。例如两张表交集，表df1和df4合并前后的效果如图4.52和图4.53所示。</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051227829.png" alt="image-20211020051227829"></p>
<p>​                                   图4.52　交叉合并前</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051243654.png" alt="image-20211020051243654"></p>
<p>​                                       图4.53　交叉合并后<br>主要代码如下：</p>
<p>result = pd.concat([df1, df4], axis=1, join=’inner’)</p>
<h4 id="4．指定表对齐数据（行对齐）"><a href="#4．指定表对齐数据（行对齐）" class="headerlink" title="4．指定表对齐数据（行对齐）"></a>4．指定表对齐数据（行对齐）</h4><p>如果指定参数join_axes，就可以指定根据哪张表来对齐数据。例如，根据df4对齐数据，就会保留表df4的数据，然后将表df1的数据与之合并，行数不变，合并前后的效果与如图4.54和图4.55所示。</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051305083.png" alt="image-20211020051305083"></p>
<p>​                          图4.54　指定表对齐数据合并前</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051320918.png" alt="image-20211020051320918"></p>
<p>​                           图4.55　指定表对齐数据合并后<br>主要代码如下：</p>
<p>result = pd.concat([df1, df4], axis=1, join_axes=[df4.index])</p>
<h2 id="4-7-数据导出"><a href="#4-7-数据导出" class="headerlink" title="4.7　数据导出"></a>4.7　数据导出</h2><h3 id="4-7-1-导出为-xlsx文件"><a href="#4-7-1-导出为-xlsx文件" class="headerlink" title="4.7.1　导出为.xlsx文件"></a>4.7.1　导出为.xlsx文件</h3><p>导出数据为Excel，主要使用DataFrame对象的to_excel()方法，语法如下：</p>
<p>DataFrame.to_excel(excel_writer,sheet_name=’Sheet1’,na_rep=’’,float_format=None,columns=None,header=True,<br>index=True,index_label=None,startrow=0,startcol=0,engine=None,merge_cells=True, encoding=None, inf_rep=’inf’,<br>verbose=True, freeze_panes=None)<br>参数说明：　</p>
<p>excel_writer：字符串或ExcelWriter对象。　</p>
<p>sheet_name：字符串，默认值为Sheet1，包含DataFrame的表的名称。　</p>
<p>na_rep：字符串，默认值为’ ‘。缺失数据的表示方式。　</p>
<p>float_format：字符串，默认值为None，格式化浮点数的字符串。　</p>
<p>columns：序列，可选参数，要编辑的列。　</p>
<p>header：布尔型或字符串列表，默认值为True。列名称，如果给定字符串列表，则表示它是列名称的别名。　</p>
<p>index：布尔型，默认值为True，行名（索引）。　</p>
<p>index_label：字符串或序列，默认值为None。如果需要，可以使用索引列的列标签；如果没有给出，标题和索引为True，则使用索引名称；如果数据文件使用多索引，则需使用序列。</p>
<p>startrow：指定从哪一行开始写入数据。　</p>
<p>startcol：指定从哪一列开始写入数据。　</p>
<p>engine：字符串，默认值为None，指定要使用的写引擎，如openpyxl或xlsxwriter。也可以通过io.excel.xlsx.writer、io.excel.xls.writer和io.excel.xlsm.writer进行设置。　</p>
<p>merge_cells：布尔型，默认值为True。　</p>
<p>encoding：指定Excel文件的编码方式，默认值为None。　</p>
<p>inf_rep：字符串，默认值为“正”，表示无穷大。　</p>
<p>verbose：布尔型，默认值为True。在错误日志中显示更多信息。　freeze_panes：整数的元组，长度2，默认值为None。指定要冻结的行列。</p>
<p>【示例41】　将处理后的数据导出为Excel文件。（示例位置：资源包\MR\Code\04\41）<br>将数据合并后的结果导出为Excel文件，主要代码如下：</p>
<p>df_merge.to_excel(‘merge.xlsx’)<br>运行程序，数据将导出为Excel文件，如图4.56所示。</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051510137.png" alt="image-20211020051510137"></p>
<p>​                         图4.56　导出为Excel文件</p>
<p>上述举例，如果需要指定Sheet页名称，可以通过sheet_name参数指定，主要代码如下：</p>
<p>df1.to_excel(‘df1.xlsx’,sheet_name=’df1’)</p>
<h3 id="4-7-2-导出为-csv文件"><a href="#4-7-2-导出为-csv文件" class="headerlink" title="4.7.2　导出为.csv文件"></a>4.7.2　导出为.csv文件</h3><p>导出数据为.csv文件，主要使用DataFrame对象的to_csv()方法，语法如下：</p>
<p>DataFrame.to_csv(path_or_buf=None,sep=’,’,na_rep=’’,float_format=None,columns=None,header=True,index=<br>True,index_label=None,mode=’w’,encoding=None,compression=’infer’,quoting=None,quotechar=’”‘,line_terminator=<br>None,chunksize=None,date_format=None,doublequote=True, escapechar=None, decimal=’.’,errors=’strict’)<br>参数说明：　</p>
<p>path_or_buf：要保存的路径及文件名。　</p>
<p>sep：分隔符，默认值为”,”。　</p>
<p>na_rep：指定空值的输出方式，默认值为空字符串。　</p>
<p>float_format：浮点数的输出格式，要用双引号括起来。　</p>
<p>columns：指定要导出的列，用列名列表表示，默认值为None。　header：是否输出列名，默认值为True。　</p>
<p>index：是否输出索引，默认值为True。　</p>
<p>index_label：索引列的列名，默认值为None。　</p>
<p>mode：Python写入模式，默认值为w。　</p>
<p>encoding：编码方式，默认值为utf-8。　</p>
<p>compression：压缩模式，默认值为infer。　</p>
<p>quoting：导出.csv文件是否用引号，默认值为0，表示不加双引号；如果值为1，则每个字段都会加上引号，数值也会被当作字符串看待。</p>
<p>quotechar：引用字符，当quoting=1时可以指定引号字符为双引号（” “）或单引号（’ ‘）。　</p>
<p>line_terminator：换行符，默认值为\n。</p>
<p>chunksize：一次写入.csv文件的行数，当DataFrame对象数据特别大时需要分批写入。　</p>
<p>date_format：日期输出格式。　</p>
<p>doublequote：是否添加双引用符，默认值为True。　</p>
<p>escapechar：设置转义字符。　</p>
<p>decimal：可识别十进制分隔符的字符。　</p>
<p>errors：指定如何处理编码和解码错误，默认值为strict（严格的）。</p>
<p>【示例42】　将处理后的数据导出为.csv文件。（示例位置：资源包\MR\Code\04\42）<br>下面介绍to_csv()方法常用功能，举例如下，df为DataFrame对象。<br>（1）相对位置，保存在程序所在路径下，代码如下：</p>
<p>df.to_csv(‘Result.csv’)<br>（2）绝对位置，代码如下：</p>
<p>df.to_csv(‘d:\Result.csv’)<br>（3）分隔符。使用问号（？）分隔符分隔需要保存的数据，代码如下：</p>
<p>df.to_csv(‘Result.csv’,sep=’?’)``<br>（4）替换空值，缺失值保存为NA，代码如下：</p>
<p>df.to_csv(‘Result1.csv’,na_rep=’NA’)<br>（5）格式化数据，保留两位小数，代码如下：</p>
<p>df.to_csv(‘Result1.csv’,float_format=’%.2f’)<br>（6）保留某列数据，保存索引列和name列，代码如下：</p>
<p>df.to_csv(‘Result.csv’,columns=[‘name’])<br>（7）是否保留列名，不保留列名，代码如下：</p>
<p>df.to_csv(‘Result.csv’,header=False)<br>（8）是否保留行索引，不保留行索引，代码如下：</p>
<p>df.to_csv(‘Result.csv’,index=False)</p>
<h3 id="4-7-3-导出多个Sheet"><a href="#4-7-3-导出多个Sheet" class="headerlink" title="4.7.3　导出多个Sheet"></a>4.7.3　导出多个Sheet</h3><p>导出多个Sheet，应首先使用pd.ExcelWriter()方法打开一个Excel文件，然后再使用to_excel()方法导出指定的Sheet。</p>
<p>【示例43】　导出Excel中多个Sheet页的数据。（示例位置：资源包\MR\Code\04\43）<br>导出指定Sheet页中的数据，主要代码如下：</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051720411.png" alt="image-20211020051720411"></p>
<h2 id="4-8-日期数据处理"><a href="#4-8-日期数据处理" class="headerlink" title="4.8　日期数据处理"></a>4.8　日期数据处理</h2><h3 id="4-8-1-DataFrame的日期数据转换"><a href="#4-8-1-DataFrame的日期数据转换" class="headerlink" title="4.8.1　DataFrame的日期数据转换"></a>4.8.1　DataFrame的日期数据转换</h3><p>日常工作中，有一个非常麻烦的事情就是日期的格式可以有很多种表达，我们看到同样是2020年2月14日，可以有很多种格式，如图4.57所示。那么，我们需要先将这些格式统一后才能进行后续的工作。Pandas提供了to_datetime()方法可以帮助我们解决这一问题。<br>to_datetime()方法可以用来批量处理日期数据转换，对于处理大数据非常实用和方便，它可以将日期数据转换成你需要的各种格式。例如，将2/14/20和14-2-2020转换为日期格式2020-02-14。to_datetime()方法的语法如下：</p>
<p>pandas.to_datetime(arg,errors=’ignore’,dayfirst=False,yearfirst=False,utc=None,box=True,format=None,exact=<br>True,unit=None,infer_datetime_format=False,origin=’unix’,cache=False)<br>参数说明：　</p>
<p>arg：字符串、日期时间、字符串数组。　</p>
<p>errors：值为ignore、raise或coerce，具体说明如下，默认值为ignore，即忽略错误。　</p>
<p>ignore：无效的解析将返回原值。　</p>
<p>raise：无效的解析将引发异常。　</p>
<p>coerce：无效的解析将被设置为NaT，即无法转换为日期的数据将被转换为NaT。　</p>
<p>dayfirst：第一个为天，布尔型，默认值为False。例如02/09/2020，如果值为True，则解析日期的第一个为天，即2020-09-02；如果值为False，则解析日期与原日期一致，即2020-02-09。　</p>
<p>yearfirst：第一个为年，布尔型，默认值为False。例如14-Feb-20，如果值为True，则解析日期的第一个为年，即2014-02-20；如果值为False，则解析日期与原日期一致，即2020-02-14。　</p>
<p>utc：默认值为None。返回utc即协调世界时间。　</p>
<p>box：布尔值，默认值为True，如果值为True，则返回DatetimeIndex；如果值为False，则返回ndarray。　</p>
<p>format：格式化显示时间的格式。字符串，默认值为None。　</p>
<p>exact：布尔值，默认值为True。如果为True，则要求格式完全匹配；如果为False，则允许格式与目标字符串中的任何位置匹配。　</p>
<p>unit：默认值为None，参数的单位（D、s、、ms、μs、ns）表示时间的单位。　</p>
<p>infer_datetime_format：默认值为False。如果没有格式，则尝试根据第一个日期时间字符串推断格式。　</p>
<p>origin：默认值为unix。定义参考日期。数值将被解析为单位数。　</p>
<p>cache：默认值为False。如果值为True，则使用唯一、转换日期的缓存应用日期时间转换。在解析重复日期字符串，特别是带有时区偏移的字符串时，可能会产生明显的加速。只有在至少有50个值时才使用缓存。越界值的存在将使缓存不可用，并可能减慢解析速度。　</p>
<p>返回值：日期时间。</p>
<p>【示例44】　将各种日期字符串转换为指定的日期格式。（示例位置：资源包\MR\Code\04\44）<br>将2020年2月14日的各种格式转换为日期格式，程序代码如下：</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051913944.png" alt="image-20211020051913944"></p>
<p>运行程序，控制台输出结果如图4.58所示。</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051928130.png" alt="image-20211020051928130"></p>
<p>​                   图4.57　日期的多种格式转换</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051944812.png" alt="image-20211020051944812"></p>
<p>​                 图4.58　2020年2月14日的各种格式转换为日期格式<br>还可以实现从DataFrame对象中的多列，如年、月、日各列组合成一列日期。键值是常用的日期缩略语。</p>
<p>组合要求：　</p>
<p>必选：year、month、day。　</p>
<p>可选：hour、minute、second、millisecond（毫秒）、microsecond（微秒）、nanosecond（纳秒）。</p>
<p>【示例45】　将一组数据组合为日期数据。（示例位置：资源包\MR\Code\04\45）<br>将一组数据组合为日期数据，主要代码如下：</p>
<p>运行程序，控制台输出结果如图4.59所示。</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020052022697.png" alt="image-20211020052022697"></p>
<p>​                                        图4.59　日期组合</p>
<h3 id="4-8-2-dt对象的使用"><a href="#4-8-2-dt对象的使用" class="headerlink" title="4.8.2　dt对象的使用"></a>4.8.2　dt对象的使用</h3><p>dt对象是Series对象中用于获取日期属性的一个访问器对象，通过它可以获取日期中的年、月、日、星期数、季节等，还可以判断日期是否处在年底。语法如下：</p>
<p>  Series.dt()<br>参数说明：　</p>
<p>返回值：返回与原始系列相同的索引系列。如果Series不包含类日期值，则引发错误。　</p>
<p>dt对象提供了year、month、day、dayofweek、dayofyear、is_leap_year、quarter、weekday_name等属性和方法。</p>
<p>例如，year可以获取“年”、month可以获取“月”、quarter可以直接得到每个日期分别是第几个季度，weekday_name可以直接得到每个日期对应的是周几。</p>
<p>【示例46】　获取日期中的年、月、日、星期数等。（示例位置：资源包\MR\Code\04\46）<br>使用dt对象获取日期中的年、月、日、星期数、季节等。<br>（1）获取年、月、日，代码如下：</p>
<p>df[‘年’],df[‘月’],df[‘日’]=df[‘日期’].dt.year,df[‘日期’].dt.month,df[‘日期’].dt.day<br>（2）从日期判断出所处星期数，代码如下：</p>
<p>df[‘星期几’]=df[‘日期’].dt.day_name()<br>（3）从日期判断所处季度，代码如下：</p>
<p>df[‘季度’]=df[‘日期’].dt.quarter<br>（4）从日期判断是否为年底最后一天，代码如下：</p>
<p>df[‘是否年底’]=df[‘日期’].dt.is_year_end<br>运行程序，控制台输出结果如图4.60所示。</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020052128703.png" alt="image-20211020052128703"></p>
<p>​                               图4.60　dt对象日期转换</p>
<h3 id="4-8-3-获取日期区间的数据"><a href="#4-8-3-获取日期区间的数据" class="headerlink" title="4.8.3　获取日期区间的数据"></a>4.8.3　获取日期区间的数据</h3><p>获取日期区间的数据的方法是直接在DataFrame对象中输入日期或日期区间，但前提必须设置日期为索引，举例如下。　</p>
<p>获取2018年的数据。</p>
<p>df1[‘2018’]　</p>
<p>获取2017—2018年的数据。</p>
<p>df1[‘2017’:’2018’]　</p>
<p>获取某月（2018年7月）的数据。</p>
<p>df1[‘2018-07’]　</p>
<p>获取具体某天（2018年5月6日）的数据。</p>
<p>df1[‘2018-05-06’:’2018-05-06’]</p>
<p>【示例47】　获取指定日期区间的订单数据。（示例位置：资源包\MR\Code\04\47）<br>获取2018年5月11日至6月10日的订单，结果如图4.61所示。<br>程序代码如下：</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020052236563.png" alt="image-20211020052236563"></p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020052256160.png" alt="image-20211020052256160"></p>
<p>​            图4.61　2018年5月11日至6月10日的订单（省略部分数据）</p>
<h3 id="4-8-4-按不同时期统计并显示数据"><a href="#4-8-4-按不同时期统计并显示数据" class="headerlink" title="4.8.4　按不同时期统计并显示数据"></a>4.8.4　按不同时期统计并显示数据</h3><h4 id="1．按时期统计数据"><a href="#1．按时期统计数据" class="headerlink" title="1．按时期统计数据"></a>1．按时期统计数据</h4><p>按时期统计数据主要通过DataFrame对象的resample()方法结合数据计算函数实现。resample()方法主要应用于时间序列频率转换和重采样，它可以从日期中获取年、月、日、星期、季节等，结合数据计算函数就可以实现按年、月、日、星期或季度等不同时期统计数据。举例如下所示。<br>（1）按年统计数据，代码如下：</p>
<p>df1=df1.resample(‘AS’).sum()<br>（2）按季度统计数据，代码如下：</p>
<p>df2.resample(‘Q’).sum()<br>（3）按月度统计数据，代码如下：</p>
<p>df1.resample(‘M’).sum()<br>（4）按星期统计数据，代码如下：</p>
<p>df1.resample(‘W’).sum()<br>（5）按天统计数据，代码如下：</p>
<p>df1.resample(‘D’).sum()</p>
<p>实用技巧<br>按日期统计数据过程中，可能会出现如图4.62所示的错误提示。</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020052356675.png" alt="image-20211020052356675"></p>
<p>图4.62　错误提示</p>
<p>完整错误描述：<br>TypeError: Only valid with DatetimeIndex, TimedeltaIndex or PeriodIndex, but got an instance of’Index’<br>出现上述错误，是由于<strong>resample()函数要求索引必须为日期型</strong>。<br>解决方法：将数据的索引转换为datetime类型，主要代码如下：</p>
<p>df1.index = pd.to_datetime(df1.index)</p>
<h4 id="2．按时期显示数据"><a href="#2．按时期显示数据" class="headerlink" title="2．按时期显示数据"></a>2．按时期显示数据</h4><p>DataFrame对象的to_period()方法可以将时间戳转换为时期，从而实现按时期显示数据，前提是日期必须设置为索引。语法如下：</p>
<p>DataFrame.to_period(freq=None, axis=0, copy=True)<br>参数说明：　</p>
<p>freq：字符串，周期索引的频率，默认值为None。　</p>
<p>axis：行列索引，axis=0表示行索引，axis=1表示列索引。默认值为0，即表示行索引。　</p>
<p>copy：是否复制数据，默认值为True，如果值为False，则不复制数据。　返回值：带周期索引的时间序列。</p>
<p>【示例48】　从日期中获取不同的时期。（示例位置：资源包\MR\Code\04\48）<br>从日期中获取不同的时期，主要代码如下：</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020052452293.png" alt="image-20211020052452293"></p>
<h4 id="3．按时期统计并显示数据"><a href="#3．按时期统计并显示数据" class="headerlink" title="3．按时期统计并显示数据"></a>3．按时期统计并显示数据</h4><p>（1）按年统计并显示数据，代码如下：</p>
<p>df2.resample(‘AS’).sum().to_period(‘A’)<br>控制台输出结果如图4.63所示。<br>（2）按季度统计并显示数据，代码如下：</p>
<p>Q_df=df2.resample(‘Q’).sum().to_period(‘Q’)</p>
<p>控制台输出结果如图4.64所示。</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020052536700.png" alt="image-20211020052536700"></p>
<p>​                            图4.63　按年统计并显示数据</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020052550813.png" alt="image-20211020052550813"></p>
<p>​                      图4.64　按季度统计并显示数据<br>（3）按月统计并显示数据，代码如下：</p>
<p>df2.resample(‘M’).sum().to_period(‘M’)<br>控制台输出结果如图4.65所示。<br>（4）按星期统计并显示数据（前5条数据），代码如下：</p>
<p>df2.resample(‘W’).sum().to_period(‘W’).head()<br>控制台输出结果如图4.66所示。</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020052622774.png" alt="image-20211020052622774"></p>
<p>​                          图4.65　按月统计并显示数据</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020052640893.png" alt="image-20211020052640893"></p>
<p>​                      图4.66　按星期统计并显示数据</p>
<h2 id="4-9-时间序列"><a href="#4-9-时间序列" class="headerlink" title="4.9　时间序列"></a>4.9　时间序列</h2><h3 id="4-9-1-重采样（Resample-方法）"><a href="#4-9-1-重采样（Resample-方法）" class="headerlink" title="4.9.1　重采样（Resample()方法）"></a>4.9.1　重采样（Resample()方法）</h3><p>通过前面的学习，我们学会了如何生成不同频率的时间索引，按小时、按天、按周、按月等，如果想对数据做不同频率的转换，该怎么办？在Pandas中对时间序列的频率的调整称为重新采样，即将时间序列从一个频率转换到另一个频率的处理过程。例如，每天一个频率转换为每5天一个频率，如图4.67所示。</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020052720517.png" alt="image-20211020052720517"></p>
<p>​                                       图4.67　时间频率<br>重采样主要使用resample()方法，该方法用于对常规时间序列重新采样和频率转换，包括降采样和升采样两种。首先了解下resample()方法，语法如下：</p>
<p>DataFrame.resample(rule,how=None,axis=0,fill_method=None,closed=None,label=None,convention=’start’,kind=<br>None,loffset=None,limit=None,base=0,on=None,level=None)<br>参数说明：　</p>
<p>rule：字符串，偏移量表示目标字符串或对象转换。　</p>
<p>how：用于产生聚合值的函数名或数组函数。例如mean、ohlc和np.max等，默认值为mean，其他常用的值为first、last、median、max和min。　</p>
<p>axis：整型，表示行列，axis=0表示列，axis=1表示行。默认值为0，即表示列。　fill_method：升采样时所使用的填充方法，ffill()方法（用前值填充）或bfill()方法（用后值填充），默认值为None。　</p>
<p>closed：降采样时，时间区间的开和闭，与数学里区间的概念一样，其值为right或left，right表示左开右闭（即左边值不包括在内），left表示左闭右开（即右边值不包括在内），默认值为right左开右闭。　</p>
<p>label：降采样时，如何设置聚合值的标签。例如，10:30—10:35会被标记成10:30还是10:35，默认值为None。　</p>
<p>convention：当重采样时，将低频率转换到高频率所采用的约定，其值为start或end，默认值为start。　</p>
<p>kind：聚合到时期（period）或时间戳（timestamp），默认聚合到时间序列的索引类型，默认值为None。　</p>
<p>loffset：聚合标签的时间校正值，默认值为None。例如，-1s或Second(-1)用于将聚合标签调早1秒。　</p>
<p>limit：向前或向后填充时，允许填充的最大时期数，默认值为None。</p>
<p>　base：整型，默认值为0。对于均匀细分1天的频率，聚合间隔的“原点”。例如，对于5min频率，base的范围可以是0～4。　on：字符串，可选参数，默认值为None。对DataFrame对象使用列代替索引进行重新采样。列必须与日期时间类似。　</p>
<p>level：字符串或整型，可选参数，默认值为None。用于多索引，重新采样的级别名称或级别编号，级别必须与日期时间类似。　</p>
<p>返回值：重新采样对象。</p>
<p>【示例49】　一分钟的时间序列转换为3分钟的时间序列。（示例位置：资源包\MR\Code\04\49）<br>首先创建一个包含9个一分钟的时间序列，然后使用resample()方法转换为3分钟的时间序列，并对索引列进行求和计算，如图4.68所示。</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020052840027.png" alt="image-20211020052840027"></p>
<p>​                          图4.68　时间序列转换</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211106103741281.png" alt="image-20211106103741281">程序代码如下：</p>
<p>01  import pandas as pd<br>02  index = pd.date_range(‘02/02/2020’, periods=9, freq=’T’)</p>
<p>03  series = pd.Series(range(9), index=index)<br>04  print(series)<br>05  print(series.resample(‘3T’).sum())</p>
<h3 id="4-9-2-降采样处理"><a href="#4-9-2-降采样处理" class="headerlink" title="4.9.2　降采样处理"></a>4.9.2　降采样处理</h3><p>降采样是周期由高频率转向低频率。例如，将5min股票交易数据转换为日交易，按天统计的销售数据转换为按周统计。<br>数据降采样会涉及数据的聚合。例如，天数据变成周数据，那么就要对1周7天的数据进行聚合，聚合的方式主要包括求和、求均值等。例如，淘宝店铺每天销售数据（部分数据），如图4.69所示。</p>
<p>【示例50】　按周统计销售数据。（示例位置：资源包\MR\Code\04\50）<br>使用resample()方法来做降采样处理，频率为“周”，也就是将上述销售数据处理为每周（每7天）求和一次数据，程序代码如下：</p>
<p>01 import pandas as pd<br>02 df=pd.read_excel(‘time.xls’)<br>03 df1 = df.set_index(‘订单付款时间’)  #设置“订单付款时间”为索引<br>04 print(df1.resample(‘W’).sum().head())<br>运行程序，控制台输出结果如图4.70所示。<br>在参数说明中，我们列出了closed参数的解释，如果把closed参数值设置为left，结果如图4.71所示。</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020052938423.png" alt="image-20211020052938423"></p>
<p>​              图4.69　淘宝店铺每天销售数据（部分数据）</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020053019859.png" alt="image-20211020053019859"></p>
<p>​                                       图4.70　周数据统计1</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020053036196.png" alt="image-20211020053036196"></p>
<p>​                              图4.71　周数据统计2</p>
<h3 id="4-9-3-升采样处理"><a href="#4-9-3-升采样处理" class="headerlink" title="4.9.3　升采样处理"></a>4.9.3　升采样处理</h3><p>​    升采样是周期由低频率转向高频率。将数据从低频率转换到高频率时，就不需要聚合了，将其重采样到日频率，默认会引入缺失值。<br>例如，原来是按周统计的数据，现在变成按天统计。升采样会涉及数据的填充，根据填充的方法不同，填充的数据也不同。下面介绍3种填充方法。　不填充。空值用NaN代替，使用asfreq()方法。　用前值填充。用前面的值填充空值，使用ffill()方法或者pad()方法。为了方便记忆，ffill()方法可以使用它的第一个字母“f”代替，代表forward，向前的意思。　用后值填充，使用bfill()方法，可以使用字母“b”代替，代表back，向后的意思。</p>
<p>【示例51】　每6小时统计一次数据。（示例位置：资源包\MR\Code\04\51）<br>下面创建一个时间序列，起始日期是2020-02-02，一共两天，每天对应的数值分别是1和2，通过升采样处理为每6小时统计一次数据，空值以不同的方式填充，程序代码如下：</p>
<p>01  import pandas as pd<br>02  import numpy as np<br>03  rng = pd.date_range(‘20200202’, periods=2)<br>05  s1_6h_asfreq = s1.resample(‘6H’).asfreq()</p>
<p>06  print(s1_6h_asfreq)<br>07  s1_6h_pad = s1.resample(‘6H’).pad()<br>08  print(s1_6h_pad)<br>09  s1_6h_ffill = s1.resample(‘6H’).ffill()<br>10  print(s1_6h_ffill)<br>11  s1_6h_bfill = s1.resample(‘6H’).bfill()<br>12  print(s1_6h_bfill)<br>运行程序，控制台输出结果如图4.72所示。</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020053124798.png" alt="image-20211020053124798"></p>
<p>​                          图4.72　6小时数据统计</p>
<h3 id="4-9-4-时间序列数据汇总（ohlc-函数）"><a href="#4-9-4-时间序列数据汇总（ohlc-函数）" class="headerlink" title="4.9.4　时间序列数据汇总（ohlc()函数）"></a>4.9.4　时间序列数据汇总（ohlc()函数）</h3><p>在金融领域，经常会看到开盘（open）、收盘（close）、最高价（high）和最低价（low）数据，而在Pandas中经过重新采样的数据也可以实现这样的结果，通过调用ohlc()函数得到数据汇总结果，即开始值（open）、结束值（close）、最高值（high）和最低值（low）。ohlc()函数的语法如下：</p>
<p>resample.ohlc()<br>ohlc()函数返回DataFrame对象，每组数据的open（开）、high（高）、low（低）和close（关）值。</p>
<p>【示例52】　统计数据的open、high、low和close值。（示例位置：资源包\MR\Code\04\52）<br>下面是一组5分钟的时间序列，通过ohlc()函数获取该时间序列中每组时间的开始值、最高值、最低值和结束值，程序代码如下：</p>
<p>01  import pandas as pd<br>02  import numpy as np<br>03  rng = pd.date_range(‘2/2/2020’,periods=12,freq=’T’)<br>04  s1 = pd.Series(np.arange(12),index=rng)<br>05  print(s1.resample(‘5min’).ohlc())<br>运行程序，控制台输出结果如图4.73所示。</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020053212045.png" alt="image-20211020053212045"></p>
<p>​                          图4.73　时间序列数据汇总</p>
<h3 id="4-9-5-移动窗口数据计算（rolling-函数）"><a href="#4-9-5-移动窗口数据计算（rolling-函数）" class="headerlink" title="4.9.5　移动窗口数据计算（rolling()函数）"></a>4.9.5　移动窗口数据计算（rolling()函数）</h3><p>通过重采样可以得到想要的任何频率的数据，但是这些数据也是一个时点的数据，那么就存在这样一个问题：时点的数据波动较大，某一点的数据就不能很好地表现它本身的特性，于是就有了“移动窗口”的概念，简单地说，为了提升数据的可靠性，将某个点的取值扩大到包含这个点的一段区间，用区间来进行判断，这个区间就是窗口。<br>下面举例说明，图4.74显示了移动窗口数据示意图，其中时间序列代表1号到15号每天的销量数据，接下来以3天为一个窗口，将该窗口从左至右依次移动，统计出3天的平均值作为这个点的值，如3号的销量是1号、2号和3号的平均值。</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020053234231.png" alt="image-20211020053234231"></p>
<p>​                      图4.74　移动窗口数据示意图<br>通过上述示意图相信您已经理解了移动窗口，在Pandas中可以通过rolling()函数实现移动窗口数据的计算，语法如下：</p>
<p>DataFrame.rolling(window, min_periods=None, center=False, win_type=None, on=None, axis=0, closed=None)</p>
<p>参数说明：　</p>
<p>window：时间窗口的大小，有两种形式，即int或offset。如果使用int，则数值表示计算统计量的观测值的数量，即向前几个数据；如果使用offset，则表示时间窗口的大小。　</p>
<p>min_periods：每个窗口最少包含的观测值数量，小于这个值的窗口结果为NA。值可以是int，默认值为None。offset情况下，默认值为1。</p>
<p>center：把窗口的标签设置为居中。布尔型，默认值为False，居右。</p>
<p>win_type：窗口的类型。截取窗的各种函数。字符串类型，默认值为None。　</p>
<p>on：可选参数。对于DataFrame对象，是指定要计算移动窗口的列，值为列名。　</p>
<p>axis：整型，axis=0表示列，axis=1表示行。默认值为0，即对列进行计算。　</p>
<p>closed：定义区间的开闭，支持int类型的窗口。对于offset类型默认是左开右闭（默认值为right）。可以根据情况指定left。　</p>
<p>返回值：为特定操作而生成的窗口或移动窗口子类。</p>
<p>【示例53】　创建淘宝每日销量数据。（示例位置：资源包\MR\Code\04\53）<br>首先创建一组淘宝每日销量数据，程序代码如下：</p>
<p>01  import pandas as pd<br>02  index=pd.date_range(‘20200201’,’20200215’)<br>03  data=[3,6,7,4,2,1,3,8,9,10,12,15,13,22,14]<br>04  s1_data=pd.Series(data,index=index)<br>05  print(s1_data)<br>运行程序，控制台输出结果如图4.75所示。</p>
<p>【示例54】　使用rolling()函数计算3天的均值。（示例位置：资源包\MR\Code\04\54）</p>
<p>下面使用rolling()函数计算2020-02-01至2020-02-15中每3天的均值，窗口个数为3，代码如下：</p>
<p>s1_data.rolling(3).mean()<br>运行程序，看下rolling()函数是如何计算的？在图4.76中，当窗口开始移动时，第一个时间点2020-02-01和第二个时间点2020-02-02的数值为空，这是因为窗口个数为3，它们前面有空数据，所以均值为空；而到第三个时间点2020-02-03时，它前面的数据是2020-02-01至2020-02-03，所以3天的均值是5.333333；以此类推。</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020053403924.png" alt="image-20211020053403924"></p>
<p>​                                     图4.75　原始数据</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020053419587.png" alt="image-20211020053419587"></p>
<p>​                       图4.76　2020-02-01至2020-02-15移动窗口均值1</p>
<p>【示例55】　用当天的数据代表窗口数据。（示例位置：资源包\MR\Code\04\55）<br>在计算第一个时间点2020-02-01的窗口数据时，虽然数据不够窗口长度3，但是至少有当天的数据，那么能否用当天的数据代表窗口数据呢？答案是肯定的，通过设置min_periods参数即可，它表示窗口最少包含的观测值，小于这个值的窗口长度显示为空，等于或大于时都有值，主要代码如下：</p>
<p>s1_data.rolling(3,min_periods=1).mean()</p>
<p>运行程序，对比效果如图4.77所示。<br>上述举例，我们再扩展下，通过图表观察原始数据与移动窗口数据的平稳性，如图4.78所示。其中实线代表移动窗口数据，其走向更平稳，这也是学习移动窗口rolling()函数的原因。</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020053518298.png" alt="image-20211020053518298"></p>
<p>​                 图4.77　2020-02-01至2020-02-15移动窗口均值2</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020053531782.png" alt="image-20211020053531782"></p>
<p>​                     图4.78　移动窗口数据的平稳性说明<br>虚线代表原始数据，实线代表移动窗口数据。</p>
<h2 id="4-10-综合应用"><a href="#4-10-综合应用" class="headerlink" title="4.10　综合应用"></a>4.10　综合应用</h2><h3 id="4-10-1-案例1：Excel多表合并"><a href="#4-10-1-案例1：Excel多表合并" class="headerlink" title="4.10.1　案例1：Excel多表合并"></a>4.10.1　案例1：Excel多表合并</h3><p>案例位置：资源包\MR\Code\04\example\01<br>在日常工作中，几乎我们每天都有大量的数据需要处理，桌面上总是布满密密麻麻的Excel表，这样看上去非常凌乱，其实我们完全可以将其中类别相同的Excel表合并到一起，这样不但不会丢失数据，而且还可以有效地分析数据。下面使用concat()方法将指定文件夹内的所有Excel表合并，程序代码如下：</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020053607260.png" alt="image-20211020053607260"></p>
<h3 id="4-10-2-案例2：股票行情数据分析"><a href="#4-10-2-案例2：股票行情数据分析" class="headerlink" title="4.10.2　案例2：股票行情数据分析"></a>4.10.2　案例2：股票行情数据分析</h3><p>案例位置：资源包\MR\Code\04\example\02<br>股票数据包括开盘价、收盘价、最高价、最低价、成交量等多个指标。其中，收盘价是当日行情的标准，也是下一个交易日开盘价的依据，可以预测未来证券市场行情，因此当投资者对行情分析时，一般采用收盘价作为计算依据。<br>下面使用rolling()函数计算某股票20天、50天和200天的收盘价均值并生成走势图（也称K线图），如图4.79所示。</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020053723586.png" alt="image-20211020053723586"></p>
<p>​                                       图4.79　股票行情分析</p>
<p>程序代码如下：</p>
<p><img src="/2021/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020053800663.png" alt="image-20211020053800663"></p>
<p>实用技巧<br>默认情况下，图表嵌入控制台（IPython console）中并以静态方式显示，无法进行移动、放大、缩小等操作。此时需要在工具中的首选项窗口进行设置，方法为选择Tools→Preferences命令，打开Preferences（首选项）窗口，在左侧列表中选择IPython console（IPython控制台），在右侧窗口选择Graphics（图形）选项卡，然后在Backend（后端）下拉列表框中选择Automatic（自动）或者Qt5，单击Apply（应用）按钮。设置完成后重新启动Spyder才生效。</p>
<h2 id="4-11-小结"><a href="#4-11-小结" class="headerlink" title="4.11　小结"></a>4.11　小结</h2><p>本章是Pandas的进阶学习，有一定难度，但同时也更能够体现Pandas的强大之处，不仅可以完成数据处理工作，而且还能够实现数据的统计分析。Pandas提供的大量函数使统计分析工作变得简单高效。别具特色的“数据位移”是一个非常有用的方法，与其他方法结合，能够实现很多难以想象的功能，数据转换将DataFrame与Python数据类型之间进行灵活转换。不仅如此，对于日期数据的处理、时间序列也都提供了专门的函数和方法，使得量化数据得心应手。</p>
<pre><code class="python">import pymysql
from sqlalchemy import create_engine
import pandas as pd
engine = create_engine(&#39;mysql+pymysql://root:123456@127.0.0.1:3306/2013a&#39;)
sql2=&#39;select * from stu;&#39;
df2=pd.read_excel(&#39;费用.xlsx&#39;)
df2.to_sql(&#39;feiyong&#39;,engine) # 存入数据库
df_read1=pd.read_sql_query(sql2,engine) # 读出数据
</code></pre>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
  </entry>
</search>
