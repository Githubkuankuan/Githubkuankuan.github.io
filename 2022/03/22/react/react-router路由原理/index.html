<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
    
    <meta name="referrer" content="no-referrer-when-downgrade">
    
    <meta name="renderer" content="webkit"/>
    <meta name="force-rendering" content="webkit"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
    <script>if (/*@cc_on!@*/false || (!!window.MSInputMethodContext && !!document.documentMode)) window.location.href="https://support.dmeng.net/upgrade-your-browser.html?referrer="+encodeURIComponent(window.location.href); </script>
    
    
        <link rel="preload" crossorigin="crossorigin" href="/fonts/roboto/Roboto-Regular.woff2" as="font">
        <link rel="preload" crossorigin="crossorigin" href="/fonts/roboto/Roboto-Bold.woff2" as="font">
    
    
    
        <link rel="shortcut icon" href="https://z3.ax1x.com/2021/11/29/oM334O.png">
    

    
    
        
<link rel="stylesheet" href="/css/mdui.min.v1.0.0.css">

    
    
<link rel="stylesheet" href="/css/main.css">
<link rel="stylesheet" href="/css/iconfont.css">


    
    

    
        <script data-ad-client="ca-" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    












          


    
    
    <title>
        
            react-router路由原理 | KKBlog
        
    </title>
    
    
<meta name="generator" content="Hexo 5.4.2"></head>
<body class="mdui-drawer-body-left mdui-appbar-with-toolbar mdui-theme-primary-teal mdui-theme-accent-blue">
  
  <header class="mdui-appbar mdui-appbar-fixed">
  <div id="toolbar" class="mdui-toolbar mdui-color-theme">
    <button class="mdui-btn mdui-btn-icon" mdui-drawer="{target: '#sidebar', swipe: true}"><i class="iconfont icon-menu"></i></button>
    <a href="/" class="mdui-typo-headline">KKBlog</a>
    <a href="/" class="header-subtitle mdui-typo-headline"></a>
    <div class="mdui-toolbar-spacer"></div>
    <button class="mdui-btn mdui-btn-icon" mdui-dialog="{target: '#search'}" mdui-tooltip="{content: 'search'}"><i class="iconfont icon-search"></i></button>
  </div>
</header>

<div class="mdui-dialog" id="search">
  
    <div class="search-form">
      <input type="search" class="search-form-input" placeholder="请输入关键字" onfocus="listenSearchFunc()">
    </div>
    <div class="search-result" data-resource="/search.xml"></div>
  
</div>

  <aside id="sidebar" class="mdui-drawer">
    <div class="mdui-tab" mdui-tab>
        <a href="#sidebar-tab1" id="sidebartab" class="mdui-ripple mdui-tab-active">站点概览</a>
        <a href="#sidebar-tab2" id="sidebartab" class="mdui-ripple">关于</a>
    </div>

    
    <div id="sidebar-tab1" class="mdui-p-a-1">
        <div class="mdui-list">
            
                
                <a href="/" class="mdui-list-item mdui-ripple">
                    <div class="mdui-list-item-icon">
                        <i class="iconfont icon-home"></i>
                    </div>
                    <div class="mdui-list-item-content">主页</div>
                </a>
            
                
                <a href="/tags/" class="mdui-list-item mdui-ripple">
                    <div class="mdui-list-item-icon">
                        <i class="iconfont icon-bookmark"></i>
                    </div>
                    <div class="mdui-list-item-content">标签</div>
                </a>
            
                
                <a href="/categories/" class="mdui-list-item mdui-ripple">
                    <div class="mdui-list-item-icon">
                        <i class="iconfont icon-folder"></i>
                    </div>
                    <div class="mdui-list-item-content">分类</div>
                </a>
            
                
                <a href="/archives/" class="mdui-list-item mdui-ripple">
                    <div class="mdui-list-item-icon">
                        <i class="iconfont icon-archive"></i>
                    </div>
                    <div class="mdui-list-item-content">归档</div>
                </a>
            
                
                <a href="/about/" class="mdui-list-item mdui-ripple">
                    <div class="mdui-list-item-icon">
                        <i class="iconfont icon-user"></i>
                    </div>
                    <div class="mdui-list-item-content">关于</div>
                </a>
            
            <div class="mdui-list-item mdui-ripple">
                <div class="mdui-list-item-icon">
                    <i class="iconfont icon-moon"></i>
                </div>
                <div class="mdui-list-item-content">夜间模式</div>
                <label class="mdui-switch" id="darkmode">
                  <input type="checkbox" id="nightmode_switch"/>
                  <i class="mdui-switch-icon"></i>
                </label>
            </div>           
        </div>
    </div>

    
    <div id="sidebar-tab2" class="mdui-p-a-1">
        <div class="sidebar-overview">
            <div class="sidebar-avatar">
                
                    <img src="https://s3.bmp.ovh/imgs/2021/11/b74ba8f7a70ffeb0.jpg"/>
                
            </div>
            <div class="sidebar-author-name">Dalu Kuankuan</div>
            <div class="sidebar-description">选择有时候比努力更重要</div>
        </div>
        <div class="sidebar-links">
            
                
                <div class="mdui-chip">
                    <span class="mdui-chip-icon"><i class="iconfont icon-mail"></i></span>
                    <a href="mailto:zhanglukuan0927@gmail.com" class="mdui-chip-title">E-Mail</a>
                </div>
            
                
                <div class="mdui-chip">
                    <span class="mdui-chip-icon"><i class="iconfont icon-github"></i></span>
                    <a target="_blank" rel="noopener" href="https://your.url" class="mdui-chip-title">GitHub</a>
                </div>
            
                
                <div class="mdui-chip">
                    <span class="mdui-chip-icon"><i class="iconfont icon-steam"></i></span>
                    <a target="_blank" rel="noopener" href="https://your.url" class="mdui-chip-title">Steam</a>
                </div>
            
                
                <div class="mdui-chip">
                    <span class="mdui-chip-icon"><i class="iconfont icon-weibo"></i></span>
                    <a target="_blank" rel="noopener" href="https://your.url" class="mdui-chip-title">Weibo</a>
                </div>
            
        </div>
        <ul class="mdui-list" mdui-collapse="{accordion: true}">
            <li class="mdui-collapse-item">
                <div class="mdui-collapse-item-header mdui-list-item mdui-ripple">
                    <div class="mdui-list-item-icon">
                        <i class="iconfont icon-link"></i>
                    </div>
                    <div class="mdui-list-item-content">友情链接</div>
                    <div class="mdui-collapse-item-arrow">
                        <i class="mdui-list-item-icon iconfont icon-angle-down"></i>
                    </div>
                </div>
                <ul id="linksList" class="mdui-collapse-item-body mdui-list mdui-list-dense">
                    
                        <a target="_blank" rel="noopener" href="https://garybear.cn/hexo-theme-meadow/" class="mdui-list-item mdui-ripple">
                            Meadow说明文档
                        </a>
                    
                </ul>
            </li>
        </ul>
    </div>

    <div class="mdui-divider"></div>
    
    
</aside>
  
  <main id="main-contain" class="mdui-container mdui-m-t-5">
    <article id="article" class="mdui-card mdui-p-b-2 mdui-m-b-5">
  <header class="mdui-card-media">
    
    
      <div class="post-header"> 
  <a class="post-header-title" href="/2022/03/22/react/react-router%E8%B7%AF%E7%94%B1%E5%8E%9F%E7%90%86/">react-router路由原理</a>
  <div class="post-header-meta">
    <span>
      <span class="iconfont icon-calendar"></span>
      发布于:&nbsp;2022-03-22
    </span>
    <span>
      <span class="iconfont icon-calendar-check"></span>
      更新于:&nbsp;2022-03-22
    </span>
    <span>
      <span class="iconfont icon-folder"></span>
      分类于:&nbsp;<a class="category-link" href="/categories/react/">react</a>
    </span>
    
      <span>
        <span class="iconfont icon-eye"></span>
        阅读次数:&nbsp;
        <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv"></span></span>
      </span>
    
  </div>
</div>   
    



    
    
    <div class="mdui-card-menu">
    
      <button class="mdui-btn mdui-btn-icon mdui-text-color-teal" mdui-menu="{target: '#share_menu', align: 'right'}"><i class="iconfont icon-share"></i></button>
      <ul class="mdui-menu" id="share_menu">
        <li class="mdui-menu-item">
          <a href="http://service.weibo.com/share/share.php?appkey=&title=react-router路由原理&url=http://example.com/2022/03/22/react/react-router%E8%B7%AF%E7%94%B1%E5%8E%9F%E7%90%86/&pic=http://example.comhttps://z3.ax1x.com/2021/11/29/oM334O.png&searchPic=false&style=simple" target="_blank" class="mdui-ripple">分享到 Weibo</a>
        </li>
        <li class="mdui-menu-item">
          <a href="https://twitter.com/intent/tweet?text=react-router路由原理&url=http://example.com/2022/03/22/react/react-router%E8%B7%AF%E7%94%B1%E5%8E%9F%E7%90%86/&via=Dalu Kuankuan" target="_blank" class="mdui-ripple">分享到 Twitter</a>
        </li>
        <li class="mdui-menu-item">
          <a href="https://www.facebook.com/sharer/sharer.php?u=http://example.com/2022/03/22/react/react-router%E8%B7%AF%E7%94%B1%E5%8E%9F%E7%90%86/" target="_blank" class="mdui-ripple">分享到 Facebook</a>
        </li>
        <li class="mdui-menu-item">
          <a href="https://plus.google.com/share?url=http://example.com/2022/03/22/react/react-router%E8%B7%AF%E7%94%B1%E5%8E%9F%E7%90%86/" target="_blank" class="mdui-ripple">分享到 Google+</a>
        </li>
        <li class="mdui-menu-item">
          <a href="https://www.linkedin.com/shareArticle?mini=true&url=http://example.com/2022/03/22/react/react-router%E8%B7%AF%E7%94%B1%E5%8E%9F%E7%90%86/&title=react-router路由原理" target="_blank" class="mdui-ripple">分享到 LinkedIn</a>
        </li>
        <li class="mdui-menu-item">
          <a href="http://connect.qq.com/widget/shareqq/index.html?site=KKBlog&title=react-router路由原理&summary=选择有时候比努力更重要&pics=http://example.comhttps://z3.ax1x.com/2021/11/29/oM334O.png&url=http://example.com/2022/03/22/react/react-router%E8%B7%AF%E7%94%B1%E5%8E%9F%E7%90%86/" target="_blank" class="mdui-ripple">分享到 QQ</a>
        </li>
        <li class="mdui-menu-item">
          <a href="https://telegram.me/share/url?url=http://example.com/2022/03/22/react/react-router%E8%B7%AF%E7%94%B1%E5%8E%9F%E7%90%86/&text=react-router路由原理" target="_blank" class="mdui-ripple">分享到 Telegram</a>
        </li>
      </ul>
    
  </div>
  </header>
  
  
  
  
  <div class="post-tags">
    
      <i class="iconfont icon-tag">
        <a rel="tag" href = /tags/react-router%E8%B7%AF%E7%94%B1/ >react-router路由</a>
      </i>
    
  </div>

  
  <div class="mdui-card-content mdui-typo mdui-p-x-4">
    <h1 id="一、正确理解react-router"><a href="#一、正确理解react-router" class="headerlink" title="一、正确理解react-router"></a>一、正确理解react-router</h1><h2 id="1-理解单页面应用"><a href="#1-理解单页面应用" class="headerlink" title="1. 理解单页面应用"></a>1. 理解单页面应用</h2><p><strong>什么是单页面应用？</strong><br>个人理解，单页面应用是使用一个html下，一次性加载js，css等资源，所有页面都在一个容器页面下，页面切换实质是组件的切换。</p>
<p><img src="/2022/03/22/react/react-router%E8%B7%AF%E7%94%B1%E5%8E%9F%E7%90%86/img.png"></p>
<h2 id="2-react-router初探，揭露路由原理面纱"><a href="#2-react-router初探，揭露路由原理面纱" class="headerlink" title="2. react-router初探，揭露路由原理面纱"></a>2. react-router初探，揭露路由原理面纱</h2><p><strong>① react-router-dom和react-router和history库三者什么关系</strong><br>history可以理解为react-router的核心，也是整个路由原理的核心，里卖弄继承了 popstate，history.pushState等底层路由实现的原理方法，接下来我们会一一解释。<br>react-router可以理解为是react-router-dom的核心，里面封装了Router，Route，Switch等核心组件,实现了从路由的改变到组件的更新的核心功能,在我们的项目中只要一次性引入react-router-dom就可以了。<br>react-router-dom,在react-router的核心基础上，添加了用于跳转的Link组件，和history模式下的BrowserRouter和hash模式下的HashRouter组件等。所谓BrowserRouter和HashRouter，也只不过用了history库中createBrowserHistory和createHashHistory方法<br>react-router-dom 我们不多说了，这里我们重点看一下react-router。</p>
<p><strong>②来个小demo尝尝鲜?</strong></p>
<pre><code class="js">import &#123; BrowserRouter as Router, Switch, Route, Redirect,Link &#125; from &#39;react-router-dom&#39;

import Detail from &#39;../src/page/detail&#39;
import List from &#39;../src/page/list&#39;
import Index from &#39;../src/page/home/index&#39;

const menusList = [
  &#123;
    name: &#39;首页&#39;,
    path: &#39;/index&#39;
  &#125;,
  &#123;
    name: &#39;列表&#39;,
    path: &#39;/list&#39;
  &#125;,
  &#123;
    name: &#39;详情&#39;,
    path: &#39;/detail&#39;
  &#125;,
]
const index = () =&gt; &#123;
  return &lt;div &gt;
    &lt;div &gt;
     
      &lt;Router  &gt;
      &lt;div&gt;&#123;
        /* link 路由跳转 */
         menusList.map(router=&gt;&lt;Link key=&#123;router.path&#125; to=&#123; router.path &#125; &gt;
           &lt;span className=&quot;routerLink&quot; &gt;&#123;router.name&#125;&lt;/span&gt;
         &lt;/Link&gt;)
      &#125;&lt;/div&gt;
        &lt;Switch&gt;
          &lt;Route path=&#123;&#39;/index&#39;&#125; component=&#123;Index&#125; &gt;&lt;/Route&gt;
          &lt;Route path=&#123;&#39;/list&#39;&#125; component=&#123;List&#125; &gt;&lt;/Route&gt;
          &lt;Route path=&#123;&#39;/detail&#39;&#125; component=&#123;Detail&#125; &gt;&lt;/Route&gt;
          &#123;/*  路由不匹配，重定向到/index  */&#125;
          &lt;Redirect from=&#39;/*&#39; to=&#39;/index&#39; /&gt;
        &lt;/Switch&gt;
      &lt;/Router&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&#125;
</code></pre>
<p><strong>效果如下</strong><br><img src="https://img-blog.csdnimg.cn/img_convert/08f57d33419dbf8917460d531662c9d9.png"></p>
<h1 id="二、单页面实现核心原理"><a href="#二、单页面实现核心原理" class="headerlink" title="二、单页面实现核心原理"></a>二、单页面实现核心原理</h1><p>单页面应用路由实现原理是，切换url，监听url变化，从而渲染不同的页面组件。<br>主要的方式history模式和hash模式。</p>
<h2 id="1-history模式原理"><a href="#1-history模式原理" class="headerlink" title="1. history模式原理"></a>1. history模式原理</h2><p><strong>① 改变路由</strong><br><code>history.pushState</code></p>
<pre><code class="js">history.pushState(state,title,path)
</code></pre>
<ol>
<li><code>state</code>：一个与指定网址相关的状态对象，popstate事件触发时，该对象会传入回调函数。如果不需要可填null。</li>
<li>title：新页面的标题，但是所有浏览器目前都忽略这个值，可填null。</li>
<li>path：新的网址，必须与当前页面处于同一个域。浏览器的地址将显示这个地址。</li>
</ol>
<p><code>history.replaceState</code></p>
<pre><code class="js">history.replaceState(state,title,path)
</code></pre>
<p>参数和pushState一样，这个方法会修改当前的 history 对象记录， history.length 的长度不会改变。<br><strong>② 监听路由</strong><br><code>popstate事件</code></p>
<pre><code class="js">window.addEventListener(&#39;popstate&#39;,function(e)&#123;
    /* 监听改变 */
&#125;)
</code></pre>
<p>同一个文档的 history 对象出现变化时，就会触发 popstate 事件<br>history.pushState 可以使浏览器地址改变，但是无需刷新页面。注意 ⚠️的是：用 history.pushState() 或者 history.replaceState() 不会触发 popstate 事件。 popstate 事件只会在浏览器某些行为下触发, 比如点击后退、前进按钮或者调用 history.back()、history.forward()、history.go()方法。</p>
<h2 id="2-hash模式原理"><a href="#2-hash模式原理" class="headerlink" title="2. hash模式原理"></a>2. hash模式原理</h2><p><strong>① 改变路由</strong><br><code>window.location.hash</code><br>通过window.location.hash 属性获取和设置 hash 值。</p>
<p><strong>② 监听路由</strong><br><code>onhashchange</code></p>
<pre><code class="js">window.addEventListener(&#39;hashchange&#39;,function(e)&#123;
    /* 监听改变 */
&#125;)
</code></pre>
<h1 id="三、理解-history-库"><a href="#三、理解-history-库" class="headerlink" title="三、理解 history 库"></a>三、理解 history 库</h1><p>react-router路由离不开history库，history专注于记录路由history状态，以及path改变了，我们应该做写什么。<br>在history模式下用popstate监听路由变化，在hash模式下用hashchange监听路由的变化。<br>接下来我们看 Browser模式下的createBrowserHistory 和 Hash模式下的 createHashHistory方法。</p>
<h3 id="1-createBrowserHistory"><a href="#1-createBrowserHistory" class="headerlink" title="1. createBrowserHistory"></a>1. createBrowserHistory</h3><p>Browser模式下路由的运行 ，一切都从createBrowserHistory开始。这里我们参考的history-4.7.2版本，最新版本中api可能有些出入，但是原理都是一样的，在解析history过程中，我们重点关注setState ,push ,handlePopState,listen方法</p>
<pre><code class="js">const PopStateEvent = &#39;popstate&#39;
const HashChangeEvent = &#39;hashchange&#39;
/* 这里简化了createBrowserHistory，列出了几个核心api及其作用 */
function createBrowserHistory()&#123;
    /* 全局history  */
    const globalHistory = window.history
    /* 处理路由转换，记录了listens信息。 */
    const transitionManager = createTransitionManager()
    /* 改变location对象，通知组件更新 */
    const setState = () =&gt; &#123; /* ... */ &#125;
    
    /* 处理当path改变后，处理popstate变化的回调函数 */
    const handlePopState = () =&gt; &#123; /* ... */ &#125;
   
    /* history.push方法，改变路由，通过全局对象history.pushState改变url, 通知router触发更新，替换组件 */
    const push=() =&gt; &#123; /*...*/ &#125;
    
    /* 底层应用事件监听器，监听popstate事件 */
    const listen=()=&gt;&#123; /*...*/ &#125; 
    return &#123;
       push,
       listen,
       /* .... */ 
    &#125;
&#125;
</code></pre>
<p>下面逐一分析各个api,和他们之前的相互作用</p>
<pre><code class="js">const PopStateEvent = &#39;popstate&#39;
const HashChangeEvent = &#39;hashchange&#39;
</code></pre>
<p><code>popstate</code> 和 <code>hashchange</code> 是监听路由变化底层方法。</p>
<p><strong>① setState</strong></p>
<pre><code class="js">const setState = (nextState) =&gt; &#123;
    /* 合并信息 */
    Object.assign(history, nextState)
    history.length = globalHistory.length
    /* 通知每一个listens 路由已经发生变化 */
    transitionManager.notifyListeners(
      history.location,
      history.action
    )
  &#125;
</code></pre>
<p>代码很简单：统一每个transitionManager管理的listener路由状态已经更新。<br>什么时候绑定listener， 我们在接下来的React-Router代码中会介绍。</p>
<p><strong>② listen</strong></p>
<pre><code class="js">const listen = (listener) =&gt; &#123;
    /* 添加listen */
    const unlisten = transitionManager.appendListener(listener)
    checkDOMListeners(1)

    return () =&gt; &#123;
      checkDOMListeners(-1)
      unlisten()
    &#125;
&#125;
</code></pre>
<p><strong>checkDOMListeners</strong></p>
<pre><code class="js">const checkDOMListeners = (delta) =&gt; &#123;
    listenerCount += delta
    if (listenerCount === 1) &#123;
      addEventListener(window, PopStateEvent, handlePopState)
      if (needsHashChangeListener)
        addEventListener(window, HashChangeEvent, handleHashChange)
    &#125; else if (listenerCount === 0) &#123;
      removeEventListener(window, PopStateEvent, handlePopState)
      if (needsHashChangeListener)
        removeEventListener(window, HashChangeEvent, handleHashChange)
    &#125;
  &#125;
</code></pre>
<p>listen本质通过checkDOMListeners的参数 1 或 -1 来绑定/解绑 popstate 事件，当路由发生改变的时候，调用处理函数handlePopState。<br>接下来我们看看push方法。</p>
<p><strong>③ push</strong></p>
<pre><code class="js"> const push = (path, state) =&gt; &#123;
    const action = &#39;PUSH&#39;
    /* 1 创建location对象 */
    const location = createLocation(path, state, createKey(), history.location)
    /* 确定是否能进行路由转换，还在确认的时候又开始了另一个转变 ,可能会造成异常 */
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, (ok) =&gt; &#123;
      if (!ok)
        return
      const href = createHref(location)
      const &#123; key, state &#125; = location
      if (canUseHistory) &#123;
        /* 改变 url */
        globalHistory.pushState(&#123; key, state &#125;, null, href)
        if (forceRefresh) &#123;
          window.location.href = href
        &#125; else &#123;
          /* 改变 react-router location对象, 创建更新环境 */
          setState(&#123; action, location &#125;)
        &#125;
      &#125; else &#123;
        window.location.href = href
      &#125;
    &#125;)
  &#125;
</code></pre>
<p>push ( history.push ) 流程大致是 首先生成一个最新的location对象，然后通过window.history.pushState方法改变浏览器当前路由(即当前的path),最后通过setState方法通知React-Router更新，并传递当前的location对象，由于这次url变化的，是history.pushState产生的，并不会触发popState方法，所以需要手动setState，触发组件更新。</p>
<p><strong>④ handlePopState</strong></p>
<pre><code class="js">/* 我们简化一下handlePopState */
const handlePopState = (event)=&gt;&#123;
     /* 获取当前location对象 */
    const location = getDOMLocation(event.state)
    const action = &#39;POP&#39;

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, (ok) =&gt; &#123;
        if (ok) &#123;
          setState(&#123; action, location &#125;)
        &#125; else &#123;
          revertPop(location)
        &#125;
    &#125;)
&#125;
</code></pre>
<p>handlePopState 代码很简单 ，判断一下action类型为pop,然后 setState ，从新加载组件。</p>
<h3 id="2-createHashHistory"><a href="#2-createHashHistory" class="headerlink" title="2. createHashHistory"></a>2. createHashHistory</h3><p>hash 模式和 history API类似，我们重点讲一下 hash模式下，怎么监听路由，和push , replace方法是怎么改变改变路径的。<br><strong>监听哈希路由变化</strong></p>
<pre><code class="js">  const HashChangeEvent = &#39;hashchange&#39;
  const checkDOMListeners = (delta) =&gt; &#123;
    listenerCount += delta
    if (listenerCount === 1) &#123;
      addEventListener(window, HashChangeEvent, handleHashChange)
    &#125; else if (listenerCount === 0) &#123;
      removeEventListener(window, HashChangeEvent, handleHashChange)
    &#125;
  &#125;
</code></pre>
<p>和之前所说的一样，就是用hashchange来监听hash路由的变化。</p>
<p><strong>改变哈希路由</strong></p>
<pre><code class="js">/* 对应 push 方法 */
const pushHashPath = (path) =&gt;
  window.location.hash = path

/* 对应replace方法 */
const replaceHashPath = (path) =&gt; &#123;
  const hashIndex = window.location.href.indexOf(&#39;#&#39;)

  window.location.replace(
    window.location.href.slice(0, hashIndex &gt;= 0 ? hashIndex : 0) + &#39;#&#39; + path
  )
&#125;
</code></pre>
<p>在hash模式下 ，history.push 底层是调用了window.location.href来改变路由。history.replace底层是掉用<br>window.location.replace改变路由。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>我们用一幅图来描述了一下history库整体流程。</strong></p>
<p><img src="/2022/03/22/react/react-router%E8%B7%AF%E7%94%B1%E5%8E%9F%E7%90%86/img_1.png"></p>
<h1 id="四、-核心api"><a href="#四、-核心api" class="headerlink" title="四、 核心api"></a>四、 核心api</h1><h2 id="1、Router-接收location变化，派发更新流"><a href="#1、Router-接收location变化，派发更新流" class="headerlink" title="1、Router-接收location变化，派发更新流"></a>1、Router-接收location变化，派发更新流</h2><p>Router 作用是把 history location 等路由信息 传递下去<br><code>Router</code></p>
<pre><code class="js">/* Router 作用是把 history location 等路由信息 传递下去  */
class Router extends React.Component &#123;
  static computeRootMatch(pathname) &#123;
    return &#123; path: &#39;/&#39;, url: &#39;/&#39;, params: &#123;&#125;, isExact: pathname === &#39;/&#39; &#125;;
  &#125;
  constructor(props) &#123;
    super(props);
    this.state = &#123;
      location: props.history.location
    &#125;;
    //记录pending位置
    //如果存在任何&lt;Redirect&gt;，则在构造函数中进行更改
    //在初始渲染时。如果有，它们将在
    //在子组件身上激活，我们可能会
    //在安装&lt;Router&gt;之前获取一个新位置。
    this._isMounted = false;
    this._pendingLocation = null;
    /* 此时的history，是history创建的history对象 */
    if (!props.staticContext) &#123;
      /* 这里判断 componentDidMount 和 history.listen 执行顺序 然后把 location复制 ，防止组件重新渲染 */
      this.unlisten = props.history.listen(location =&gt; &#123;
        /* 创建监听者 */
        if (this._isMounted) &#123;

          this.setState(&#123; location &#125;);
        &#125; else &#123;
          this._pendingLocation = location;
        &#125;
      &#125;);
    &#125;
  &#125;
  componentDidMount() &#123;
    this._isMounted = true;
    if (this._pendingLocation) &#123;
      this.setState(&#123; location: this._pendingLocation &#125;);
    &#125;
  &#125;
  componentWillUnmount() &#123;
    /* 解除监听 */
    if (this.unlisten) this.unlisten();
  &#125;
  render() &#123;
    return (
      /*  这里可以理解 react.createContext 创建一个 context上下文 ，保存router基本信息。children */
      &lt;RouterContext.Provider
          children=&#123;this.props.children || null&#125;
          value=&#123;&#123;
          history: this.props.history,
          location: this.state.location,
          match: Router.computeRootMatch(this.state.location.pathname),
          staticContext: this.props.staticContext
        &#125;&#125;
      /&gt;
    );
  &#125;
&#125;
</code></pre>
<p><strong>总结：</strong></p>
<p>初始化绑定listen, 路由变化,通知改变location,改变组件。 react的history路由状态是保存在React.Content上下文之间, 状态更新。<br>一个项目应该有一个根Router ， 来产生切换路由组件之前的更新作用。<br>如果存在多个Router会造成，会造成切换路由，页面不更新的情况。</p>
<h2 id="2、Switch-匹配正确的唯一的路由"><a href="#2、Switch-匹配正确的唯一的路由" class="headerlink" title="2、Switch-匹配正确的唯一的路由"></a>2、Switch-匹配正确的唯一的路由</h2><p>根据router更新流，来渲染当前组件。</p>
<pre><code class="js">/* switch组件 */
class Switch extends React.Component &#123;
  render() &#123;
    return (
      &lt;RouterContext.Consumer&gt;
        &#123;/* 含有 history location 对象的 context */&#125;
        &#123;context =&gt; &#123;
          invariant(context, &#39;You should not use &lt;Switch&gt; outside a &lt;Router&gt;&#39;);
          const location = this.props.location || context.location;
          let element, match;
          //我们使用React.Children.forEach而不是React.Children.toArray（）.find（）
          //这里是因为toArray向所有子元素添加了键，我们不希望
          //为呈现相同的两个&lt;Route&gt;s触发卸载/重新装载
          //组件位于不同的URL。
          //这里只需然第一个 含有 match === null 的组件
          React.Children.forEach(this.props.children, child =&gt; &#123;
            if (match == null &amp;&amp; React.isValidElement(child)) &#123;
              element = child;
              // 子组件 也就是 获取 Route中的 path 或者 rediect 的 from
              const path = child.props.path || child.props.from;
              match = path
                ? matchPath(location.pathname, &#123; ...child.props, path &#125;)
                : context.match;
            &#125;
          &#125;);
          return match
            ? React.cloneElement(element, &#123; location, computedMatch: match &#125;)
            : null;
        &#125;&#125;
      &lt;/RouterContext.Consumer&gt;
    );
  &#125;
&#125;
</code></pre>
<p>找到与当前path,匹配的组件进行渲染。 通过pathname和组件的path进行匹配。找到符合path的router组件。<br><strong>matchPath</strong></p>
<pre><code class="js">function matchPath(pathname, options = &#123;&#125;) &#123;
  if (typeof options === &quot;string&quot; || Array.isArray(options)) &#123;
    options = &#123; path: options &#125;;
  &#125;

  const &#123; path, exact = false, strict = false, sensitive = false &#125; = options;

  const paths = [].concat(path);

  return paths.reduce((matched, path) =&gt; &#123;
    if (!path &amp;&amp; path !== &quot;&quot;) return null;
    if (matched) return matched;

    const &#123; regexp, keys &#125; = compilePath(path, &#123;
      end: exact,
      strict,
      sensitive
    &#125;);
    const match = regexp.exec(pathname);
    /* 匹配不成功，返回null */
    if (!match) return null;

    const [url, ...values] = match;
    const isExact = pathname === url;

    if (exact &amp;&amp; !isExact) return null;

    return &#123;
      path, // the path used to match
      url: path === &quot;/&quot; &amp;&amp; url === &quot;&quot; ? &quot;/&quot; : url, // the matched portion of the URL
      isExact, // whether or not we matched exactly
      params: keys.reduce((memo, key, index) =&gt; &#123;
        memo[key.name] = values[index];
        return memo;
      &#125;, &#123;&#125;)
    &#125;;
  &#125;, null);
&#125;
</code></pre>
<h2 id="3、Route-组件页面承载容器"><a href="#3、Route-组件页面承载容器" class="headerlink" title="3、Route-组件页面承载容器"></a>3、Route-组件页面承载容器</h2><pre><code class="js">/**
 * The public API for matching a single path and rendering.
 */
class Route extends React.Component &#123;
  render() &#123;
    return (
      &lt;RouterContext.Consumer&gt;
        &#123;context =&gt; &#123;
          /* router / route 会给予警告警告 */
          invariant(context, &quot;You should not use &lt;Route&gt; outside a &lt;Router&gt;&quot;);
          // computedMatch 为 经过 swich处理后的 path
          const location = this.props.location || context.location;
          const match = this.props.computedMatch 
            ? this.props.computedMatch // &lt;Switch&gt; already computed the match for us
            : this.props.path
            ? matchPath(location.pathname, this.props)
            : context.match;
          const props = &#123; ...context, location, match &#125;;
          let &#123; children, component, render &#125; = this.props;

          if (Array.isArray(children) &amp;&amp; children.length === 0) &#123;
            children = null;
          &#125;

          return (
            &lt;RouterContext.Provider value=&#123;props&#125;&gt;
              &#123;props.match
                ? children
                  ? typeof children === &quot;function&quot;
                    ? __DEV__
                      ? evalChildrenDev(children, props, this.props.path)
                      : children(props)
                    : children
                  : component
                  ? React.createElement(component, props)
                  : render
                  ? render(props)
                  : null
                : typeof children === &quot;function&quot;
                ? __DEV__
                  ? evalChildrenDev(children, props, this.props.path)
                  : children(props)
                : null&#125;
            &lt;/RouterContext.Provider&gt;
          );
        &#125;&#125;
      &lt;/RouterContext.Consumer&gt;
    );
  &#125;
&#125;
</code></pre>
<p>匹配path,渲染组件。作为路由组件的容器,可以根据将实际的组件渲染出来。通过RouterContext.Consume 取出当前上一级的location,match等信息。作为prop传递给页面组件。使得我们可以在页面组件中的props中获取location ,match等信息。</p>
<h2 id="4、Redirect-没有符合的路由，那么重定向"><a href="#4、Redirect-没有符合的路由，那么重定向" class="headerlink" title="4、Redirect-没有符合的路由，那么重定向"></a>4、Redirect-没有符合的路由，那么重定向</h2><p>重定向组件， 如果来路由匹配上，会重定向对应的路由。</p>
<pre><code class="js">function Redirect(&#123; computedMatch, to, push = false &#125;) &#123;
  return (
    &lt;RouterContext.Consumer&gt;
      &#123;context =&gt; &#123;
        const &#123; history, staticContext &#125; = context;
        /* method就是路由跳转方法。 */
        const method = push ? history.push : history.replace;
        /* 找到符合match的location ，格式化location */
        const location = createLocation(
          computedMatch
            ? typeof to === &#39;string&#39;
              ? generatePath(to, computedMatch.params)
              : &#123;
                  ...to,
                  pathname: generatePath(to.pathname, computedMatch.params)
                &#125;
            : to
        )
        /* 初始化的时候进行路由跳转，当初始化的时候，mounted执行push方法，当组件更新的时候，如果location不相等。同样会执行history方法重定向 */
        return (
          &lt;Lifecycle
              onMount=&#123;() =&gt; &#123;
              method(location);
            &#125;&#125;
              onUpdate=&#123;(self, prevProps) =&gt; &#123;
              const prevLocation = createLocation(prevProps.to);
              if (
                !locationsAreEqual(prevLocation, &#123;
                  ...location,
                  key: prevLocation.key
                &#125;)
              ) &#123;
                method(location);
              &#125; 
            &#125;&#125;
              to=&#123;to&#125;
          /&gt;
        );
      &#125;&#125;
    &lt;/RouterContext.Consumer&gt;
  );
&#125;
</code></pre>
<p>初始化的时候进行路由跳转，当初始化的时候，mounted执行push方法，当组件更新的时候，如果location不相等。同样会执行history方法重定向。</p>
<h1 id="五、总结-流程分析"><a href="#五、总结-流程分析" class="headerlink" title="五、总结 + 流程分析"></a>五、总结 + 流程分析</h1><p><strong>总结</strong></p>
<p>history提供了核心api，如监听路由，更改路由的方法，已经保存路由状态state。</p>
<p>react-router提供路由渲染组件，路由唯一性匹配组件，重定向组件等功能组件。</p>
<p><strong>流程分析</strong></p>
<p><strong>当地址栏改变url，组件的更新渲染都经历了什么？😊😊😊</strong><br>拿history模式做参考。当url改变，首先触发histoy，调用事件监听popstate事件， 触发回调函数handlePopState，触发history下面的setstate方法，产生新的location对象，然后通知Router组件更新location并通过context上下文传递，switch通过传递的更新流，匹配出符合的Route组件渲染，最后有Route组件取出context内容，传递给渲染页面，渲染更新。</p>
<p><strong>当我们调用history.push方法，切换路由，组件的更新渲染又都经历了什么呢？</strong><br>我们还是拿history模式作为参考，当我们调用history.push方法，首先调用history的push方法，通过history.pushState来改变当前url，接下来触发history下面的setState方法，接下来的步骤就和上面一模一样了，这里就不一一说了。</p>
<p><strong>我们用一幅图来表示各个路由组件之间的关系。</strong></p>
<p><img src="/2022/03/22/react/react-router%E8%B7%AF%E7%94%B1%E5%8E%9F%E7%90%86/img_2.png"></p>
<p>希望读过此篇文章的朋友，能够明白react-router的整个流程，代码逻辑不是很难理解。整个流程我给大家分析了一遍，希望同学们能主动看一波源码，把整个流程搞明白。纸上得来终觉浅,绝知此事要躬行。</p>

  </div>
  <!--文末结束语-->
  
    <div style="text-align:center;color: #ccc;font-size:24px;"> --- 本文结束 <i class="iconfont icon-heartbeat" style="font-size:24px;"></i> The End --- </div>
  
  <!--页脚广告-->
  
  <div class="mdui-divider"></div>
  
  <nav>
    
      <a rel="prev" class="post-nav-item mdui-float-left" href="/2022/03/22/react/react-redux%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/">
        <i class="iconfont icon-angle-left"></i>
        <span>react-redux的核心原理</span>
      </a>
    
    
      <a rel="next" class="post-nav-item mdui-float-right" href="/2022/03/05/react/React-Router%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88/">
        <span>React-Router的实现原理及工作方式分别是什么</span>
        <i class="iconfont icon-angle-right"></i>
      </a>
    
  </nav>
</article>




  <div class="toc-button"  style="z-index: 100;">
    <button class="mdui-fab mdui-ripple mdui-color-teal" mdui-menu="{target: '#toc'}"><i class="iconfont icon-list"></i></button>
    <ul class="mdui-menu" id="toc">
      <li class="mdui-menu-item">
        <a href="/2022/03/22/react/react-router%E8%B7%AF%E7%94%B1%E5%8E%9F%E7%90%86/" id="toc-header" class="mdui-ripple">文章目录</a>
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%AD%A3%E7%A1%AE%E7%90%86%E8%A7%A3react-router"><span class="toc-number">1.</span> <span class="toc-text">一、正确理解react-router</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%90%86%E8%A7%A3%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8"><span class="toc-number">1.1.</span> <span class="toc-text">1. 理解单页面应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-react-router%E5%88%9D%E6%8E%A2%EF%BC%8C%E6%8F%AD%E9%9C%B2%E8%B7%AF%E7%94%B1%E5%8E%9F%E7%90%86%E9%9D%A2%E7%BA%B1"><span class="toc-number">1.2.</span> <span class="toc-text">2. react-router初探，揭露路由原理面纱</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%AE%9E%E7%8E%B0%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">二、单页面实现核心原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-history%E6%A8%A1%E5%BC%8F%E5%8E%9F%E7%90%86"><span class="toc-number">2.1.</span> <span class="toc-text">1. history模式原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-hash%E6%A8%A1%E5%BC%8F%E5%8E%9F%E7%90%86"><span class="toc-number">2.2.</span> <span class="toc-text">2. hash模式原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%90%86%E8%A7%A3-history-%E5%BA%93"><span class="toc-number">3.</span> <span class="toc-text">三、理解 history 库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-createBrowserHistory"><span class="toc-number">3.0.1.</span> <span class="toc-text">1. createBrowserHistory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-createHashHistory"><span class="toc-number">3.0.2.</span> <span class="toc-text">2. createHashHistory</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.1.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81-%E6%A0%B8%E5%BF%83api"><span class="toc-number">4.</span> <span class="toc-text">四、 核心api</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81Router-%E6%8E%A5%E6%94%B6location%E5%8F%98%E5%8C%96%EF%BC%8C%E6%B4%BE%E5%8F%91%E6%9B%B4%E6%96%B0%E6%B5%81"><span class="toc-number">4.1.</span> <span class="toc-text">1、Router-接收location变化，派发更新流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81Switch-%E5%8C%B9%E9%85%8D%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%94%AF%E4%B8%80%E7%9A%84%E8%B7%AF%E7%94%B1"><span class="toc-number">4.2.</span> <span class="toc-text">2、Switch-匹配正确的唯一的路由</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81Route-%E7%BB%84%E4%BB%B6%E9%A1%B5%E9%9D%A2%E6%89%BF%E8%BD%BD%E5%AE%B9%E5%99%A8"><span class="toc-number">4.3.</span> <span class="toc-text">3、Route-组件页面承载容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81Redirect-%E6%B2%A1%E6%9C%89%E7%AC%A6%E5%90%88%E7%9A%84%E8%B7%AF%E7%94%B1%EF%BC%8C%E9%82%A3%E4%B9%88%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">4.4.</span> <span class="toc-text">4、Redirect-没有符合的路由，那么重定向</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%80%BB%E7%BB%93-%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-number">5.</span> <span class="toc-text">五、总结 + 流程分析</span></a></li></ol>
      </li>
    </ul>
  </div>



    <div id="comment" class="mdui-card mdui-p-a-2 mdui-m-b-5">
      <div class="mdui-tab" mdui-tab>
        
          <a href="#comment-tab0" class="mdui-ripple">valine</a>
        
      </div>
      
        <div id="comment-tab0" class="mdui-p-a-2">
          <div id="vcomments"></div>
<script src="//cdnjs.loli.net/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>
<script>
  var GUEST_INFO = ['nick', 'mail', 'link'];
  var guest_info = ''.split(',').filter(function (item) {
    return GUEST_INFO.indexOf(item) > -1;
  });
  var notify = '' === 'true';
  var verify = '' === 'true';
  new Valine({
    el: '#vcomments',
    notify: notify,
    verify: verify,
    appId: 'K384DoBsTJo09tPYtLMxDJz1-gzGzoHsz',
    appKey: 'Bp5G6BLH11s6zkpTjHkvoG1g',
    placeholder: '',
    pageSize: '',
    avatar: '',
    lang: '',
    guest_info: guest_info
  });
</script>
        </div>
      
    </div>

  </main>
  <footer id="footer" class="mdui-text-center mdui-m-t-5 mdui-p-b-2 mdui-p-t-4 mdui-color-theme">
  <div class="mdui-container">
    <div class="mdui-row">
      
        <a href="https://beian.miit.gov.cn" rel="noopener" target="_blank"></a>
      
      <span>
        &copy; 2015 - 2022 
        
          <span style="color:#d9333f" class="iconfont icon-heart"></span>
        
        Dalu Kuankuan
      </span>
    </div>
    <div class="mdui-row">
      
        <div class="mdui-col-xs-6 mdui-text-right">
          <span>Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a></span>
        </div>
        <div class="mdui-col-xs-6 mdui-text-left">
          <span>Theme: <a href="https://github.com/kb1000fx/Meadow" rel="noopener" target="_blank">Meadow</a></span>
        </div>
      
    </div>
    <div class="mdui-row">
      
        <div class="mdui-col-xs-6 mdui-text-right">
          <span id="busuanzi_container_site_uv" style="display: none;"> <span class="iconfont icon-user"></span>总访客量 <span id="busuanzi_value_site_uv"></span></span>
        </div>
        <div class="mdui-col-xs-6 mdui-text-left">
          <span id="busuanzi_container_site_pv" style="display: none;"> <span class="iconfont icon-eye"></span>总访问量 <span id="busuanzi_value_site_pv"></span></span>
        </div>
      
    </div>
 </div>
</footer>
  
  <button id="gotop" class="mdui-fab mdui-fab-fixed mdui-fab-hide mdui-ripple mdui-color-teal" style="z-index:100;"><i class="iconfont icon-arrowup"></i></button>
  
  

    <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




    <script src="https://cdn.jsdelivr.net/npm/mermaid@8.4.8/dist/mermaid.min.js"></script>
    <script>mermaid.initialize({
        startOnLoad: true,
        theme: "default"
    });</script>




    
<script src="/js/mdui.min.v1.0.0.js"></script>




<script src="/js/meadow.js"></script>

</body>
</html >