<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
    
    <meta name="referrer" content="no-referrer-when-downgrade">
    
    <meta name="renderer" content="webkit"/>
    <meta name="force-rendering" content="webkit"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
    <script>if (/*@cc_on!@*/false || (!!window.MSInputMethodContext && !!document.documentMode)) window.location.href="https://support.dmeng.net/upgrade-your-browser.html?referrer="+encodeURIComponent(window.location.href); </script>
    
    
        <link rel="preload" crossorigin="crossorigin" href="/fonts/roboto/Roboto-Regular.woff2" as="font">
        <link rel="preload" crossorigin="crossorigin" href="/fonts/roboto/Roboto-Bold.woff2" as="font">
    
    
    
        <link rel="shortcut icon" href="https://z3.ax1x.com/2021/11/29/oM334O.png">
    

    
    
        
<link rel="stylesheet" href="/css/mdui.min.v1.0.0.css">

    
    
<link rel="stylesheet" href="/css/main.css">
<link rel="stylesheet" href="/css/iconfont.css">


    
    

    
        <script data-ad-client="ca-" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    












          


    
    
    <title>
        
            ES Promise.all/race | KKBlog
        
    </title>
    
    
<meta name="generator" content="Hexo 5.4.2"></head>
<body class="mdui-drawer-body-left mdui-appbar-with-toolbar mdui-theme-primary-teal mdui-theme-accent-blue">
  
  <header class="mdui-appbar mdui-appbar-fixed">
  <div id="toolbar" class="mdui-toolbar mdui-color-theme">
    <button class="mdui-btn mdui-btn-icon" mdui-drawer="{target: '#sidebar', swipe: true}"><i class="iconfont icon-menu"></i></button>
    <a href="/" class="mdui-typo-headline">KKBlog</a>
    <a href="/" class="header-subtitle mdui-typo-headline"></a>
    <div class="mdui-toolbar-spacer"></div>
    <button class="mdui-btn mdui-btn-icon" mdui-dialog="{target: '#search'}" mdui-tooltip="{content: 'search'}"><i class="iconfont icon-search"></i></button>
  </div>
</header>

<div class="mdui-dialog" id="search">
  
    <div class="search-form">
      <input type="search" class="search-form-input" placeholder="请输入关键字" onfocus="listenSearchFunc()">
    </div>
    <div class="search-result" data-resource="/search.xml"></div>
  
</div>

  <aside id="sidebar" class="mdui-drawer">
    <div class="mdui-tab" mdui-tab>
        <a href="#sidebar-tab1" id="sidebartab" class="mdui-ripple mdui-tab-active">站点概览</a>
        <a href="#sidebar-tab2" id="sidebartab" class="mdui-ripple">关于</a>
    </div>

    
    <div id="sidebar-tab1" class="mdui-p-a-1">
        <div class="mdui-list">
            
                
                <a href="/" class="mdui-list-item mdui-ripple">
                    <div class="mdui-list-item-icon">
                        <i class="iconfont icon-home"></i>
                    </div>
                    <div class="mdui-list-item-content">主页</div>
                </a>
            
                
                <a href="/tags/" class="mdui-list-item mdui-ripple">
                    <div class="mdui-list-item-icon">
                        <i class="iconfont icon-bookmark"></i>
                    </div>
                    <div class="mdui-list-item-content">标签</div>
                </a>
            
                
                <a href="/categories/" class="mdui-list-item mdui-ripple">
                    <div class="mdui-list-item-icon">
                        <i class="iconfont icon-folder"></i>
                    </div>
                    <div class="mdui-list-item-content">分类</div>
                </a>
            
                
                <a href="/archives/" class="mdui-list-item mdui-ripple">
                    <div class="mdui-list-item-icon">
                        <i class="iconfont icon-archive"></i>
                    </div>
                    <div class="mdui-list-item-content">归档</div>
                </a>
            
                
                <a href="/tools/" class="mdui-list-item mdui-ripple">
                    <div class="mdui-list-item-icon">
                        <i class="iconfont icon-tools"></i>
                    </div>
                    <div class="mdui-list-item-content">工具箱</div>
                </a>
            
                
                <a href="/about/" class="mdui-list-item mdui-ripple">
                    <div class="mdui-list-item-icon">
                        <i class="iconfont icon-user"></i>
                    </div>
                    <div class="mdui-list-item-content">关于</div>
                </a>
            
            <div class="mdui-list-item mdui-ripple">
                <div class="mdui-list-item-icon">
                    <i class="iconfont icon-moon"></i>
                </div>
                <div class="mdui-list-item-content">夜间模式</div>
                <label class="mdui-switch" id="darkmode">
                  <input type="checkbox" id="nightmode_switch"/>
                  <i class="mdui-switch-icon"></i>
                </label>
            </div>           
        </div>
    </div>

    
    <div id="sidebar-tab2" class="mdui-p-a-1">
        <div class="sidebar-overview">
            <div class="sidebar-avatar">
                
                    <img src="https://s3.bmp.ovh/imgs/2021/11/b74ba8f7a70ffeb0.jpg"/>
                
            </div>
            <div class="sidebar-author-name">Dalu Kuankuan</div>
            <div class="sidebar-description">选择有时候比努力更重要</div>
        </div>
        <div class="sidebar-links">
            
                
                <div class="mdui-chip">
                    <span class="mdui-chip-icon"><i class="iconfont icon-mail"></i></span>
                    <a href="mailto:xxx@xxx.com" class="mdui-chip-title">E-Mail</a>
                </div>
            
                
                <div class="mdui-chip">
                    <span class="mdui-chip-icon"><i class="iconfont icon-github"></i></span>
                    <a target="_blank" rel="noopener" href="https://your.url" class="mdui-chip-title">GitHub</a>
                </div>
            
                
                <div class="mdui-chip">
                    <span class="mdui-chip-icon"><i class="iconfont icon-steam"></i></span>
                    <a target="_blank" rel="noopener" href="https://your.url" class="mdui-chip-title">Steam</a>
                </div>
            
                
                <div class="mdui-chip">
                    <span class="mdui-chip-icon"><i class="iconfont icon-weibo"></i></span>
                    <a target="_blank" rel="noopener" href="https://your.url" class="mdui-chip-title">Weibo</a>
                </div>
            
        </div>
        <ul class="mdui-list" mdui-collapse="{accordion: true}">
            <li class="mdui-collapse-item">
                <div class="mdui-collapse-item-header mdui-list-item mdui-ripple">
                    <div class="mdui-list-item-icon">
                        <i class="iconfont icon-link"></i>
                    </div>
                    <div class="mdui-list-item-content">友情链接</div>
                    <div class="mdui-collapse-item-arrow">
                        <i class="mdui-list-item-icon iconfont icon-angle-down"></i>
                    </div>
                </div>
                <ul id="linksList" class="mdui-collapse-item-body mdui-list mdui-list-dense">
                    
                        <a target="_blank" rel="noopener" href="https://garybear.cn/hexo-theme-meadow/" class="mdui-list-item mdui-ripple">
                            Meadow说明文档
                        </a>
                    
                </ul>
            </li>
        </ul>
    </div>

    <div class="mdui-divider"></div>
    
    
</aside>
  
  <main id="main-contain" class="mdui-container mdui-m-t-5">
    <article id="article" class="mdui-card mdui-p-b-2 mdui-m-b-5">
  <header class="mdui-card-media">
    
    
      <div class="post-header"> 
  <a class="post-header-title" href="/2020/07/01/JavaScript/jsPromise%E5%8E%9F%E7%90%86/">ES Promise.all/race</a>
  <div class="post-header-meta">
    <span>
      <span class="iconfont icon-calendar"></span>
      发布于:&nbsp;2020-07-01
    </span>
    <span>
      <span class="iconfont icon-calendar-check"></span>
      更新于:&nbsp;2022-05-02
    </span>
    <span>
      <span class="iconfont icon-folder"></span>
      分类于:&nbsp;<a class="category-link" href="/categories/%E5%BC%82%E6%AD%A5/">异步</a> > <a class="category-link" href="/categories/%E5%BC%82%E6%AD%A5/javascript/">javascript</a>
    </span>
    
      <span>
        <span class="iconfont icon-eye"></span>
        阅读次数:&nbsp;
        <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv"></span></span>
      </span>
    
  </div>
</div>   
    



    
    
    <div class="mdui-card-menu">
    
      <button class="mdui-btn mdui-btn-icon mdui-text-color-teal" mdui-menu="{target: '#share_menu', align: 'right'}"><i class="iconfont icon-share"></i></button>
      <ul class="mdui-menu" id="share_menu">
        <li class="mdui-menu-item">
          <a href="http://service.weibo.com/share/share.php?appkey=&title=ES Promise.all/race&url=http://example.com/2020/07/01/JavaScript/jsPromise%E5%8E%9F%E7%90%86/&pic=http://example.comhttps://z3.ax1x.com/2021/11/29/oM334O.png&searchPic=false&style=simple" target="_blank" class="mdui-ripple">分享到 Weibo</a>
        </li>
        <li class="mdui-menu-item">
          <a href="https://twitter.com/intent/tweet?text=ES Promise.all/race&url=http://example.com/2020/07/01/JavaScript/jsPromise%E5%8E%9F%E7%90%86/&via=Dalu Kuankuan" target="_blank" class="mdui-ripple">分享到 Twitter</a>
        </li>
        <li class="mdui-menu-item">
          <a href="https://www.facebook.com/sharer/sharer.php?u=http://example.com/2020/07/01/JavaScript/jsPromise%E5%8E%9F%E7%90%86/" target="_blank" class="mdui-ripple">分享到 Facebook</a>
        </li>
        <li class="mdui-menu-item">
          <a href="https://plus.google.com/share?url=http://example.com/2020/07/01/JavaScript/jsPromise%E5%8E%9F%E7%90%86/" target="_blank" class="mdui-ripple">分享到 Google+</a>
        </li>
        <li class="mdui-menu-item">
          <a href="https://www.linkedin.com/shareArticle?mini=true&url=http://example.com/2020/07/01/JavaScript/jsPromise%E5%8E%9F%E7%90%86/&title=ES Promise.all/race" target="_blank" class="mdui-ripple">分享到 LinkedIn</a>
        </li>
        <li class="mdui-menu-item">
          <a href="http://connect.qq.com/widget/shareqq/index.html?site=KKBlog&title=ES Promise.all/race&summary=选择有时候比努力更重要&pics=http://example.comhttps://z3.ax1x.com/2021/11/29/oM334O.png&url=http://example.com/2020/07/01/JavaScript/jsPromise%E5%8E%9F%E7%90%86/" target="_blank" class="mdui-ripple">分享到 QQ</a>
        </li>
        <li class="mdui-menu-item">
          <a href="https://telegram.me/share/url?url=http://example.com/2020/07/01/JavaScript/jsPromise%E5%8E%9F%E7%90%86/&text=ES Promise.all/race" target="_blank" class="mdui-ripple">分享到 Telegram</a>
        </li>
      </ul>
    
  </div>
  </header>
  
  
  
  
  <div class="post-tags">
    
      <i class="iconfont icon-tag">
        <a rel="tag" href = /tags/javascript/ >javascript</a>
      </i>
    
      <i class="iconfont icon-tag">
        <a rel="tag" href = /tags/Promise/ >Promise</a>
      </i>
    
  </div>

  
  <div class="mdui-card-content mdui-typo mdui-p-x-4">
    <h1 id="一、Promise基础用法"><a href="#一、Promise基础用法" class="headerlink" title="一、Promise基础用法"></a>一、Promise基础用法</h1><h2 id="1-1-基本用法"><a href="#1-1-基本用法" class="headerlink" title="1.1 基本用法"></a>1.1 基本用法</h2><pre><code>new Promise(function(resolve, reject) &#123;
    //待处理的异步逻辑
    //处理结束后，调用resolve或reject方法
&#125;)
</code></pre>
<blockquote>
<ul>
<li>新建一个<code>promise</code>很简单，只需要<code>new</code>一个<code>promise</code>对象即可。所以<code>promise</code>本质上就是一个函数，它接受一个函数作为参数，并且会返回<code>promise</code>对象，这就给链式调用提供了基础</li>
<li>其实<code>Promise</code>函数的使命，就是构建出它的实例，并且负责帮我们管理这些实例。而这些实例有以下三种状态：</li>
</ul>
</blockquote>
<ul>
<li><code>pending</code>: 初始状态，位履行或拒绝</li>
<li><code>fulfilled</code>: 意味着操作成功完成</li>
<li><code>rejected</code>: 意味着操作失败</li>
</ul>
<blockquote>
<p><code>pending</code> 状态的 <code>Promise</code>对象可能以 <code>fulfilled</code>状态返回了一个值，也可能被某种理由（异常信息）拒绝（<code>reject</code>）了。当其中任一种情况出现时，<code>Promise</code> 对象的 <code>then</code> 方法绑定的处理方法（handlers）就会被调用，then方法分别指定了<code>resolve</code>方法和<code>reject</code>方法的回调函数</p>
</blockquote>
<p><img src="https://mengera88.github.io/images/promises.png" alt="img"></p>
<pre><code>var promise = new Promise(function(resolve, reject) &#123;
  if (/* 异步操作成功 */)&#123;
    resolve(value);
  &#125; else &#123;
    reject(error);
  &#125;
&#125;);
promise.then(function(value) &#123;
  // 如果调用了resolve方法，执行此函数
&#125;, function(value) &#123;
  // 如果调用了reject方法，执行此函数
&#125;);
</code></pre>
<blockquote>
<p>上述代码很清晰的展示了<code>promise</code>对象运行的机制。下面再看一个示例：</p>
</blockquote>
<pre><code>var getJSON = function(url) &#123;
  var promise = new Promise(function(resolve, reject)&#123;
    var client = new XMLHttpRequest();
    client.open(&quot;GET&quot;, url);
    client.onreadystatechange = handler;
    client.responseType = &quot;json&quot;;
    client.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);
    client.send();
    function handler() &#123;
      if (this.status === 200) &#123; 
              resolve(this.response); 
          &#125; else &#123; 
              reject(new Error(this.statusText)); 
          &#125;
    &#125;;
  &#125;);
  return promise;
&#125;;
getJSON(&quot;/posts.json&quot;).then(function(json) &#123;
  console.log(&#39;Contents: &#39; + json);
&#125;, function(error) &#123;
  console.error(&#39;出错了&#39;, error);
&#125;);
</code></pre>
<blockquote>
<p>上面代码中，<code>resolve</code>方法和<code>reject</code>方法调用时，都带有参数。它们的参数会被传递给回调函数。<code>reject</code>方法的参数通常是<code>Error</code>对象的实例，而<code>resolve</code>方法的参数除了正常的值以外，还可能是另一个<code>Promise</code>实例，比如像下面这样。</p>
</blockquote>
<pre><code>var p1 = new Promise(function(resolve, reject)&#123;
  // ... some code
&#125;);
var p2 = new Promise(function(resolve, reject)&#123;
  // ... some code
  resolve(p1);
&#125;)
</code></pre>
<blockquote>
<p>上面代码中，<code>p1</code>和<code>p2</code>都是<code>Promise</code>的实例，但是<code>p2</code>的<code>resolve</code>方法将<code>p1</code>作为参数，这时<code>p1</code>的状态就会传递给<code>p2</code>。如果调用的时候，<code>p1</code>的状态是<code>pending</code>，那么<code>p2</code>的回调函数就会等待<code>p1</code>的状态改变；如果<code>p1</code>的状态已经是<code>fulfilled</code>或者<code>rejected</code>，那么<code>p2</code>的回调函数将会立刻执行</p>
</blockquote>
<h2 id="1-2-promise捕获错误"><a href="#1-2-promise捕获错误" class="headerlink" title="1.2 promise捕获错误"></a>1.2 promise捕获错误</h2><blockquote>
<p><code>Promise.prototype.catch</code>方法是<code>Promise.prototype.then(null, rejection)</code>的别名，用于指定发生错误时的回调函数</p>
</blockquote>
<pre><code>getJSON(&quot;/visa.json&quot;).then(function(result) &#123;
  // some code
&#125;).catch(function(error) &#123;
  // 处理前一个回调函数运行时发生的错误
  console.log(&#39;出错啦！&#39;, error);
&#125;);
</code></pre>
<blockquote>
<p><code>Promise</code>对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个<code>catch</code>语句捕获</p>
</blockquote>
<pre><code>getJSON(&quot;/visa.json&quot;).then(function(json) &#123;
  return json.name;
&#125;).then(function(name) &#123;
  // proceed
&#125;).catch(function(error) &#123;
    //处理前面任一个then函数抛出的错误
&#125;);
</code></pre>
<h2 id="1-3-常用的promise方法"><a href="#1-3-常用的promise方法" class="headerlink" title="1.3 常用的promise方法"></a>1.3 常用的promise方法</h2><p><strong>Promise.all方法</strong></p>
<blockquote>
<p><code>Promise.all</code>方法用于将多个<code>Promise</code>实例，包装成一个新的<code>Promise</code>实例</p>
</blockquote>
<pre><code>var p = Promise.all([p1,p2,p3]);
</code></pre>
<ul>
<li>上面代码中，<code>Promise.all</code>方法接受一个数组作为参数，<code>p1</code>、<code>p2</code>、<code>p3</code>都是<code>Promise</code>对象的实例。（<code>Promise.all</code>方法的参数不一定是数组，但是必须具有<code>iterator</code>接口，且返回的每个成员都是<code>Promise</code>实例。）</li>
</ul>
<blockquote>
<p><code>p</code>的状态由<code>p1</code>、<code>p2</code>、<code>p3</code>决定，分成两种情况</p>
</blockquote>
<ul>
<li>只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数</li>
<li>只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给p的回调函数</li>
</ul>
<pre><code>// 生成一个Promise对象的数组
var promises = [2, 3, 5, 7, 11, 13].map(function(id)&#123;
  return getJSON(&quot;/get/addr&quot; + id + &quot;.json&quot;);
&#125;);
Promise.all(promises).then(function(posts) &#123;
  // ...  
&#125;).catch(function(reason)&#123;
  // ...
&#125;);
</code></pre>
<p><strong>Promise.race方法</strong></p>
<blockquote>
<p><code>Promise.race</code>方法同样是将多个<code>Promise</code>实例，包装成一个新的<code>Promise</code>实例。</p>
</blockquote>
<pre><code>var p = Promise.race([p1,p2,p3]);
</code></pre>
<blockquote>
<p>上面代码中，只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的Promise实例的返回值，就传递给p的返回值</p>
</blockquote>
<ul>
<li>如果<code>Promise.all</code>方法和<code>Promise.race</code>方法的参数，不是<code>Promise</code>实例，就会先调用下面讲到的<code>Promise.resolve</code>方法，将参数转为<code>Promise</code>实例，再进一步处理</li>
</ul>
<p><strong>Promise.resolve</strong></p>
<blockquote>
<p>有时需要将现有对象转为<code>Promise</code>对象，<code>Promise.resolve</code>方法就起到这个作用</p>
</blockquote>
<pre><code>var jsPromise = Promise.resolve($.ajax(&#39;/whatever.json&#39;));
</code></pre>
<blockquote>
<p>上面代码将<code>jQuery</code>生成<code>deferred</code>对象，转为一个新的<code>ES6</code>的<code>Promise</code>对象</p>
</blockquote>
<ul>
<li>如果<code>Promise.resolve</code>方法的参数，不是具有<code>then</code>方法的对象（又称<code>thenable</code>对象），则返回一个新的<code>Promise</code>对象，且它的状态为<code>fulfilled</code>。</li>
</ul>
<pre><code>var p = Promise.resolve(&#39;Hello&#39;);
p.then(function (s)&#123;
  console.log(s)
&#125;);
// Hello
</code></pre>
<ul>
<li>上面代码生成一个新的<code>Promise</code>对象的实例<code>p</code>，它的状态为<code>fulfilled</code>，所以回调函数会立即执行，<code>Promise.resolve</code>方法的参数就是回调函数的参数</li>
<li>如果<code>Promise.resolve</code>方法的参数是一个<code>Promise</code>对象的实例，则会被原封不动地返回</li>
<li><code>Promise.reject(reason)</code>方法也会返回一个新的<code>Promise</code>实例，该实例的状态为<code>rejected</code>。<code>Promise.reject</code>方法的参数<code>reason</code>，会被传递给实例的回调函数</li>
</ul>
<pre><code>var p = Promise.reject(&#39;出错啦&#39;);
p.then(null, function (error)&#123;
  console.log(error)
&#125;);
// 出错了
</code></pre>
<h2 id="1-4-Async-await简化写法"><a href="#1-4-Async-await简化写法" class="headerlink" title="1.4 Async/await简化写法"></a>1.4 Async/await简化写法</h2><pre><code>function getDataAsync (url) &#123;
    return new Promise((resolve, reject) =&gt; &#123;
        setTimeout(() =&gt; &#123;
            var res = &#123;
                url: url,
                data: Math.random()
            &#125;
            resolve(res)
        &#125;, 1000)
    &#125;)
&#125;
async function getData () &#123;
    var res1 = await getDataAsync(&#39;/page/1?param=123&#39;)
    console.log(res1)
    var res2 = await getDataAsync(`/page/2?param=$&#123;res1.data&#125;`)
    console.log(res2)
    var res3 = await getDataAsync(`/page/2?param=$&#123;res2.data&#125;`)
    console.log(res3)
&#125;
</code></pre>
<blockquote>
<p><code>async/await</code> 是基于 <code>Promise</code> 的，因为使用 <code>async</code> 修饰的方法最终返回一个 <code>Promise</code>， 实际上，<code>async/await</code> 可以看做是使用 <code>Generator</code> 函数处理异步的语法糖，我们来看看如何使用 <code>Generator</code> 函数处理异步</p>
</blockquote>
<h2 id="1-5-Generator"><a href="#1-5-Generator" class="headerlink" title="1.5 Generator"></a>1.5 Generator</h2><p>首先异步函数依然是：</p>
<pre><code>function getDataAsync (url) &#123;
    return new Promise((resolve, reject) =&gt; &#123;
        setTimeout(() =&gt; &#123;
            var res = &#123;
                url: url,
                data: Math.random()
            &#125;
            resolve(res)
        &#125;, 1000)
    &#125;)
&#125;
</code></pre>
<blockquote>
<p>使用 <code>Generator</code> 函数可以这样写</p>
</blockquote>
<pre><code>function * getData () &#123;
    var res1 = yield getDataAsync(&#39;/page/1?param=123&#39;)
    console.log(res1)
    var res2 = yield getDataAsync(`/page/2?param=$&#123;res1.data&#125;`)
    console.log(res2)
    var res3 = yield getDataAsync(`/page/2?param=$&#123;res2.data&#125;`)
    console.log(res3))
&#125;
</code></pre>
<p>然后我们这样逐步执行</p>
<pre><code>var g = getData()
g.next().value.then(res1 =&gt; &#123;
    g.next(res1).value.then(res2 =&gt; &#123;
        g.next(res2).value.then(() =&gt; &#123;
            g.next()
        &#125;)
    &#125;)
&#125;)
</code></pre>
<blockquote>
<p>上面的代码，我们逐步调用遍历器的 <code>next()</code> 方法，由于每一个 <code>next()</code> 方法返回值的 <code>value</code> 属性为一个 <code>Promise</code> 对象，所以我们为其添加 <code>then</code> 方法， 在 <code>then</code>方法里面接着运行 <code>next</code> 方法挪移遍历器指针，直到 <code>Generator</code> 函数运行完成，实际上，这个过程我们不必手动完成，可以封装成一个简单的执行器</p>
</blockquote>
<pre><code>function run (gen) &#123;
    var g = gen()

    function next (data) &#123;
        var res = g.next(data)
        if (res.done) return res.value
        res.value.then((data) =&gt; &#123;
            next(data)
        &#125;)
    &#125;

    next()

&#125;
</code></pre>
<blockquote>
<p><code>run</code>方法用来自动运行异步的 <code>Generator</code> 函数，其实就是一个递归的过程调用的过程。这样我们就不必手动执行 <code>Generator</code> 函数了。 有了 <code>run</code> 方法，我们只需要这样运行 getData 方法</p>
</blockquote>
<pre><code>run(getData)
</code></pre>
<blockquote>
<p>这样，我们就可以把异步操作封装到 <code>Generator</code> 函数内部，使用 <code>run</code> 方法作为 <code>Generator</code> 函数的自执行器，来处理异步。其实我们不难发现， <code>async/await</code> 方法相比于 <code>Generator</code> 处理异步的方式，有很多相似的地方，只不过 <code>async/await</code> 在语义化方面更加明显，同时 <code>async/await</code> 不需要我们手写执行器，其内部已经帮我们封装好了，这就是为什么说 <code>async/await</code> 是 <code>Generator</code> 函数处理异步的语法糖了</p>
</blockquote>
<h1 id="二、Promise实现原理剖析"><a href="#二、Promise实现原理剖析" class="headerlink" title="二、Promise实现原理剖析"></a>二、Promise实现原理剖析</h1><h2 id="2-1-Promise标准"><a href="#2-1-Promise标准" class="headerlink" title="2.1 Promise标准"></a>2.1 Promise标准</h2><ul>
<li><code>Promise</code> 规范有很多，如<code>Promise/A</code>，<code>Promise/B</code>，<code>Promise/D</code>以及 <code>Promise/A</code> 的升级版 <code>Promise/A+</code>。<code>ES6</code>中采用了 <code>Promise/A+</code> 规范</li>
</ul>
<p>中文版规范: <a target="_blank" rel="noopener" href="http://www.ituring.com.cn/article/66566">Promises/A+规范(中文)</a></p>
<p><strong>Promise标准解读</strong></p>
<ul>
<li>一个<code>promise</code>的当前状态只能是<code>pending</code>、<code>fulfilled</code>和<code>rejected</code>三种之一。状态改变只能是<code>pending</code>到<code>fulfilled</code>或者<code>pending</code>到<code>rejected</code>。状态改变不可逆</li>
<li><code>promise</code>的<code>then</code>方法接收两个可选参数，表示该<code>promise</code>状态改变时的回调(<code>promise.then(onFulfilled, onRejected)</code>)。<code>then</code>方法返回一个<code>promise</code>。<code>then</code> 方法可以被同一个 <code>promise</code> 调用多次</li>
</ul>
<h2 id="2-2-实现Promise"><a href="#2-2-实现Promise" class="headerlink" title="2.2 实现Promise"></a>2.2 实现Promise</h2><p><strong>构造函数</strong></p>
<pre><code>function Promise(resolver) &#123;&#125;
</code></pre>
<p><strong>原型方法</strong></p>
<pre><code>Promise.prototype.then = function() &#123;&#125;
Promise.prototype.catch = function() &#123;&#125;
</code></pre>
<p><strong>静态方法</strong></p>
<pre><code>Promise.resolve = function() &#123;&#125;
Promise.reject = function() &#123;&#125;
Promise.all = function() &#123;&#125;
Promise.race = function() &#123;&#125;
</code></pre>
<h2 id="2-3-极简promise雏形"><a href="#2-3-极简promise雏形" class="headerlink" title="2.3 极简promise雏形"></a>2.3 极简promise雏形</h2><pre><code>function Promise(fn) &#123;
    var value = null,
        callbacks = [];  //callbacks为数组，因为可能同时有很多个回调
    this.then = function (onFulfilled) &#123;
        callbacks.push(onFulfilled);
    &#125;;
    function resolve(value) &#123;
        callbacks.forEach(function (callback) &#123;
            callback(value);
        &#125;);
    &#125;
    fn(resolve);
&#125;
</code></pre>
<p><strong>大致的逻辑是这样的</strong></p>
<ul>
<li>调用<code>then</code>方法，将想要在<code>Promise</code>异步操作成功时执行的回调放入<code>callbacks</code>队列，其实也就是注册回调函数，可以向观察者模式方向思考</li>
<li>创建<code>Promise</code>实例时传入的函数会被赋予一个函数类型的参数，即<code>resolve</code>，它接收一个参数<code>value</code>，代表异步操作返回的结果，当一步操作执行成功后，用户会调用<code>resolve</code>方法，这时候其实真正执行的操作是将<code>callbacks</code>队列中的回调一一执行</li>
</ul>
<pre><code>//例1
function getUserId() &#123;
    return new Promise(function(resolve) &#123;
        //异步请求
        http.get(url, function(results) &#123;
            resolve(results.id)
        &#125;)
    &#125;)
&#125;
getUserId().then(function(id) &#123;
    //一些处理
&#125;)
// 结合例子1分析

// fn 就是getUserId函数
function Promise(fn) &#123;
    var value = null,
        callbacks = [];  //callbacks为数组，因为可能同时有很多个回调
    
    // 当用户调用getUserId().then的时候开始注册传进来的回调函数
    // onFulfilled就是例子中的function(id)&#123;&#125;
    // 把then的回调函数收集起来 在resolve的时候调用
    this.then = function (onFulfilled) &#123;
        callbacks.push(onFulfilled);
    &#125;;
    
    // value是fn函数执行后返回的值
    function resolve(value) &#123;
        // callbacks是传给then的回调函数就是例子中的function(id)&#123;&#125;
        // 遍历用户通过then传递进来的回调函数把resolve成功的结果返回给then调用即then(function(data)&#123; console.log(data) &#125;) 这里的data就是通过这里调用返回
        callbacks.forEach(function (callback) &#123;
            callback(value);
        &#125;);
    &#125;
    
    //执行fn函数即getUserId()并且传入函数参数resolve 当fn执行完成返回的值传递给resolve函数
    fn(resolve);
&#125;
</code></pre>
<blockquote>
<p>结合例1中的代码来看，首先<code>new Promise</code>时，传给<code>promise</code>的函数发送异步请求，接着调用<code>promise</code>对象的<code>then</code>属性，注册请求成功的回调函数，然后当异步请求发送成功时，调用<code>resolve(results.id)</code>方法, 该方法执行<code>then</code>方法注册的回调数组</p>
</blockquote>
<ul>
<li><code>then</code>方法应该能够链式调用，但是上面的最基础简单的版本显然无法支持链式调用。想让<code>then</code>方法支持链式调用，其实也是很简单的</li>
</ul>
<pre><code>this.then = function (onFulfilled) &#123;
    callbacks.push(onFulfilled);
    return this;
&#125;;
</code></pre>
<blockquote>
<p>只要简单一句话就可以实现类似下面的链式调用</p>
</blockquote>
<pre><code>// 例2
getUserId().then(function (id) &#123;
    // 一些处理
&#125;).then(function (id) &#123;
    // 一些处理
&#125;);
</code></pre>
<h2 id="2-4-加入延时机制"><a href="#2-4-加入延时机制" class="headerlink" title="2.4 加入延时机制"></a>2.4 加入延时机制</h2><blockquote>
<p>上述代码可能还存在一个问题：如果在<code>then</code>方法注册回调之前，<code>resolve</code>函数就执行了，怎么办？比如<code>promise</code>内部的函数是同步函数</p>
</blockquote>
<pre><code>// 例3
function getUserId() &#123;
    return new Promise(function (resolve) &#123;
        resolve(9876);
    &#125;);
&#125;
getUserId().then(function (id) &#123;
    // 一些处理
&#125;);
</code></pre>
<blockquote>
<p>这显然是不允许的，<code>Promises/A+</code>规范明确要求回调需要通过异步方式执行，用以保证一致可靠的执行顺序。因此我们要加入一些处理，保证在<code>resolve</code>执行之前，<code>then</code>方法已经注册完所有的回调。我们可以这样改造下<code>resolve</code>函数:</p>
</blockquote>
<pre><code>function resolve(value) &#123;
    setTimeout(function() &#123;
        callbacks.forEach(function (callback) &#123;
            callback(value);
        &#125;);
    &#125;, 0)
&#125;
</code></pre>
<blockquote>
<p>上述代码的思路也很简单，就是通过<code>setTimeout</code>机制，将<code>resolve</code>中执行回调的逻辑放置到<code>JS</code>任务队列末尾，以保证在<code>resolve</code>执行时，<code>then</code>方法的回调函数已经注册完成</p>
</blockquote>
<ul>
<li>但是，这样好像还存在一个问题，可以细想一下：如果<code>Promise</code>异步操作已经成功，这时，在异步操作成功之前注册的回调都会执行，但是在<code>Promise</code>异步操作成功这之后调用的<code>then</code>注册的回调就再也不会执行了，这显然不是我们想要的</li>
</ul>
<h2 id="2-5-加入状态"><a href="#2-5-加入状态" class="headerlink" title="2.5 加入状态"></a>2.5 加入状态</h2><p>我们必须加入状态机制，也就是大家熟知的<code>pending</code>、<code>fulfilled</code>、<code>rejected</code></p>
<blockquote>
<p><code>Promises/A+</code>规范中的<code>2.1 Promise States</code>中明确规定了，<code>pending</code>可以转化为<code>fulfilled</code>或<code>rejected</code>并且只能转化一次，也就是说如果<code>pending</code>转化到<code>fulfilled</code>状态，那么就不能再转化到r<code>ejected</code>。并且<code>fulfilled</code>和<code>rejected</code>状态只能由<code>pending</code>转化而来，两者之间不能互相转换</p>
</blockquote>
<p><img src="https://mengera88.github.io/images/promiseState.png" alt="img"></p>
<pre><code>//改进后的代码是这样的：

function Promise(fn) &#123;
    var state = &#39;pending&#39;,
        value = null,
        callbacks = [];
    this.then = function (onFulfilled) &#123;
        if (state === &#39;pending&#39;) &#123;
            callbacks.push(onFulfilled);
            return this;
        &#125;
        onFulfilled(value);
        return this;
    &#125;;
    function resolve(newValue) &#123;
        value = newValue;
        state = &#39;fulfilled&#39;;
        setTimeout(function () &#123;
            callbacks.forEach(function (callback) &#123;
                callback(value);
            &#125;);
        &#125;, 0);
    &#125;
    fn(resolve);
&#125;
</code></pre>
<blockquote>
<p>上述代码的思路是这样的：<code>resolve</code>执行时，会将状态设置为<code>fulfilled</code>，在此之后调用<code>then</code>添加的新回调，都会立即执行</p>
</blockquote>
<h2 id="2-6-链式Promise"><a href="#2-6-链式Promise" class="headerlink" title="2.6 链式Promise"></a>2.6 链式Promise</h2><blockquote>
<p>如果用户在<code>then</code>函数里面注册的仍然是一个<code>Promise</code>，该如何解决？比如下面的例4</p>
</blockquote>
<pre><code>// 例4
getUserId()
    .then(getUserJobById)
    .then(function (job) &#123;
        // 对job的处理
    &#125;);
function getUserJobById(id) &#123;
    return new Promise(function (resolve) &#123;
        http.get(baseUrl + id, function(job) &#123;
            resolve(job);
        &#125;);
    &#125;);
&#125;
</code></pre>
<ul>
<li>这种场景相信用过<code>promise</code>的人都知道会有很多，那么类似这种就是所谓的链式<code>Promise</code></li>
<li>链式<code>Promise</code>是指在当前<code>promise</code>达到<code>fulfilled</code>状态后，即开始进行下一个<code>promise</code>（后邻<code>promise</code>）。那么我们如何衔接当前<code>promise</code>和后邻<code>promise</code>呢？（这是这里的难点</li>
<li>只要在<code>then</code>方法里面<code>return</code>一个<code>promise</code>就好啦。<code>Promises/A+</code>规范中的<code>2.2.7</code>就是这样</li>
</ul>
<blockquote>
<p>下面来看看这段暗藏玄机的<code>then</code>方法和<code>resolve</code>方法改造代码</p>
</blockquote>
<pre><code>function Promise(fn) &#123;
    var state = &#39;pending&#39;,
        value = null,
        callbacks = [];
    this.then = function (onFulfilled) &#123;
        return new Promise(function (resolve) &#123;
            handle(&#123;
                onFulfilled: onFulfilled || null,
                resolve: resolve
            &#125;);
        &#125;);
    &#125;;
    function handle(callback) &#123;
        if (state === &#39;pending&#39;) &#123;
            callbacks.push(callback);
            return;
        &#125;
        //如果then中没有传递任何东西
        if(!callback.onFulfilled) &#123;
            callback.resolve(value);
            return;
        &#125;
        var ret = callback.onFulfilled(value);
        callback.resolve(ret);
    &#125;
    
    function resolve(newValue) &#123;
        if (newValue &amp;&amp; (typeof newValue === &#39;object&#39; || typeof newValue === &#39;function&#39;)) &#123;
            var then = newValue.then;
            if (typeof then === &#39;function&#39;) &#123;
                then.call(newValue, resolve);
                return;
            &#125;
        &#125;
        state = &#39;fulfilled&#39;;
        value = newValue;
        setTimeout(function () &#123;
            callbacks.forEach(function (callback) &#123;
                handle(callback);
            &#125;);
        &#125;, 0);
    &#125;
    fn(resolve);
&#125;
</code></pre>
<blockquote>
<p>我们结合例4的代码，分析下上面的代码逻辑，为了方便阅读，我把例4的代码贴在这里</p>
</blockquote>
<pre><code>// 例4
getUserId()
    .then(getUserJobById)
    .then(function (job) &#123;
        // 对job的处理
    &#125;);
function getUserJobById(id) &#123;
    return new Promise(function (resolve) &#123;
        http.get(baseUrl + id, function(job) &#123;
            resolve(job);
        &#125;);
    &#125;);
&#125;
</code></pre>
<ul>
<li><code>then</code>方法中，创建并返回了新的<code>Promise</code>实例，这是串行<code>Promis</code>e的基础，并且支持链式调用</li>
<li><code>handle</code>方法是<code>promise</code>内部的方法。<code>then</code>方法传入的形参<code>onFulfilled</code>以及创建新<code>Promise</code>实例时传入的<code>resolve</code>均被<code>push</code>到当前<code>promise</code>的<code>callbacks</code>队列中，这是衔接当前<code>promise</code>和后邻<code>promise</code>的关键所在</li>
<li><code>getUserId</code>生成的<code>promise</code>（简称<code>getUserId promise</code>）异步操作成功，执行其内部方法<code>resolve</code>，传入的参数正是异步操作的结果<code>id</code></li>
<li>调用<code>handle</code>方法处理<code>callbacks</code>队列中的回调：<code>getUserJobById</code>方法，生成新的<code>promise</code>（g<code>etUserJobById promise</code>）</li>
<li>执行之前由<code>getUserId promise</code>的<code>then</code>方法生成的新<code>promise</code>(称为<code>bridge promise</code>)的<code>resolve</code>方法，传入参数为<code>getUserJobById promise</code>。这种情况下，会将该<code>resolve</code>方法传入<code>getUserJobById promise</code>的<code>then</code>方法中，并直接返回</li>
<li>在<code>getUserJobById promise</code>异步操作成功时，执行其<code>callbacks</code>中的回调：<code>getUserId bridge promise</code>中的<code>resolve</code>方法</li>
<li>最后执行<code>getUserId bridge promise</code>的后邻<code>promise</code>的<code>callbacks</code>中的回调</li>
</ul>
<h2 id="2-7-失败处理"><a href="#2-7-失败处理" class="headerlink" title="2.7 失败处理"></a>2.7 失败处理</h2><blockquote>
<p>在异步操作失败时，标记其状态为<code>rejected</code>，并执行注册的失败回调</p>
</blockquote>
<pre><code>//例5
function getUserId() &#123;
    return new Promise(function(resolve) &#123;
        //异步请求
        http.get(url, function(error, results) &#123;
            if (error) &#123;
                reject(error);
            &#125;
            resolve(results.id)
        &#125;)
    &#125;)
&#125;
getUserId().then(function(id) &#123;
    //一些处理
&#125;, function(error) &#123;
    console.log(error)
&#125;)
</code></pre>
<blockquote>
<p>有了之前处理<code>fulfilled</code>状态的经验，支持错误处理变得很容易,只需要在注册回调、处理状态变更上都要加入新的逻辑</p>
</blockquote>
<pre><code>function Promise(fn) &#123;
    var state = &#39;pending&#39;,
        value = null,
        callbacks = [];
    this.then = function (onFulfilled, onRejected) &#123;
        return new Promise(function (resolve, reject) &#123;
            handle(&#123;
                onFulfilled: onFulfilled || null,
                onRejected: onRejected || null,
                resolve: resolve,
                reject: reject
            &#125;);
        &#125;);
    &#125;;
    function handle(callback) &#123;
        if (state === &#39;pending&#39;) &#123;
            callbacks.push(callback);
            return;
        &#125;
        var cb = state === &#39;fulfilled&#39; ? callback.onFulfilled : callback.onRejected,
            ret;
        if (cb === null) &#123;
            cb = state === &#39;fulfilled&#39; ? callback.resolve : callback.reject;
            cb(value);
            return;
        &#125;
        ret = cb(value);
        callback.resolve(ret);
    &#125;
    function resolve(newValue) &#123;
        if (newValue &amp;&amp; (typeof newValue === &#39;object&#39; || typeof newValue === &#39;function&#39;)) &#123;
            var then = newValue.then;
            if (typeof then === &#39;function&#39;) &#123;
                then.call(newValue, resolve, reject);
                return;
            &#125;
        &#125;
        state = &#39;fulfilled&#39;;
        value = newValue;
        execute();
    &#125;
    function reject(reason) &#123;
        state = &#39;rejected&#39;;
        value = reason;
        execute();
    &#125;
    function execute() &#123;
        setTimeout(function () &#123;
            callbacks.forEach(function (callback) &#123;
                handle(callback);
            &#125;);
        &#125;, 0);
    &#125;
    fn(resolve, reject);
&#125;
</code></pre>
<blockquote>
<p>上述代码增加了新的<code>reject</code>方法，供异步操作失败时调用，同时抽出了<code>resolve</code>和<code>reject</code>共用的部分，形成<code>execute</code>方法</p>
</blockquote>
<p>错误冒泡是上述代码已经支持，且非常实用的一个特性。在<code>handle</code>中发现没有指定异步操作失败的回调时，会直接将<code>bridge promise</code>(<code>then</code>函数返回的<code>promise</code>，后同)设为<code>rejected</code>状态，如此达成执行后续失败回调的效果。这有利于简化串行Promise的失败处理成本，因为一组异步操作往往会对应一个实际功能，失败处理方法通常是一致的</p>
<pre><code>//例6
getUserId()
    .then(getUserJobById)
    .then(function (job) &#123;
        // 处理job
    &#125;, function (error) &#123;
        // getUserId或者getUerJobById时出现的错误
        console.log(error);
    &#125;);
</code></pre>
<h2 id="2-8-异常处理"><a href="#2-8-异常处理" class="headerlink" title="2.8 异常处理"></a>2.8 异常处理</h2><blockquote>
<p>如果在执行成功回调、失败回调时代码出错怎么办？对于这类异常，可以使用<code>try-catch</code>捕获错误，并将<code>bridge promise</code>设为<code>rejected</code>状态。<code>handle</code>方法改造如下</p>
</blockquote>
<pre><code>function handle(callback) &#123;
    if (state === &#39;pending&#39;) &#123;
        callbacks.push(callback);
        return;
    &#125;
    var cb = state === &#39;fulfilled&#39; ? callback.onFulfilled : callback.onRejected,
        ret;
    if (cb === null) &#123;
        cb = state === &#39;fulfilled&#39; ? callback.resolve : callback.reject;
        cb(value);
        return;
    &#125;
    try &#123;
        ret = cb(value);
        callback.resolve(ret);
    &#125; catch (e) &#123;
        callback.reject(e);
    &#125; 
&#125;
</code></pre>
<blockquote>
<p>如果在异步操作中，多次执行<code>resolve</code>或者<code>reject</code>会重复处理后续回调，可以通过内置一个标志位解决</p>
</blockquote>
<h2 id="2-9-完整实现"><a href="#2-9-完整实现" class="headerlink" title="2.9 完整实现"></a>2.9 完整实现</h2><pre><code>// 三种状态
const PENDING = &quot;pending&quot;;
const RESOLVED = &quot;resolved&quot;;
const REJECTED = &quot;rejected&quot;;
// promise 接收一个函数参数，该函数会立即执行
function MyPromise(fn) &#123;
  let _this = this;
  _this.currentState = PENDING;
  _this.value = undefined;
  // 用于保存 then 中的回调，只有当 promise
  // 状态为 pending 时才会缓存，并且每个实例至多缓存一个
  _this.resolvedCallbacks = [];
  _this.rejectedCallbacks = [];

  _this.resolve = function (value) &#123;
    if (value instanceof MyPromise) &#123;
      // 如果 value 是个 Promise，递归执行
      return value.then(_this.resolve, _this.reject)
    &#125;
    setTimeout(() =&gt; &#123; // 异步执行，保证执行顺序
      if (_this.currentState === PENDING) &#123;
        _this.currentState = RESOLVED;
        _this.value = value;
        _this.resolvedCallbacks.forEach(cb =&gt; cb());
      &#125;
    &#125;)
  &#125;;

  _this.reject = function (reason) &#123;
    setTimeout(() =&gt; &#123; // 异步执行，保证执行顺序
      if (_this.currentState === PENDING) &#123;
        _this.currentState = REJECTED;
        _this.value = reason;
        _this.rejectedCallbacks.forEach(cb =&gt; cb());
      &#125;
    &#125;)
  &#125;
  // 用于解决以下问题
  // new Promise(() =&gt; throw Error(&#39;error))
  try &#123;
    fn(_this.resolve, _this.reject);
  &#125; catch (e) &#123;
    _this.reject(e);
  &#125;
&#125;

MyPromise.prototype.then = function (onResolved, onRejected) &#123;
  var self = this;
  // 规范 2.2.7，then 必须返回一个新的 promise
  var promise2;
  // 规范 2.2.onResolved 和 onRejected 都为可选参数
  // 如果类型不是函数需要忽略，同时也实现了透传
  // Promise.resolve(4).then().then((value) =&gt; console.log(value))
  onResolved = typeof onResolved === &#39;function&#39; ? onResolved : v =&gt; v;
  onRejected = typeof onRejected === &#39;function&#39; ? onRejected : r =&gt; throw r;

  if (self.currentState === RESOLVED) &#123;
    return (promise2 = new MyPromise(function (resolve, reject) &#123;
      // 规范 2.2.4，保证 onFulfilled，onRjected 异步执行
      // 所以用了 setTimeout 包裹下
      setTimeout(function () &#123;
        try &#123;
          var x = onResolved(self.value);
          resolutionProcedure(promise2, x, resolve, reject);
        &#125; catch (reason) &#123;
          reject(reason);
        &#125;
      &#125;);
    &#125;));
  &#125;

  if (self.currentState === REJECTED) &#123;
    return (promise2 = new MyPromise(function (resolve, reject) &#123;
      setTimeout(function () &#123;
        // 异步执行onRejected
        try &#123;
          var x = onRejected(self.value);
          resolutionProcedure(promise2, x, resolve, reject);
        &#125; catch (reason) &#123;
          reject(reason);
        &#125;
      &#125;);
    &#125;));
  &#125;

  if (self.currentState === PENDING) &#123;
    return (promise2 = new MyPromise(function (resolve, reject) &#123;
      self.resolvedCallbacks.push(function () &#123;
        // 考虑到可能会有报错，所以使用 try/catch 包裹
        try &#123;
          var x = onResolved(self.value);
          resolutionProcedure(promise2, x, resolve, reject);
        &#125; catch (r) &#123;
          reject(r);
        &#125;
      &#125;);

      self.rejectedCallbacks.push(function () &#123;
        try &#123;
          var x = onRejected(self.value);
          resolutionProcedure(promise2, x, resolve, reject);
        &#125; catch (r) &#123;
          reject(r);
        &#125;
      &#125;);
    &#125;));
  &#125;
&#125;;
// 规范 2.3
function resolutionProcedure(promise2, x, resolve, reject) &#123;
  // 规范 2.3.1，x 不能和 promise2 相同，避免循环引用
  if (promise2 === x) &#123;
    return reject(new TypeError(&quot;Error&quot;));
  &#125;
  // 规范 2.3.2
  // 如果 x 为 Promise，状态为 pending 需要继续等待否则执行
  if (x instanceof MyPromise) &#123;
    if (x.currentState === PENDING) &#123;
      x.then(function (value) &#123;
        // 再次调用该函数是为了确认 x resolve 的
        // 参数是什么类型，如果是基本类型就再次 resolve
        // 把值传给下个 then
        resolutionProcedure(promise2, value, resolve, reject);
      &#125;, reject);
    &#125; else &#123;
      x.then(resolve, reject);
    &#125;
    return;
  &#125;
  // 规范 2.3.3.3.3
  // reject 或者 resolve 其中一个执行过得话，忽略其他的
  let called = false;
  // 规范 2.3.3，判断 x 是否为对象或者函数
  if (x !== null &amp;&amp; (typeof x === &quot;object&quot; || typeof x === &quot;function&quot;)) &#123;
    // 规范 2.3.3.2，如果不能取出 then，就 reject
    try &#123;
      // 规范 2.3.3.1
      let then = x.then;
      // 如果 then 是函数，调用 x.then
      if (typeof then === &quot;function&quot;) &#123;
        // 规范 2.3.3.3
        then.call(
          x,
          y =&gt; &#123;
            if (called) return;
            called = true;
            // 规范 2.3.3.3.1
            resolutionProcedure(promise2, y, resolve, reject);
          &#125;,
          e =&gt; &#123;
            if (called) return;
            called = true;
            reject(e);
          &#125;
        );
      &#125; else &#123;
        // 规范 2.3.3.4
        resolve(x);
      &#125;
    &#125; catch (e) &#123;
      if (called) return;
      called = true;
      reject(e);
    &#125;
  &#125; else &#123;
    // 规范 2.3.4，x 为基本类型
    resolve(x);
  &#125;
&#125;
</code></pre>
<h2 id="2-10-小结"><a href="#2-10-小结" class="headerlink" title="2.10 小结"></a>2.10 小结</h2><p><strong>这里一定要注意的点是</strong>：<code>promise</code>里面的<code>then</code>函数仅仅是注册了后续需要执行的代码，真正的执行是在<code>resolve</code>方法里面执行的，理清了这层，再来分析源码会省力的多</p>
<blockquote>
<p>现在回顾下<code>Promise</code>的实现过程，其主要使用了设计模式中的观察者模式</p>
</blockquote>
<ul>
<li>通过<code>Promise.prototype.then</code>和<code>Promise.prototype.catch</code>方法将观察者方法注册到被观察者<code>Promise</code>对象中，同时返回一个新的<code>Promise</code>对象，以便可以链式调用</li>
<li>被观察者管理内部<code>pending</code>、<code>fulfilled</code>和<code>rejected</code>的状态转变，同时通过构造函数中传递的<code>resolve</code>和<code>reject</code>方法以主动触发状态转变和通知观察者</li>
</ul>
<h1 id="三、参考"><a href="#三、参考" class="headerlink" title="三、参考"></a>三、参考</h1><ul>
<li><a target="_blank" rel="noopener" href="http://es6.ruanyifeng.com/#docs/promise">ruanyifeng-Promise 对象</a></li>
</ul>

  </div>
  <!--文末结束语-->
  
    <div style="text-align:center;color: #ccc;font-size:24px;"> --- 本文结束 <i class="iconfont icon-heartbeat" style="font-size:24px;"></i> The End --- </div>
  
  <!--页脚广告-->
  
  <div class="mdui-divider"></div>
  
  <nav>
    
      <a rel="prev" class="post-nav-item mdui-float-left" href="/2020/08/24/JavaScript/js-%E7%BB%A7%E6%89%BF/">
        <i class="iconfont icon-angle-left"></i>
        <span>js 继承</span>
      </a>
    
    
      <a rel="next" class="post-nav-item mdui-float-right" href="/2020/06/10/vue/vue-%E7%BB%84%E4%BB%B6%E5%8C%96/">
        <span>vue-组件化</span>
        <i class="iconfont icon-angle-right"></i>
      </a>
    
  </nav>
</article>






    <div id="comment" class="mdui-card mdui-p-a-2 mdui-m-b-5">
      <div class="mdui-tab" mdui-tab>
        
          <a href="#comment-tab0" class="mdui-ripple">valine</a>
        
      </div>
      
        <div id="comment-tab0" class="mdui-p-a-2">
          <div id="vcomments"></div>
<script src="//cdnjs.loli.net/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>
<script>
  var GUEST_INFO = ['nick', 'mail', 'link'];
  var guest_info = ''.split(',').filter(function (item) {
    return GUEST_INFO.indexOf(item) > -1;
  });
  var notify = '' === 'true';
  var verify = '' === 'true';
  new Valine({
    el: '#vcomments',
    notify: notify,
    verify: verify,
    appId: 'K384DoBsTJo09tPYtLMxDJz1-gzGzoHsz',
    appKey: 'Bp5G6BLH11s6zkpTjHkvoG1g',
    placeholder: '',
    pageSize: '',
    avatar: '',
    lang: '',
    guest_info: guest_info
  });
</script>
        </div>
      
    </div>

  </main>
  <footer id="footer" class="mdui-text-center mdui-m-t-5 mdui-p-b-2 mdui-p-t-4 mdui-color-theme">
  <div class="mdui-container">
    <div class="mdui-row">
      
        <a href="https://beian.miit.gov.cn" rel="noopener" target="_blank"></a>
      
      <span>
        &copy; 2015 - 2022 
        
          <span style="color:#d9333f" class="iconfont icon-heart"></span>
        
        Dalu Kuankuan
      </span>
    </div>
    <div class="mdui-row">
      
        <div class="mdui-col-xs-6 mdui-text-right">
          <span>Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a></span>
        </div>
        <div class="mdui-col-xs-6 mdui-text-left">
          <span>Theme: <a href="https://github.com/kb1000fx/Meadow" rel="noopener" target="_blank">Meadow</a></span>
        </div>
      
    </div>
    <div class="mdui-row">
      
        <div class="mdui-col-xs-6 mdui-text-right">
          <span id="busuanzi_container_site_uv" style="display: none;"> <span class="iconfont icon-user"></span>总访客量 <span id="busuanzi_value_site_uv"></span></span>
        </div>
        <div class="mdui-col-xs-6 mdui-text-left">
          <span id="busuanzi_container_site_pv" style="display: none;"> <span class="iconfont icon-eye"></span>总访问量 <span id="busuanzi_value_site_pv"></span></span>
        </div>
      
    </div>
 </div>
</footer>
  
  <button id="gotop" class="mdui-fab mdui-fab-fixed mdui-fab-hide mdui-ripple mdui-color-teal" style="z-index:100;"><i class="iconfont icon-arrowup"></i></button>
  
  

    <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




    <script src="https://cdn.jsdelivr.net/npm/mermaid@8.4.8/dist/mermaid.min.js"></script>
    <script>mermaid.initialize({
        startOnLoad: true,
        theme: "default"
    });</script>




    
<script src="/js/mdui.min.v1.0.0.js"></script>




<script src="/js/meadow.js"></script>

</body>
</html >