<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
    
    <meta name="referrer" content="no-referrer-when-downgrade">
    
    <meta name="renderer" content="webkit"/>
    <meta name="force-rendering" content="webkit"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
    <script>if (/*@cc_on!@*/false || (!!window.MSInputMethodContext && !!document.documentMode)) window.location.href="https://support.dmeng.net/upgrade-your-browser.html?referrer="+encodeURIComponent(window.location.href); </script>
    
    
        <link rel="preload" crossorigin="crossorigin" href="/fonts/roboto/Roboto-Regular.woff2" as="font">
        <link rel="preload" crossorigin="crossorigin" href="/fonts/roboto/Roboto-Bold.woff2" as="font">
    
    
    
        <link rel="shortcut icon" href="https://z3.ax1x.com/2021/11/29/oM334O.png">
    

    
    
        
<link rel="stylesheet" href="/css/mdui.min.v1.0.0.css">

    
    
<link rel="stylesheet" href="/css/main.css">
<link rel="stylesheet" href="/css/iconfont.css">


    
    

    
        <script data-ad-client="ca-" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    












          


    
    
    <title>
        
            pandas统计分析 | KKBlog
        
    </title>
    
    
<meta name="generator" content="Hexo 5.4.2"></head>
<body class="mdui-drawer-body-left mdui-appbar-with-toolbar mdui-theme-primary-teal mdui-theme-accent-blue">
  
  <header class="mdui-appbar mdui-appbar-fixed">
  <div id="toolbar" class="mdui-toolbar mdui-color-theme">
    <button class="mdui-btn mdui-btn-icon" mdui-drawer="{target: '#sidebar', swipe: true}"><i class="iconfont icon-menu"></i></button>
    <a href="/" class="mdui-typo-headline">KKBlog</a>
    <a href="/" class="header-subtitle mdui-typo-headline"></a>
    <div class="mdui-toolbar-spacer"></div>
    <button class="mdui-btn mdui-btn-icon" mdui-dialog="{target: '#search'}" mdui-tooltip="{content: 'search'}"><i class="iconfont icon-search"></i></button>
  </div>
</header>

<div class="mdui-dialog" id="search">
  
    <div class="search-form">
      <input type="search" class="search-form-input" placeholder="请输入关键字" onfocus="listenSearchFunc()">
    </div>
    <div class="search-result" data-resource="/search.xml"></div>
  
</div>

  <aside id="sidebar" class="mdui-drawer">
    <div class="mdui-tab" mdui-tab>
        <a href="#sidebar-tab1" id="sidebartab" class="mdui-ripple mdui-tab-active">站点概览</a>
        <a href="#sidebar-tab2" id="sidebartab" class="mdui-ripple">关于</a>
    </div>

    
    <div id="sidebar-tab1" class="mdui-p-a-1">
        <div class="mdui-list">
            
                
                <a href="/" class="mdui-list-item mdui-ripple">
                    <div class="mdui-list-item-icon">
                        <i class="iconfont icon-home"></i>
                    </div>
                    <div class="mdui-list-item-content">主页</div>
                </a>
            
                
                <a href="/tags/" class="mdui-list-item mdui-ripple">
                    <div class="mdui-list-item-icon">
                        <i class="iconfont icon-bookmark"></i>
                    </div>
                    <div class="mdui-list-item-content">标签</div>
                </a>
            
                
                <a href="/categories/" class="mdui-list-item mdui-ripple">
                    <div class="mdui-list-item-icon">
                        <i class="iconfont icon-folder"></i>
                    </div>
                    <div class="mdui-list-item-content">分类</div>
                </a>
            
                
                <a href="/archives/" class="mdui-list-item mdui-ripple">
                    <div class="mdui-list-item-icon">
                        <i class="iconfont icon-archive"></i>
                    </div>
                    <div class="mdui-list-item-content">归档</div>
                </a>
            
                
                <a href="/tools/" class="mdui-list-item mdui-ripple">
                    <div class="mdui-list-item-icon">
                        <i class="iconfont icon-tools"></i>
                    </div>
                    <div class="mdui-list-item-content">工具箱</div>
                </a>
            
                
                <a href="/about/" class="mdui-list-item mdui-ripple">
                    <div class="mdui-list-item-icon">
                        <i class="iconfont icon-user"></i>
                    </div>
                    <div class="mdui-list-item-content">关于</div>
                </a>
            
            <div class="mdui-list-item mdui-ripple">
                <div class="mdui-list-item-icon">
                    <i class="iconfont icon-moon"></i>
                </div>
                <div class="mdui-list-item-content">夜间模式</div>
                <label class="mdui-switch" id="darkmode">
                  <input type="checkbox" id="nightmode_switch"/>
                  <i class="mdui-switch-icon"></i>
                </label>
            </div>           
        </div>
    </div>

    
    <div id="sidebar-tab2" class="mdui-p-a-1">
        <div class="sidebar-overview">
            <div class="sidebar-avatar">
                
                    <img src="https://s3.bmp.ovh/imgs/2021/11/b74ba8f7a70ffeb0.jpg"/>
                
            </div>
            <div class="sidebar-author-name">Dalu Kuankuan</div>
            <div class="sidebar-description">选择有时候比努力更重要</div>
        </div>
        <div class="sidebar-links">
            
                
                <div class="mdui-chip">
                    <span class="mdui-chip-icon"><i class="iconfont icon-mail"></i></span>
                    <a href="mailto:xxx@xxx.com" class="mdui-chip-title">E-Mail</a>
                </div>
            
                
                <div class="mdui-chip">
                    <span class="mdui-chip-icon"><i class="iconfont icon-github"></i></span>
                    <a target="_blank" rel="noopener" href="https://your.url" class="mdui-chip-title">GitHub</a>
                </div>
            
                
                <div class="mdui-chip">
                    <span class="mdui-chip-icon"><i class="iconfont icon-steam"></i></span>
                    <a target="_blank" rel="noopener" href="https://your.url" class="mdui-chip-title">Steam</a>
                </div>
            
                
                <div class="mdui-chip">
                    <span class="mdui-chip-icon"><i class="iconfont icon-weibo"></i></span>
                    <a target="_blank" rel="noopener" href="https://your.url" class="mdui-chip-title">Weibo</a>
                </div>
            
        </div>
        <ul class="mdui-list" mdui-collapse="{accordion: true}">
            <li class="mdui-collapse-item">
                <div class="mdui-collapse-item-header mdui-list-item mdui-ripple">
                    <div class="mdui-list-item-icon">
                        <i class="iconfont icon-link"></i>
                    </div>
                    <div class="mdui-list-item-content">友情链接</div>
                    <div class="mdui-collapse-item-arrow">
                        <i class="mdui-list-item-icon iconfont icon-angle-down"></i>
                    </div>
                </div>
                <ul id="linksList" class="mdui-collapse-item-body mdui-list mdui-list-dense">
                    
                        <a target="_blank" rel="noopener" href="https://garybear.cn/hexo-theme-meadow/" class="mdui-list-item mdui-ripple">
                            Meadow说明文档
                        </a>
                    
                </ul>
            </li>
        </ul>
    </div>

    <div class="mdui-divider"></div>
    
    
</aside>
  
  <main id="main-contain" class="mdui-container mdui-m-t-5">
    <article id="article" class="mdui-card mdui-p-b-2 mdui-m-b-5">
  <header class="mdui-card-media">
    
    
      <div class="post-header"> 
  <a class="post-header-title" href="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/">pandas统计分析</a>
  <div class="post-header-meta">
    <span>
      <span class="iconfont icon-calendar"></span>
      发布于:&nbsp;2020-12-09
    </span>
    <span>
      <span class="iconfont icon-calendar-check"></span>
      更新于:&nbsp;2021-12-09
    </span>
    <span>
      <span class="iconfont icon-folder"></span>
      分类于:&nbsp;<a class="category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/">数据分析</a>
    </span>
    
      <span>
        <span class="iconfont icon-eye"></span>
        阅读次数:&nbsp;
        <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv"></span></span>
      </span>
    
  </div>
</div>   
    



    
    
    <div class="mdui-card-menu">
    
      <button class="mdui-btn mdui-btn-icon mdui-text-color-teal" mdui-menu="{target: '#share_menu', align: 'right'}"><i class="iconfont icon-share"></i></button>
      <ul class="mdui-menu" id="share_menu">
        <li class="mdui-menu-item">
          <a href="http://service.weibo.com/share/share.php?appkey=&title=pandas统计分析&url=http://example.com/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/&pic=http://example.comhttps://z3.ax1x.com/2021/11/29/oM334O.png&searchPic=false&style=simple" target="_blank" class="mdui-ripple">分享到 Weibo</a>
        </li>
        <li class="mdui-menu-item">
          <a href="https://twitter.com/intent/tweet?text=pandas统计分析&url=http://example.com/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/&via=Dalu Kuankuan" target="_blank" class="mdui-ripple">分享到 Twitter</a>
        </li>
        <li class="mdui-menu-item">
          <a href="https://www.facebook.com/sharer/sharer.php?u=http://example.com/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/" target="_blank" class="mdui-ripple">分享到 Facebook</a>
        </li>
        <li class="mdui-menu-item">
          <a href="https://plus.google.com/share?url=http://example.com/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/" target="_blank" class="mdui-ripple">分享到 Google+</a>
        </li>
        <li class="mdui-menu-item">
          <a href="https://www.linkedin.com/shareArticle?mini=true&url=http://example.com/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/&title=pandas统计分析" target="_blank" class="mdui-ripple">分享到 LinkedIn</a>
        </li>
        <li class="mdui-menu-item">
          <a href="http://connect.qq.com/widget/shareqq/index.html?site=KKBlog&title=pandas统计分析&summary=选择有时候比努力更重要&pics=http://example.comhttps://z3.ax1x.com/2021/11/29/oM334O.png&url=http://example.com/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/" target="_blank" class="mdui-ripple">分享到 QQ</a>
        </li>
        <li class="mdui-menu-item">
          <a href="https://telegram.me/share/url?url=http://example.com/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/&text=pandas统计分析" target="_blank" class="mdui-ripple">分享到 Telegram</a>
        </li>
      </ul>
    
  </div>
  </header>
  
  
  
  
  
  <div class="mdui-card-content mdui-typo mdui-p-x-4">
    <p>第四章 Pandas统计分析</p>
<h2 id="4-1-数据计算"><a href="#4-1-数据计算" class="headerlink" title="4.1 数据计算"></a>4.1 数据计算</h2><p>Pandas提供了大量的数据计算函数，可以实现求和、求均值、求最大值、求最小值、求中位数、求众数、求方差、标准差等，从而使得数据统计变得简单高效。</p>
<h3 id="4-1-1求和函数（sum"><a href="#4-1-1求和函数（sum" class="headerlink" title="4.1.1求和函数（sum())"></a>4.1.1求和函数（sum())</h3><p>DataFrame.sum(axis=None, skipna=None, level=None, numeric_only=None, min_count=0, **kwargs)<br>参数说明：　</p>
<p>axis：axis=1表示行，axis=0表示列，默认值为None（无）。　skipna：布尔型，表示计算结果是否排除NaN/Null值，默认值为None。</p>
<p>level：表示索引层级，默认值为None。　</p>
<p>numeric_only：仅数字，布尔型，默认值为None。　</p>
<p>min_count：表示执行操作所需的数目，整型，默认值为0。　**kwargs：要传递给函数的附加关键字参数。　</p>
<p>返回值：返回Series对象或DataFrame对象。行或列求和数据。</p>
<p>【示例01】　计算语文、数学和英语三科的总成绩。（示例位置：资源包\MR\Code\04\01）<br>首先，创建一组DataFrame类型的数据，包括语文、数学和英语三科的成绩，如图4.1所示。<br>程序代码如下：</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020032035450.png" alt="image-20211020032035450">下面使用sum()函数计算三科的总成绩，代码如下：</p>
<p>df[‘总成绩’]=df.sum(axis=1)</p>
<p>运行程序，输出结果如图4.2所示。</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020032210845.png" alt="image-20211020032210845"></p>
<p>​                                        图4.1　DataFrame数据</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020032230748.png" alt="image-20211020032230748"></p>
<p>​                                  图4.2　sum()函数计算三科的总成绩</p>
<h3 id="4-1-2-求均值（mean-函数）"><a href="#4-1-2-求均值（mean-函数）" class="headerlink" title="4.1.2　求均值（mean()函数）"></a>4.1.2　求均值（mean()函数）</h3><p>DataFrame.mean(axis=None, skipna=None, level=None, numeric_only=None, kwargs)<br>参数说明：　</p>
<p>axis：axis=1表示行，axis=0表示列，默认值为None（无）。　</p>
<p>skipna：布尔型，表示计算结果是否排除NaN/Null值，默认值为None。　</p>
<p>level：表示索引层级，默认值为None。　</p>
<p>numeric_only：仅数字，布尔型，默认值为None。　</p>
<p>kwargs：要传递给函数的附加关键字参数。　</p>
<p>返回值：返回Series对象或DataFrame对象。行或列平均值数据。</p>
<p>【示例02】　计算语文、数学和英语各科的平均分。（示例位置：资源包\MR\Code\04\02）<br>计算语文、数学和英语各科成绩的平均值，程序代码如下：</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020032641368.png" alt="image-20211020032641368"></p>
<p>运行程序，输出结果如图4.3所示。</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020032714762.png" alt="image-20211020032714762"></p>
<p>​                             图4.3　mean()函数计算三科成绩的平均值<br>从运行结果得知：语文平均分109，数学平均分107，英语平均分114.667。</p>
<h3 id="4-1-3-求最大值（max-函数）"><a href="#4-1-3-求最大值（max-函数）" class="headerlink" title="4.1.3　求最大值（max()函数）"></a>4.1.3　求最大值（max()函数）</h3><p>在Python中通过调用DataFrame对象的max()函数实现行／列数据最大值运算，语法如下：</p>
<p>DataFrame.max(axis=None, skipna=None, level=None, numeric_only=None, **kwargs)<br>参数说明：　**</p>
<p>**axis：axis=1表示行，axis=0表示列，默认值为None（无）。　skipna：布尔型，表示计算结果是否排除NaN/Null值，默认值为None。　</p>
<p>**level：表示索引层级，默认值为None。　</p>
<p>**numeric_only：仅数字，布尔型，默认值为None。　</p>
<p>kwargs：要传递给函数的附加关键字参数。　</p>
<p>返回值：返回Series对象或DataFrame对象。行或列最大值数据。</p>
<p>【示例03】　计算语文、数学和英语各科的最高分。（示例位置：资源包\MR\Code\04\03）<br>计算语文、数学和英语各科成绩的最大值，程序代码如下：</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020032850843.png" alt="image-20211020032850843"></p>
<p>运行程序，输出结果如图4.4所示。</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020033031795.png" alt="image-20211020033031795"></p>
<p>​                       图4.4　max()函数计算三科成绩的最大值</p>
<p>4.1.4　求最小值（min()函数）<br>在Python中通过调用DataFrame对象的min()函数实现行／列数据最小值运算，语法如下：</p>
<p>DataFrame.min(axis=None, skipna=None, level=None, numeric_only=None, **kwargs)<br>参数说明：　**</p>
<p>**axis：axis=1表示行，axis=0表示列，默认值为None（无）。　skipna：布尔型，表示计算结果是否排除NaN/Null值，默认值为None。　</p>
<p>**level：表示索引层级，默认值为None。　</p>
<p>**numeric_only：仅数字，布尔型，默认值为None。　</p>
<p>kwargs：要传递给函数的附加关键字参数。　</p>
<p>返回值：返回Series对象或DataFrame对象。行或列最小值数据。</p>
<p>【示例04】　计算语文、数学和英语各科的最低分。（示例位置：资源包\MR\Code\04\04）<br>计算语文、数学和英语各科成绩的最小值，程序代码如下：</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020033254349.png" alt="image-20211020033254349"></p>
<p>运行程序，输出结果如图4.5所示。</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020033314763.png" alt="image-20211020033314763"></p>
<h3 id="4-1-5-求中位数（median-函数）"><a href="#4-1-5-求中位数（median-函数）" class="headerlink" title="4.1.5　求中位数（median()函数）"></a>4.1.5　求中位数（median()函数）</h3><p>中位数又称中值，是统计学专有名词，是指按顺序排列的一组数据中位于中间位置的数，其不受异常值的影响。例如，年龄23、45、35、25、22、34、28这7个数，中位数就是排序后位于中间的数字，即28；而年龄23、45、35、25、22、34、28、27这8个数，中位数则是排序后位于中间两个数的平均值，即27.5。在Python中直接调用DataFrame对象的median()函数就可以轻松实现中位数的运算，语法如下：</p>
<p>DataFrame.median(axis=None,skipna=None,level=None,numeric_only=None,**kwargs)<br>参数说明：　**</p>
<p>**axis：axis=1表示行，axis=0表示列，默认值为None（无）。　skipna：布尔型，表示计算结果是否排除NaN/Null值，默认值为None。　</p>
<p>**level：表示索引层级，默认值为None。　</p>
<p>**numeric_only：仅数字，布尔型，默认值为None。　</p>
<p>kwargs：要传递给函数的附加关键字参数。　</p>
<p>返回值：返回Series对象或DataFrame对象。</p>
<p>【示例05】　计算学生各科成绩的中位数1。（示例位置：资源包\MR\Code\04\05）<br>下面给出一组数据（3条记录），然后使用median()函数计算语文、数学和英语各科成绩的中位数，程序代码如下：</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020033458773.png" alt="image-20211020033458773"></p>
<p>运行程序，控制台输出结果如下：</p>
<p>语文    130.0数学    120.0英语    130.0</p>
<p>【示例06】　计算学生各科成绩的中位数2。（示例位置：资源包\MR\Code\04\06）<br>下面再给出一组数据（4条记录），同样使用median()函数计算语文、数学和英语各科成绩的中位数，程序代码如下：</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020033625031.png" alt="image-20211020033625031"></p>
<p>运行程序，控制台输出结果如下：</p>
<p>语文    121.5数学    121.5英语    120.0</p>
<h3 id="4-1-6-求众数（mode-函数）"><a href="#4-1-6-求众数（mode-函数）" class="headerlink" title="4.1.6　求众数（mode()函数）"></a>4.1.6　求众数（mode()函数）</h3><p>什么是众数？众数的众字有多的意思，顾名思义，众数就是一组数据中出现最多的数称为众数，它代表了数据的一般水平。<br>在Python中通过调用DataFrame对象的mode()函数可以实现众数运算，语法如下：</p>
<p>DataFrame.mode(axis=0,numeric_only=False,dropna=True)<br>参数说明：　</p>
<p>axis：axis=1表示行，axis=0表示列，默认值为0。　</p>
<p>numeric_only：仅数字，布尔型，默认值为False。如果值为True，则仅适用于数字列。　</p>
<p>dropna：是否删除缺失值，布尔型，默认值为True。　</p>
<p>返回值：返回Series对象或DataFrame对象。<br>首先看一组原始数据，如图4.6所示。</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020033849240.png" alt="image-20211020033849240"></p>
<p>【示例07】　计算学生各科成绩的众数。（示例位置：资源包\MR\Code\04\07）<br>计算语文、数学和英语三科成绩的众数、每一行的众数和“数学”成绩的众数，程序代码如下：</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020034005721.png" alt="image-20211020034005721"></p>
<p>三科成绩的众数：<br>每一行的众数：</p>
<p>0  110<br>1  130<br>2  130<br>数学成绩的众数：</p>
<p>0  120</p>
<h3 id="4-1-7-求方差（var-函数）"><a href="#4-1-7-求方差（var-函数）" class="headerlink" title="4.1.7　求方差（var()函数）"></a>4.1.7　求方差（var()函数）</h3><p>方差用于衡量一组数据的离散程度，即各组数据与它们的平均数的差的平方，那么我们用这个结果来衡量这组数据的波动大小，并把它叫作这组数据的方差，方差越小越稳定。通过方差可以了解一个问题的波动性。下面简单介绍下方差的意义，相信通过一个简单的举例您就会了解。<br>例如，某校两名同学的物理成绩都很优秀，而参加物理竞赛的名额只有一个，那么选谁去获得名次的机率更大呢？于是根据历史数据计算出了两名同学的平均成绩，但结果是实力相当，平均成绩都是107.6，怎么办呢？这时让方差帮决定，看看谁的成绩更稳定。首先汇总物理成绩，如图4.7所示。</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020034219502.png" alt="image-20211020034219502"></p>
<p>​                                            图4.7　物理成绩<br>通过方差对比两名同学物理成绩的波动，如图4.8所示。</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020034235082.png" alt="image-20211020034235082"></p>
<p>​                                                   图4.8　方差<br>接着来看一下总体波动（方差和），“小黑”的数据是73.2，“小白”的数据是949.2，很明显“小黑”的物理成绩波动较小，发挥更稳定，所以应该选“小黑”参加物理竞赛。<br>以上举例就是方差的意义。大数据时代，它能够帮助我们解决很多身边的问题、协助我们做出合理的决策。<br>在Python中通过调用DataFrame对象的var()函数可以实现方差运算，语法如下：</p>
<p><strong>DataFrame.var(axis=None,skipna=None,level=None,ddof=1,numeric_only=None,kwargs)</strong><br>参数说明：　</p>
<p>axis：axis=1表示行，axis=0表示列，默认值为None（无）。　skipna：布尔型，表示计算结果是否排除NaN/Null值，默认值为None。　</p>
<p>level：表示索引层级，默认值为None。　</p>
<p>ddof：整型，默认值为1。自由度，计算中使用的除数是N-ddof，其中N表示元素的数量。　</p>
<p>numeric_only：仅数字，布尔型，默认值为None。　</p>
<p>kwargs：要传递给函数的附加关键字参数。　</p>
<p>返回值：返回Series对象或DataFrame对象。</p>
<p>【示例08】　通过方差判断谁的物理成绩更稳定。（示例位置：资源包\MR\Code\04\08）<br>计算“小黑”和“小白”物理成绩的方差，程序代码如下：</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020034435272.png" alt="image-20211020034435272"></p>
<p>运行程序，控制台输出结果如下：</p>
<p>小黑     18.3小白    237.3<br>从运行结果得知：“小黑”的物理成绩波动较小，发挥更稳定。这里需要注意的是，Pandas中计算的方差为无偏样本方差（即方差和／样本数-1），NumPy中计算的方差就是样本方差本身（即方差和／样本数）。</p>
<h3 id="4-1-8-标准差（数据标准化std-函数）"><a href="#4-1-8-标准差（数据标准化std-函数）" class="headerlink" title="4.1.8　标准差（数据标准化std()函数）"></a>4.1.8　标准差（数据标准化std()函数）</h3><p>标准差又称均方差，是方差的平方根，用来表示数据的离散程度。<br>在Python中通过调用DataFrame对象的std()函数求标准差，语法如下：</p>
<p>DataFrame.std(axis=None,skipna=None,level=None,ddof=1,numeric_only=None,**kwargs)<br>std()函数的参数与var()函数一样，这里不再赘述。</p>
<p>【示例09】　计算各科成绩的标准差。（示例位置：资源包\MR\Code\04\09）<br>使用std()函数计算标准差，程序代码如下：</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020034453875.png" alt="image-20211020034453875"></p>
<p>运行程序，控制台输出结果如下：</p>
<p>语文    11.547005数学     5.773503英语    11.5547005</p>
<h3 id="4-1-9-求分位数（quantile-函数）"><a href="#4-1-9-求分位数（quantile-函数）" class="headerlink" title="4.1.9　求分位数（quantile()函数）"></a>4.1.9　求分位数（quantile()函数）</h3><p>分位数也称分位点，它以概率依据将数据分割为几个等份，常用的有中位数（即二分位数）、四分位数、百分位数等。分位数是数据分析中常用的一个统计量，经过抽样得到一个样本值。例如，经常会听老师说：“这次考试竟然有20%的同学不及格！”，那么这句话就体现了分位数的应用。在Python中通过调用DataFrame对象的quantile()函数求分位数，语法如下：</p>
<p><strong>DataFrame.quantile(q=0.5,axis=0,numeric_only=True, interpolation=’linear’)</strong><br>参数说明：　</p>
<p>q：浮点型或数组，默认为0.5（50%分位数），其值为0～1。　</p>
<p>axis：axis=1表示行，axis=0表示列。默认值为0。　</p>
<p>numeric_only：仅数字，布尔型，默认值为True。　</p>
<p>interpolation：内插值，可选参数[{‘linear’,‘lower’,‘higher’,‘midpoint’,‘nearest’}]用于指定要使用的插值方法，当期望的分位数为数据点i～j时。　</p>
<p>​    linear’：i+(j-i)×分数，其中分数是指数被i和j包围的小数部分。　</p>
<p>​    lower：i。　</p>
<p>​    higher：j。　 </p>
<p>​    nearest：i或j二者以最近者为准。　</p>
<p>​    midpoint：(i+j)/2。　</p>
<p>返回值：返回Series或DataFrame对象。</p>
<p>【示例10】　通过分位数确定被淘汰的35%的学生。（示例位置：资源包\MR\Code\04\10）<br>以学生成绩为例，数学成绩分别为120、89、98、78、65、102、112、56、79、45的10名同学，现根据分数淘汰35%的学生，该如何处理？首先使用quantile()函数计算35%的分位数，然后将学生成绩与分位数比较，筛选小于等于分位数的学生，程序代码如下：</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020035437337.png" alt="image-20211020035437337"></p>
<p>运行程序，控制台输出结果如下：</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020035513992.png" alt="image-20211020035513992"></p>
<p>从运行结果得知：即将被淘汰的学生有4名，分数分别为78、65、56和45。</p>
<p>【示例11】　计算日期、时间和时间增量数据的分位数。（示例位置：资源包\MR\Code\04\11）<br>如果参数numeric_only=False，将计算日期、时间和时间增量数据的分位数，程序代码如下：<br>运行程序，控制台输出结果如下：</p>
<p>A                  1.5<br>B 2019-07-02 12:00:00<br>C          1 days 12:00:00<br>Name: 0.5, dtype: object</p>
<h2 id="4-2-数据格式化"><a href="#4-2-数据格式化" class="headerlink" title="4.2　数据格式化"></a>4.2　数据格式化</h2><p>在进行数据处理时，尤其是在数据计算中应用求均值（mean()函数）后，发现结果中的小数位数增加了许多。此时就需要对数据进行格式化，以增加数据的可读性。例如，保留小数点位数、百分号、千位分隔符等。首先来看一组数据，如图4.9所示。</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020035851798.png" alt="image-20211020035851798"></p>
<p>​                                         图4.9　原始数据</p>
<h3 id="4-2-1-设置小数位数"><a href="#4-2-1-设置小数位数" class="headerlink" title="4.2.1　设置小数位数"></a>4.2.1　设置小数位数</h3><p>设置小数位数主要使用DataFrame对象的round()函数，该函数可以实现四舍五入，而它的decimals参数则用于设置保留小数的位数，设置后数据类型不会发生变化，依然是浮点型。语法如下：</p>
<p>DataFrame.round(decimals=0, *args, **kwargs)　**</p>
<p>decimals：每一列四舍五入的小数位数，整型、字典或Series对象。如果是整数，则将每一列四舍五入到相同的位置。否则，将字典和Series舍入到可变数目的位置；如果小数是类似于字典的，那么列名应该在键中；如果小数是级数，列名应该在索引中。没有包含在小数中的任何列都将保持原样。非输入列的小数元素将被忽略。　</p>
<p>args：附加的关键字参数。　</p>
<p>kwargs：附加的关键字参数。　</p>
<p>返回值：返回DataFrame对象。</p>
<p>【示例12】　四舍五入保留指定的小数位数。（示例位置：资源包\MR\Code\04\12）<br>使用round()函数四舍五入保留小数位数，程序代码如下：</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020040002742.png" alt="image-20211020040002742"></p>
<p>运行程序，控制台输出结果如下：</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020040023289.png" alt="image-20211020040023289"></p>
<p>当然，保留小数位数也可以用自定义函数，例如，为DataFrame对象中的各个浮点值保留两位小数，主要代码如下：</p>
<p>df.applymap(lambda x: ‘%.2f’%x)</p>
<p>注意<br>经过自定义函数处理过的数据将不再是浮点型而是对象型，如果后续计算需要数据，则应先进行数据类型转换。</p>
<h3 id="4-2-2-设置百分比"><a href="#4-2-2-设置百分比" class="headerlink" title="4.2.2　设置百分比"></a>4.2.2　设置百分比</h3><p>在数据分析过程中，有时需要百分比数据。那么，利用自定义函数将数据进行格式化处理，处理后的数据就可以从浮点型转换成带指定小数位数的百分比数据，主要使用apply()函数与format()函数。</p>
<p>【示例13】　将指定数据格式化为百分比数据。（示例位置：资源包\MR\Code\04\13）<br>将A1列的数据格式化为百分比数据，程序代码如下：</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020040234891.png" alt="image-20211020040234891"></p>
<p>运行程序，控制台输出结果如下：</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020040335780.png" alt="image-20211020040335780"></p>
<h3 id="4-2-3-设置千位分隔符"><a href="#4-2-3-设置千位分隔符" class="headerlink" title="4.2.3　设置千位分隔符"></a>4.2.3　设置千位分隔符</h3><p>由于业务需要，有时需要将数据格式化为带千位分隔符的数据。那么，处理后的数据将不再是浮点型而是对象型。</p>
<p>【示例14】　将金额格式化为带千位分隔符的数据。（示例位置：资源包\MR\Code\04\14）<br>将图书销售码洋格式化为带千位分隔符的数据，程序代码如下：</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020040604750.png" alt="image-20211020040604750"></p>
<p>运行程序，控制台输出结果如下：</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020040623599.png" alt="image-20211020040623599"></p>
<p>注意<br>设置千位分隔符后，对于程序来说，这些数据将不再是数值型，而是数字和逗号组成的字符串，如果由于程序需要再变成数值型就会很麻烦，因此设置千位分隔符要慎重。</p>
<h2 id="4-3-数据分组统计"><a href="#4-3-数据分组统计" class="headerlink" title="4.3　数据分组统计"></a>4.3　数据分组统计</h2><p>本节主要介绍分组统计函数groupby()的各种应用。</p>
<h3 id="4-3-1-分组统计groupby-函数"><a href="#4-3-1-分组统计groupby-函数" class="headerlink" title="4.3.1　分组统计groupby()函数"></a>4.3.1　分组统计groupby()函数</h3><p>对数据进行分组统计，主要使用DataFrame对象的groupby()函数，其功能如下。<br>（1）根据给定的条件将数据拆分成组。</p>
<p>（2）每个组都可以独立应用函数（如求和函数sum()、求平均值函数mean()等）。</p>
<p>（3）将结果合并到一个数据结构中。</p>
<p>groupby()函数用于将数据按照一列或多列进行分组，一般与计算函数结合使用，实现数据的分组统计，语法如下：</p>
<p><strong>DataFrame.groupby(by=None,axis=0,level=None,as_index=True,sort=True,group_keys=True,squeeze=False,observed=False)</strong></p>
<p>参数说明：　</p>
<p>by：映射、字典或Series对象、数组、标签或标签列表。如果by是一个函数，则对象索引的每个值都调用它；如果传递了一个字典或Series对象，则使用该字典或Series对象值来确定组；如果传递了数组ndarray，则按原样使用这些值来确定组。　</p>
<p>axis：axis=1表示行，axis=0表示列。默认值为0。　</p>
<p>level：表示索引层级，默认值为None（无）。　</p>
<p>as_index：布尔型，默认值为True，返回以组标签为索引的对象。　sort：对组进行排序，布尔型，默认值为True。　</p>
<p>group_keys：布尔型，默认值为True，调用apply()函数时，将分组的键添加到索引以标识片段。　</p>
<p>squeeze：布尔型，默认值为False。如果可能，减少返回类型的维度；否则返回一致类型。　</p>
<p>observed： <em>bool, default False</em> 布尔型, 观察者, 默认为False。当以石斑鱼为分类时，才会使用该参数。如果参数值为True，则仅显示分类石斑鱼的观测值；如果参数值为False，则显示分类石斑鱼的所有值。</p>
<p>返回值：返回DataFrameGroupBy，返回包含有关组的信息的groupby对象。</p>
<h4 id="1．按照一列分组统计"><a href="#1．按照一列分组统计" class="headerlink" title="1．按照一列分组统计"></a>1．按照一列分组统计</h4><p>【示例15】　根据“一级分类”统计订单数据。（示例位置：资源包\MR\Code\04\15）<br>按照图书“一级分类”对订单数据进行分组统计求和，程序代码如下：</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020042705196.png" alt="image-20211020042705196"></p>
<p>运行程序，输出结果如图4.10所示。</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020042744863.png" alt="image-20211020042744863"></p>
<p>​                                 图4.10　按照一列分组统计</p>
<h4 id="2．按照多列分组统计"><a href="#2．按照多列分组统计" class="headerlink" title="2．按照多列分组统计"></a>2．按照多列分组统计</h4><p>多列分组统计，以列表形式指定列。</p>
<p>【示例16】　根据两级分类统计订单数据。（示例位置：资源包\MR\Code\04\16）<br>按照图书“一级分类”和“二级分类”对订单数据进行分组统计求和，主要代码如下：</p>
<p>01 #抽取数据<br>02 df1=df[[‘一级分类’,’二级分类’,’7天点击量’,’订单预定’]]<br>03 df1=df1.groupby([‘一级分类’,’二级分类’]).sum()    #分组统计求和</p>
<p>运行程序，输出结果如图4.11所示。</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020042906442.png" alt="image-20211020042906442"></p>
<p>​                                    图4.11　按照多列分组统计</p>
<h4 id="3．分组并按指定列进行数据计算"><a href="#3．分组并按指定列进行数据计算" class="headerlink" title="3．分组并按指定列进行数据计算"></a>3．分组并按指定列进行数据计算</h4><p>前面介绍的分组统计是按照所有列进行汇总计算的，那么如何按照指定列汇总计算呢？</p>
<p>【示例17】　统计各编程语言的7天点击量。（示例位置：资源包\MR\Code\04\17）<br>统计各编程语言的7天点击量，首先按“二级分类”分组，然后抽取“7天点击量”列并对该列进行求和运算，主要代码如下：</p>
<p>df1=df1.groupby(‘二级分类’)[‘7天点击量’].sum()<br>运行程序，输出结果如图4.12所示。</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020043023795.png" alt="image-20211020043023795"></p>
<p>图4.12　分组并按指定列进行数据计算</p>
<h3 id="4-3-2-对分组数据进行迭代"><a href="#4-3-2-对分组数据进行迭代" class="headerlink" title="4.3.2　对分组数据进行迭代"></a>4.3.2　对分组数据进行迭代</h3><p>通过for循环对分组统计数据进行迭代（遍历分组数据）。</p>
<p>【示例18】　迭代一级分类的订单数据。（示例位置：资源包\MR\Code\04\18）<br>按照“一级分类”分组，并输出每一分类中的订单数据，主要代码如下：</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020043149194.png" alt="image-20211020043149194"></p>
<p>运行程序，控制台输出结果如图4.13所示。<br>上述代码中，name是groupby()函数中“一级分类”的值，group是分组后的数据。如果groupby()函数对多列进行分组，那么需要在for循环中指定多列。</p>
<p>【示例19】　迭代两级分类的订单数据。（示例位置：资源包\MR\Code\04\19）<br>迭代“一级分类”和“二级分类”的订单数据，主要代码如下：</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020043219251.png" alt="image-20211020043219251"></p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020043328145.png" alt="image-20211020043328145"></p>
<p>​                          图4.13　对分组数据进行迭代</p>
<h3 id="4-3-3-对分组的某列或多列使用聚合函数（agg-函数）"><a href="#4-3-3-对分组的某列或多列使用聚合函数（agg-函数）" class="headerlink" title="4.3.3　对分组的某列或多列使用聚合函数（agg()函数）"></a>4.3.3　对分组的某列或多列使用聚合函数（agg()函数）</h3><p>Python也可以实现像SQL中的分组聚合运算操作，主要通过groupby()函数与agg()函数实现。【示例20】　对分组统计结果使用聚合函数。（示例位置：资源包\MR\Code\04\20）<br>按“一级分类”分组统计“7天点击量”“订单预定”的平均值和总和，主要代码如下：</p>
<p>print(df1.groupby(‘一级分类’).agg([‘mean’,’sum’]))<br>运行程序，控制台输出结果如图4.14所示。</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020043531227.png" alt="image-20211020043531227"></p>
<p>​                 图4.14　分组统计“7天点击量”“订单预定”的平均值和总和</p>
<p>【示例21】　针对不同的列使用不同的聚合函数。（示例位置：资源包\MR\Code\04\21）<br>在上述示例中，还可以针对不同的列使用不同的聚合函数。例如，按“一级分类”分组统计“7天点击量”的平均值和总和、“订单预定”的总和，主要代码如下：</p>
<p>print(df1.groupby(‘一级分类’).agg({‘7天点击量’:[‘mean’,’sum’], ‘订单预定’:[‘sum’]}))<br>运行程序，控制台输出结果如图4.15所示。</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020043554534.png" alt="image-20211020043554534"></p>
<p>​           图4.15　分组统计“7天点击量”的平均值和总和、“订单预定”的总和</p>
<p>【示例22】　通过自定义函数实现分组统计。（示例位置：资源包\MR\Code\04\22）<br>通过自定义函数也可以实现数据分组统计。例如，统计1月份销售数据中，购买次数最多的产品，主要代码如下：</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020043631773.png" alt="image-20211020043631773"></p>
<p>运行程序，控制台输出结果如图4.16所示。</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020043647886.png" alt="image-20211020043647886"></p>
<p>​                             图4.16　统计购买次数最多的产品</p>
<p>从运行结果得知：“零基础学Python”是用户购买次数最多的产品。实用技巧<br>在图4.16显示的输出结果中可以看到，lambda()函数名称<lambda>被输出出来，看上去不是很美观，那么如何去掉它？方法是使用__name__方法修改函数名称，主要代码如下：</lambda></p>
<p>max.<strong>name</strong> = “购买次数最多”<br>运行程序，控制台输出结果如图4.17所示。</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020043747160.png" alt="image-20211020043747160"></p>
<p>​                         图4.17　使用__name__方法修改函数名称</p>
<h3 id="4-3-4-通过字典和Series对象进行分组统计"><a href="#4-3-4-通过字典和Series对象进行分组统计" class="headerlink" title="4.3.4　通过字典和Series对象进行分组统计"></a>4.3.4　通过字典和Series对象进行分组统计</h3><h4 id="1．通过字典进行分组统计"><a href="#1．通过字典进行分组统计" class="headerlink" title="1．通过字典进行分组统计"></a>1．通过字典进行分组统计</h4><p>首先创建字典建立对应关系，然后将字典传递给groupby()函数从而实现数据分组统计。</p>
<p>【示例23】　通过字典分组统计“北上广”销量。（示例位置：资源包\MR\Code\04\23）<br>统计各地区销量，业务要求将“北京”“上海”“广州”3个一线城市放在一起统计。那么首先创建一个字典将“北京出库销量”“上海出库销量”“广州出库销量”都对应“北上广”；然后使用groupby()函数进行分组统计。主要代码如下：</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020043824543.png" alt="image-20211020043824543"></p>
<p>运行程序，控制台输出结果如图4.18所示。</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020043847244.png" alt="image-20211020043847244"></p>
<p>​                                 图4.18　通过字典进行分组统计</p>
<h4 id="2．通过Series对象进行分组统计"><a href="#2．通过Series对象进行分组统计" class="headerlink" title="2．通过Series对象进行分组统计"></a>2．通过Series对象进行分组统计</h4><p>通过Series对象进行分组统计与字典的方法类似。</p>
<p>【示例24】　通过Series对象分组统计“北上广”销量。（示例位置：资源包\MR\Code\04\24）<br>首先，创建一个Series对象，主要代码如下：</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020043933019.png" alt="image-20211020043933019"></p>
<p>运行程序，输出结果如图4.19所示。<br>然后，将Series对象传递给groupby()函数实现数据分组统计，主要代码如下：</p>
<p>01  df1=df.groupby(s1,axis=1).sum()<br>02  print(df1)<br>运行程序，控制台输出结果如图4.20所示。</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020043959963.png" alt="image-20211020043959963"></p>
<p>​                             图4.19　通过Series对象进行分组统计</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020044040014.png" alt="image-20211020044040014"></p>
<p>​                             图4.20　分组统计结果</p>
<h2 id="4-4-数据移位"><a href="#4-4-数据移位" class="headerlink" title="4.4　数据移位"></a>4.4　数据移位</h2><p>什么是数据移位？例如，分析数据时需要上一条数据怎么办？当然是移动至上一条，从而得到该条数据，这就是数据移位。在Pandas中，使用shift()方法可以获得上一条数据，该方法返回向下移位后的结果，从而得到上一条数据。例如，获取某学生上一次英语成绩，如图4.21所示。</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020044117875.png" alt="image-20211020044117875"></p>
<p>​                              图4.21　获取学生上一次英语成绩<br>shift()方法是一个非常有用的方法，用于数据位移与其他方法结合，能实现很多难以想象的功能，语法格式如下：</p>
<p>DataFrame.shift(periods=1, freq=None, axis=0)<br>参数说明：　</p>
<p>periods：表示移动的幅度，可以是正数，也可以是负数，默认值是1，1表示移动一次。注意这里移动的都是数据，而索引是不移动的，移动之后是没有对应值的，赋值为NaN。　</p>
<p>freq：可选参数，默认值为None，只适用于时间序列，如果这个参数存在，那么会按照参数值移动时间索引，而数据值没有发生变化。　</p>
<p>axis：axis=1表示行，axis=0表示列。默认值为0。</p>
<p>【示例25】　统计学生英语周测成绩的升降情况。（示例位置：资源包\MR\Code\04\25）<br>使用shift()方法统计学生每周英语测试成绩的升降情况，程序代码如下：</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020044313140.png" alt="image-20211020044313140"></p>
<p>运行程序，控制台输出结果如图4.22所示。<br>从运行结果得知：第2次比第1次下降5分，第3次比第2次下降6分，第4次比第3次提升21分，第5次比第4次下降5分。<br>这里再扩展下，通过10次周测来一看下学生整体英语成绩的升降情况，如图4.23和图4.24所示。</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020044330897.png" alt="image-20211020044330897"></p>
<p>​                                     图4.22　英语升降情况</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020044547566.png" alt="image-20211020044547566"></p>
<p>​                               图4.23　10次周测英语成绩升降情况</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020044603814.png" alt="image-20211020044603814"></p>
<p>​                     图4.24　图表展示英语成绩升降情况</p>
<p>说明</p>
<p>有关图表的知识将在第6章介绍，这里先简单了解。</p>
<p>shift()方法还有很多方面的应用。例如这样一个场景：分析股票数据，获取的股票数据中有股票的实时价格，也有每日的收盘价“close”，此时需要将实时价格和上一个工作日的收盘价进行对比，那么通过shift()方法就可以轻松解决。shift()方法还可以应用于时间序列，感兴趣的读者可以在学习完成后续章节进行尝试和探索。</p>
<h2 id="4-5-数据转换"><a href="#4-5-数据转换" class="headerlink" title="4.5　数据转换"></a>4.5　数据转换</h2><p>数据转换一般包括一列数据转换为多列数据、行列转换、DataFrame转换为字典、DataFrame转换为列表和DataFrame转换为元组等。</p>
<h3 id="4-5-1-一列数据转换为多列数据"><a href="#4-5-1-一列数据转换为多列数据" class="headerlink" title="4.5.1　一列数据转换为多列数据"></a>4.5.1　一列数据转换为多列数据</h3><p>一列数据转换为多列数据的情况在日常工作中经常会用到，从各种系统中导出的订单号、名称、地址很多都是复合组成的（即由多项内容组成），那么，这些列在查找、统计、合并时就没办法使用，需要将它们拆分开。例如，地址信息由省市区街道门牌号等信息组成，如果按省、市或区统计数据，就需要将地址信息中的“省”“市”“区”拆分开，此时就应用到了一列数据转多列数据，通常使用以下方法。</p>
<h4 id="1．split-方法"><a href="#1．split-方法" class="headerlink" title="1．split()方法"></a>1．split()方法</h4><p>Pandas的DataFrame对象中的str.split()内置方法可以实现分割字符串，语法如下：</p>
<p>Series.str.split(pat=None, n=-1, expand=False)<br>参数说明：　</p>
<p>pat：字符串、符号或正则表达式，字符串分割的依据，默认以空格分割字符串。　</p>
<p>n：整型，分割次数，默认值是-1，0或-1都将返回所有拆分。　expand：布尔型，分割后的结果是否转换为DataFrame，默认值是False。　</p>
<p>返回值：系列、索引、DataFrame或多重索引。<br>首先，我们来看一组淘宝销售订单数据（部分数据），如图4.25所示。</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020044753477.png" alt="image-20211020044753477"></p>
<p>图4.25　淘宝销售订单数据（部分数据）<br>从图4-25中数据得知：不仅“收货地址”是复合的，“宝贝标题”也是复合的，即由多种产品组成。</p>
<p>【示例26】　分割“收货地址”数据中的“省、市、区”。（示例位置：资源包\MR\Code\04\26）<br>使用split()方法先对“收货地址”进行分割，程序代码如下：</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020044817707.png" alt="image-20211020044817707"></p>
<p>运行程序，输出结果如图4.26所示。</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020044931041.png" alt="image-20211020044931041"></p>
<p>​                                  图4.26　分割后的收货地址</p>
<h4 id="2．join-方法与split-方法结合"><a href="#2．join-方法与split-方法结合" class="headerlink" title="2．join()方法与split()方法结合"></a>2．join()方法与split()方法结合</h4><p>【示例27】　以逗号分隔多种产品数据。（示例位置：资源包\MR\Code\04\27）<br>通过join()方法与split()方法结合，以逗号“,”分隔“宝贝标题”，主要代码如下：</p>
<p>df = df.join(df[‘宝贝标题’].str.split(‘, ‘, expand=True))</p>
<p>运行程序，输出结果如图4.27所示。</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020044959881.png" alt="image-20211020044959881"></p>
<p>​                                   图4.27　分隔后的“宝贝标题”<br>从运行结果得知：“宝贝标题”中含有多种产品的数据被拆分开，这样操作便于日后对每种产品的销量进行统计。<br>将DataFrame中的tuple（元组）类型数据分隔成多列</p>
<p>【示例28】　对元组数据进行分隔。（示例位置：资源包\MR\Code\04\28）<br>首先，创建一组包含元组的数据，程序代码如下：</p>
<p>01  import pandas as pd<br>02  df = pd.DataFrame({‘a’:[1,2,3,4,5], ‘b’:[(1,2), (3,4),(5,6),(7,8),(9,10)]})<br>03  print(df)</p>
<p>然后，使用apply()函数对元组进行分隔，主要代码如下：</p>
<p>df[[‘b1’, ‘b2’]] = df[‘b’].apply(pd.Series)<br>或者使用join()方法结合apply()函数，主要代码如下：</p>
<p>df= df.join(df[‘b’].apply(pd.Series))<br>运行程序，控制台输出原始数据如图4.28所示，结果如图4.29和图4.30所示。</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045110497.png" alt="image-20211020045110497"></p>
<p>​                                            图4.28　原始数据</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045122797.png" alt="image-20211020045122797"></p>
<p>​                             图4.29　apply()函数分隔元组</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045146968.png" alt="image-20211020045146968"></p>
<p>​                       图4.30　join()方法结合apply()函数分隔元组</p>
<h3 id="4-5-2-行列转换"><a href="#4-5-2-行列转换" class="headerlink" title="4.5.2　行列转换"></a>4.5.2　行列转换</h3><p>在Pandas处理数据过程中，有时需要对数据进行行列转换或重排，主要使用stack()方法、unstack()方法和pivot()方法，下面介绍这3种方法的应用。</p>
<h4 id="1．stack-方法"><a href="#1．stack-方法" class="headerlink" title="1．stack()方法"></a>1．stack()方法</h4><p>stack()方法用于将原来的<strong>列索引转换成最内层的行索引</strong>，转换效果对比示意图如图4.31所示。</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045215351.png" alt="image-20211020045215351"></p>
<p>​                               图4.31　转换效果对比示意图<br>stack()方法的语法如下：</p>
<p>DataFrame.stack(level=-1, dropna=True)<br>参数说明：　</p>
<p>level：索引层级，定义为一个索引或标签，或索引或标签列表，默认值是-1。　</p>
<p>dropna：布尔型，默认值是True，　</p>
<p>返回值：DataFrame对象或Series对象。</p>
<p>【示例29】　对英语成绩表进行行列转换。（示例位置：资源包\MR\Code\04\29）<br>将学生英语成绩表进行行列转换，程序代码如下：</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045321517.png" alt="image-20211020045321517"></p>
<h4 id="2．unstack-方法"><a href="#2．unstack-方法" class="headerlink" title="2．unstack()方法"></a>2．unstack()方法</h4><p>unstack()方法与stack()方法相反，它是stack()方法的逆操作，即将最内层的行索引转换成列索引，转换效果对比如图4.32所示。</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045341690.png" alt="image-20211020045341690"></p>
<p>​                   图4.32　unstack()方法转换数据示意图<br>unstack()方法的语法如下：</p>
<p>DataFrame.unstack(level=-1, fill_value=None)<br>参数说明：　</p>
<p>level：索引层级，定义为一个索引或标签，或索引或标签列表，默认值是-1。　</p>
<p>fill_value：整型、字符串或字典，如果unstack()方法产生丢失值，则用这个值替换NaN。　返回值：DataFrame对象或Series对象。</p>
<p>【示例30】　使用unstack()方法转换学生成绩表。（示例位置：资源包\MR\Code\04\30）<br>同样转换学生成绩表，主要代码如下：</p>
<p>01 df=pd.read_excel(‘grade.xls’,sheet_name=’英语2’)      #导入Excel文件<br>02 df = df.set_index([‘班级’,’序号’,’Unnamed: 2’])       #设置多级索引<br>03 print(df.unstack())<br>unstack()方法中有一个参数可以指定转换第几层索引，例如，unstack(0)就是把第一层行索引转换为列索引，默认是将最内层索引转换为列索引。</p>
<h4 id="3．pivot-方法"><a href="#3．pivot-方法" class="headerlink" title="3．pivot()方法"></a>3．pivot()方法</h4><p>pivot()方法针对列的值，即指定某列的值作为行索引，指定某列的值作为列索引，然后再指定哪些列作为索引对应的值。unstack()方法针对索引进行操作，pivot()方法针对值进行操作。但实际上，二者的功能往往可以互相实现。<br>pivot()方法的语法如下：</p>
<p>DataFrame.pivot(index=None, columns=None, values=None)<br>参数说明：　</p>
<p>index：字符串或对象，可选参数。列用于创建新DataFrame数据的索引。如果没有，则使用现有索引。　</p>
<p>columns：字符串或对象，列用于创建新DataFrame的列。　</p>
<p>values：列用于填充新DataFrame的值，如果未指定，则将使用所有剩余的列，结果将具有分层索引列。　</p>
<p>返回值：DataFrame对象或Series对象。</p>
<p>【示例31】　使用pivot()方法转换学生成绩表。（示例位置：资源包\MR\Code\04\31）<br>使用pivot()方法转换学生成绩表，主要代码如下：</p>
<p>01 df=pd.read_excel(‘grade.xls’,sheet_name=’英语3’)         #导入Excel文件<br>02 df1=df.pivot(index=’序号’,columns=’班级’,values=’得分’)<br>运行程序，输出结果如图4.33所示。</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045550818.png" alt="image-20211020045550818"></p>
<p>图4.33　使用pivot()方法转换学生成绩表</p>
<h3 id="4-5-3-DataFrame转换为字典"><a href="#4-5-3-DataFrame转换为字典" class="headerlink" title="4.5.3　DataFrame转换为字典"></a>4.5.3　DataFrame转换为字典</h3><p>DataFrame转换为字典主要使用DataFrame对象的to_dict()方法，以索引作为字典的键（key），以列作为字典的值（value）。例如，有一个DataFrame对象（索引为“类别”、列为“数量”），通过to_dict()方法就会生成一个字典，示意图如图4.34所示。如果DataFrame对象包含两列，那么to_dict()方法就会生成一个两层的字典（dict），第一层是列名作为字典的键（key），第二层以索引列的值作为字典的键（key），以列值作为字典的值（value）。</p>
<p>【示例32】　将Excel销售数据转换为字典。（示例位置：资源包\MR\Code\04\32）<br>使用to_dict()方法将按“宝贝标题”分组统计后的部分数据转换为字典，程序代码如下：</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045613721.png" alt="image-20211020045613721"></p>
<p>运行程序，控制台输出结果如图4.35所示。</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045643137.png" alt="image-20211020045643137"></p>
<p>​                       图4.34　DataFrame转换为字典示意图</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045702961.png" alt="image-20211020045702961"></p>
<p>​                           图4.35　DataFrame转换为字典</p>
<h3 id="4-5-4-DataFrame转换为列表"><a href="#4-5-4-DataFrame转换为列表" class="headerlink" title="4.5.4　DataFrame转换为列表"></a>4.5.4　DataFrame转换为列表</h3><p>DataFrame转换为列表主要使用DataFrame对象的tolist()方法。</p>
<p>【示例33】　将电商数据转换为列表。（示例位置：资源包\MR\Code\04\33）<br>将淘宝销售数据中的“买家会员名”转换为列表，程序代码如下：</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045737401.png" alt="image-20211020045737401"></p>
<p>运行程序，控制台输出结果如图4.36所示。</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045806297.png" alt="image-20211020045806297"></p>
<p>图4.36　DataFrame转换为列表</p>
<h3 id="4-5-5-DataFrame转换为元组"><a href="#4-5-5-DataFrame转换为元组" class="headerlink" title="4.5.5　DataFrame转换为元组"></a>4.5.5　DataFrame转换为元组</h3><p>DataFrame转换为元组，首先通过循环语句按行读取DataFrame数据，然后使用元组函数tuple()将其转换为元组。</p>
<p>【示例34】　将Excel数据转换为元组。（示例位置：资源包\MR\Code\04\34）<br>将Excel表中的人物关系部分数据转换成元组，程序代码如下：</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045832962.png" alt="image-20211020045832962"></p>
<p>运行程序，控制台输出结果如图4.37所示。</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045913740.png" alt="image-20211020045913740"></p>
<p>​                            图4.37　DataFrame转换为元组</p>
<h3 id="4-5-6-Excel转换为HTML网页格式"><a href="#4-5-6-Excel转换为HTML网页格式" class="headerlink" title="4.5.6　Excel转换为HTML网页格式"></a>4.5.6　Excel转换为HTML网页格式</h3><p>日常工作中，有时会涉及财务数据的处理，而Excel应用最为广泛，但是对于展示数据来说，Excel并不友好，如果你想用其他格式的文件来向用户展示，那么，HTML网页格式是不错的选择。首先使用read_excel()方法导入Excel文件，然后使用to_html()方法将DataFrame数据导出为HTML格式，这样便实现了Excel转换为HTML格式。</p>
<p>【示例35】　将Excel订单数据转换为HTML网页格式。（示例位置：资源包\MR\Code\04\35）<br>将淘宝部分订单数据转换为HTML网页格式，效果如图4.38所示。</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045939834.png" alt="image-20211020045939834"></p>
<p>​                              图4.38　Excel转换为HTML网页格式<br>程序代码如下：</p>
<p>01 import pandas as pd<br>02 df=pd.read_excel(‘mrbooks.xls’)<br>03 df.to_html(‘mrbook.html’,header = True,index = False)</p>
<h2 id="4-6-数据合并"><a href="#4-6-数据合并" class="headerlink" title="4.6　数据合并"></a>4.6　数据合并</h2><p>DataFrame数据合并主要使用merge()方法和concat()方法。</p>
<h3 id="4-6-1-数据合并（merge-方法）"><a href="#4-6-1-数据合并（merge-方法）" class="headerlink" title="4.6.1　数据合并（merge()方法）"></a>4.6.1　数据合并（merge()方法）</h3><p>Pandas模块的merge()方法是按照两个DataFrame对象列名相同的列进行连接合并，两个DataFrame对象必须具有同名的列。merge()方法的语法如下：</p>
<p>pandas.merge(right,how=’inner’,on=None,left_on=None,right_on=None,left_index=False,right_index=False,sort=<br>False,suffixes=(‘_x’,’_y’),copy=True,indicator=False,validate=None)<br>参数说明：　</p>
<p>right：合并对象，DataFrame对象或Series对象。　</p>
<p>how：合并类型，参数值可以是left（左合并）、right（右合并）、outer（外部合并）或inner（内部合并），默认值为inner。各个值的说明如下。　</p>
<p>​        left：只使用来自左数据集的键，类似于SQL左外部联接，保留键的顺序。　</p>
<p>​        right：只使用来自右数据集的键，类似于SQL右外部联接，保留键的顺序。　</p>
<p>​        outer：使用来自两个数据集的键，类似于SQL外部联接，按字典顺序对键进行排序。　</p>
<p>​        inner：使用来自两个数据集的键的交集，类似于SQL内部连接，保持左键的顺序。</p>
<p>on：标签、列表或数组，默认值为None。DataFrame对象连接的列或索引级别名称。也可以是DataFrame对象长度的数组或数组列表。</p>
<p>left_on：标签、列表或数组，默认值为None。要连接的左数据集的列或索引级名称，也可以是左数据集长度的数组或数组列表。　</p>
<p>right_on：标签、列表或数组，默认值为None。要连接的右数据集的列或索引级名称，也可以是右数据集长度的数组或数组列表。　left_index：布尔型，默认值为False。使用左数据集的索引作为连接键。如果是多重索引，则其他数据中的键数（索引或列数）必须匹配索引级别数。</p>
<p>right_index：布尔型，默认值为False，使用右数据集的索引作为连接键。　</p>
<p>sort：布尔型，默认值为False，在合并结果中按字典顺序对连接键进行排序。如果值为False，则连接键的顺序取决于连接类型how参数。　</p>
<p>suffixes：元组类型，默认值为(‘_x’,’_y’)。当左侧数据集和右侧数据集的列名相同时，数据合并后列名将带上“_x”和“_y”后缀。　</p>
<p>copy：是否复制数据，默认值为True。如果值为False，则不复制数据。　</p>
<p>indicator：布尔型或字符串，默认值为False。如果值为True，则添加一个列以输出名为_Merge的DataFrame对象，其中包含每一行的信息。如果是字符串，将向输出的DataFrame对象中添加包含每一行信息的列，并将列命名为字符型的值。　</p>
<p>validate：字符串，检查合并数据是否为指定类型。可选参数，其值说明如下。　one_to_one或“1:1”：检查合并键在左、右数据集中是否都是唯一的。　one_to_many或“1:m”：检查合并键在左数据集中是否唯一。　many_to_one或“m:1”：检查合并键在右数据集中是否唯一。　many_to_many或“m:m”：允许，但不检查。　</p>
<p>返回值：DataFrame对象，两个合并对象的数据集。</p>
<h4 id="1．常规合并"><a href="#1．常规合并" class="headerlink" title="1．常规合并"></a>1．常规合并</h4><p>【示例36】　合并学生成绩表。（示例位置：资源包\MR\Code\04\36）<br>假设一个DataFrame对象包含了学生的“语文”“数学”“英语”成绩，而另一个DataFrame对象则包含了学生的“体育”成绩，现在将它们合并，示意图如图4.39所示。</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020050304612.png" alt="image-20211020050304612"></p>
<p>​                 图4.39　数据合并效果对比示意图<br>程序代码如下：</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020050326358.png" alt="image-20211020050326358"></p>
<p>运行程序，控制台输出结果如图4.40所示。</p>
<p>【示例37】　通过索引合并数据。（示例位置：资源包\MR\Code\04\37）<br>如果通过索引列合并，则需要设置right_index参数和left_index参数值为True。例如，上述举例，通过列索引合并，主要代码如下：</p>
<p>01 df_merge=pd.merge(df1,df2,right_index=True,left_index=True)<br>02 print(df_merge)<br>运行程序，控制台输出结果如图4.41所示。</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020050352118.png" alt="image-20211020050352118"></p>
<p>​                           图4.40　合并结果</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020050412167.png" alt="image-20211020050412167"></p>
<p>​                            图4.41　通过索引列合并</p>
<p>【示例38】　对合并数据去重。（示例位置：资源包\MR\Code\04\38）<br>从图4.41中的运行结果得知：数据中存在重复列（如编号），如果不想要重复列，可以设置按指定列和列索引合并数据，主要代码如下：</p>
<p>df_merge=pd.merge(df1,df2,on=’编号’,left_index=True,right_index=True)</p>
<p>还可以通过how参数解决这一问题。例如，设置该参数值为left，就是让df1保留所有的行列数据，df2则根据df1的行列进行补全，主要代码如下：</p>
<p>df_merge=pd.merge(df1,df2,on=’编号’,how=’left’)<br>运行程序，控制台输出结果如图4.42所示。</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020050506047.png" alt="image-20211020050506047"></p>
<p>图4.42　合并结果</p>
<h4 id="2．多对一的数据合并"><a href="#2．多对一的数据合并" class="headerlink" title="2．多对一的数据合并"></a>2．多对一的数据合并</h4><p>多对一是指两个数据集（df1、df2）的共有列中的数据不是一对一的关系，例如，df1中的“编号”是唯一的，而df2中的“编号”有重复的编号，类似这种就是多对一的关系，示意图如图4.43所示。【示例39】　根据共有列进行合并数据。（示例位置：资源包\MR\Code\04\39）<br>根据共有列中的数据进行合并，df2根据df1的行列进行补全，程序代码如下：</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020050528714.png" alt="image-20211020050528714"></p>
<p>运行程序，控制台输出结果如图4.44所示。</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020050545631.png" alt="image-20211020050545631"></p>
<p>​                                     图4.43　多对一合并示意图</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020050604101.png" alt="image-20211020050604101"></p>
<p>​                                  图4.44　合并结果</p>
<h4 id="3．多对多的数据合并"><a href="#3．多对多的数据合并" class="headerlink" title="3．多对多的数据合并"></a>3．多对多的数据合并</h4><p>多对多是指两个数据集（df1、df2）的共有列中的数据不全是一对一的关系，都有重复数据，例如“编号”，示图如图4.45所示。</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020050702131.png" alt="image-20211020050702131"></p>
<p>​                                    图4.45　多对多示意图</p>
<p>【示例40】　合并数据并相互补全。（示例位置：资源包\MR\Code\04\40）<br>根据共有列中的数据进行合并，df2、df1相互补全，程序代码如下：</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020050733884.png" alt="image-20211020050733884"></p>
<p>运行程序，控制台输出结果如图4.46所示。</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020050749641.png" alt="image-20211020050749641"></p>
<p>​                                               图4.46　合并结果</p>
<h3 id="4-6-2-数据合并（concat-方法）"><a href="#4-6-2-数据合并（concat-方法）" class="headerlink" title="4.6.2　数据合并（concat()方法）"></a>4.6.2　数据合并（concat()方法）</h3><p>concat()方法可以根据不同的方式将数据合并，语法如下：</p>
<p>pandas.concat(objs,axis=0,join=’outer’,ignore_index: bool = False, keys=None, levels=None, names=None,<br>verify_integrity: bool = False, sort: bool = False, copy: bool = True)<br>参数说明：　</p>
<p>objs：Series、DataFrame或Panel对象的序列或映射。如果传递一个字典，则排序的键将用作键参数。　</p>
<p>axis：axis=1表示行，axis=0表示列。默认值为0。　</p>
<p>join：值为inner（内连接）或outer（外连连接），处理其他轴上的索引方式。默认值为outer。　</p>
<p>ignore_index：布尔值，默认值为False，保留索引，索引值为0，…，n-1。如果值为True，则忽略索引。　</p>
<p>keys：序列，默认值为None。使用传递的键作为最外层构建层次索引。如果为多索引，应该使用元组。　</p>
<p>levels：序列列表，默认值为None。用于构建MultiIndex的特定级别（唯一值）；否则，它们将从键推断。　</p>
<p>names：list列表，默认值为None。结果层次索引中的级别的名称。　</p>
<p>verify_integrity：布尔值，默认值为False。检查新连接的轴是否包含重复项。　</p>
<p>sort：布尔值，默认值为True（1.0.0以后版本默认值为False，即不排序）。如果连接为外连接（join=’outer’），则对未对齐的非连接轴进行排序；如果连接为内连接（join=’inner’），则该参数不起作用。</p>
<p>copy：是否复制数据，默认值为True，如果值为False，则不复制数据。</p>
<p>下面介绍concat()方法不同的合并方式，其中dfs代表合并后的DataFrame对象，df1、df2等代表单个DataFrame对象，result代表合并后的结果（DataFrame对象）。</p>
<h4 id="1．相同字段的表首尾相接"><a href="#1．相同字段的表首尾相接" class="headerlink" title="1．相同字段的表首尾相接"></a>1．相同字段的表首尾相接</h4><p>表结构相同的数据将直接合并，表首尾相接，主要代码如下：</p>
<p>01  dfs= [df1, df2, df3]<br>02  result = pd.concat(dfs)<br>例如，表df1、df2和df3结构相同，如图4.47所示。合并后的效果如图4.48所示。如果想要在合并数据时标记源数据来自哪张表，则需要在代码中加入参数keys，例如表名分别为“1月”“2月”“3月”，合并后的效果如图4.49所示。</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051001176.png" alt="image-20211020051001176"></p>
<p>​                          图4.47　3张相同字段的表</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051019220.png" alt="image-20211020051019220"></p>
<p>​                                     图4.48　首尾相接合并后的效果</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051035379.png" alt="image-20211020051035379"></p>
<p>​                        图4.49　合并后带标记（月份）的效果<br>主要代码如下：</p>
<p>result = pd.concat(dfs, keys=[‘1月’, ‘2月’, ‘3月’])</p>
<h4 id="2．横向表合并（行对齐）"><a href="#2．横向表合并（行对齐）" class="headerlink" title="2．横向表合并（行对齐）"></a>2．横向表合并（行对齐）</h4><p>当合并的数据列名称不一致时，可以设置参数axis=1，concat()方法将按行对齐，然后将不同列名的两组数据进行合并，缺失的数据用NaN填充，df1和df4合并前后效果如图4.50和图4.51所示。</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051057217.png" alt="image-20211020051057217"></p>
<p>​                        图4.50　横向表合并前</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051113896.png" alt="image-20211020051113896"></p>
<p>​                            图4.51　横向表合并后<br>主要代码如下：</p>
<p>result = pd.concat([df1, df4], axis=1)</p>
<h4 id="3．交叉合并"><a href="#3．交叉合并" class="headerlink" title="3．交叉合并"></a>3．交叉合并</h4><p>交叉合并，需要在代码中加上join参数，如果值为inner，结果是两张表的交集；如果值为outer，结果是两张表的并集。例如两张表交集，表df1和df4合并前后的效果如图4.52和图4.53所示。</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051227829.png" alt="image-20211020051227829"></p>
<p>​                                   图4.52　交叉合并前</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051243654.png" alt="image-20211020051243654"></p>
<p>​                                       图4.53　交叉合并后<br>主要代码如下：</p>
<p>result = pd.concat([df1, df4], axis=1, join=’inner’)</p>
<h4 id="4．指定表对齐数据（行对齐）"><a href="#4．指定表对齐数据（行对齐）" class="headerlink" title="4．指定表对齐数据（行对齐）"></a>4．指定表对齐数据（行对齐）</h4><p>如果指定参数join_axes，就可以指定根据哪张表来对齐数据。例如，根据df4对齐数据，就会保留表df4的数据，然后将表df1的数据与之合并，行数不变，合并前后的效果与如图4.54和图4.55所示。</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051305083.png" alt="image-20211020051305083"></p>
<p>​                          图4.54　指定表对齐数据合并前</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051320918.png" alt="image-20211020051320918"></p>
<p>​                           图4.55　指定表对齐数据合并后<br>主要代码如下：</p>
<p>result = pd.concat([df1, df4], axis=1, join_axes=[df4.index])</p>
<h2 id="4-7-数据导出"><a href="#4-7-数据导出" class="headerlink" title="4.7　数据导出"></a>4.7　数据导出</h2><h3 id="4-7-1-导出为-xlsx文件"><a href="#4-7-1-导出为-xlsx文件" class="headerlink" title="4.7.1　导出为.xlsx文件"></a>4.7.1　导出为.xlsx文件</h3><p>导出数据为Excel，主要使用DataFrame对象的to_excel()方法，语法如下：</p>
<p>DataFrame.to_excel(excel_writer,sheet_name=’Sheet1’,na_rep=’’,float_format=None,columns=None,header=True,<br>index=True,index_label=None,startrow=0,startcol=0,engine=None,merge_cells=True, encoding=None, inf_rep=’inf’,<br>verbose=True, freeze_panes=None)<br>参数说明：　</p>
<p>excel_writer：字符串或ExcelWriter对象。　</p>
<p>sheet_name：字符串，默认值为Sheet1，包含DataFrame的表的名称。　</p>
<p>na_rep：字符串，默认值为’ ‘。缺失数据的表示方式。　</p>
<p>float_format：字符串，默认值为None，格式化浮点数的字符串。　</p>
<p>columns：序列，可选参数，要编辑的列。　</p>
<p>header：布尔型或字符串列表，默认值为True。列名称，如果给定字符串列表，则表示它是列名称的别名。　</p>
<p>index：布尔型，默认值为True，行名（索引）。　</p>
<p>index_label：字符串或序列，默认值为None。如果需要，可以使用索引列的列标签；如果没有给出，标题和索引为True，则使用索引名称；如果数据文件使用多索引，则需使用序列。</p>
<p>startrow：指定从哪一行开始写入数据。　</p>
<p>startcol：指定从哪一列开始写入数据。　</p>
<p>engine：字符串，默认值为None，指定要使用的写引擎，如openpyxl或xlsxwriter。也可以通过io.excel.xlsx.writer、io.excel.xls.writer和io.excel.xlsm.writer进行设置。　</p>
<p>merge_cells：布尔型，默认值为True。　</p>
<p>encoding：指定Excel文件的编码方式，默认值为None。　</p>
<p>inf_rep：字符串，默认值为“正”，表示无穷大。　</p>
<p>verbose：布尔型，默认值为True。在错误日志中显示更多信息。　freeze_panes：整数的元组，长度2，默认值为None。指定要冻结的行列。</p>
<p>【示例41】　将处理后的数据导出为Excel文件。（示例位置：资源包\MR\Code\04\41）<br>将数据合并后的结果导出为Excel文件，主要代码如下：</p>
<p>df_merge.to_excel(‘merge.xlsx’)<br>运行程序，数据将导出为Excel文件，如图4.56所示。</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051510137.png" alt="image-20211020051510137"></p>
<p>​                         图4.56　导出为Excel文件</p>
<p>上述举例，如果需要指定Sheet页名称，可以通过sheet_name参数指定，主要代码如下：</p>
<p>df1.to_excel(‘df1.xlsx’,sheet_name=’df1’)</p>
<h3 id="4-7-2-导出为-csv文件"><a href="#4-7-2-导出为-csv文件" class="headerlink" title="4.7.2　导出为.csv文件"></a>4.7.2　导出为.csv文件</h3><p>导出数据为.csv文件，主要使用DataFrame对象的to_csv()方法，语法如下：</p>
<p>DataFrame.to_csv(path_or_buf=None,sep=’,’,na_rep=’’,float_format=None,columns=None,header=True,index=<br>True,index_label=None,mode=’w’,encoding=None,compression=’infer’,quoting=None,quotechar=’”‘,line_terminator=<br>None,chunksize=None,date_format=None,doublequote=True, escapechar=None, decimal=’.’,errors=’strict’)<br>参数说明：　</p>
<p>path_or_buf：要保存的路径及文件名。　</p>
<p>sep：分隔符，默认值为”,”。　</p>
<p>na_rep：指定空值的输出方式，默认值为空字符串。　</p>
<p>float_format：浮点数的输出格式，要用双引号括起来。　</p>
<p>columns：指定要导出的列，用列名列表表示，默认值为None。　header：是否输出列名，默认值为True。　</p>
<p>index：是否输出索引，默认值为True。　</p>
<p>index_label：索引列的列名，默认值为None。　</p>
<p>mode：Python写入模式，默认值为w。　</p>
<p>encoding：编码方式，默认值为utf-8。　</p>
<p>compression：压缩模式，默认值为infer。　</p>
<p>quoting：导出.csv文件是否用引号，默认值为0，表示不加双引号；如果值为1，则每个字段都会加上引号，数值也会被当作字符串看待。</p>
<p>quotechar：引用字符，当quoting=1时可以指定引号字符为双引号（” “）或单引号（’ ‘）。　</p>
<p>line_terminator：换行符，默认值为\n。</p>
<p>chunksize：一次写入.csv文件的行数，当DataFrame对象数据特别大时需要分批写入。　</p>
<p>date_format：日期输出格式。　</p>
<p>doublequote：是否添加双引用符，默认值为True。　</p>
<p>escapechar：设置转义字符。　</p>
<p>decimal：可识别十进制分隔符的字符。　</p>
<p>errors：指定如何处理编码和解码错误，默认值为strict（严格的）。</p>
<p>【示例42】　将处理后的数据导出为.csv文件。（示例位置：资源包\MR\Code\04\42）<br>下面介绍to_csv()方法常用功能，举例如下，df为DataFrame对象。<br>（1）相对位置，保存在程序所在路径下，代码如下：</p>
<p>df.to_csv(‘Result.csv’)<br>（2）绝对位置，代码如下：</p>
<p>df.to_csv(‘d:\Result.csv’)<br>（3）分隔符。使用问号（？）分隔符分隔需要保存的数据，代码如下：</p>
<p>df.to_csv(‘Result.csv’,sep=’?’)``<br>（4）替换空值，缺失值保存为NA，代码如下：</p>
<p>df.to_csv(‘Result1.csv’,na_rep=’NA’)<br>（5）格式化数据，保留两位小数，代码如下：</p>
<p>df.to_csv(‘Result1.csv’,float_format=’%.2f’)<br>（6）保留某列数据，保存索引列和name列，代码如下：</p>
<p>df.to_csv(‘Result.csv’,columns=[‘name’])<br>（7）是否保留列名，不保留列名，代码如下：</p>
<p>df.to_csv(‘Result.csv’,header=False)<br>（8）是否保留行索引，不保留行索引，代码如下：</p>
<p>df.to_csv(‘Result.csv’,index=False)</p>
<h3 id="4-7-3-导出多个Sheet"><a href="#4-7-3-导出多个Sheet" class="headerlink" title="4.7.3　导出多个Sheet"></a>4.7.3　导出多个Sheet</h3><p>导出多个Sheet，应首先使用pd.ExcelWriter()方法打开一个Excel文件，然后再使用to_excel()方法导出指定的Sheet。</p>
<p>【示例43】　导出Excel中多个Sheet页的数据。（示例位置：资源包\MR\Code\04\43）<br>导出指定Sheet页中的数据，主要代码如下：</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051720411.png" alt="image-20211020051720411"></p>
<h2 id="4-8-日期数据处理"><a href="#4-8-日期数据处理" class="headerlink" title="4.8　日期数据处理"></a>4.8　日期数据处理</h2><h3 id="4-8-1-DataFrame的日期数据转换"><a href="#4-8-1-DataFrame的日期数据转换" class="headerlink" title="4.8.1　DataFrame的日期数据转换"></a>4.8.1　DataFrame的日期数据转换</h3><p>日常工作中，有一个非常麻烦的事情就是日期的格式可以有很多种表达，我们看到同样是2020年2月14日，可以有很多种格式，如图4.57所示。那么，我们需要先将这些格式统一后才能进行后续的工作。Pandas提供了to_datetime()方法可以帮助我们解决这一问题。<br>to_datetime()方法可以用来批量处理日期数据转换，对于处理大数据非常实用和方便，它可以将日期数据转换成你需要的各种格式。例如，将2/14/20和14-2-2020转换为日期格式2020-02-14。to_datetime()方法的语法如下：</p>
<p>pandas.to_datetime(arg,errors=’ignore’,dayfirst=False,yearfirst=False,utc=None,box=True,format=None,exact=<br>True,unit=None,infer_datetime_format=False,origin=’unix’,cache=False)<br>参数说明：　</p>
<p>arg：字符串、日期时间、字符串数组。　</p>
<p>errors：值为ignore、raise或coerce，具体说明如下，默认值为ignore，即忽略错误。　</p>
<p>ignore：无效的解析将返回原值。　</p>
<p>raise：无效的解析将引发异常。　</p>
<p>coerce：无效的解析将被设置为NaT，即无法转换为日期的数据将被转换为NaT。　</p>
<p>dayfirst：第一个为天，布尔型，默认值为False。例如02/09/2020，如果值为True，则解析日期的第一个为天，即2020-09-02；如果值为False，则解析日期与原日期一致，即2020-02-09。　</p>
<p>yearfirst：第一个为年，布尔型，默认值为False。例如14-Feb-20，如果值为True，则解析日期的第一个为年，即2014-02-20；如果值为False，则解析日期与原日期一致，即2020-02-14。　</p>
<p>utc：默认值为None。返回utc即协调世界时间。　</p>
<p>box：布尔值，默认值为True，如果值为True，则返回DatetimeIndex；如果值为False，则返回ndarray。　</p>
<p>format：格式化显示时间的格式。字符串，默认值为None。　</p>
<p>exact：布尔值，默认值为True。如果为True，则要求格式完全匹配；如果为False，则允许格式与目标字符串中的任何位置匹配。　</p>
<p>unit：默认值为None，参数的单位（D、s、、ms、μs、ns）表示时间的单位。　</p>
<p>infer_datetime_format：默认值为False。如果没有格式，则尝试根据第一个日期时间字符串推断格式。　</p>
<p>origin：默认值为unix。定义参考日期。数值将被解析为单位数。　</p>
<p>cache：默认值为False。如果值为True，则使用唯一、转换日期的缓存应用日期时间转换。在解析重复日期字符串，特别是带有时区偏移的字符串时，可能会产生明显的加速。只有在至少有50个值时才使用缓存。越界值的存在将使缓存不可用，并可能减慢解析速度。　</p>
<p>返回值：日期时间。</p>
<p>【示例44】　将各种日期字符串转换为指定的日期格式。（示例位置：资源包\MR\Code\04\44）<br>将2020年2月14日的各种格式转换为日期格式，程序代码如下：</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051913944.png" alt="image-20211020051913944"></p>
<p>运行程序，控制台输出结果如图4.58所示。</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051928130.png" alt="image-20211020051928130"></p>
<p>​                   图4.57　日期的多种格式转换</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051944812.png" alt="image-20211020051944812"></p>
<p>​                 图4.58　2020年2月14日的各种格式转换为日期格式<br>还可以实现从DataFrame对象中的多列，如年、月、日各列组合成一列日期。键值是常用的日期缩略语。</p>
<p>组合要求：　</p>
<p>必选：year、month、day。　</p>
<p>可选：hour、minute、second、millisecond（毫秒）、microsecond（微秒）、nanosecond（纳秒）。</p>
<p>【示例45】　将一组数据组合为日期数据。（示例位置：资源包\MR\Code\04\45）<br>将一组数据组合为日期数据，主要代码如下：</p>
<p>运行程序，控制台输出结果如图4.59所示。</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020052022697.png" alt="image-20211020052022697"></p>
<p>​                                        图4.59　日期组合</p>
<h3 id="4-8-2-dt对象的使用"><a href="#4-8-2-dt对象的使用" class="headerlink" title="4.8.2　dt对象的使用"></a>4.8.2　dt对象的使用</h3><p>dt对象是Series对象中用于获取日期属性的一个访问器对象，通过它可以获取日期中的年、月、日、星期数、季节等，还可以判断日期是否处在年底。语法如下：</p>
<p>  Series.dt()<br>参数说明：　</p>
<p>返回值：返回与原始系列相同的索引系列。如果Series不包含类日期值，则引发错误。　</p>
<p>dt对象提供了year、month、day、dayofweek、dayofyear、is_leap_year、quarter、weekday_name等属性和方法。</p>
<p>例如，year可以获取“年”、month可以获取“月”、quarter可以直接得到每个日期分别是第几个季度，weekday_name可以直接得到每个日期对应的是周几。</p>
<p>【示例46】　获取日期中的年、月、日、星期数等。（示例位置：资源包\MR\Code\04\46）<br>使用dt对象获取日期中的年、月、日、星期数、季节等。<br>（1）获取年、月、日，代码如下：</p>
<p>df[‘年’],df[‘月’],df[‘日’]=df[‘日期’].dt.year,df[‘日期’].dt.month,df[‘日期’].dt.day<br>（2）从日期判断出所处星期数，代码如下：</p>
<p>df[‘星期几’]=df[‘日期’].dt.day_name()<br>（3）从日期判断所处季度，代码如下：</p>
<p>df[‘季度’]=df[‘日期’].dt.quarter<br>（4）从日期判断是否为年底最后一天，代码如下：</p>
<p>df[‘是否年底’]=df[‘日期’].dt.is_year_end<br>运行程序，控制台输出结果如图4.60所示。</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020052128703.png" alt="image-20211020052128703"></p>
<p>​                               图4.60　dt对象日期转换</p>
<h3 id="4-8-3-获取日期区间的数据"><a href="#4-8-3-获取日期区间的数据" class="headerlink" title="4.8.3　获取日期区间的数据"></a>4.8.3　获取日期区间的数据</h3><p>获取日期区间的数据的方法是直接在DataFrame对象中输入日期或日期区间，但前提必须设置日期为索引，举例如下。　</p>
<p>获取2018年的数据。</p>
<p>df1[‘2018’]　</p>
<p>获取2017—2018年的数据。</p>
<p>df1[‘2017’:’2018’]　</p>
<p>获取某月（2018年7月）的数据。</p>
<p>df1[‘2018-07’]　</p>
<p>获取具体某天（2018年5月6日）的数据。</p>
<p>df1[‘2018-05-06’:’2018-05-06’]</p>
<p>【示例47】　获取指定日期区间的订单数据。（示例位置：资源包\MR\Code\04\47）<br>获取2018年5月11日至6月10日的订单，结果如图4.61所示。<br>程序代码如下：</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020052236563.png" alt="image-20211020052236563"></p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020052256160.png" alt="image-20211020052256160"></p>
<p>​            图4.61　2018年5月11日至6月10日的订单（省略部分数据）</p>
<h3 id="4-8-4-按不同时期统计并显示数据"><a href="#4-8-4-按不同时期统计并显示数据" class="headerlink" title="4.8.4　按不同时期统计并显示数据"></a>4.8.4　按不同时期统计并显示数据</h3><h4 id="1．按时期统计数据"><a href="#1．按时期统计数据" class="headerlink" title="1．按时期统计数据"></a>1．按时期统计数据</h4><p>按时期统计数据主要通过DataFrame对象的resample()方法结合数据计算函数实现。resample()方法主要应用于时间序列频率转换和重采样，它可以从日期中获取年、月、日、星期、季节等，结合数据计算函数就可以实现按年、月、日、星期或季度等不同时期统计数据。举例如下所示。<br>（1）按年统计数据，代码如下：</p>
<p>df1=df1.resample(‘AS’).sum()<br>（2）按季度统计数据，代码如下：</p>
<p>df2.resample(‘Q’).sum()<br>（3）按月度统计数据，代码如下：</p>
<p>df1.resample(‘M’).sum()<br>（4）按星期统计数据，代码如下：</p>
<p>df1.resample(‘W’).sum()<br>（5）按天统计数据，代码如下：</p>
<p>df1.resample(‘D’).sum()</p>
<p>实用技巧<br>按日期统计数据过程中，可能会出现如图4.62所示的错误提示。</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020052356675.png" alt="image-20211020052356675"></p>
<p>图4.62　错误提示</p>
<p>完整错误描述：<br>TypeError: Only valid with DatetimeIndex, TimedeltaIndex or PeriodIndex, but got an instance of’Index’<br>出现上述错误，是由于<strong>resample()函数要求索引必须为日期型</strong>。<br>解决方法：将数据的索引转换为datetime类型，主要代码如下：</p>
<p>df1.index = pd.to_datetime(df1.index)</p>
<h4 id="2．按时期显示数据"><a href="#2．按时期显示数据" class="headerlink" title="2．按时期显示数据"></a>2．按时期显示数据</h4><p>DataFrame对象的to_period()方法可以将时间戳转换为时期，从而实现按时期显示数据，前提是日期必须设置为索引。语法如下：</p>
<p>DataFrame.to_period(freq=None, axis=0, copy=True)<br>参数说明：　</p>
<p>freq：字符串，周期索引的频率，默认值为None。　</p>
<p>axis：行列索引，axis=0表示行索引，axis=1表示列索引。默认值为0，即表示行索引。　</p>
<p>copy：是否复制数据，默认值为True，如果值为False，则不复制数据。　返回值：带周期索引的时间序列。</p>
<p>【示例48】　从日期中获取不同的时期。（示例位置：资源包\MR\Code\04\48）<br>从日期中获取不同的时期，主要代码如下：</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020052452293.png" alt="image-20211020052452293"></p>
<h4 id="3．按时期统计并显示数据"><a href="#3．按时期统计并显示数据" class="headerlink" title="3．按时期统计并显示数据"></a>3．按时期统计并显示数据</h4><p>（1）按年统计并显示数据，代码如下：</p>
<p>df2.resample(‘AS’).sum().to_period(‘A’)<br>控制台输出结果如图4.63所示。<br>（2）按季度统计并显示数据，代码如下：</p>
<p>Q_df=df2.resample(‘Q’).sum().to_period(‘Q’)</p>
<p>控制台输出结果如图4.64所示。</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020052536700.png" alt="image-20211020052536700"></p>
<p>​                            图4.63　按年统计并显示数据</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020052550813.png" alt="image-20211020052550813"></p>
<p>​                      图4.64　按季度统计并显示数据<br>（3）按月统计并显示数据，代码如下：</p>
<p>df2.resample(‘M’).sum().to_period(‘M’)<br>控制台输出结果如图4.65所示。<br>（4）按星期统计并显示数据（前5条数据），代码如下：</p>
<p>df2.resample(‘W’).sum().to_period(‘W’).head()<br>控制台输出结果如图4.66所示。</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020052622774.png" alt="image-20211020052622774"></p>
<p>​                          图4.65　按月统计并显示数据</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020052640893.png" alt="image-20211020052640893"></p>
<p>​                      图4.66　按星期统计并显示数据</p>
<h2 id="4-9-时间序列"><a href="#4-9-时间序列" class="headerlink" title="4.9　时间序列"></a>4.9　时间序列</h2><h3 id="4-9-1-重采样（Resample-方法）"><a href="#4-9-1-重采样（Resample-方法）" class="headerlink" title="4.9.1　重采样（Resample()方法）"></a>4.9.1　重采样（Resample()方法）</h3><p>通过前面的学习，我们学会了如何生成不同频率的时间索引，按小时、按天、按周、按月等，如果想对数据做不同频率的转换，该怎么办？在Pandas中对时间序列的频率的调整称为重新采样，即将时间序列从一个频率转换到另一个频率的处理过程。例如，每天一个频率转换为每5天一个频率，如图4.67所示。</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020052720517.png" alt="image-20211020052720517"></p>
<p>​                                       图4.67　时间频率<br>重采样主要使用resample()方法，该方法用于对常规时间序列重新采样和频率转换，包括降采样和升采样两种。首先了解下resample()方法，语法如下：</p>
<p>DataFrame.resample(rule,how=None,axis=0,fill_method=None,closed=None,label=None,convention=’start’,kind=<br>None,loffset=None,limit=None,base=0,on=None,level=None)<br>参数说明：　</p>
<p>rule：字符串，偏移量表示目标字符串或对象转换。　</p>
<p>how：用于产生聚合值的函数名或数组函数。例如mean、ohlc和np.max等，默认值为mean，其他常用的值为first、last、median、max和min。　</p>
<p>axis：整型，表示行列，axis=0表示列，axis=1表示行。默认值为0，即表示列。　fill_method：升采样时所使用的填充方法，ffill()方法（用前值填充）或bfill()方法（用后值填充），默认值为None。　</p>
<p>closed：降采样时，时间区间的开和闭，与数学里区间的概念一样，其值为right或left，right表示左开右闭（即左边值不包括在内），left表示左闭右开（即右边值不包括在内），默认值为right左开右闭。　</p>
<p>label：降采样时，如何设置聚合值的标签。例如，10:30—10:35会被标记成10:30还是10:35，默认值为None。　</p>
<p>convention：当重采样时，将低频率转换到高频率所采用的约定，其值为start或end，默认值为start。　</p>
<p>kind：聚合到时期（period）或时间戳（timestamp），默认聚合到时间序列的索引类型，默认值为None。　</p>
<p>loffset：聚合标签的时间校正值，默认值为None。例如，-1s或Second(-1)用于将聚合标签调早1秒。　</p>
<p>limit：向前或向后填充时，允许填充的最大时期数，默认值为None。</p>
<p>　base：整型，默认值为0。对于均匀细分1天的频率，聚合间隔的“原点”。例如，对于5min频率，base的范围可以是0～4。　on：字符串，可选参数，默认值为None。对DataFrame对象使用列代替索引进行重新采样。列必须与日期时间类似。　</p>
<p>level：字符串或整型，可选参数，默认值为None。用于多索引，重新采样的级别名称或级别编号，级别必须与日期时间类似。　</p>
<p>返回值：重新采样对象。</p>
<p>【示例49】　一分钟的时间序列转换为3分钟的时间序列。（示例位置：资源包\MR\Code\04\49）<br>首先创建一个包含9个一分钟的时间序列，然后使用resample()方法转换为3分钟的时间序列，并对索引列进行求和计算，如图4.68所示。</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020052840027.png" alt="image-20211020052840027"></p>
<p>​                          图4.68　时间序列转换</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211106103741281.png" alt="image-20211106103741281">程序代码如下：</p>
<p>01  import pandas as pd<br>02  index = pd.date_range(‘02/02/2020’, periods=9, freq=’T’)</p>
<p>03  series = pd.Series(range(9), index=index)<br>04  print(series)<br>05  print(series.resample(‘3T’).sum())</p>
<h3 id="4-9-2-降采样处理"><a href="#4-9-2-降采样处理" class="headerlink" title="4.9.2　降采样处理"></a>4.9.2　降采样处理</h3><p>降采样是周期由高频率转向低频率。例如，将5min股票交易数据转换为日交易，按天统计的销售数据转换为按周统计。<br>数据降采样会涉及数据的聚合。例如，天数据变成周数据，那么就要对1周7天的数据进行聚合，聚合的方式主要包括求和、求均值等。例如，淘宝店铺每天销售数据（部分数据），如图4.69所示。</p>
<p>【示例50】　按周统计销售数据。（示例位置：资源包\MR\Code\04\50）<br>使用resample()方法来做降采样处理，频率为“周”，也就是将上述销售数据处理为每周（每7天）求和一次数据，程序代码如下：</p>
<p>01 import pandas as pd<br>02 df=pd.read_excel(‘time.xls’)<br>03 df1 = df.set_index(‘订单付款时间’)  #设置“订单付款时间”为索引<br>04 print(df1.resample(‘W’).sum().head())<br>运行程序，控制台输出结果如图4.70所示。<br>在参数说明中，我们列出了closed参数的解释，如果把closed参数值设置为left，结果如图4.71所示。</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020052938423.png" alt="image-20211020052938423"></p>
<p>​              图4.69　淘宝店铺每天销售数据（部分数据）</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020053019859.png" alt="image-20211020053019859"></p>
<p>​                                       图4.70　周数据统计1</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020053036196.png" alt="image-20211020053036196"></p>
<p>​                              图4.71　周数据统计2</p>
<h3 id="4-9-3-升采样处理"><a href="#4-9-3-升采样处理" class="headerlink" title="4.9.3　升采样处理"></a>4.9.3　升采样处理</h3><p>​    升采样是周期由低频率转向高频率。将数据从低频率转换到高频率时，就不需要聚合了，将其重采样到日频率，默认会引入缺失值。<br>例如，原来是按周统计的数据，现在变成按天统计。升采样会涉及数据的填充，根据填充的方法不同，填充的数据也不同。下面介绍3种填充方法。　不填充。空值用NaN代替，使用asfreq()方法。　用前值填充。用前面的值填充空值，使用ffill()方法或者pad()方法。为了方便记忆，ffill()方法可以使用它的第一个字母“f”代替，代表forward，向前的意思。　用后值填充，使用bfill()方法，可以使用字母“b”代替，代表back，向后的意思。</p>
<p>【示例51】　每6小时统计一次数据。（示例位置：资源包\MR\Code\04\51）<br>下面创建一个时间序列，起始日期是2020-02-02，一共两天，每天对应的数值分别是1和2，通过升采样处理为每6小时统计一次数据，空值以不同的方式填充，程序代码如下：</p>
<p>01  import pandas as pd<br>02  import numpy as np<br>03  rng = pd.date_range(‘20200202’, periods=2)<br>05  s1_6h_asfreq = s1.resample(‘6H’).asfreq()</p>
<p>06  print(s1_6h_asfreq)<br>07  s1_6h_pad = s1.resample(‘6H’).pad()<br>08  print(s1_6h_pad)<br>09  s1_6h_ffill = s1.resample(‘6H’).ffill()<br>10  print(s1_6h_ffill)<br>11  s1_6h_bfill = s1.resample(‘6H’).bfill()<br>12  print(s1_6h_bfill)<br>运行程序，控制台输出结果如图4.72所示。</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020053124798.png" alt="image-20211020053124798"></p>
<p>​                          图4.72　6小时数据统计</p>
<h3 id="4-9-4-时间序列数据汇总（ohlc-函数）"><a href="#4-9-4-时间序列数据汇总（ohlc-函数）" class="headerlink" title="4.9.4　时间序列数据汇总（ohlc()函数）"></a>4.9.4　时间序列数据汇总（ohlc()函数）</h3><p>在金融领域，经常会看到开盘（open）、收盘（close）、最高价（high）和最低价（low）数据，而在Pandas中经过重新采样的数据也可以实现这样的结果，通过调用ohlc()函数得到数据汇总结果，即开始值（open）、结束值（close）、最高值（high）和最低值（low）。ohlc()函数的语法如下：</p>
<p>resample.ohlc()<br>ohlc()函数返回DataFrame对象，每组数据的open（开）、high（高）、low（低）和close（关）值。</p>
<p>【示例52】　统计数据的open、high、low和close值。（示例位置：资源包\MR\Code\04\52）<br>下面是一组5分钟的时间序列，通过ohlc()函数获取该时间序列中每组时间的开始值、最高值、最低值和结束值，程序代码如下：</p>
<p>01  import pandas as pd<br>02  import numpy as np<br>03  rng = pd.date_range(‘2/2/2020’,periods=12,freq=’T’)<br>04  s1 = pd.Series(np.arange(12),index=rng)<br>05  print(s1.resample(‘5min’).ohlc())<br>运行程序，控制台输出结果如图4.73所示。</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020053212045.png" alt="image-20211020053212045"></p>
<p>​                          图4.73　时间序列数据汇总</p>
<h3 id="4-9-5-移动窗口数据计算（rolling-函数）"><a href="#4-9-5-移动窗口数据计算（rolling-函数）" class="headerlink" title="4.9.5　移动窗口数据计算（rolling()函数）"></a>4.9.5　移动窗口数据计算（rolling()函数）</h3><p>通过重采样可以得到想要的任何频率的数据，但是这些数据也是一个时点的数据，那么就存在这样一个问题：时点的数据波动较大，某一点的数据就不能很好地表现它本身的特性，于是就有了“移动窗口”的概念，简单地说，为了提升数据的可靠性，将某个点的取值扩大到包含这个点的一段区间，用区间来进行判断，这个区间就是窗口。<br>下面举例说明，图4.74显示了移动窗口数据示意图，其中时间序列代表1号到15号每天的销量数据，接下来以3天为一个窗口，将该窗口从左至右依次移动，统计出3天的平均值作为这个点的值，如3号的销量是1号、2号和3号的平均值。</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020053234231.png" alt="image-20211020053234231"></p>
<p>​                      图4.74　移动窗口数据示意图<br>通过上述示意图相信您已经理解了移动窗口，在Pandas中可以通过rolling()函数实现移动窗口数据的计算，语法如下：</p>
<p>DataFrame.rolling(window, min_periods=None, center=False, win_type=None, on=None, axis=0, closed=None)</p>
<p>参数说明：　</p>
<p>window：时间窗口的大小，有两种形式，即int或offset。如果使用int，则数值表示计算统计量的观测值的数量，即向前几个数据；如果使用offset，则表示时间窗口的大小。　</p>
<p>min_periods：每个窗口最少包含的观测值数量，小于这个值的窗口结果为NA。值可以是int，默认值为None。offset情况下，默认值为1。</p>
<p>center：把窗口的标签设置为居中。布尔型，默认值为False，居右。</p>
<p>win_type：窗口的类型。截取窗的各种函数。字符串类型，默认值为None。　</p>
<p>on：可选参数。对于DataFrame对象，是指定要计算移动窗口的列，值为列名。　</p>
<p>axis：整型，axis=0表示列，axis=1表示行。默认值为0，即对列进行计算。　</p>
<p>closed：定义区间的开闭，支持int类型的窗口。对于offset类型默认是左开右闭（默认值为right）。可以根据情况指定left。　</p>
<p>返回值：为特定操作而生成的窗口或移动窗口子类。</p>
<p>【示例53】　创建淘宝每日销量数据。（示例位置：资源包\MR\Code\04\53）<br>首先创建一组淘宝每日销量数据，程序代码如下：</p>
<p>01  import pandas as pd<br>02  index=pd.date_range(‘20200201’,’20200215’)<br>03  data=[3,6,7,4,2,1,3,8,9,10,12,15,13,22,14]<br>04  s1_data=pd.Series(data,index=index)<br>05  print(s1_data)<br>运行程序，控制台输出结果如图4.75所示。</p>
<p>【示例54】　使用rolling()函数计算3天的均值。（示例位置：资源包\MR\Code\04\54）</p>
<p>下面使用rolling()函数计算2020-02-01至2020-02-15中每3天的均值，窗口个数为3，代码如下：</p>
<p>s1_data.rolling(3).mean()<br>运行程序，看下rolling()函数是如何计算的？在图4.76中，当窗口开始移动时，第一个时间点2020-02-01和第二个时间点2020-02-02的数值为空，这是因为窗口个数为3，它们前面有空数据，所以均值为空；而到第三个时间点2020-02-03时，它前面的数据是2020-02-01至2020-02-03，所以3天的均值是5.333333；以此类推。</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020053403924.png" alt="image-20211020053403924"></p>
<p>​                                     图4.75　原始数据</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020053419587.png" alt="image-20211020053419587"></p>
<p>​                       图4.76　2020-02-01至2020-02-15移动窗口均值1</p>
<p>【示例55】　用当天的数据代表窗口数据。（示例位置：资源包\MR\Code\04\55）<br>在计算第一个时间点2020-02-01的窗口数据时，虽然数据不够窗口长度3，但是至少有当天的数据，那么能否用当天的数据代表窗口数据呢？答案是肯定的，通过设置min_periods参数即可，它表示窗口最少包含的观测值，小于这个值的窗口长度显示为空，等于或大于时都有值，主要代码如下：</p>
<p>s1_data.rolling(3,min_periods=1).mean()</p>
<p>运行程序，对比效果如图4.77所示。<br>上述举例，我们再扩展下，通过图表观察原始数据与移动窗口数据的平稳性，如图4.78所示。其中实线代表移动窗口数据，其走向更平稳，这也是学习移动窗口rolling()函数的原因。</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020053518298.png" alt="image-20211020053518298"></p>
<p>​                 图4.77　2020-02-01至2020-02-15移动窗口均值2</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020053531782.png" alt="image-20211020053531782"></p>
<p>​                     图4.78　移动窗口数据的平稳性说明<br>虚线代表原始数据，实线代表移动窗口数据。</p>
<h2 id="4-10-综合应用"><a href="#4-10-综合应用" class="headerlink" title="4.10　综合应用"></a>4.10　综合应用</h2><h3 id="4-10-1-案例1：Excel多表合并"><a href="#4-10-1-案例1：Excel多表合并" class="headerlink" title="4.10.1　案例1：Excel多表合并"></a>4.10.1　案例1：Excel多表合并</h3><p>案例位置：资源包\MR\Code\04\example\01<br>在日常工作中，几乎我们每天都有大量的数据需要处理，桌面上总是布满密密麻麻的Excel表，这样看上去非常凌乱，其实我们完全可以将其中类别相同的Excel表合并到一起，这样不但不会丢失数据，而且还可以有效地分析数据。下面使用concat()方法将指定文件夹内的所有Excel表合并，程序代码如下：</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020053607260.png" alt="image-20211020053607260"></p>
<h3 id="4-10-2-案例2：股票行情数据分析"><a href="#4-10-2-案例2：股票行情数据分析" class="headerlink" title="4.10.2　案例2：股票行情数据分析"></a>4.10.2　案例2：股票行情数据分析</h3><p>案例位置：资源包\MR\Code\04\example\02<br>股票数据包括开盘价、收盘价、最高价、最低价、成交量等多个指标。其中，收盘价是当日行情的标准，也是下一个交易日开盘价的依据，可以预测未来证券市场行情，因此当投资者对行情分析时，一般采用收盘价作为计算依据。<br>下面使用rolling()函数计算某股票20天、50天和200天的收盘价均值并生成走势图（也称K线图），如图4.79所示。</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020053723586.png" alt="image-20211020053723586"></p>
<p>​                                       图4.79　股票行情分析</p>
<p>程序代码如下：</p>
<p><img src="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020053800663.png" alt="image-20211020053800663"></p>
<p>实用技巧<br>默认情况下，图表嵌入控制台（IPython console）中并以静态方式显示，无法进行移动、放大、缩小等操作。此时需要在工具中的首选项窗口进行设置，方法为选择Tools→Preferences命令，打开Preferences（首选项）窗口，在左侧列表中选择IPython console（IPython控制台），在右侧窗口选择Graphics（图形）选项卡，然后在Backend（后端）下拉列表框中选择Automatic（自动）或者Qt5，单击Apply（应用）按钮。设置完成后重新启动Spyder才生效。</p>
<h2 id="4-11-小结"><a href="#4-11-小结" class="headerlink" title="4.11　小结"></a>4.11　小结</h2><p>本章是Pandas的进阶学习，有一定难度，但同时也更能够体现Pandas的强大之处，不仅可以完成数据处理工作，而且还能够实现数据的统计分析。Pandas提供的大量函数使统计分析工作变得简单高效。别具特色的“数据位移”是一个非常有用的方法，与其他方法结合，能够实现很多难以想象的功能，数据转换将DataFrame与Python数据类型之间进行灵活转换。不仅如此，对于日期数据的处理、时间序列也都提供了专门的函数和方法，使得量化数据得心应手。</p>
<pre><code class="python">import pymysql
from sqlalchemy import create_engine
import pandas as pd
engine = create_engine(&#39;mysql+pymysql://root:123456@127.0.0.1:3306/2013a&#39;)
sql2=&#39;select * from stu;&#39;
df2=pd.read_excel(&#39;费用.xlsx&#39;)
df2.to_sql(&#39;feiyong&#39;,engine) # 存入数据库
df_read1=pd.read_sql_query(sql2,engine) # 读出数据
</code></pre>

  </div>
  <!--文末结束语-->
  
    <div style="text-align:center;color: #ccc;font-size:24px;"> --- 本文结束 <i class="iconfont icon-heartbeat" style="font-size:24px;"></i> The End --- </div>
  
  <!--页脚广告-->
  
  <div class="mdui-divider"></div>
  
  <nav>
    
      <a rel="prev" class="post-nav-item mdui-float-left" href="/2020/12/09/%E5%9B%BE%E8%A7%A3%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97NumPy/">
        <i class="iconfont icon-angle-left"></i>
        <span>图解数组计算模块NumPy</span>
      </a>
    
    
      <a rel="next" class="post-nav-item mdui-float-right" href="/2020/12/09/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/">
        <span>Python数据分析从入门到精通</span>
        <i class="iconfont icon-angle-right"></i>
      </a>
    
  </nav>
</article>




  <div class="toc-button"  style="z-index: 100;">
    <button class="mdui-fab mdui-ripple mdui-color-teal" mdui-menu="{target: '#toc'}"><i class="iconfont icon-list"></i></button>
    <ul class="mdui-menu" id="toc">
      <li class="mdui-menu-item">
        <a href="/2020/12/09/pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/" id="toc-header" class="mdui-ripple">文章目录</a>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E6%95%B0%E6%8D%AE%E8%AE%A1%E7%AE%97"><span class="toc-number">1.</span> <span class="toc-text">4.1 数据计算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1%E6%B1%82%E5%92%8C%E5%87%BD%E6%95%B0%EF%BC%88sum"><span class="toc-number">1.1.</span> <span class="toc-text">4.1.1求和函数（sum())</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-2-%E6%B1%82%E5%9D%87%E5%80%BC%EF%BC%88mean-%E5%87%BD%E6%95%B0%EF%BC%89"><span class="toc-number">1.2.</span> <span class="toc-text">4.1.2　求均值（mean()函数）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-3-%E6%B1%82%E6%9C%80%E5%A4%A7%E5%80%BC%EF%BC%88max-%E5%87%BD%E6%95%B0%EF%BC%89"><span class="toc-number">1.3.</span> <span class="toc-text">4.1.3　求最大值（max()函数）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-5-%E6%B1%82%E4%B8%AD%E4%BD%8D%E6%95%B0%EF%BC%88median-%E5%87%BD%E6%95%B0%EF%BC%89"><span class="toc-number">1.4.</span> <span class="toc-text">4.1.5　求中位数（median()函数）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-6-%E6%B1%82%E4%BC%97%E6%95%B0%EF%BC%88mode-%E5%87%BD%E6%95%B0%EF%BC%89"><span class="toc-number">1.5.</span> <span class="toc-text">4.1.6　求众数（mode()函数）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-7-%E6%B1%82%E6%96%B9%E5%B7%AE%EF%BC%88var-%E5%87%BD%E6%95%B0%EF%BC%89"><span class="toc-number">1.6.</span> <span class="toc-text">4.1.7　求方差（var()函数）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-8-%E6%A0%87%E5%87%86%E5%B7%AE%EF%BC%88%E6%95%B0%E6%8D%AE%E6%A0%87%E5%87%86%E5%8C%96std-%E5%87%BD%E6%95%B0%EF%BC%89"><span class="toc-number">1.7.</span> <span class="toc-text">4.1.8　标准差（数据标准化std()函数）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-9-%E6%B1%82%E5%88%86%E4%BD%8D%E6%95%B0%EF%BC%88quantile-%E5%87%BD%E6%95%B0%EF%BC%89"><span class="toc-number">1.8.</span> <span class="toc-text">4.1.9　求分位数（quantile()函数）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="toc-number">2.</span> <span class="toc-text">4.2　数据格式化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-%E8%AE%BE%E7%BD%AE%E5%B0%8F%E6%95%B0%E4%BD%8D%E6%95%B0"><span class="toc-number">2.1.</span> <span class="toc-text">4.2.1　设置小数位数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-%E8%AE%BE%E7%BD%AE%E7%99%BE%E5%88%86%E6%AF%94"><span class="toc-number">2.2.</span> <span class="toc-text">4.2.2　设置百分比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-3-%E8%AE%BE%E7%BD%AE%E5%8D%83%E4%BD%8D%E5%88%86%E9%9A%94%E7%AC%A6"><span class="toc-number">2.3.</span> <span class="toc-text">4.2.3　设置千位分隔符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E6%95%B0%E6%8D%AE%E5%88%86%E7%BB%84%E7%BB%9F%E8%AE%A1"><span class="toc-number">3.</span> <span class="toc-text">4.3　数据分组统计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-1-%E5%88%86%E7%BB%84%E7%BB%9F%E8%AE%A1groupby-%E5%87%BD%E6%95%B0"><span class="toc-number">3.1.</span> <span class="toc-text">4.3.1　分组统计groupby()函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%8E%E6%8C%89%E7%85%A7%E4%B8%80%E5%88%97%E5%88%86%E7%BB%84%E7%BB%9F%E8%AE%A1"><span class="toc-number">3.1.1.</span> <span class="toc-text">1．按照一列分组统计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%8E%E6%8C%89%E7%85%A7%E5%A4%9A%E5%88%97%E5%88%86%E7%BB%84%E7%BB%9F%E8%AE%A1"><span class="toc-number">3.1.2.</span> <span class="toc-text">2．按照多列分组统计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%8E%E5%88%86%E7%BB%84%E5%B9%B6%E6%8C%89%E6%8C%87%E5%AE%9A%E5%88%97%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E8%AE%A1%E7%AE%97"><span class="toc-number">3.1.3.</span> <span class="toc-text">3．分组并按指定列进行数据计算</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-2-%E5%AF%B9%E5%88%86%E7%BB%84%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E8%BF%AD%E4%BB%A3"><span class="toc-number">3.2.</span> <span class="toc-text">4.3.2　对分组数据进行迭代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-3-%E5%AF%B9%E5%88%86%E7%BB%84%E7%9A%84%E6%9F%90%E5%88%97%E6%88%96%E5%A4%9A%E5%88%97%E4%BD%BF%E7%94%A8%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0%EF%BC%88agg-%E5%87%BD%E6%95%B0%EF%BC%89"><span class="toc-number">3.3.</span> <span class="toc-text">4.3.3　对分组的某列或多列使用聚合函数（agg()函数）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-4-%E9%80%9A%E8%BF%87%E5%AD%97%E5%85%B8%E5%92%8CSeries%E5%AF%B9%E8%B1%A1%E8%BF%9B%E8%A1%8C%E5%88%86%E7%BB%84%E7%BB%9F%E8%AE%A1"><span class="toc-number">3.4.</span> <span class="toc-text">4.3.4　通过字典和Series对象进行分组统计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%8E%E9%80%9A%E8%BF%87%E5%AD%97%E5%85%B8%E8%BF%9B%E8%A1%8C%E5%88%86%E7%BB%84%E7%BB%9F%E8%AE%A1"><span class="toc-number">3.4.1.</span> <span class="toc-text">1．通过字典进行分组统计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%8E%E9%80%9A%E8%BF%87Series%E5%AF%B9%E8%B1%A1%E8%BF%9B%E8%A1%8C%E5%88%86%E7%BB%84%E7%BB%9F%E8%AE%A1"><span class="toc-number">3.4.2.</span> <span class="toc-text">2．通过Series对象进行分组统计</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E6%95%B0%E6%8D%AE%E7%A7%BB%E4%BD%8D"><span class="toc-number">4.</span> <span class="toc-text">4.4　数据移位</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2"><span class="toc-number">5.</span> <span class="toc-text">4.5　数据转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-1-%E4%B8%80%E5%88%97%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%A4%9A%E5%88%97%E6%95%B0%E6%8D%AE"><span class="toc-number">5.1.</span> <span class="toc-text">4.5.1　一列数据转换为多列数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%8Esplit-%E6%96%B9%E6%B3%95"><span class="toc-number">5.1.1.</span> <span class="toc-text">1．split()方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%8Ejoin-%E6%96%B9%E6%B3%95%E4%B8%8Esplit-%E6%96%B9%E6%B3%95%E7%BB%93%E5%90%88"><span class="toc-number">5.1.2.</span> <span class="toc-text">2．join()方法与split()方法结合</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-2-%E8%A1%8C%E5%88%97%E8%BD%AC%E6%8D%A2"><span class="toc-number">5.2.</span> <span class="toc-text">4.5.2　行列转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%8Estack-%E6%96%B9%E6%B3%95"><span class="toc-number">5.2.1.</span> <span class="toc-text">1．stack()方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%8Eunstack-%E6%96%B9%E6%B3%95"><span class="toc-number">5.2.2.</span> <span class="toc-text">2．unstack()方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%8Epivot-%E6%96%B9%E6%B3%95"><span class="toc-number">5.2.3.</span> <span class="toc-text">3．pivot()方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-3-DataFrame%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%AD%97%E5%85%B8"><span class="toc-number">5.3.</span> <span class="toc-text">4.5.3　DataFrame转换为字典</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-4-DataFrame%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%88%97%E8%A1%A8"><span class="toc-number">5.4.</span> <span class="toc-text">4.5.4　DataFrame转换为列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-5-DataFrame%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%85%83%E7%BB%84"><span class="toc-number">5.5.</span> <span class="toc-text">4.5.5　DataFrame转换为元组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-6-Excel%E8%BD%AC%E6%8D%A2%E4%B8%BAHTML%E7%BD%91%E9%A1%B5%E6%A0%BC%E5%BC%8F"><span class="toc-number">5.6.</span> <span class="toc-text">4.5.6　Excel转换为HTML网页格式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-%E6%95%B0%E6%8D%AE%E5%90%88%E5%B9%B6"><span class="toc-number">6.</span> <span class="toc-text">4.6　数据合并</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-1-%E6%95%B0%E6%8D%AE%E5%90%88%E5%B9%B6%EF%BC%88merge-%E6%96%B9%E6%B3%95%EF%BC%89"><span class="toc-number">6.1.</span> <span class="toc-text">4.6.1　数据合并（merge()方法）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%8E%E5%B8%B8%E8%A7%84%E5%90%88%E5%B9%B6"><span class="toc-number">6.1.1.</span> <span class="toc-text">1．常规合并</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%8E%E5%A4%9A%E5%AF%B9%E4%B8%80%E7%9A%84%E6%95%B0%E6%8D%AE%E5%90%88%E5%B9%B6"><span class="toc-number">6.1.2.</span> <span class="toc-text">2．多对一的数据合并</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%8E%E5%A4%9A%E5%AF%B9%E5%A4%9A%E7%9A%84%E6%95%B0%E6%8D%AE%E5%90%88%E5%B9%B6"><span class="toc-number">6.1.3.</span> <span class="toc-text">3．多对多的数据合并</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-2-%E6%95%B0%E6%8D%AE%E5%90%88%E5%B9%B6%EF%BC%88concat-%E6%96%B9%E6%B3%95%EF%BC%89"><span class="toc-number">6.2.</span> <span class="toc-text">4.6.2　数据合并（concat()方法）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%8E%E7%9B%B8%E5%90%8C%E5%AD%97%E6%AE%B5%E7%9A%84%E8%A1%A8%E9%A6%96%E5%B0%BE%E7%9B%B8%E6%8E%A5"><span class="toc-number">6.2.1.</span> <span class="toc-text">1．相同字段的表首尾相接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%8E%E6%A8%AA%E5%90%91%E8%A1%A8%E5%90%88%E5%B9%B6%EF%BC%88%E8%A1%8C%E5%AF%B9%E9%BD%90%EF%BC%89"><span class="toc-number">6.2.2.</span> <span class="toc-text">2．横向表合并（行对齐）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%8E%E4%BA%A4%E5%8F%89%E5%90%88%E5%B9%B6"><span class="toc-number">6.2.3.</span> <span class="toc-text">3．交叉合并</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%EF%BC%8E%E6%8C%87%E5%AE%9A%E8%A1%A8%E5%AF%B9%E9%BD%90%E6%95%B0%E6%8D%AE%EF%BC%88%E8%A1%8C%E5%AF%B9%E9%BD%90%EF%BC%89"><span class="toc-number">6.2.4.</span> <span class="toc-text">4．指定表对齐数据（行对齐）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7-%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%87%BA"><span class="toc-number">7.</span> <span class="toc-text">4.7　数据导出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-1-%E5%AF%BC%E5%87%BA%E4%B8%BA-xlsx%E6%96%87%E4%BB%B6"><span class="toc-number">7.1.</span> <span class="toc-text">4.7.1　导出为.xlsx文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-2-%E5%AF%BC%E5%87%BA%E4%B8%BA-csv%E6%96%87%E4%BB%B6"><span class="toc-number">7.2.</span> <span class="toc-text">4.7.2　导出为.csv文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-3-%E5%AF%BC%E5%87%BA%E5%A4%9A%E4%B8%AASheet"><span class="toc-number">7.3.</span> <span class="toc-text">4.7.3　导出多个Sheet</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-8-%E6%97%A5%E6%9C%9F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86"><span class="toc-number">8.</span> <span class="toc-text">4.8　日期数据处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-1-DataFrame%E7%9A%84%E6%97%A5%E6%9C%9F%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2"><span class="toc-number">8.1.</span> <span class="toc-text">4.8.1　DataFrame的日期数据转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-2-dt%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">8.2.</span> <span class="toc-text">4.8.2　dt对象的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-3-%E8%8E%B7%E5%8F%96%E6%97%A5%E6%9C%9F%E5%8C%BA%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-number">8.3.</span> <span class="toc-text">4.8.3　获取日期区间的数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-4-%E6%8C%89%E4%B8%8D%E5%90%8C%E6%97%B6%E6%9C%9F%E7%BB%9F%E8%AE%A1%E5%B9%B6%E6%98%BE%E7%A4%BA%E6%95%B0%E6%8D%AE"><span class="toc-number">8.4.</span> <span class="toc-text">4.8.4　按不同时期统计并显示数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%8E%E6%8C%89%E6%97%B6%E6%9C%9F%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE"><span class="toc-number">8.4.1.</span> <span class="toc-text">1．按时期统计数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%8E%E6%8C%89%E6%97%B6%E6%9C%9F%E6%98%BE%E7%A4%BA%E6%95%B0%E6%8D%AE"><span class="toc-number">8.4.2.</span> <span class="toc-text">2．按时期显示数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%8E%E6%8C%89%E6%97%B6%E6%9C%9F%E7%BB%9F%E8%AE%A1%E5%B9%B6%E6%98%BE%E7%A4%BA%E6%95%B0%E6%8D%AE"><span class="toc-number">8.4.3.</span> <span class="toc-text">3．按时期统计并显示数据</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-9-%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97"><span class="toc-number">9.</span> <span class="toc-text">4.9　时间序列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-9-1-%E9%87%8D%E9%87%87%E6%A0%B7%EF%BC%88Resample-%E6%96%B9%E6%B3%95%EF%BC%89"><span class="toc-number">9.1.</span> <span class="toc-text">4.9.1　重采样（Resample()方法）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-9-2-%E9%99%8D%E9%87%87%E6%A0%B7%E5%A4%84%E7%90%86"><span class="toc-number">9.2.</span> <span class="toc-text">4.9.2　降采样处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-9-3-%E5%8D%87%E9%87%87%E6%A0%B7%E5%A4%84%E7%90%86"><span class="toc-number">9.3.</span> <span class="toc-text">4.9.3　升采样处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-9-4-%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%95%B0%E6%8D%AE%E6%B1%87%E6%80%BB%EF%BC%88ohlc-%E5%87%BD%E6%95%B0%EF%BC%89"><span class="toc-number">9.4.</span> <span class="toc-text">4.9.4　时间序列数据汇总（ohlc()函数）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-9-5-%E7%A7%BB%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%95%B0%E6%8D%AE%E8%AE%A1%E7%AE%97%EF%BC%88rolling-%E5%87%BD%E6%95%B0%EF%BC%89"><span class="toc-number">9.5.</span> <span class="toc-text">4.9.5　移动窗口数据计算（rolling()函数）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-10-%E7%BB%BC%E5%90%88%E5%BA%94%E7%94%A8"><span class="toc-number">10.</span> <span class="toc-text">4.10　综合应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-1-%E6%A1%88%E4%BE%8B1%EF%BC%9AExcel%E5%A4%9A%E8%A1%A8%E5%90%88%E5%B9%B6"><span class="toc-number">10.1.</span> <span class="toc-text">4.10.1　案例1：Excel多表合并</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-2-%E6%A1%88%E4%BE%8B2%EF%BC%9A%E8%82%A1%E7%A5%A8%E8%A1%8C%E6%83%85%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90"><span class="toc-number">10.2.</span> <span class="toc-text">4.10.2　案例2：股票行情数据分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-11-%E5%B0%8F%E7%BB%93"><span class="toc-number">11.</span> <span class="toc-text">4.11　小结</span></a></li></ol>
      </li>
    </ul>
  </div>



    <div id="comment" class="mdui-card mdui-p-a-2 mdui-m-b-5">
      <div class="mdui-tab" mdui-tab>
        
          <a href="#comment-tab0" class="mdui-ripple">valine</a>
        
      </div>
      
        <div id="comment-tab0" class="mdui-p-a-2">
          <div id="vcomments"></div>
<script src="//cdnjs.loli.net/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>
<script>
  var GUEST_INFO = ['nick', 'mail', 'link'];
  var guest_info = ''.split(',').filter(function (item) {
    return GUEST_INFO.indexOf(item) > -1;
  });
  var notify = '' === 'true';
  var verify = '' === 'true';
  new Valine({
    el: '#vcomments',
    notify: notify,
    verify: verify,
    appId: 'K384DoBsTJo09tPYtLMxDJz1-gzGzoHsz',
    appKey: 'Bp5G6BLH11s6zkpTjHkvoG1g',
    placeholder: '',
    pageSize: '',
    avatar: '',
    lang: '',
    guest_info: guest_info
  });
</script>
        </div>
      
    </div>

  </main>
  <footer id="footer" class="mdui-text-center mdui-m-t-5 mdui-p-b-2 mdui-p-t-4 mdui-color-theme">
  <div class="mdui-container">
    <div class="mdui-row">
      
        <a href="https://beian.miit.gov.cn" rel="noopener" target="_blank"></a>
      
      <span>
        &copy; 2015 - 2022 
        
          <span style="color:#d9333f" class="iconfont icon-heart"></span>
        
        Dalu Kuankuan
      </span>
    </div>
    <div class="mdui-row">
      
        <div class="mdui-col-xs-6 mdui-text-right">
          <span>Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a></span>
        </div>
        <div class="mdui-col-xs-6 mdui-text-left">
          <span>Theme: <a href="https://github.com/kb1000fx/Meadow" rel="noopener" target="_blank">Meadow</a></span>
        </div>
      
    </div>
    <div class="mdui-row">
      
        <div class="mdui-col-xs-6 mdui-text-right">
          <span id="busuanzi_container_site_uv" style="display: none;"> <span class="iconfont icon-user"></span>总访客量 <span id="busuanzi_value_site_uv"></span></span>
        </div>
        <div class="mdui-col-xs-6 mdui-text-left">
          <span id="busuanzi_container_site_pv" style="display: none;"> <span class="iconfont icon-eye"></span>总访问量 <span id="busuanzi_value_site_pv"></span></span>
        </div>
      
    </div>
 </div>
</footer>
  
  <button id="gotop" class="mdui-fab mdui-fab-fixed mdui-fab-hide mdui-ripple mdui-color-teal" style="z-index:100;"><i class="iconfont icon-arrowup"></i></button>
  
  

    <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




    <script src="https://cdn.jsdelivr.net/npm/mermaid@8.4.8/dist/mermaid.min.js"></script>
    <script>mermaid.initialize({
        startOnLoad: true,
        theme: "default"
    });</script>




    
<script src="/js/mdui.min.v1.0.0.js"></script>




<script src="/js/meadow.js"></script>

</body>
</html >